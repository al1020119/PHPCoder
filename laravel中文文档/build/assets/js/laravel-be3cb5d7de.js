/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 15);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(12).nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).setImmediate, __webpack_require__(0).clearImmediate))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcz9iMDg4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGltbWVkaWF0ZUlkcyA9IHt9O1xudmFyIG5leHRJbW1lZGlhdGVJZCA9IDA7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7IHRpbWVvdXQuY2xvc2UoKTsgfTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBUaGF0J3Mgbm90IGhvdyBub2RlLmpzIGltcGxlbWVudHMgaXQgYnV0IHRoZSBleHBvc2VkIGFwaSBpcyB0aGUgc2FtZS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGlkID0gbmV4dEltbWVkaWF0ZUlkKys7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBmYWxzZSA6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpbW1lZGlhdGVJZHNbaWRdID0gdHJ1ZTtcblxuICBuZXh0VGljayhmdW5jdGlvbiBvbk5leHRUaWNrKCkge1xuICAgIGlmIChpbW1lZGlhdGVJZHNbaWRdKSB7XG4gICAgICAvLyBmbi5jYWxsKCkgaXMgZmFzdGVyIHNvIHdlIG9wdGltaXplIGZvciB0aGUgY29tbW9uIHVzZS1jYXNlXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NhbGwtYXBwbHktc2VndVxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbi5jYWxsKG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gUHJldmVudCBpZHMgZnJvbSBsZWFraW5nXG4gICAgICBleHBvcnRzLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSB0eXBlb2YgY2xlYXJJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNsZWFySW1tZWRpYXRlIDogZnVuY3Rpb24oaWQpIHtcbiAgZGVsZXRlIGltbWVkaWF0ZUlkc1tpZF07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 1 */
/***/ function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, {}))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9hbWQtb3B0aW9ucy5qcz81ZjcxIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX2FtZF9vcHRpb25zX187XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, setImmediate) {var require;var require;var require;var require;/*! algoliasearch 3.7.7 | Â© 2014, 2015 Algolia SAS | github.com/algolia/algoliasearch-client-js */\n(function(f){var g;if(typeof window!=='undefined'){g=window}else if(typeof self!=='undefined'){g=self}g.ALGOLIA_MIGRATION_LAYER=f()})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\n    module.exports = function load (src, opts, cb) {\n        var head = document.head || document.getElementsByTagName('head')[0]\n        var script = document.createElement('script')\n\n        if (typeof opts === 'function') {\n            cb = opts\n            opts = {}\n        }\n\n        opts = opts || {}\n        cb = cb || function() {}\n\n        script.type = opts.type || 'text/javascript'\n        script.charset = opts.charset || 'utf8';\n        script.async = 'async' in opts ? !!opts.async : true\n        script.src = src\n\n        if (opts.attrs) {\n            setAttributes(script, opts.attrs)\n        }\n\n        if (opts.text) {\n            script.text = '' + opts.text\n        }\n\n        var onend = 'onload' in script ? stdOnEnd : ieOnEnd\n        onend(script, cb)\n\n        // some good legacy browsers (firefox) fail the 'in' detection above\n        // so as a fallback we always set onload\n        // old IE will ignore this and new IE will set onload\n        if (!script.onload) {\n            stdOnEnd(script, cb);\n        }\n\n        head.appendChild(script)\n    }\n\n    function setAttributes(script, attrs) {\n        for (var attr in attrs) {\n            script.setAttribute(attr, attrs[attr]);\n        }\n    }\n\n    function stdOnEnd (script, cb) {\n        script.onload = function () {\n            this.onerror = this.onload = null\n            cb(null, script)\n        }\n        script.onerror = function () {\n            // this.onload = null here is necessary\n            // because even IE9 works not like others\n            this.onerror = this.onload = null\n            cb(new Error('Failed to load ' + this.src), script)\n        }\n    }\n\n    function ieOnEnd (script, cb) {\n        script.onreadystatechange = function () {\n            if (this.readyState != 'complete' && this.readyState != 'loaded') return\n            this.onreadystatechange = null\n            cb(null, script) // there is no way to catch loading errors in IE8\n        }\n    }\n\n},{}],2:[function(require,module,exports){\n    'use strict';\n\n// this module helps finding if the current page is using\n// the cdn.jsdelivr.net/algoliasearch/latest/$BUILDNAME.min.js version\n\n    module.exports = isUsingLatest;\n\n    function isUsingLatest(buildName) {\n        var toFind = new RegExp('cdn\\\\.jsdelivr\\\\.net/algoliasearch/latest/' +\n            buildName.replace('.', '\\\\.') + // algoliasearch, algoliasearch.angular\n            '(?:\\\\.min)?\\\\.js$'); // [.min].js\n\n        var scripts = document.getElementsByTagName('script');\n        var found = false;\n        for (var currentScript = 0, nbScripts = scripts.length; currentScript < nbScripts; currentScript++) {\n            if (scripts[currentScript].src && toFind.test(scripts[currentScript].src)) {\n                found = true;\n                break;\n            }\n        }\n\n        return found;\n    }\n\n},{}],3:[function(require,module,exports){\n    'use strict';\n\n    module.exports = loadV2;\n\n    function loadV2(buildName) {\n        var loadScript = require(1);\n        var v2ScriptUrl = '//cdn.jsdelivr.net/algoliasearch/2/' + buildName + '.min.js';\n\n        var message = '-- AlgoliaSearch `latest` warning --\\n' +\n            'Warning, you are using the `latest` version string from jsDelivr to load the AlgoliaSearch library.\\n' +\n            'Using `latest` is no more recommended, you should load //cdn.jsdelivr.net/algoliasearch/2/algoliasearch.min.js\\n\\n' +\n            'Also, we updated the AlgoliaSearch JavaScript client to V3. If you want to upgrade,\\n' +\n            'please read our migration guide at https://github.com/algolia/algoliasearch-client-js/wiki/Migration-guide-from-2.x.x-to-3.x.x\\n' +\n            '-- /AlgoliaSearch  `latest` warning --';\n\n        if (window.console) {\n            if (window.console.warn) {\n                window.console.warn(message);\n            } else if (window.console.log) {\n                window.console.log(message);\n            }\n        }\n\n        // If current script loaded asynchronously,\n        // it will load the script with DOMElement\n        // otherwise, it will load the script with document.write\n        try {\n            // why \\x3c? http://stackoverflow.com/a/236106/147079\n            document.write('\\x3Cscript>window.ALGOLIA_SUPPORTS_DOCWRITE = true\\x3C/script>');\n\n            if (window.ALGOLIA_SUPPORTS_DOCWRITE === true) {\n                document.write('\\x3Cscript src=\"' + v2ScriptUrl + '\">\\x3C/script>');\n                scriptLoaded('document.write')();\n            } else {\n                loadScript(v2ScriptUrl, scriptLoaded('DOMElement'));\n            }\n        } catch (e) {\n            loadScript(v2ScriptUrl, scriptLoaded('DOMElement'));\n        }\n    }\n\n    function scriptLoaded(method) {\n        return function log() {\n            var message = 'AlgoliaSearch: loaded V2 script using ' + method;\n\n            if (window.console && window.console.log) {\n                window.console.log(message);\n            }\n        };\n    }\n\n},{\"1\":1}],4:[function(require,module,exports){\n    'use strict';\n\n    /*eslint no-unused-vars: [2, {\"vars\": \"local\"}]*/\n\n    module.exports = oldGlobals;\n\n// put old window.AlgoliaSearch.. into window. again so that\n// users upgrading to V3 without changing their code, will be warned\n    function oldGlobals() {\n        var message = '-- AlgoliaSearch V2 => V3 error --\\n' +\n            'You are trying to use a new version of the AlgoliaSearch JavaScript client with an old notation.\\n' +\n            'Please read our migration guide at https://github.com/algolia/algoliasearch-client-js/wiki/Migration-guide-from-2.x.x-to-3.x.x\\n' +\n            '-- /AlgoliaSearch V2 => V3 error --';\n\n        window.AlgoliaSearch = function() {\n            throw new Error(message);\n        };\n\n        window.AlgoliaSearchHelper = function() {\n            throw new Error(message);\n        };\n\n        window.AlgoliaExplainResults = function() {\n            throw new Error(message);\n        };\n    }\n\n},{}],5:[function(require,module,exports){\n    'use strict';\n\n// This script will be browserified and prepended to the normal build\n// directly in window, not wrapped in any module definition\n// To avoid cases where we are loaded with /latest/ along with\n    migrationLayer(\"algoliasearch\");\n\n// Now onto the V2 related code:\n//  If the client is using /latest/$BUILDNAME.min.js, load V2 of the library\n//\n//  Otherwise, setup a migration layer that will throw on old constructors like\n//  new AlgoliaSearch().\n//  So that users upgrading from v2 to v3 will have a clear information\n//  message on what to do if they did not read the migration guide\n    function migrationLayer(buildName) {\n        var isUsingLatest = require(2);\n        var loadV2 = require(3);\n        var oldGlobals = require(4);\n\n        if (isUsingLatest(buildName)) {\n            loadV2(buildName);\n        } else {\n            oldGlobals();\n        }\n    }\n\n},{\"2\":2,\"3\":3,\"4\":4}]},{},[5])(5)\n});(function(f){if(true){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.algoliasearch = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n    function EventEmitter() {\n        this._events = this._events || {};\n        this._maxListeners = this._maxListeners || undefined;\n    }\n    module.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\n    EventEmitter.EventEmitter = EventEmitter;\n\n    EventEmitter.prototype._events = undefined;\n    EventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\n    EventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\n    EventEmitter.prototype.setMaxListeners = function(n) {\n        if (!isNumber(n) || n < 0 || isNaN(n))\n            throw TypeError('n must be a positive number');\n        this._maxListeners = n;\n        return this;\n    };\n\n    EventEmitter.prototype.emit = function(type) {\n        var arguments$1 = arguments;\n        var this$1 = this;\n\n        var er, handler, len, args, i, listeners;\n\n        if (!this._events)\n            this._events = {};\n\n        // If there is no 'error' event listener then throw.\n        if (type === 'error') {\n            if (!this._events.error ||\n                (isObject(this._events.error) && !this._events.error.length)) {\n                er = arguments[1];\n                if (er instanceof Error) {\n                    throw er; // Unhandled 'error' event\n                }\n                throw TypeError('Uncaught, unspecified \"error\" event.');\n            }\n        }\n\n        handler = this._events[type];\n\n        if (isUndefined(handler))\n            return false;\n\n        if (isFunction(handler)) {\n            switch (arguments.length) {\n                // fast cases\n                case 1:\n                    handler.call(this);\n                    break;\n                case 2:\n                    handler.call(this, arguments[1]);\n                    break;\n                case 3:\n                    handler.call(this, arguments[1], arguments[2]);\n                    break;\n                // slower\n                default:\n                    len = arguments.length;\n                    args = new Array(len - 1);\n                    for (i = 1; i < len; i++)\n                        args[i - 1] = arguments$1[i];\n                    handler.apply(this, args);\n            }\n        } else if (isObject(handler)) {\n            len = arguments.length;\n            args = new Array(len - 1);\n            for (i = 1; i < len; i++)\n                args[i - 1] = arguments$1[i];\n\n            listeners = handler.slice();\n            len = listeners.length;\n            for (i = 0; i < len; i++)\n                listeners[i].apply(this$1, args);\n        }\n\n        return true;\n    };\n\n    EventEmitter.prototype.addListener = function(type, listener) {\n        var m;\n\n        if (!isFunction(listener))\n            throw TypeError('listener must be a function');\n\n        if (!this._events)\n            this._events = {};\n\n        // To avoid recursion in the case that type === \"newListener\"! Before\n        // adding it to the listeners, first emit \"newListener\".\n        if (this._events.newListener)\n            this.emit('newListener', type,\n                isFunction(listener.listener) ?\n                    listener.listener : listener);\n\n        if (!this._events[type])\n        // Optimize the case of one listener. Don't need the extra array object.\n            this._events[type] = listener;\n        else if (isObject(this._events[type]))\n        // If we've already got an array, just append.\n            this._events[type].push(listener);\n        else\n        // Adding the second element, need to change to array.\n            this._events[type] = [this._events[type], listener];\n\n        // Check for listener leak\n        if (isObject(this._events[type]) && !this._events[type].warned) {\n            var m;\n            if (!isUndefined(this._maxListeners)) {\n                m = this._maxListeners;\n            } else {\n                m = EventEmitter.defaultMaxListeners;\n            }\n\n            if (m && m > 0 && this._events[type].length > m) {\n                this._events[type].warned = true;\n                console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n                if (typeof console.trace === 'function') {\n                    // not supported in IE 10\n                    console.trace();\n                }\n            }\n        }\n\n        return this;\n    };\n\n    EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n    EventEmitter.prototype.once = function(type, listener) {\n        if (!isFunction(listener))\n            throw TypeError('listener must be a function');\n\n        var fired = false;\n\n        function g() {\n            this.removeListener(type, g);\n\n            if (!fired) {\n                fired = true;\n                listener.apply(this, arguments);\n            }\n        }\n\n        g.listener = listener;\n        this.on(type, g);\n\n        return this;\n    };\n\n// emits a 'removeListener' event iff the listener was removed\n    EventEmitter.prototype.removeListener = function(type, listener) {\n        var list, position, length, i;\n\n        if (!isFunction(listener))\n            throw TypeError('listener must be a function');\n\n        if (!this._events || !this._events[type])\n            return this;\n\n        list = this._events[type];\n        length = list.length;\n        position = -1;\n\n        if (list === listener ||\n            (isFunction(list.listener) && list.listener === listener)) {\n            delete this._events[type];\n            if (this._events.removeListener)\n                this.emit('removeListener', type, listener);\n\n        } else if (isObject(list)) {\n            for (i = length; i-- > 0;) {\n                if (list[i] === listener ||\n                    (list[i].listener && list[i].listener === listener)) {\n                    position = i;\n                    break;\n                }\n            }\n\n            if (position < 0)\n                return this;\n\n            if (list.length === 1) {\n                list.length = 0;\n                delete this._events[type];\n            } else {\n                list.splice(position, 1);\n            }\n\n            if (this._events.removeListener)\n                this.emit('removeListener', type, listener);\n        }\n\n        return this;\n    };\n\n    EventEmitter.prototype.removeAllListeners = function(type) {\n        var this$1 = this;\n\n        var key, listeners;\n\n        if (!this._events)\n            return this;\n\n        // not listening for removeListener, no need to emit\n        if (!this._events.removeListener) {\n            if (arguments.length === 0)\n                this._events = {};\n            else if (this._events[type])\n                delete this._events[type];\n            return this;\n        }\n\n        // emit removeListener for all listeners on all events\n        if (arguments.length === 0) {\n            for (key in this._events) {\n                if (key === 'removeListener') continue;\n                this$1.removeAllListeners(key);\n            }\n            this.removeAllListeners('removeListener');\n            this._events = {};\n            return this;\n        }\n\n        listeners = this._events[type];\n\n        if (isFunction(listeners)) {\n            this.removeListener(type, listeners);\n        } else {\n            // LIFO order\n            while (listeners.length)\n                this$1.removeListener(type, listeners[listeners.length - 1]);\n        }\n        delete this._events[type];\n\n        return this;\n    };\n\n    EventEmitter.prototype.listeners = function(type) {\n        var ret;\n        if (!this._events || !this._events[type])\n            ret = [];\n        else if (isFunction(this._events[type]))\n            ret = [this._events[type]];\n        else\n            ret = this._events[type].slice();\n        return ret;\n    };\n\n    EventEmitter.listenerCount = function(emitter, type) {\n        var ret;\n        if (!emitter._events || !emitter._events[type])\n            ret = 0;\n        else if (isFunction(emitter._events[type]))\n            ret = 1;\n        else\n            ret = emitter._events[type].length;\n        return ret;\n    };\n\n    function isFunction(arg) {\n        return typeof arg === 'function';\n    }\n\n    function isNumber(arg) {\n        return typeof arg === 'number';\n    }\n\n    function isObject(arg) {\n        return typeof arg === 'object' && arg !== null;\n    }\n\n    function isUndefined(arg) {\n        return arg === void 0;\n    }\n\n},{}],2:[function(require,module,exports){\n// shim for using process in browser\n\n    var process = module.exports = {};\n    var queue = [];\n    var draining = false;\n    var currentQueue;\n    var queueIndex = -1;\n\n    function cleanUpNextTick() {\n        draining = false;\n        if (currentQueue.length) {\n            queue = currentQueue.concat(queue);\n        } else {\n            queueIndex = -1;\n        }\n        if (queue.length) {\n            drainQueue();\n        }\n    }\n\n    function drainQueue() {\n        if (draining) {\n            return;\n        }\n        var timeout = setTimeout(cleanUpNextTick);\n        draining = true;\n\n        var len = queue.length;\n        while(len) {\n            currentQueue = queue;\n            queue = [];\n            while (++queueIndex < len) {\n                currentQueue[queueIndex].run();\n            }\n            queueIndex = -1;\n            len = queue.length;\n        }\n        currentQueue = null;\n        draining = false;\n        clearTimeout(timeout);\n    }\n\n    process.nextTick = function (fun) {\n        var arguments$1 = arguments;\n\n        var args = new Array(arguments.length - 1);\n        if (arguments.length > 1) {\n            for (var i = 1; i < arguments.length; i++) {\n                args[i - 1] = arguments$1[i];\n            }\n        }\n        queue.push(new Item(fun, args));\n        if (queue.length === 1 && !draining) {\n            setTimeout(drainQueue, 0);\n        }\n    };\n\n// v8 likes predictible objects\n    function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n    }\n    Item.prototype.run = function () {\n        this.fun.apply(null, this.array);\n    };\n    process.title = 'browser';\n    process.browser = true;\n    process.env = {};\n    process.argv = [];\n    process.version = ''; // empty string to avoid regexp issues\n    process.versions = {};\n\n    function noop() {}\n\n    process.on = noop;\n    process.addListener = noop;\n    process.once = noop;\n    process.off = noop;\n    process.removeListener = noop;\n    process.removeAllListeners = noop;\n    process.emit = noop;\n\n    process.binding = function (name) {\n        throw new Error('process.binding is not supported');\n    };\n\n// TODO(shtylman)\n    process.cwd = function () { return '/' };\n    process.chdir = function (dir) {\n        throw new Error('process.chdir is not supported');\n    };\n    process.umask = function() { return 0; };\n\n},{}],3:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n    'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\n    function hasOwnProperty(obj, prop) {\n        return Object.prototype.hasOwnProperty.call(obj, prop);\n    }\n\n    module.exports = function(qs, sep, eq, options) {\n        sep = sep || '&';\n        eq = eq || '=';\n        var obj = {};\n\n        if (typeof qs !== 'string' || qs.length === 0) {\n            return obj;\n        }\n\n        var regexp = /\\+/g;\n        qs = qs.split(sep);\n\n        var maxKeys = 1000;\n        if (options && typeof options.maxKeys === 'number') {\n            maxKeys = options.maxKeys;\n        }\n\n        var len = qs.length;\n        // maxKeys <= 0 means that we should not limit keys count\n        if (maxKeys > 0 && len > maxKeys) {\n            len = maxKeys;\n        }\n\n        for (var i = 0; i < len; ++i) {\n            var x = qs[i].replace(regexp, '%20'),\n                idx = x.indexOf(eq),\n                kstr, vstr, k, v;\n\n            if (idx >= 0) {\n                kstr = x.substr(0, idx);\n                vstr = x.substr(idx + 1);\n            } else {\n                kstr = x;\n                vstr = '';\n            }\n\n            k = decodeURIComponent(kstr);\n            v = decodeURIComponent(vstr);\n\n            if (!hasOwnProperty(obj, k)) {\n                obj[k] = v;\n            } else if (isArray(obj[k])) {\n                obj[k].push(v);\n            } else {\n                obj[k] = [obj[k], v];\n            }\n        }\n\n        return obj;\n    };\n\n    var isArray = Array.isArray || function (xs) {\n            return Object.prototype.toString.call(xs) === '[object Array]';\n        };\n\n},{}],4:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n    'use strict';\n\n    var stringifyPrimitive = function(v) {\n        switch (typeof v) {\n            case 'string':\n                return v;\n\n            case 'boolean':\n                return v ? 'true' : 'false';\n\n            case 'number':\n                return isFinite(v) ? v : '';\n\n            default:\n                return '';\n        }\n    };\n\n    module.exports = function(obj, sep, eq, name) {\n        sep = sep || '&';\n        eq = eq || '=';\n        if (obj === null) {\n            obj = undefined;\n        }\n\n        if (typeof obj === 'object') {\n            return map(objectKeys(obj), function(k) {\n                var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n                if (isArray(obj[k])) {\n                    return map(obj[k], function(v) {\n                        return ks + encodeURIComponent(stringifyPrimitive(v));\n                    }).join(sep);\n                } else {\n                    return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n                }\n            }).join(sep);\n\n        }\n\n        if (!name) return '';\n        return encodeURIComponent(stringifyPrimitive(name)) + eq +\n            encodeURIComponent(stringifyPrimitive(obj));\n    };\n\n    var isArray = Array.isArray || function (xs) {\n            return Object.prototype.toString.call(xs) === '[object Array]';\n        };\n\n    function map (xs, f) {\n        if (xs.map) return xs.map(f);\n        var res = [];\n        for (var i = 0; i < xs.length; i++) {\n            res.push(f(xs[i], i));\n        }\n        return res;\n    }\n\n    var objectKeys = Object.keys || function (obj) {\n            var res = [];\n            for (var key in obj) {\n                if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n            }\n            return res;\n        };\n\n},{}],5:[function(require,module,exports){\n    'use strict';\n\n    exports.decode = exports.parse = require(3);\n    exports.encode = exports.stringify = require(4);\n\n},{\"3\":3,\"4\":4}],6:[function(require,module,exports){\n\n    /**\n     * This is the web browser implementation of `debug()`.\n     *\n     * Expose `debug()` as the module.\n     */\n\n    exports = module.exports = require(7);\n    exports.log = log;\n    exports.formatArgs = formatArgs;\n    exports.save = save;\n    exports.load = load;\n    exports.useColors = useColors;\n    exports.storage = 'undefined' != typeof chrome\n    && 'undefined' != typeof chrome.storage\n        ? chrome.storage.local\n        : localstorage();\n\n    /**\n     * Colors.\n     */\n\n    exports.colors = [\n        'lightseagreen',\n        'forestgreen',\n        'goldenrod',\n        'dodgerblue',\n        'darkorchid',\n        'crimson'\n    ];\n\n    /**\n     * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n     * and the Firebug extension (any Firefox version) are known\n     * to support \"%c\" CSS customizations.\n     *\n     * TODO: add a `localStorage` variable to explicitly enable/disable colors\n     */\n\n    function useColors() {\n        // is webkit? http://stackoverflow.com/a/16459606/376773\n        return ('WebkitAppearance' in document.documentElement.style) ||\n                // is firebug? http://stackoverflow.com/a/398120/376773\n            (window.console && (console.firebug || (console.exception && console.table))) ||\n                // is firefox >= v31?\n                // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n            (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n    }\n\n    /**\n     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n     */\n\n    exports.formatters.j = function(v) {\n        return JSON.stringify(v);\n    };\n\n\n    /**\n     * Colorize log arguments if enabled.\n     *\n     * @api public\n     */\n\n    function formatArgs() {\n        var args = arguments;\n        var useColors = this.useColors;\n\n        args[0] = (useColors ? '%c' : '')\n            + this.namespace\n            + (useColors ? ' %c' : ' ')\n            + args[0]\n            + (useColors ? '%c ' : ' ')\n            + '+' + exports.humanize(this.diff);\n\n        if (!useColors) return args;\n\n        var c = 'color: ' + this.color;\n        args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n        // the final \"%c\" is somewhat tricky, because there could be other\n        // arguments passed either before or after the %c, so we need to\n        // figure out the correct index to insert the CSS into\n        var index = 0;\n        var lastC = 0;\n        args[0].replace(/%[a-z%]/g, function(match) {\n            if ('%%' === match) return;\n            index++;\n            if ('%c' === match) {\n                // we only are interested in the *last* %c\n                // (the user may have provided their own)\n                lastC = index;\n            }\n        });\n\n        args.splice(lastC, 0, c);\n        return args;\n    }\n\n    /**\n     * Invokes `console.log()` when available.\n     * No-op when `console.log` is not a \"function\".\n     *\n     * @api public\n     */\n\n    function log() {\n        // this hackery is required for IE8/9, where\n        // the `console.log` function doesn't have 'apply'\n        return 'object' === typeof console\n            && console.log\n            && Function.prototype.apply.call(console.log, console, arguments);\n    }\n\n    /**\n     * Save `namespaces`.\n     *\n     * @param {String} namespaces\n     * @api private\n     */\n\n    function save(namespaces) {\n        try {\n            if (null == namespaces) {\n                exports.storage.removeItem('debug');\n            } else {\n                exports.storage.debug = namespaces;\n            }\n        } catch(e) {}\n    }\n\n    /**\n     * Load `namespaces`.\n     *\n     * @return {String} returns the previously persisted debug modes\n     * @api private\n     */\n\n    function load() {\n        var r;\n        try {\n            r = exports.storage.debug;\n        } catch(e) {}\n        return r;\n    }\n\n    /**\n     * Enable namespaces listed in `localStorage.debug` initially.\n     */\n\n    exports.enable(load());\n\n    /**\n     * Localstorage attempts to return the localstorage.\n     *\n     * This is necessary because safari throws\n     * when a user disables cookies/localstorage\n     * and you attempt to access it.\n     *\n     * @return {LocalStorage}\n     * @api private\n     */\n\n    function localstorage(){\n        try {\n            return window.localStorage;\n        } catch (e) {}\n    }\n\n},{\"7\":7}],7:[function(require,module,exports){\n\n    /**\n     * This is the common logic for both the Node.js and web browser\n     * implementations of `debug()`.\n     *\n     * Expose `debug()` as the module.\n     */\n\n    exports = module.exports = debug;\n    exports.coerce = coerce;\n    exports.disable = disable;\n    exports.enable = enable;\n    exports.enabled = enabled;\n    exports.humanize = require(8);\n\n    /**\n     * The currently active debug mode names, and names to skip.\n     */\n\n    exports.names = [];\n    exports.skips = [];\n\n    /**\n     * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n     *\n     * Valid key names are a single, lowercased letter, i.e. \"n\".\n     */\n\n    exports.formatters = {};\n\n    /**\n     * Previously assigned color.\n     */\n\n    var prevColor = 0;\n\n    /**\n     * Previous log timestamp.\n     */\n\n    var prevTime;\n\n    /**\n     * Select a color.\n     *\n     * @return {Number}\n     * @api private\n     */\n\n    function selectColor() {\n        return exports.colors[prevColor++ % exports.colors.length];\n    }\n\n    /**\n     * Create a debugger with the given `namespace`.\n     *\n     * @param {String} namespace\n     * @return {Function}\n     * @api public\n     */\n\n    function debug(namespace) {\n\n        // define the `disabled` version\n        function disabled() {\n        }\n        disabled.enabled = false;\n\n        // define the `enabled` version\n        function enabled() {\n\n            var self = enabled;\n\n            // set `diff` timestamp\n            var curr = +new Date();\n            var ms = curr - (prevTime || curr);\n            self.diff = ms;\n            self.prev = prevTime;\n            self.curr = curr;\n            prevTime = curr;\n\n            // add the `color` if not set\n            if (null == self.useColors) self.useColors = exports.useColors();\n            if (null == self.color && self.useColors) self.color = selectColor();\n\n            var args = Array.prototype.slice.call(arguments);\n\n            args[0] = exports.coerce(args[0]);\n\n            if ('string' !== typeof args[0]) {\n                // anything else let's inspect with %o\n                args = ['%o'].concat(args);\n            }\n\n            // apply any `formatters` transformations\n            var index = 0;\n            args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n                // if we encounter an escaped % then don't increase the array index\n                if (match === '%%') return match;\n                index++;\n                var formatter = exports.formatters[format];\n                if ('function' === typeof formatter) {\n                    var val = args[index];\n                    match = formatter.call(self, val);\n\n                    // now we need to remove `args[index]` since it's inlined in the `format`\n                    args.splice(index, 1);\n                    index--;\n                }\n                return match;\n            });\n\n            if ('function' === typeof exports.formatArgs) {\n                args = exports.formatArgs.apply(self, args);\n            }\n            var logFn = enabled.log || exports.log || console.log.bind(console);\n            logFn.apply(self, args);\n        }\n        enabled.enabled = true;\n\n        var fn = exports.enabled(namespace) ? enabled : disabled;\n\n        fn.namespace = namespace;\n\n        return fn;\n    }\n\n    /**\n     * Enables a debug mode by namespaces. This can include modes\n     * separated by a colon and wildcards.\n     *\n     * @param {String} namespaces\n     * @api public\n     */\n\n    function enable(namespaces) {\n        exports.save(namespaces);\n\n        var split = (namespaces || '').split(/[\\s,]+/);\n        var len = split.length;\n\n        for (var i = 0; i < len; i++) {\n            if (!split[i]) continue; // ignore empty strings\n            namespaces = split[i].replace(/\\*/g, '.*?');\n            if (namespaces[0] === '-') {\n                exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n            } else {\n                exports.names.push(new RegExp('^' + namespaces + '$'));\n            }\n        }\n    }\n\n    /**\n     * Disable debug output.\n     *\n     * @api public\n     */\n\n    function disable() {\n        exports.enable('');\n    }\n\n    /**\n     * Returns true if the given mode name is enabled, false otherwise.\n     *\n     * @param {String} name\n     * @return {Boolean}\n     * @api public\n     */\n\n    function enabled(name) {\n        var i, len;\n        for (i = 0, len = exports.skips.length; i < len; i++) {\n            if (exports.skips[i].test(name)) {\n                return false;\n            }\n        }\n        for (i = 0, len = exports.names.length; i < len; i++) {\n            if (exports.names[i].test(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Coerce `val`.\n     *\n     * @param {Mixed} val\n     * @return {Mixed}\n     * @api private\n     */\n\n    function coerce(val) {\n        if (val instanceof Error) return val.stack || val.message;\n        return val;\n    }\n\n},{\"8\":8}],8:[function(require,module,exports){\n    /**\n     * Helpers.\n     */\n\n    var s = 1000;\n    var m = s * 60;\n    var h = m * 60;\n    var d = h * 24;\n    var y = d * 365.25;\n\n    /**\n     * Parse or format the given `val`.\n     *\n     * Options:\n     *\n     *  - `long` verbose formatting [false]\n     *\n     * @param {String|Number} val\n     * @param {Object} options\n     * @return {String|Number}\n     * @api public\n     */\n\n    module.exports = function(val, options){\n        options = options || {};\n        if ('string' == typeof val) return parse(val);\n        // long, short were \"future reserved words in js\", YUI compressor fail on them\n        // https://github.com/algolia/algoliasearch-client-js/issues/113#issuecomment-111978606\n        // https://github.com/yui/yuicompressor/issues/47\n        // https://github.com/rauchg/ms.js/pull/40\n        return options['long']\n            ? _long(val)\n            : _short(val);\n    };\n\n    /**\n     * Parse the given `str` and return milliseconds.\n     *\n     * @param {String} str\n     * @return {Number}\n     * @api private\n     */\n\n    function parse(str) {\n        str = '' + str;\n        if (str.length > 10000) return;\n        var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n        if (!match) return;\n        var n = parseFloat(match[1]);\n        var type = (match[2] || 'ms').toLowerCase();\n        switch (type) {\n            case 'years':\n            case 'year':\n            case 'yrs':\n            case 'yr':\n            case 'y':\n                return n * y;\n            case 'days':\n            case 'day':\n            case 'd':\n                return n * d;\n            case 'hours':\n            case 'hour':\n            case 'hrs':\n            case 'hr':\n            case 'h':\n                return n * h;\n            case 'minutes':\n            case 'minute':\n            case 'mins':\n            case 'min':\n            case 'm':\n                return n * m;\n            case 'seconds':\n            case 'second':\n            case 'secs':\n            case 'sec':\n            case 's':\n                return n * s;\n            case 'milliseconds':\n            case 'millisecond':\n            case 'msecs':\n            case 'msec':\n            case 'ms':\n                return n;\n        }\n    }\n\n    /**\n     * Short format for `ms`.\n     *\n     * @param {Number} ms\n     * @return {String}\n     * @api private\n     */\n\n    function _short(ms) {\n        if (ms >= d) return Math.round(ms / d) + 'd';\n        if (ms >= h) return Math.round(ms / h) + 'h';\n        if (ms >= m) return Math.round(ms / m) + 'm';\n        if (ms >= s) return Math.round(ms / s) + 's';\n        return ms + 'ms';\n    }\n\n    /**\n     * Long format for `ms`.\n     *\n     * @param {Number} ms\n     * @return {String}\n     * @api private\n     */\n\n    function _long(ms) {\n        return plural(ms, d, 'day')\n            || plural(ms, h, 'hour')\n            || plural(ms, m, 'minute')\n            || plural(ms, s, 'second')\n            || ms + ' ms';\n    }\n\n    /**\n     * Pluralization helper.\n     */\n\n    function plural(ms, n, name) {\n        if (ms < n) return;\n        if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n        return Math.ceil(ms / n) + ' ' + name + 's';\n    }\n\n},{}],9:[function(require,module,exports){\n    (function (process,global){\n        /*!\n         * @overview es6-promise - a tiny implementation of Promises/A+.\n         * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n         * @license   Licensed under MIT license\n         *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n         * @version   2.3.0\n         */\n\n        (function() {\n            \"use strict\";\n            function lib$es6$promise$utils$$objectOrFunction(x) {\n                return typeof x === 'function' || (typeof x === 'object' && x !== null);\n            }\n\n            function lib$es6$promise$utils$$isFunction(x) {\n                return typeof x === 'function';\n            }\n\n            function lib$es6$promise$utils$$isMaybeThenable(x) {\n                return typeof x === 'object' && x !== null;\n            }\n\n            var lib$es6$promise$utils$$_isArray;\n            if (!Array.isArray) {\n                lib$es6$promise$utils$$_isArray = function (x) {\n                    return Object.prototype.toString.call(x) === '[object Array]';\n                };\n            } else {\n                lib$es6$promise$utils$$_isArray = Array.isArray;\n            }\n\n            var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n            var lib$es6$promise$asap$$len = 0;\n            var lib$es6$promise$asap$$toString = {}.toString;\n            var lib$es6$promise$asap$$vertxNext;\n            var lib$es6$promise$asap$$customSchedulerFn;\n\n            var lib$es6$promise$asap$$asap = function asap(callback, arg) {\n                lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n                lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n                lib$es6$promise$asap$$len += 2;\n                if (lib$es6$promise$asap$$len === 2) {\n                    // If len is 2, that means that we need to schedule an async flush.\n                    // If additional callbacks are queued before the queue is flushed, they\n                    // will be processed by this flush that we are scheduling.\n                    if (lib$es6$promise$asap$$customSchedulerFn) {\n                        lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n                    } else {\n                        lib$es6$promise$asap$$scheduleFlush();\n                    }\n                }\n            }\n\n            function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n                lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n            }\n\n            function lib$es6$promise$asap$$setAsap(asapFn) {\n                lib$es6$promise$asap$$asap = asapFn;\n            }\n\n            var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\n            var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n            var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n            var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n            // test for web worker but not in IE10\n            var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n                typeof importScripts !== 'undefined' &&\n                typeof MessageChannel !== 'undefined';\n\n            // node\n            function lib$es6$promise$asap$$useNextTick() {\n                var nextTick = process.nextTick;\n                // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n                // setImmediate should be used instead instead\n                var version = process.versions.node.match(/^(?:(\\d+)\\.)?(?:(\\d+)\\.)?(\\*|\\d+)$/);\n                if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {\n                    nextTick = setImmediate;\n                }\n                return function() {\n                    nextTick(lib$es6$promise$asap$$flush);\n                };\n            }\n\n            // vertx\n            function lib$es6$promise$asap$$useVertxTimer() {\n                return function() {\n                    lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n                };\n            }\n\n            function lib$es6$promise$asap$$useMutationObserver() {\n                var iterations = 0;\n                var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n                var node = document.createTextNode('');\n                observer.observe(node, { characterData: true });\n\n                return function() {\n                    node.data = (iterations = ++iterations % 2);\n                };\n            }\n\n            // web worker\n            function lib$es6$promise$asap$$useMessageChannel() {\n                var channel = new MessageChannel();\n                channel.port1.onmessage = lib$es6$promise$asap$$flush;\n                return function () {\n                    channel.port2.postMessage(0);\n                };\n            }\n\n            function lib$es6$promise$asap$$useSetTimeout() {\n                return function() {\n                    setTimeout(lib$es6$promise$asap$$flush, 1);\n                };\n            }\n\n            var lib$es6$promise$asap$$queue = new Array(1000);\n            function lib$es6$promise$asap$$flush() {\n                for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {\n                    var callback = lib$es6$promise$asap$$queue[i];\n                    var arg = lib$es6$promise$asap$$queue[i+1];\n\n                    callback(arg);\n\n                    lib$es6$promise$asap$$queue[i] = undefined;\n                    lib$es6$promise$asap$$queue[i+1] = undefined;\n                }\n\n                lib$es6$promise$asap$$len = 0;\n            }\n\n            function lib$es6$promise$asap$$attemptVertex() {\n                try {\n                    var r = require;\n                    var vertx = r('vertx');\n                    lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n                    return lib$es6$promise$asap$$useVertxTimer();\n                } catch(e) {\n                    return lib$es6$promise$asap$$useSetTimeout();\n                }\n            }\n\n            var lib$es6$promise$asap$$scheduleFlush;\n            // Decide what async method to use to triggering processing of queued callbacks:\n            if (lib$es6$promise$asap$$isNode) {\n                lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n            } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n                lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n            } else if (lib$es6$promise$asap$$isWorker) {\n                lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n            } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {\n                lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertex();\n            } else {\n                lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n            }\n\n            function lib$es6$promise$$internal$$noop() {}\n\n            var lib$es6$promise$$internal$$PENDING   = void 0;\n            var lib$es6$promise$$internal$$FULFILLED = 1;\n            var lib$es6$promise$$internal$$REJECTED  = 2;\n\n            var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n            function lib$es6$promise$$internal$$selfFullfillment() {\n                return new TypeError(\"You cannot resolve a promise with itself\");\n            }\n\n            function lib$es6$promise$$internal$$cannotReturnOwn() {\n                return new TypeError('A promises callback cannot return that same promise.');\n            }\n\n            function lib$es6$promise$$internal$$getThen(promise) {\n                try {\n                    return promise.then;\n                } catch(error) {\n                    lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n                    return lib$es6$promise$$internal$$GET_THEN_ERROR;\n                }\n            }\n\n            function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n                try {\n                    then.call(value, fulfillmentHandler, rejectionHandler);\n                } catch(e) {\n                    return e;\n                }\n            }\n\n            function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n                lib$es6$promise$asap$$asap(function(promise) {\n                    var sealed = false;\n                    var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {\n                        if (sealed) { return; }\n                        sealed = true;\n                        if (thenable !== value) {\n                            lib$es6$promise$$internal$$resolve(promise, value);\n                        } else {\n                            lib$es6$promise$$internal$$fulfill(promise, value);\n                        }\n                    }, function(reason) {\n                        if (sealed) { return; }\n                        sealed = true;\n\n                        lib$es6$promise$$internal$$reject(promise, reason);\n                    }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n                    if (!sealed && error) {\n                        sealed = true;\n                        lib$es6$promise$$internal$$reject(promise, error);\n                    }\n                }, promise);\n            }\n\n            function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n                if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n                    lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n                } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n                    lib$es6$promise$$internal$$reject(promise, thenable._result);\n                } else {\n                    lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {\n                        lib$es6$promise$$internal$$resolve(promise, value);\n                    }, function(reason) {\n                        lib$es6$promise$$internal$$reject(promise, reason);\n                    });\n                }\n            }\n\n            function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {\n                if (maybeThenable.constructor === promise.constructor) {\n                    lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n                } else {\n                    var then = lib$es6$promise$$internal$$getThen(maybeThenable);\n\n                    if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n                        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n                    } else if (then === undefined) {\n                        lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n                    } else if (lib$es6$promise$utils$$isFunction(then)) {\n                        lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n                    } else {\n                        lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n                    }\n                }\n            }\n\n            function lib$es6$promise$$internal$$resolve(promise, value) {\n                if (promise === value) {\n                    lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFullfillment());\n                } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n                    lib$es6$promise$$internal$$handleMaybeThenable(promise, value);\n                } else {\n                    lib$es6$promise$$internal$$fulfill(promise, value);\n                }\n            }\n\n            function lib$es6$promise$$internal$$publishRejection(promise) {\n                if (promise._onerror) {\n                    promise._onerror(promise._result);\n                }\n\n                lib$es6$promise$$internal$$publish(promise);\n            }\n\n            function lib$es6$promise$$internal$$fulfill(promise, value) {\n                if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\n                promise._result = value;\n                promise._state = lib$es6$promise$$internal$$FULFILLED;\n\n                if (promise._subscribers.length !== 0) {\n                    lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);\n                }\n            }\n\n            function lib$es6$promise$$internal$$reject(promise, reason) {\n                if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n                promise._state = lib$es6$promise$$internal$$REJECTED;\n                promise._result = reason;\n\n                lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);\n            }\n\n            function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n                var subscribers = parent._subscribers;\n                var length = subscribers.length;\n\n                parent._onerror = null;\n\n                subscribers[length] = child;\n                subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n                subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;\n\n                if (length === 0 && parent._state) {\n                    lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);\n                }\n            }\n\n            function lib$es6$promise$$internal$$publish(promise) {\n                var subscribers = promise._subscribers;\n                var settled = promise._state;\n\n                if (subscribers.length === 0) { return; }\n\n                var child, callback, detail = promise._result;\n\n                for (var i = 0; i < subscribers.length; i += 3) {\n                    child = subscribers[i];\n                    callback = subscribers[i + settled];\n\n                    if (child) {\n                        lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n                    } else {\n                        callback(detail);\n                    }\n                }\n\n                promise._subscribers.length = 0;\n            }\n\n            function lib$es6$promise$$internal$$ErrorObject() {\n                this.error = null;\n            }\n\n            var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n            function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n                try {\n                    return callback(detail);\n                } catch(e) {\n                    lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n                    return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n                }\n            }\n\n            function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n                var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n                    value, error, succeeded, failed;\n\n                if (hasCallback) {\n                    value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n\n                    if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n                        failed = true;\n                        error = value.error;\n                        value = null;\n                    } else {\n                        succeeded = true;\n                    }\n\n                    if (promise === value) {\n                        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n                        return;\n                    }\n\n                } else {\n                    value = detail;\n                    succeeded = true;\n                }\n\n                if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n                    // noop\n                } else if (hasCallback && succeeded) {\n                    lib$es6$promise$$internal$$resolve(promise, value);\n                } else if (failed) {\n                    lib$es6$promise$$internal$$reject(promise, error);\n                } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n                    lib$es6$promise$$internal$$fulfill(promise, value);\n                } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n                    lib$es6$promise$$internal$$reject(promise, value);\n                }\n            }\n\n            function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n                try {\n                    resolver(function resolvePromise(value){\n                        lib$es6$promise$$internal$$resolve(promise, value);\n                    }, function rejectPromise(reason) {\n                        lib$es6$promise$$internal$$reject(promise, reason);\n                    });\n                } catch(e) {\n                    lib$es6$promise$$internal$$reject(promise, e);\n                }\n            }\n\n            function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n                var enumerator = this;\n\n                enumerator._instanceConstructor = Constructor;\n                enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n                if (enumerator._validateInput(input)) {\n                    enumerator._input     = input;\n                    enumerator.length     = input.length;\n                    enumerator._remaining = input.length;\n\n                    enumerator._init();\n\n                    if (enumerator.length === 0) {\n                        lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n                    } else {\n                        enumerator.length = enumerator.length || 0;\n                        enumerator._enumerate();\n                        if (enumerator._remaining === 0) {\n                            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n                        }\n                    }\n                } else {\n                    lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());\n                }\n            }\n\n            lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {\n                return lib$es6$promise$utils$$isArray(input);\n            };\n\n            lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {\n                return new Error('Array Methods must be provided an Array');\n            };\n\n            lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {\n                this._result = new Array(this.length);\n            };\n\n            var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n\n            lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {\n                var enumerator = this;\n\n                var length  = enumerator.length;\n                var promise = enumerator.promise;\n                var input   = enumerator._input;\n\n                for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n                    enumerator._eachEntry(input[i], i);\n                }\n            };\n\n            lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n                var enumerator = this;\n                var c = enumerator._instanceConstructor;\n\n                if (lib$es6$promise$utils$$isMaybeThenable(entry)) {\n                    if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {\n                        entry._onerror = null;\n                        enumerator._settledAt(entry._state, i, entry._result);\n                    } else {\n                        enumerator._willSettleAt(c.resolve(entry), i);\n                    }\n                } else {\n                    enumerator._remaining--;\n                    enumerator._result[i] = entry;\n                }\n            };\n\n            lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n                var enumerator = this;\n                var promise = enumerator.promise;\n\n                if (promise._state === lib$es6$promise$$internal$$PENDING) {\n                    enumerator._remaining--;\n\n                    if (state === lib$es6$promise$$internal$$REJECTED) {\n                        lib$es6$promise$$internal$$reject(promise, value);\n                    } else {\n                        enumerator._result[i] = value;\n                    }\n                }\n\n                if (enumerator._remaining === 0) {\n                    lib$es6$promise$$internal$$fulfill(promise, enumerator._result);\n                }\n            };\n\n            lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n                var enumerator = this;\n\n                lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {\n                    enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n                }, function(reason) {\n                    enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n                });\n            };\n            function lib$es6$promise$promise$all$$all(entries) {\n                return new lib$es6$promise$enumerator$$default(this, entries).promise;\n            }\n            var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n            function lib$es6$promise$promise$race$$race(entries) {\n                /*jshint validthis:true */\n                var Constructor = this;\n\n                var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n                if (!lib$es6$promise$utils$$isArray(entries)) {\n                    lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n                    return promise;\n                }\n\n                var length = entries.length;\n\n                function onFulfillment(value) {\n                    lib$es6$promise$$internal$$resolve(promise, value);\n                }\n\n                function onRejection(reason) {\n                    lib$es6$promise$$internal$$reject(promise, reason);\n                }\n\n                for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n                    lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n                }\n\n                return promise;\n            }\n            var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n            function lib$es6$promise$promise$resolve$$resolve(object) {\n                /*jshint validthis:true */\n                var Constructor = this;\n\n                if (object && typeof object === 'object' && object.constructor === Constructor) {\n                    return object;\n                }\n\n                var promise = new Constructor(lib$es6$promise$$internal$$noop);\n                lib$es6$promise$$internal$$resolve(promise, object);\n                return promise;\n            }\n            var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n            function lib$es6$promise$promise$reject$$reject(reason) {\n                /*jshint validthis:true */\n                var Constructor = this;\n                var promise = new Constructor(lib$es6$promise$$internal$$noop);\n                lib$es6$promise$$internal$$reject(promise, reason);\n                return promise;\n            }\n            var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n\n            var lib$es6$promise$promise$$counter = 0;\n\n            function lib$es6$promise$promise$$needsResolver() {\n                throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n            }\n\n            function lib$es6$promise$promise$$needsNew() {\n                throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n            }\n\n            var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n            /**\n             Promise objects represent the eventual result of an asynchronous operation. The\n             primary way of interacting with a promise is through its `then` method, which\n             registers callbacks to receive either a promise's eventual value or the reason\n             why the promise cannot be fulfilled.\n\n             Terminology\n             -----------\n\n             - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n             - `thenable` is an object or function that defines a `then` method.\n             - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n             - `exception` is a value that is thrown using the throw statement.\n             - `reason` is a value that indicates why a promise was rejected.\n             - `settled` the final resting state of a promise, fulfilled or rejected.\n\n             A promise can be in one of three states: pending, fulfilled, or rejected.\n\n             Promises that are fulfilled have a fulfillment value and are in the fulfilled\n             state.  Promises that are rejected have a rejection reason and are in the\n             rejected state.  A fulfillment value is never a thenable.\n\n             Promises can also be said to *resolve* a value.  If this value is also a\n             promise, then the original promise's settled state will match the value's\n             settled state.  So a promise that *resolves* a promise that rejects will\n             itself reject, and a promise that *resolves* a promise that fulfills will\n             itself fulfill.\n\n\n             Basic Usage:\n             ------------\n\n             ```js\n             var promise = new Promise(function(resolve, reject) {\n        // on success\n        resolve(value);\n\n        // on failure\n        reject(reason);\n      });\n\n             promise.then(function(value) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n             ```\n\n             Advanced Usage:\n             ---------------\n\n             Promises shine when abstracting away asynchronous interactions such as\n             `XMLHttpRequest`s.\n\n             ```js\n             function getJSON(url) {\n        return new Promise(function(resolve, reject){\n          var xhr = new XMLHttpRequest();\n\n          xhr.open('GET', url);\n          xhr.onreadystatechange = handler;\n          xhr.responseType = 'json';\n          xhr.setRequestHeader('Accept', 'application/json');\n          xhr.send();\n\n          function handler() {\n            if (this.readyState === this.DONE) {\n              if (this.status === 200) {\n                resolve(this.response);\n              } else {\n                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n              }\n            }\n          };\n        });\n      }\n\n             getJSON('/posts.json').then(function(json) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n             ```\n\n             Unlike callbacks, promises are great composable primitives.\n\n             ```js\n             Promise.all([\n             getJSON('/posts'),\n             getJSON('/comments')\n             ]).then(function(values){\n        values[0] // => postsJSON\n        values[1] // => commentsJSON\n\n        return values;\n      });\n             ```\n\n             @class Promise\n             @param {function} resolver\n             Useful for tooling.\n             @constructor\n             */\n            function lib$es6$promise$promise$$Promise(resolver) {\n                this._id = lib$es6$promise$promise$$counter++;\n                this._state = undefined;\n                this._result = undefined;\n                this._subscribers = [];\n\n                if (lib$es6$promise$$internal$$noop !== resolver) {\n                    if (!lib$es6$promise$utils$$isFunction(resolver)) {\n                        lib$es6$promise$promise$$needsResolver();\n                    }\n\n                    if (!(this instanceof lib$es6$promise$promise$$Promise)) {\n                        lib$es6$promise$promise$$needsNew();\n                    }\n\n                    lib$es6$promise$$internal$$initializePromise(this, resolver);\n                }\n            }\n\n            lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n            lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n            lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n            lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n            lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n            lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;\n            lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;\n\n            lib$es6$promise$promise$$Promise.prototype = {\n                constructor: lib$es6$promise$promise$$Promise,\n\n                /**\n                 The primary way of interacting with a promise is through its `then` method,\n                 which registers callbacks to receive either a promise's eventual value or the\n                 reason why the promise cannot be fulfilled.\n\n                 ```js\n                 findUser().then(function(user){\n        // user is available\n      }, function(reason){\n        // user is unavailable, and you are given the reason why\n      });\n                 ```\n\n                 Chaining\n                 --------\n\n                 The return value of `then` is itself a promise.  This second, 'downstream'\n                 promise is resolved with the return value of the first promise's fulfillment\n                 or rejection handler, or rejected if the handler throws an exception.\n\n                 ```js\n                 findUser().then(function (user) {\n        return user.name;\n      }, function (reason) {\n        return 'default name';\n      }).then(function (userName) {\n        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n        // will be `'default name'`\n      });\n\n                 findUser().then(function (user) {\n        throw new Error('Found user, but still unhappy');\n      }, function (reason) {\n        throw new Error('`findUser` rejected and we're unhappy');\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n      });\n                 ```\n                 If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\n                 ```js\n                 findUser().then(function (user) {\n        throw new PedagogicalException('Upstream error');\n      }).then(function (value) {\n        // never reached\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // The `PedgagocialException` is propagated all the way down to here\n      });\n                 ```\n\n                 Assimilation\n                 ------------\n\n                 Sometimes the value you want to propagate to a downstream promise can only be\n                 retrieved asynchronously. This can be achieved by returning a promise in the\n                 fulfillment or rejection handler. The downstream promise will then be pending\n                 until the returned promise is settled. This is called *assimilation*.\n\n                 ```js\n                 findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // The user's comments are now available\n      });\n                 ```\n\n                 If the assimliated promise rejects, then the downstream promise will also reject.\n\n                 ```js\n                 findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // If `findCommentsByAuthor` fulfills, we'll have the value here\n      }, function (reason) {\n        // If `findCommentsByAuthor` rejects, we'll have the reason here\n      });\n                 ```\n\n                 Simple Example\n                 --------------\n\n                 Synchronous Example\n\n                 ```javascript\n                 var result;\n\n                 try {\n        result = findResult();\n        // success\n      } catch(reason) {\n        // failure\n      }\n                 ```\n\n                 Errback Example\n\n                 ```js\n                 findResult(function(result, err){\n        if (err) {\n          // failure\n        } else {\n          // success\n        }\n      });\n                 ```\n\n                 Promise Example;\n\n                 ```javascript\n                 findResult().then(function(result){\n        // success\n      }, function(reason){\n        // failure\n      });\n                 ```\n\n                 Advanced Example\n                 --------------\n\n                 Synchronous Example\n\n                 ```javascript\n                 var author, books;\n\n                 try {\n        author = findAuthor();\n        books  = findBooksByAuthor(author);\n        // success\n      } catch(reason) {\n        // failure\n      }\n                 ```\n\n                 Errback Example\n\n                 ```js\n\n                 function foundBooks(books) {\n\n      }\n\n                 function failure(reason) {\n\n      }\n\n                 findAuthor(function(author, err){\n        if (err) {\n          failure(err);\n          // failure\n        } else {\n          try {\n            findBoooksByAuthor(author, function(books, err) {\n              if (err) {\n                failure(err);\n              } else {\n                try {\n                  foundBooks(books);\n                } catch(reason) {\n                  failure(reason);\n                }\n              }\n            });\n          } catch(error) {\n            failure(err);\n          }\n          // success\n        }\n      });\n                 ```\n\n                 Promise Example;\n\n                 ```javascript\n                 findAuthor().\n                 then(findBooksByAuthor).\n                 then(function(books){\n          // found books\n      }).catch(function(reason){\n        // something went wrong\n      });\n                 ```\n\n                 @method then\n                 @param {Function} onFulfilled\n                 @param {Function} onRejected\n                 Useful for tooling.\n                 @return {Promise}\n                 */\n                then: function(onFulfillment, onRejection) {\n                    var parent = this;\n                    var state = parent._state;\n\n                    if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {\n                        return this;\n                    }\n\n                    var child = new this.constructor(lib$es6$promise$$internal$$noop);\n                    var result = parent._result;\n\n                    if (state) {\n                        var callback = arguments[state - 1];\n                        lib$es6$promise$asap$$asap(function(){\n                            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);\n                        });\n                    } else {\n                        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n                    }\n\n                    return child;\n                },\n\n                /**\n                 `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n                 as the catch block of a try/catch statement.\n\n                 ```js\n                 function findAuthor(){\n        throw new Error('couldn't find that author');\n      }\n\n                 // synchronous\n                 try {\n        findAuthor();\n      } catch(reason) {\n        // something went wrong\n      }\n\n                 // async with promises\n                 findAuthor().catch(function(reason){\n        // something went wrong\n      });\n                 ```\n\n                 @method catch\n                 @param {Function} onRejection\n                 Useful for tooling.\n                 @return {Promise}\n                 */\n                'catch': function(onRejection) {\n                    return this.then(null, onRejection);\n                }\n            };\n            function lib$es6$promise$polyfill$$polyfill() {\n                var local;\n\n                if (typeof global !== 'undefined') {\n                    local = global;\n                } else if (typeof self !== 'undefined') {\n                    local = self;\n                } else {\n                    try {\n                        local = Function('return this')();\n                    } catch (e) {\n                        throw new Error('polyfill failed because global object is unavailable in this environment');\n                    }\n                }\n\n                var P = local.Promise;\n\n                if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n                    return;\n                }\n\n                local.Promise = lib$es6$promise$promise$$default;\n            }\n            var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n\n            var lib$es6$promise$umd$$ES6Promise = {\n                'Promise': lib$es6$promise$promise$$default,\n                'polyfill': lib$es6$promise$polyfill$$default\n            };\n\n            /* global define:true module:true window: true */\n            if (typeof define === 'function' && define['amd']) {\n                define(function() { return lib$es6$promise$umd$$ES6Promise; });\n            } else if (typeof module !== 'undefined' && module['exports']) {\n                module['exports'] = lib$es6$promise$umd$$ES6Promise;\n            } else if (typeof this !== 'undefined') {\n                this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n            }\n\n            lib$es6$promise$polyfill$$default();\n        }).call(this);\n\n\n    }).call(this,require(2),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"2\":2}],10:[function(require,module,exports){\n    if (typeof Object.create === 'function') {\n        // implementation from standard node.js 'util' module\n        module.exports = function inherits(ctor, superCtor) {\n            ctor.super_ = superCtor\n            ctor.prototype = Object.create(superCtor.prototype, {\n                constructor: {\n                    value: ctor,\n                    enumerable: false,\n                    writable: true,\n                    configurable: true\n                }\n            });\n        };\n    } else {\n        // old school shim for old browsers\n        module.exports = function inherits(ctor, superCtor) {\n            ctor.super_ = superCtor\n            var TempCtor = function () {}\n            TempCtor.prototype = superCtor.prototype\n            ctor.prototype = new TempCtor()\n            ctor.prototype.constructor = ctor\n        }\n    }\n\n},{}],11:[function(require,module,exports){\n    var arrayEach = require(14),\n        baseEach = require(18),\n        createForEach = require(30);\n\n    /**\n     * Iterates over elements of `collection` invoking `iteratee` for each element.\n     * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n     * (value, index|key, collection). Iteratee functions may exit iteration early\n     * by explicitly returning `false`.\n     *\n     * **Note:** As with other \"Collections\" methods, objects with a \"length\" property\n     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`\n     * may be used for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @alias each\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array|Object|string} Returns `collection`.\n     * @example\n     *\n     * _([1, 2]).forEach(function(n) {\n *   console.log(n);\n * }).value();\n     * // => logs each value from left to right and returns the array\n     *\n     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {\n *   console.log(n, key);\n * });\n     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)\n     */\n    var forEach = createForEach(arrayEach, baseEach);\n\n    module.exports = forEach;\n\n},{\"14\":14,\"18\":18,\"30\":30}],12:[function(require,module,exports){\n    /** Used as the `TypeError` message for \"Functions\" methods. */\n    var FUNC_ERROR_TEXT = 'Expected a function';\n\n    /* Native method references for those with the same name as other `lodash` methods. */\n    var nativeMax = Math.max;\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * created function and arguments from `start` and beyond provided as an array.\n     *\n     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.restParam(function(what, names) {\n *   return what + ' ' + _.initial(names).join(', ') +\n *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n * });\n     *\n     * say('hello', 'fred', 'barney', 'pebbles');\n     * // => 'hello fred, barney, & pebbles'\n     */\n    function restParam(func, start) {\n        if (typeof func != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);\n        return function() {\n            var args = arguments,\n                index = -1,\n                length = nativeMax(args.length - start, 0),\n                rest = Array(length);\n\n            while (++index < length) {\n                rest[index] = args[start + index];\n            }\n            switch (start) {\n                case 0: return func.call(this, rest);\n                case 1: return func.call(this, args[0], rest);\n                case 2: return func.call(this, args[0], args[1], rest);\n            }\n            var otherArgs = Array(start + 1);\n            index = -1;\n            while (++index < start) {\n                otherArgs[index] = args[index];\n            }\n            otherArgs[start] = rest;\n            return func.apply(this, otherArgs);\n        };\n    }\n\n    module.exports = restParam;\n\n},{}],13:[function(require,module,exports){\n    /**\n     * Copies the values of `source` to `array`.\n     *\n     * @private\n     * @param {Array} source The array to copy values from.\n     * @param {Array} [array=[]] The array to copy values to.\n     * @returns {Array} Returns `array`.\n     */\n    function arrayCopy(source, array) {\n        var index = -1,\n            length = source.length;\n\n        array || (array = Array(length));\n        while (++index < length) {\n            array[index] = source[index];\n        }\n        return array;\n    }\n\n    module.exports = arrayCopy;\n\n},{}],14:[function(require,module,exports){\n    /**\n     * A specialized version of `_.forEach` for arrays without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns `array`.\n     */\n    function arrayEach(array, iteratee) {\n        var index = -1,\n            length = array.length;\n\n        while (++index < length) {\n            if (iteratee(array[index], index, array) === false) {\n                break;\n            }\n        }\n        return array;\n    }\n\n    module.exports = arrayEach;\n\n},{}],15:[function(require,module,exports){\n    var baseCopy = require(17),\n        keys = require(55);\n\n    /**\n     * The base implementation of `_.assign` without support for argument juggling,\n     * multiple sources, and `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssign(object, source) {\n        return source == null\n            ? object\n            : baseCopy(source, keys(source), object);\n    }\n\n    module.exports = baseAssign;\n\n},{\"17\":17,\"55\":55}],16:[function(require,module,exports){\n    var arrayCopy = require(13),\n        arrayEach = require(14),\n        baseAssign = require(15),\n        baseForOwn = require(21),\n        initCloneArray = require(33),\n        initCloneByTag = require(34),\n        initCloneObject = require(35),\n        isArray = require(47),\n        isHostObject = require(37),\n        isObject = require(50);\n\n    /** `Object#toString` result references. */\n    var argsTag = '[object Arguments]',\n        arrayTag = '[object Array]',\n        boolTag = '[object Boolean]',\n        dateTag = '[object Date]',\n        errorTag = '[object Error]',\n        funcTag = '[object Function]',\n        mapTag = '[object Map]',\n        numberTag = '[object Number]',\n        objectTag = '[object Object]',\n        regexpTag = '[object RegExp]',\n        setTag = '[object Set]',\n        stringTag = '[object String]',\n        weakMapTag = '[object WeakMap]';\n\n    var arrayBufferTag = '[object ArrayBuffer]',\n        float32Tag = '[object Float32Array]',\n        float64Tag = '[object Float64Array]',\n        int8Tag = '[object Int8Array]',\n        int16Tag = '[object Int16Array]',\n        int32Tag = '[object Int32Array]',\n        uint8Tag = '[object Uint8Array]',\n        uint8ClampedTag = '[object Uint8ClampedArray]',\n        uint16Tag = '[object Uint16Array]',\n        uint32Tag = '[object Uint32Array]';\n\n    /** Used to identify `toStringTag` values supported by `_.clone`. */\n    var cloneableTags = {};\n    cloneableTags[argsTag] = cloneableTags[arrayTag] =\n        cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =\n            cloneableTags[dateTag] = cloneableTags[float32Tag] =\n                cloneableTags[float64Tag] = cloneableTags[int8Tag] =\n                    cloneableTags[int16Tag] = cloneableTags[int32Tag] =\n                        cloneableTags[numberTag] = cloneableTags[objectTag] =\n                            cloneableTags[regexpTag] = cloneableTags[stringTag] =\n                                cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n                                    cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n    cloneableTags[errorTag] = cloneableTags[funcTag] =\n        cloneableTags[mapTag] = cloneableTags[setTag] =\n            cloneableTags[weakMapTag] = false;\n\n    /** Used for native method references. */\n    var objectProto = Object.prototype;\n\n    /**\n     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var objToString = objectProto.toString;\n\n    /**\n     * The base implementation of `_.clone` without support for argument juggling\n     * and `this` binding `customizer` functions.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @param {Function} [customizer] The function to customize cloning values.\n     * @param {string} [key] The key of `value`.\n     * @param {Object} [object] The object `value` belongs to.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates clones with source counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {\n        var result;\n        if (customizer) {\n            result = object ? customizer(value, key, object) : customizer(value);\n        }\n        if (result !== undefined) {\n            return result;\n        }\n        if (!isObject(value)) {\n            return value;\n        }\n        var isArr = isArray(value);\n        if (isArr) {\n            result = initCloneArray(value);\n            if (!isDeep) {\n                return arrayCopy(value, result);\n            }\n        } else {\n            var tag = objToString.call(value),\n                isFunc = tag == funcTag;\n\n            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n                if (isHostObject(value)) {\n                    return object ? value : {};\n                }\n                result = initCloneObject(isFunc ? {} : value);\n                if (!isDeep) {\n                    return baseAssign(result, value);\n                }\n            } else {\n                return cloneableTags[tag]\n                    ? initCloneByTag(value, tag, isDeep)\n                    : (object ? value : {});\n            }\n        }\n        // Check for circular references and return its corresponding clone.\n        stackA || (stackA = []);\n        stackB || (stackB = []);\n\n        var length = stackA.length;\n        while (length--) {\n            if (stackA[length] == value) {\n                return stackB[length];\n            }\n        }\n        // Add the source value to the stack of traversed objects and associate it with its clone.\n        stackA.push(value);\n        stackB.push(result);\n\n        // Recursively populate clone (susceptible to call stack limits).\n        (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {\n            result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);\n        });\n        return result;\n    }\n\n    module.exports = baseClone;\n\n},{\"13\":13,\"14\":14,\"15\":15,\"21\":21,\"33\":33,\"34\":34,\"35\":35,\"37\":37,\"47\":47,\"50\":50}],17:[function(require,module,exports){\n    /**\n     * Copies properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy properties from.\n     * @param {Array} props The property names to copy.\n     * @param {Object} [object={}] The object to copy properties to.\n     * @returns {Object} Returns `object`.\n     */\n    function baseCopy(source, props, object) {\n        object || (object = {});\n\n        var index = -1,\n            length = props.length;\n\n        while (++index < length) {\n            var key = props[index];\n            object[key] = source[key];\n        }\n        return object;\n    }\n\n    module.exports = baseCopy;\n\n},{}],18:[function(require,module,exports){\n    var baseForOwn = require(21),\n        createBaseEach = require(28);\n\n    /**\n     * The base implementation of `_.forEach` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object|string} Returns `collection`.\n     */\n    var baseEach = createBaseEach(baseForOwn);\n\n    module.exports = baseEach;\n\n},{\"21\":21,\"28\":28}],19:[function(require,module,exports){\n    var createBaseFor = require(29);\n\n    /**\n     * The base implementation of `baseForIn` and `baseForOwn` which iterates\n     * over `object` properties returned by `keysFunc` invoking `iteratee` for\n     * each property. Iteratee functions may exit iteration early by explicitly\n     * returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseFor = createBaseFor();\n\n    module.exports = baseFor;\n\n},{\"29\":29}],20:[function(require,module,exports){\n    var baseFor = require(19),\n        keysIn = require(56);\n\n    /**\n     * The base implementation of `_.forIn` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForIn(object, iteratee) {\n        return baseFor(object, iteratee, keysIn);\n    }\n\n    module.exports = baseForIn;\n\n},{\"19\":19,\"56\":56}],21:[function(require,module,exports){\n    var baseFor = require(19),\n        keys = require(55);\n\n    /**\n     * The base implementation of `_.forOwn` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwn(object, iteratee) {\n        return baseFor(object, iteratee, keys);\n    }\n\n    module.exports = baseForOwn;\n\n},{\"19\":19,\"55\":55}],22:[function(require,module,exports){\n    var arrayEach = require(14),\n        baseMergeDeep = require(23),\n        isArray = require(47),\n        isArrayLike = require(36),\n        isObject = require(50),\n        isObjectLike = require(41),\n        isTypedArray = require(53),\n        keys = require(55);\n\n    /**\n     * The base implementation of `_.merge` without support for argument juggling,\n     * multiple sources, and `this` binding `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {Function} [customizer] The function to customize merged values.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates values with source counterparts.\n     * @returns {Object} Returns `object`.\n     */\n    function baseMerge(object, source, customizer, stackA, stackB) {\n        if (!isObject(object)) {\n            return object;\n        }\n        var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),\n            props = isSrcArr ? undefined : keys(source);\n\n        arrayEach(props || source, function(srcValue, key) {\n            if (props) {\n                key = srcValue;\n                srcValue = source[key];\n            }\n            if (isObjectLike(srcValue)) {\n                stackA || (stackA = []);\n                stackB || (stackB = []);\n                baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);\n            }\n            else {\n                var value = object[key],\n                    result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\n                    isCommon = result === undefined;\n\n                if (isCommon) {\n                    result = srcValue;\n                }\n                if ((result !== undefined || (isSrcArr && !(key in object))) &&\n                    (isCommon || (result === result ? (result !== value) : (value === value)))) {\n                    object[key] = result;\n                }\n            }\n        });\n        return object;\n    }\n\n    module.exports = baseMerge;\n\n},{\"14\":14,\"23\":23,\"36\":36,\"41\":41,\"47\":47,\"50\":50,\"53\":53,\"55\":55}],23:[function(require,module,exports){\n    var arrayCopy = require(13),\n        isArguments = require(46),\n        isArray = require(47),\n        isArrayLike = require(36),\n        isPlainObject = require(51),\n        isTypedArray = require(53),\n        toPlainObject = require(54);\n\n    /**\n     * A specialized version of `baseMerge` for arrays and objects which performs\n     * deep merges and tracks traversed objects enabling objects with circular\n     * references to be merged.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {string} key The key of the value to merge.\n     * @param {Function} mergeFunc The function to merge values.\n     * @param {Function} [customizer] The function to customize merged values.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates values with source counterparts.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {\n        var length = stackA.length,\n            srcValue = source[key];\n\n        while (length--) {\n            if (stackA[length] == srcValue) {\n                object[key] = stackB[length];\n                return;\n            }\n        }\n        var value = object[key],\n            result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\n            isCommon = result === undefined;\n\n        if (isCommon) {\n            result = srcValue;\n            if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {\n                result = isArray(value)\n                    ? value\n                    : (isArrayLike(value) ? arrayCopy(value) : []);\n            }\n            else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n                result = isArguments(value)\n                    ? toPlainObject(value)\n                    : (isPlainObject(value) ? value : {});\n            }\n            else {\n                isCommon = false;\n            }\n        }\n        // Add the source value to the stack of traversed objects and associate\n        // it with its merged value.\n        stackA.push(srcValue);\n        stackB.push(result);\n\n        if (isCommon) {\n            // Recursively merge objects and arrays (susceptible to call stack limits).\n            object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);\n        } else if (result === result ? (result !== value) : (value === value)) {\n            object[key] = result;\n        }\n    }\n\n    module.exports = baseMergeDeep;\n\n},{\"13\":13,\"36\":36,\"46\":46,\"47\":47,\"51\":51,\"53\":53,\"54\":54}],24:[function(require,module,exports){\n    var toObject = require(43);\n\n    /**\n     * The base implementation of `_.property` without support for deep paths.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @returns {Function} Returns the new function.\n     */\n    function baseProperty(key) {\n        return function(object) {\n            return object == null ? undefined : toObject(object)[key];\n        };\n    }\n\n    module.exports = baseProperty;\n\n},{\"43\":43}],25:[function(require,module,exports){\n    var identity = require(59);\n\n    /**\n     * A specialized version of `baseCallback` which only supports `this` binding\n     * and specifying the number of arguments to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {number} [argCount] The number of arguments to provide to `func`.\n     * @returns {Function} Returns the callback.\n     */\n    function bindCallback(func, thisArg, argCount) {\n        if (typeof func != 'function') {\n            return identity;\n        }\n        if (thisArg === undefined) {\n            return func;\n        }\n        switch (argCount) {\n            case 1: return function(value) {\n                return func.call(thisArg, value);\n            };\n            case 3: return function(value, index, collection) {\n                return func.call(thisArg, value, index, collection);\n            };\n            case 4: return function(accumulator, value, index, collection) {\n                return func.call(thisArg, accumulator, value, index, collection);\n            };\n            case 5: return function(value, other, key, object, source) {\n                return func.call(thisArg, value, other, key, object, source);\n            };\n        }\n        return function() {\n            return func.apply(thisArg, arguments);\n        };\n    }\n\n    module.exports = bindCallback;\n\n},{\"59\":59}],26:[function(require,module,exports){\n    (function (global){\n        /** Native method references. */\n        var ArrayBuffer = global.ArrayBuffer,\n            Uint8Array = global.Uint8Array;\n\n        /**\n         * Creates a clone of the given array buffer.\n         *\n         * @private\n         * @param {ArrayBuffer} buffer The array buffer to clone.\n         * @returns {ArrayBuffer} Returns the cloned array buffer.\n         */\n        function bufferClone(buffer) {\n            var result = new ArrayBuffer(buffer.byteLength),\n                view = new Uint8Array(result);\n\n            view.set(new Uint8Array(buffer));\n            return result;\n        }\n\n        module.exports = bufferClone;\n\n    }).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],27:[function(require,module,exports){\n    var bindCallback = require(25),\n        isIterateeCall = require(39),\n        restParam = require(12);\n\n    /**\n     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @returns {Function} Returns the new assigner function.\n     */\n    function createAssigner(assigner) {\n        return restParam(function(object, sources) {\n            var index = -1,\n                length = object == null ? 0 : sources.length,\n                customizer = length > 2 ? sources[length - 2] : undefined,\n                guard = length > 2 ? sources[2] : undefined,\n                thisArg = length > 1 ? sources[length - 1] : undefined;\n\n            if (typeof customizer == 'function') {\n                customizer = bindCallback(customizer, thisArg, 5);\n                length -= 2;\n            } else {\n                customizer = typeof thisArg == 'function' ? thisArg : undefined;\n                length -= (customizer ? 1 : 0);\n            }\n            if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n                customizer = length < 3 ? undefined : customizer;\n                length = 1;\n            }\n            while (++index < length) {\n                var source = sources[index];\n                if (source) {\n                    assigner(object, source, customizer);\n                }\n            }\n            return object;\n        });\n    }\n\n    module.exports = createAssigner;\n\n},{\"12\":12,\"25\":25,\"39\":39}],28:[function(require,module,exports){\n    var getLength = require(31),\n        isLength = require(40),\n        toObject = require(43);\n\n    /**\n     * Creates a `baseEach` or `baseEachRight` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseEach(eachFunc, fromRight) {\n        return function(collection, iteratee) {\n            var length = collection ? getLength(collection) : 0;\n            if (!isLength(length)) {\n                return eachFunc(collection, iteratee);\n            }\n            var index = fromRight ? length : -1,\n                iterable = toObject(collection);\n\n            while ((fromRight ? index-- : ++index < length)) {\n                if (iteratee(iterable[index], index, iterable) === false) {\n                    break;\n                }\n            }\n            return collection;\n        };\n    }\n\n    module.exports = createBaseEach;\n\n},{\"31\":31,\"40\":40,\"43\":43}],29:[function(require,module,exports){\n    var toObject = require(43);\n\n    /**\n     * Creates a base function for `_.forIn` or `_.forInRight`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseFor(fromRight) {\n        return function(object, iteratee, keysFunc) {\n            var iterable = toObject(object),\n                props = keysFunc(object),\n                length = props.length,\n                index = fromRight ? length : -1;\n\n            while ((fromRight ? index-- : ++index < length)) {\n                var key = props[index];\n                if (iteratee(iterable[key], key, iterable) === false) {\n                    break;\n                }\n            }\n            return object;\n        };\n    }\n\n    module.exports = createBaseFor;\n\n},{\"43\":43}],30:[function(require,module,exports){\n    var bindCallback = require(25),\n        isArray = require(47);\n\n    /**\n     * Creates a function for `_.forEach` or `_.forEachRight`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over an array.\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @returns {Function} Returns the new each function.\n     */\n    function createForEach(arrayFunc, eachFunc) {\n        return function(collection, iteratee, thisArg) {\n            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))\n                ? arrayFunc(collection, iteratee)\n                : eachFunc(collection, bindCallback(iteratee, thisArg, 3));\n        };\n    }\n\n    module.exports = createForEach;\n\n},{\"25\":25,\"47\":47}],31:[function(require,module,exports){\n    var baseProperty = require(24);\n\n    /**\n     * Gets the \"length\" property value of `object`.\n     *\n     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n     * that affects Safari on at least iOS 8.1-8.3 ARM64.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {*} Returns the \"length\" value.\n     */\n    var getLength = baseProperty('length');\n\n    module.exports = getLength;\n\n},{\"24\":24}],32:[function(require,module,exports){\n    var isNative = require(49);\n\n    /**\n     * Gets the native function at `key` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the method to get.\n     * @returns {*} Returns the function if it's native, else `undefined`.\n     */\n    function getNative(object, key) {\n        var value = object == null ? undefined : object[key];\n        return isNative(value) ? value : undefined;\n    }\n\n    module.exports = getNative;\n\n},{\"49\":49}],33:[function(require,module,exports){\n    /** Used for native method references. */\n    var objectProto = Object.prototype;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /**\n     * Initializes an array clone.\n     *\n     * @private\n     * @param {Array} array The array to clone.\n     * @returns {Array} Returns the initialized clone.\n     */\n    function initCloneArray(array) {\n        var length = array.length,\n            result = new array.constructor(length);\n\n        // Add array properties assigned by `RegExp#exec`.\n        if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n            result.index = array.index;\n            result.input = array.input;\n        }\n        return result;\n    }\n\n    module.exports = initCloneArray;\n\n},{}],34:[function(require,module,exports){\n    (function (global){\n        var bufferClone = require(26);\n\n        /** `Object#toString` result references. */\n        var boolTag = '[object Boolean]',\n            dateTag = '[object Date]',\n            numberTag = '[object Number]',\n            regexpTag = '[object RegExp]',\n            stringTag = '[object String]';\n\n        var arrayBufferTag = '[object ArrayBuffer]',\n            float32Tag = '[object Float32Array]',\n            float64Tag = '[object Float64Array]',\n            int8Tag = '[object Int8Array]',\n            int16Tag = '[object Int16Array]',\n            int32Tag = '[object Int32Array]',\n            uint8Tag = '[object Uint8Array]',\n            uint8ClampedTag = '[object Uint8ClampedArray]',\n            uint16Tag = '[object Uint16Array]',\n            uint32Tag = '[object Uint32Array]';\n\n        /** Used to match `RegExp` flags from their coerced string values. */\n        var reFlags = /\\w*$/;\n\n        /** Native method references. */\n        var Uint8Array = global.Uint8Array;\n\n        /** Used to lookup a type array constructors by `toStringTag`. */\n        var ctorByTag = {};\n        ctorByTag[float32Tag] = global.Float32Array;\n        ctorByTag[float64Tag] = global.Float64Array;\n        ctorByTag[int8Tag] = global.Int8Array;\n        ctorByTag[int16Tag] = global.Int16Array;\n        ctorByTag[int32Tag] = global.Int32Array;\n        ctorByTag[uint8Tag] = Uint8Array;\n        ctorByTag[uint8ClampedTag] = global.Uint8ClampedArray;\n        ctorByTag[uint16Tag] = global.Uint16Array;\n        ctorByTag[uint32Tag] = global.Uint32Array;\n\n        /**\n         * Initializes an object clone based on its `toStringTag`.\n         *\n         * **Note:** This function only supports cloning values with tags of\n         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n         *\n         * @private\n         * @param {Object} object The object to clone.\n         * @param {string} tag The `toStringTag` of the object to clone.\n         * @param {boolean} [isDeep] Specify a deep clone.\n         * @returns {Object} Returns the initialized clone.\n         */\n        function initCloneByTag(object, tag, isDeep) {\n            var Ctor = object.constructor;\n            switch (tag) {\n                case arrayBufferTag:\n                    return bufferClone(object);\n\n                case boolTag:\n                case dateTag:\n                    return new Ctor(+object);\n\n                case float32Tag: case float64Tag:\n                case int8Tag: case int16Tag: case int32Tag:\n                case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n                // Safari 5 mobile incorrectly has `Object` as the constructor of typed arrays.\n                if (Ctor instanceof Ctor) {\n                    Ctor = ctorByTag[tag];\n                }\n                var buffer = object.buffer;\n                return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);\n\n                case numberTag:\n                case stringTag:\n                    return new Ctor(object);\n\n                case regexpTag:\n                    var result = new Ctor(object.source, reFlags.exec(object));\n                    result.lastIndex = object.lastIndex;\n            }\n            return result;\n        }\n\n        module.exports = initCloneByTag;\n\n    }).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"26\":26}],35:[function(require,module,exports){\n    /**\n     * Initializes an object clone.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneObject(object) {\n        var Ctor = object.constructor;\n        if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {\n            Ctor = Object;\n        }\n        return new Ctor;\n    }\n\n    module.exports = initCloneObject;\n\n},{}],36:[function(require,module,exports){\n    var getLength = require(31),\n        isLength = require(40);\n\n    /**\n     * Checks if `value` is array-like.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n     */\n    function isArrayLike(value) {\n        return value != null && isLength(getLength(value));\n    }\n\n    module.exports = isArrayLike;\n\n},{\"31\":31,\"40\":40}],37:[function(require,module,exports){\n    /**\n     * Checks if `value` is a host object in IE < 9.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n     */\n    var isHostObject = (function() {\n        try {\n            Object({ 'toString': 0 } + '');\n        } catch(e) {\n            return function() { return false; };\n        }\n        return function(value) {\n            // IE < 9 presents many host objects as `Object` objects that can coerce\n            // to strings despite having improperly defined `toString` methods.\n            return typeof value.toString != 'function' && typeof (value + '') == 'string';\n        };\n    }());\n\n    module.exports = isHostObject;\n\n},{}],38:[function(require,module,exports){\n    /** Used to detect unsigned integer values. */\n    var reIsUint = /^\\d+$/;\n\n    /**\n     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n     * of an array-like value.\n     */\n    var MAX_SAFE_INTEGER = 9007199254740991;\n\n    /**\n     * Checks if `value` is a valid array-like index.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n     */\n    function isIndex(value, length) {\n        value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\n        length = length == null ? MAX_SAFE_INTEGER : length;\n        return value > -1 && value % 1 == 0 && value < length;\n    }\n\n    module.exports = isIndex;\n\n},{}],39:[function(require,module,exports){\n    var isArrayLike = require(36),\n        isIndex = require(38),\n        isObject = require(50);\n\n    /**\n     * Checks if the provided arguments are from an iteratee call.\n     *\n     * @private\n     * @param {*} value The potential iteratee value argument.\n     * @param {*} index The potential iteratee index or key argument.\n     * @param {*} object The potential iteratee object argument.\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\n     */\n    function isIterateeCall(value, index, object) {\n        if (!isObject(object)) {\n            return false;\n        }\n        var type = typeof index;\n        if (type == 'number'\n                ? (isArrayLike(object) && isIndex(index, object.length))\n                : (type == 'string' && index in object)) {\n            var other = object[index];\n            return value === value ? (value === other) : (other !== other);\n        }\n        return false;\n    }\n\n    module.exports = isIterateeCall;\n\n},{\"36\":36,\"38\":38,\"50\":50}],40:[function(require,module,exports){\n    /**\n     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n     * of an array-like value.\n     */\n    var MAX_SAFE_INTEGER = 9007199254740991;\n\n    /**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     */\n    function isLength(value) {\n        return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n\n    module.exports = isLength;\n\n},{}],41:[function(require,module,exports){\n    /**\n     * Checks if `value` is object-like.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n     */\n    function isObjectLike(value) {\n        return !!value && typeof value == 'object';\n    }\n\n    module.exports = isObjectLike;\n\n},{}],42:[function(require,module,exports){\n    var isArguments = require(46),\n        isArray = require(47),\n        isIndex = require(38),\n        isLength = require(40),\n        isString = require(52),\n        keysIn = require(56);\n\n    /** Used for native method references. */\n    var objectProto = Object.prototype;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /**\n     * A fallback implementation of `Object.keys` which creates an array of the\n     * own enumerable property names of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function shimKeys(object) {\n        var props = keysIn(object),\n            propsLength = props.length,\n            length = propsLength && object.length;\n\n        var allowIndexes = !!length && isLength(length) &&\n            (isArray(object) || isArguments(object) || isString(object));\n\n        var index = -1,\n            result = [];\n\n        while (++index < propsLength) {\n            var key = props[index];\n            if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\n                result.push(key);\n            }\n        }\n        return result;\n    }\n\n    module.exports = shimKeys;\n\n},{\"38\":38,\"40\":40,\"46\":46,\"47\":47,\"52\":52,\"56\":56}],43:[function(require,module,exports){\n    var isObject = require(50),\n        isString = require(52),\n        support = require(58);\n\n    /**\n     * Converts `value` to an object if it's not one.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {Object} Returns the object.\n     */\n    function toObject(value) {\n        if (support.unindexedChars && isString(value)) {\n            var index = -1,\n                length = value.length,\n                result = Object(value);\n\n            while (++index < length) {\n                result[index] = value.charAt(index);\n            }\n            return result;\n        }\n        return isObject(value) ? value : Object(value);\n    }\n\n    module.exports = toObject;\n\n},{\"50\":50,\"52\":52,\"58\":58}],44:[function(require,module,exports){\n    var baseClone = require(16),\n        bindCallback = require(25),\n        isIterateeCall = require(39);\n\n    /**\n     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,\n     * otherwise they are assigned by reference. If `customizer` is provided it is\n     * invoked to produce the cloned values. If `customizer` returns `undefined`\n     * cloning is handled by the method instead. The `customizer` is bound to\n     * `thisArg` and invoked with two argument; (value [, index|key, object]).\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).\n     * The enumerable properties of `arguments` objects and objects created by\n     * constructors other than `Object` are cloned to plain `Object` objects. An\n     * empty object is returned for uncloneable values such as functions, DOM nodes,\n     * Maps, Sets, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @param {Function} [customizer] The function to customize cloning values.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {*} Returns the cloned value.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * var shallow = _.clone(users);\n     * shallow[0] === users[0];\n     * // => true\n     *\n     * var deep = _.clone(users, true);\n     * deep[0] === users[0];\n     * // => false\n     *\n     * // using a customizer callback\n     * var el = _.clone(document.body, function(value) {\n *   if (_.isElement(value)) {\n *     return value.cloneNode(false);\n *   }\n * });\n     *\n     * el === document.body\n     * // => false\n     * el.nodeName\n     * // => BODY\n     * el.childNodes.length;\n     * // => 0\n     */\n    function clone(value, isDeep, customizer, thisArg) {\n        if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {\n            isDeep = false;\n        }\n        else if (typeof isDeep == 'function') {\n            thisArg = customizer;\n            customizer = isDeep;\n            isDeep = false;\n        }\n        return typeof customizer == 'function'\n            ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))\n            : baseClone(value, isDeep);\n    }\n\n    module.exports = clone;\n\n},{\"16\":16,\"25\":25,\"39\":39}],45:[function(require,module,exports){\n    var baseClone = require(16),\n        bindCallback = require(25);\n\n    /**\n     * Creates a deep clone of `value`. If `customizer` is provided it is invoked\n     * to produce the cloned values. If `customizer` returns `undefined` cloning\n     * is handled by the method instead. The `customizer` is bound to `thisArg`\n     * and invoked with two argument; (value [, index|key, object]).\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).\n     * The enumerable properties of `arguments` objects and objects created by\n     * constructors other than `Object` are cloned to plain `Object` objects. An\n     * empty object is returned for uncloneable values such as functions, DOM nodes,\n     * Maps, Sets, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to deep clone.\n     * @param {Function} [customizer] The function to customize cloning values.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {*} Returns the deep cloned value.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * var deep = _.cloneDeep(users);\n     * deep[0] === users[0];\n     * // => false\n     *\n     * // using a customizer callback\n     * var el = _.cloneDeep(document.body, function(value) {\n *   if (_.isElement(value)) {\n *     return value.cloneNode(true);\n *   }\n * });\n     *\n     * el === document.body\n     * // => false\n     * el.nodeName\n     * // => BODY\n     * el.childNodes.length;\n     * // => 20\n     */\n    function cloneDeep(value, customizer, thisArg) {\n        return typeof customizer == 'function'\n            ? baseClone(value, true, bindCallback(customizer, thisArg, 1))\n            : baseClone(value, true);\n    }\n\n    module.exports = cloneDeep;\n\n},{\"16\":16,\"25\":25}],46:[function(require,module,exports){\n    var isArrayLike = require(36),\n        isObjectLike = require(41);\n\n    /** Used for native method references. */\n    var objectProto = Object.prototype;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /** Native method references. */\n    var propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n    /**\n     * Checks if `value` is classified as an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isArguments(function() { return arguments; }());\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    function isArguments(value) {\n        return isObjectLike(value) && isArrayLike(value) &&\n            hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\n    }\n\n    module.exports = isArguments;\n\n},{\"36\":36,\"41\":41}],47:[function(require,module,exports){\n    var getNative = require(32),\n        isLength = require(40),\n        isObjectLike = require(41);\n\n    /** `Object#toString` result references. */\n    var arrayTag = '[object Array]';\n\n    /** Used for native method references. */\n    var objectProto = Object.prototype;\n\n    /**\n     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var objToString = objectProto.toString;\n\n    /* Native method references for those with the same name as other `lodash` methods. */\n    var nativeIsArray = getNative(Array, 'isArray');\n\n    /**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * _.isArray(function() { return arguments; }());\n     * // => false\n     */\n    var isArray = nativeIsArray || function(value) {\n            return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\n        };\n\n    module.exports = isArray;\n\n},{\"32\":32,\"40\":40,\"41\":41}],48:[function(require,module,exports){\n    var isObject = require(50);\n\n    /** `Object#toString` result references. */\n    var funcTag = '[object Function]';\n\n    /** Used for native method references. */\n    var objectProto = Object.prototype;\n\n    /**\n     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var objToString = objectProto.toString;\n\n    /**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n    function isFunction(value) {\n        // The use of `Object#toString` avoids issues with the `typeof` operator\n        // in older versions of Chrome and Safari which return 'function' for regexes\n        // and Safari 8 equivalents which return 'object' for typed array constructors.\n        return isObject(value) && objToString.call(value) == funcTag;\n    }\n\n    module.exports = isFunction;\n\n},{\"50\":50}],49:[function(require,module,exports){\n    var isFunction = require(48),\n        isHostObject = require(37),\n        isObjectLike = require(41);\n\n    /** Used to detect host constructors (Safari > 5). */\n    var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n    /** Used for native method references. */\n    var objectProto = Object.prototype;\n\n    /** Used to resolve the decompiled source of functions. */\n    var fnToString = Function.prototype.toString;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /** Used to detect if a method is native. */\n    var reIsNative = RegExp('^' +\n        fnToString.call(hasOwnProperty).replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&')\n            .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n    );\n\n    /**\n     * Checks if `value` is a native function.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n     * @example\n     *\n     * _.isNative(Array.prototype.push);\n     * // => true\n     *\n     * _.isNative(_);\n     * // => false\n     */\n    function isNative(value) {\n        if (value == null) {\n            return false;\n        }\n        if (isFunction(value)) {\n            return reIsNative.test(fnToString.call(value));\n        }\n        return isObjectLike(value) && (isHostObject(value) ? reIsNative : reIsHostCtor).test(value);\n    }\n\n    module.exports = isNative;\n\n},{\"37\":37,\"41\":41,\"48\":48}],50:[function(require,module,exports){\n    /**\n     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(1);\n     * // => false\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return !!value && (type == 'object' || type == 'function');\n    }\n\n    module.exports = isObject;\n\n},{}],51:[function(require,module,exports){\n    var baseForIn = require(20),\n        isArguments = require(46),\n        isHostObject = require(37),\n        isObjectLike = require(41),\n        support = require(58);\n\n    /** `Object#toString` result references. */\n    var objectTag = '[object Object]';\n\n    /** Used for native method references. */\n    var objectProto = Object.prototype;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /**\n     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var objToString = objectProto.toString;\n\n    /**\n     * Checks if `value` is a plain object, that is, an object created by the\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n     *\n     * **Note:** This method assumes objects created by the `Object` constructor\n     * have no inherited enumerable properties.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Foo() {\n *   this.a = 1;\n * }\n     *\n     * _.isPlainObject(new Foo);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     *\n     * _.isPlainObject(Object.create(null));\n     * // => true\n     */\n    function isPlainObject(value) {\n        var Ctor;\n\n        // Exit early for non `Object` objects.\n        if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isHostObject(value) && !isArguments(value)) ||\n            (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {\n            return false;\n        }\n        // IE < 9 iterates inherited properties before own properties. If the first\n        // iterated property is an object's own property then there are no inherited\n        // enumerable properties.\n        var result;\n        if (support.ownLast) {\n            baseForIn(value, function(subValue, key, object) {\n                result = hasOwnProperty.call(object, key);\n                return false;\n            });\n            return result !== false;\n        }\n        // In most environments an object's own properties are iterated before\n        // its inherited properties. If the last iterated property is an object's\n        // own property then there are no inherited enumerable properties.\n        baseForIn(value, function(subValue, key) {\n            result = key;\n        });\n        return result === undefined || hasOwnProperty.call(value, result);\n    }\n\n    module.exports = isPlainObject;\n\n},{\"20\":20,\"37\":37,\"41\":41,\"46\":46,\"58\":58}],52:[function(require,module,exports){\n    var isObjectLike = require(41);\n\n    /** `Object#toString` result references. */\n    var stringTag = '[object String]';\n\n    /** Used for native method references. */\n    var objectProto = Object.prototype;\n\n    /**\n     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var objToString = objectProto.toString;\n\n    /**\n     * Checks if `value` is classified as a `String` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isString('abc');\n     * // => true\n     *\n     * _.isString(1);\n     * // => false\n     */\n    function isString(value) {\n        return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);\n    }\n\n    module.exports = isString;\n\n},{\"41\":41}],53:[function(require,module,exports){\n    var isLength = require(40),\n        isObjectLike = require(41);\n\n    /** `Object#toString` result references. */\n    var argsTag = '[object Arguments]',\n        arrayTag = '[object Array]',\n        boolTag = '[object Boolean]',\n        dateTag = '[object Date]',\n        errorTag = '[object Error]',\n        funcTag = '[object Function]',\n        mapTag = '[object Map]',\n        numberTag = '[object Number]',\n        objectTag = '[object Object]',\n        regexpTag = '[object RegExp]',\n        setTag = '[object Set]',\n        stringTag = '[object String]',\n        weakMapTag = '[object WeakMap]';\n\n    var arrayBufferTag = '[object ArrayBuffer]',\n        float32Tag = '[object Float32Array]',\n        float64Tag = '[object Float64Array]',\n        int8Tag = '[object Int8Array]',\n        int16Tag = '[object Int16Array]',\n        int32Tag = '[object Int32Array]',\n        uint8Tag = '[object Uint8Array]',\n        uint8ClampedTag = '[object Uint8ClampedArray]',\n        uint16Tag = '[object Uint16Array]',\n        uint32Tag = '[object Uint32Array]';\n\n    /** Used to identify `toStringTag` values of typed arrays. */\n    var typedArrayTags = {};\n    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n        typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n            typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n                typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n                    typedArrayTags[uint32Tag] = true;\n    typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n        typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n            typedArrayTags[dateTag] = typedArrayTags[errorTag] =\n                typedArrayTags[funcTag] = typedArrayTags[mapTag] =\n                    typedArrayTags[numberTag] = typedArrayTags[objectTag] =\n                        typedArrayTags[regexpTag] = typedArrayTags[setTag] =\n                            typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n\n    /** Used for native method references. */\n    var objectProto = Object.prototype;\n\n    /**\n     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var objToString = objectProto.toString;\n\n    /**\n     * Checks if `value` is classified as a typed array.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isTypedArray(new Uint8Array);\n     * // => true\n     *\n     * _.isTypedArray([]);\n     * // => false\n     */\n    function isTypedArray(value) {\n        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];\n    }\n\n    module.exports = isTypedArray;\n\n},{\"40\":40,\"41\":41}],54:[function(require,module,exports){\n    var baseCopy = require(17),\n        keysIn = require(56);\n\n    /**\n     * Converts `value` to a plain object flattening inherited enumerable\n     * properties of `value` to own properties of the plain object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Object} Returns the converted plain object.\n     * @example\n     *\n     * function Foo() {\n *   this.b = 2;\n * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.assign({ 'a': 1 }, new Foo);\n     * // => { 'a': 1, 'b': 2 }\n     *\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\n     */\n    function toPlainObject(value) {\n        return baseCopy(value, keysIn(value));\n    }\n\n    module.exports = toPlainObject;\n\n},{\"17\":17,\"56\":56}],55:[function(require,module,exports){\n    var getNative = require(32),\n        isArrayLike = require(36),\n        isObject = require(50),\n        shimKeys = require(42),\n        support = require(58);\n\n    /* Native method references for those with the same name as other `lodash` methods. */\n    var nativeKeys = getNative(Object, 'keys');\n\n    /**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects. See the\n     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keys(new Foo);\n     * // => ['a', 'b'] (iteration order is not guaranteed)\n     *\n     * _.keys('hi');\n     * // => ['0', '1']\n     */\n    var keys = !nativeKeys ? shimKeys : function(object) {\n        var Ctor = object == null ? undefined : object.constructor;\n        if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\n            (typeof object == 'function' ? support.enumPrototypes : isArrayLike(object))) {\n            return shimKeys(object);\n        }\n        return isObject(object) ? nativeKeys(object) : [];\n    };\n\n    module.exports = keys;\n\n},{\"32\":32,\"36\":36,\"42\":42,\"50\":50,\"58\":58}],56:[function(require,module,exports){\n    var arrayEach = require(14),\n        isArguments = require(46),\n        isArray = require(47),\n        isFunction = require(48),\n        isIndex = require(38),\n        isLength = require(40),\n        isObject = require(50),\n        isString = require(52),\n        support = require(58);\n\n    /** `Object#toString` result references. */\n    var arrayTag = '[object Array]',\n        boolTag = '[object Boolean]',\n        dateTag = '[object Date]',\n        errorTag = '[object Error]',\n        funcTag = '[object Function]',\n        numberTag = '[object Number]',\n        objectTag = '[object Object]',\n        regexpTag = '[object RegExp]',\n        stringTag = '[object String]';\n\n    /** Used to fix the JScript `[[DontEnum]]` bug. */\n    var shadowProps = [\n        'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',\n        'toLocaleString', 'toString', 'valueOf'\n    ];\n\n    /** Used for native method references. */\n    var errorProto = Error.prototype,\n        objectProto = Object.prototype,\n        stringProto = String.prototype;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /**\n     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var objToString = objectProto.toString;\n\n    /** Used to avoid iterating over non-enumerable properties in IE < 9. */\n    var nonEnumProps = {};\n    nonEnumProps[arrayTag] = nonEnumProps[dateTag] = nonEnumProps[numberTag] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };\n    nonEnumProps[boolTag] = nonEnumProps[stringTag] = { 'constructor': true, 'toString': true, 'valueOf': true };\n    nonEnumProps[errorTag] = nonEnumProps[funcTag] = nonEnumProps[regexpTag] = { 'constructor': true, 'toString': true };\n    nonEnumProps[objectTag] = { 'constructor': true };\n\n    arrayEach(shadowProps, function(key) {\n        for (var tag in nonEnumProps) {\n            if (hasOwnProperty.call(nonEnumProps, tag)) {\n                var props = nonEnumProps[tag];\n                props[key] = hasOwnProperty.call(props, key);\n            }\n        }\n    });\n\n    /**\n     * Creates an array of the own and inherited enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keysIn(new Foo);\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n     */\n    function keysIn(object) {\n        if (object == null) {\n            return [];\n        }\n        if (!isObject(object)) {\n            object = Object(object);\n        }\n        var length = object.length;\n\n        length = (length && isLength(length) &&\n            (isArray(object) || isArguments(object) || isString(object)) && length) || 0;\n\n        var Ctor = object.constructor,\n            index = -1,\n            proto = (isFunction(Ctor) && Ctor.prototype) || objectProto,\n            isProto = proto === object,\n            result = Array(length),\n            skipIndexes = length > 0,\n            skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error),\n            skipProto = support.enumPrototypes && isFunction(object);\n\n        while (++index < length) {\n            result[index] = (index + '');\n        }\n        // lodash skips the `constructor` property when it infers it is iterating\n        // over a `prototype` object because IE < 9 can't set the `[[Enumerable]]`\n        // attribute of an existing property and the `constructor` property of a\n        // prototype defaults to non-enumerable.\n        for (var key in object) {\n            if (!(skipProto && key == 'prototype') &&\n                !(skipErrorProps && (key == 'message' || key == 'name')) &&\n                !(skipIndexes && isIndex(key, length)) &&\n                !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n                result.push(key);\n            }\n        }\n        if (support.nonEnumShadows && object !== objectProto) {\n            var tag = object === stringProto ? stringTag : (object === errorProto ? errorTag : objToString.call(object)),\n                nonEnums = nonEnumProps[tag] || nonEnumProps[objectTag];\n\n            if (tag == objectTag) {\n                proto = objectProto;\n            }\n            length = shadowProps.length;\n            while (length--) {\n                key = shadowProps[length];\n                var nonEnum = nonEnums[key];\n                if (!(isProto && nonEnum) &&\n                    (nonEnum ? hasOwnProperty.call(object, key) : object[key] !== proto[key])) {\n                    result.push(key);\n                }\n            }\n        }\n        return result;\n    }\n\n    module.exports = keysIn;\n\n},{\"14\":14,\"38\":38,\"40\":40,\"46\":46,\"47\":47,\"48\":48,\"50\":50,\"52\":52,\"58\":58}],57:[function(require,module,exports){\n    var baseMerge = require(22),\n        createAssigner = require(27);\n\n    /**\n     * Recursively merges own enumerable properties of the source object(s), that\n     * don't resolve to `undefined` into the destination object. Subsequent sources\n     * overwrite property assignments of previous sources. If `customizer` is\n     * provided it is invoked to produce the merged values of the destination and\n     * source properties. If `customizer` returns `undefined` merging is handled\n     * by the method instead. The `customizer` is bound to `thisArg` and invoked\n     * with five arguments: (objectValue, sourceValue, key, object, source).\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var users = {\n *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]\n * };\n     *\n     * var ages = {\n *   'data': [{ 'age': 36 }, { 'age': 40 }]\n * };\n     *\n     * _.merge(users, ages);\n     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }\n     *\n     * // using a customizer callback\n     * var object = {\n *   'fruits': ['apple'],\n *   'vegetables': ['beet']\n * };\n     *\n     * var other = {\n *   'fruits': ['banana'],\n *   'vegetables': ['carrot']\n * };\n     *\n     * _.merge(object, other, function(a, b) {\n *   if (_.isArray(a)) {\n *     return a.concat(b);\n *   }\n * });\n     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }\n     */\n    var merge = createAssigner(baseMerge);\n\n    module.exports = merge;\n\n},{\"22\":22,\"27\":27}],58:[function(require,module,exports){\n    /** Used for native method references. */\n    var arrayProto = Array.prototype,\n        errorProto = Error.prototype,\n        objectProto = Object.prototype;\n\n    /** Native method references. */\n    var propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        splice = arrayProto.splice;\n\n    /**\n     * An object environment feature flags.\n     *\n     * @static\n     * @memberOf _\n     * @type Object\n     */\n    var support = {};\n\n    (function(x) {\n        var Ctor = function() { this.x = x; },\n            object = { '0': x, 'length': x },\n            props = [];\n\n        Ctor.prototype = { 'valueOf': x, 'y': x };\n        for (var key in new Ctor) { props.push(key); }\n\n        /**\n         * Detect if `name` or `message` properties of `Error.prototype` are\n         * enumerable by default (IE < 9, Safari < 5.1).\n         *\n         * @memberOf _.support\n         * @type boolean\n         */\n        support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') ||\n            propertyIsEnumerable.call(errorProto, 'name');\n\n        /**\n         * Detect if `prototype` properties are enumerable by default.\n         *\n         * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1\n         * (if the prototype or a property on the prototype has been set)\n         * incorrectly set the `[[Enumerable]]` value of a function's `prototype`\n         * property to `true`.\n         *\n         * @memberOf _.support\n         * @type boolean\n         */\n        support.enumPrototypes = propertyIsEnumerable.call(Ctor, 'prototype');\n\n        /**\n         * Detect if properties shadowing those on `Object.prototype` are non-enumerable.\n         *\n         * In IE < 9 an object's own properties, shadowing non-enumerable ones,\n         * are made non-enumerable as well (a.k.a the JScript `[[DontEnum]]` bug).\n         *\n         * @memberOf _.support\n         * @type boolean\n         */\n        support.nonEnumShadows = !/valueOf/.test(props);\n\n        /**\n         * Detect if own properties are iterated after inherited properties (IE < 9).\n         *\n         * @memberOf _.support\n         * @type boolean\n         */\n        support.ownLast = props[0] != 'x';\n\n        /**\n         * Detect if `Array#shift` and `Array#splice` augment array-like objects\n         * correctly.\n         *\n         * Firefox < 10, compatibility modes of IE 8, and IE < 9 have buggy Array\n         * `shift()` and `splice()` functions that fail to remove the last element,\n         * `value[0]`, of array-like objects even though the \"length\" property is\n         * set to `0`. The `shift()` method is buggy in compatibility modes of IE 8,\n         * while `splice()` is buggy regardless of mode in IE < 9.\n         *\n         * @memberOf _.support\n         * @type boolean\n         */\n        support.spliceObjects = (splice.call(object, 0, 1), !object[0]);\n\n        /**\n         * Detect lack of support for accessing string characters by index.\n         *\n         * IE < 8 can't access characters by index. IE 8 can only access characters\n         * by index on string literals, not string objects.\n         *\n         * @memberOf _.support\n         * @type boolean\n         */\n        support.unindexedChars = ('x'[0] + Object('x')[0]) != 'xx';\n    }(1, 0));\n\n    module.exports = support;\n\n},{}],59:[function(require,module,exports){\n    /**\n     * This method returns the first argument provided to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * _.identity(object) === object;\n     * // => true\n     */\n    function identity(value) {\n        return value;\n    }\n\n    module.exports = identity;\n\n},{}],60:[function(require,module,exports){\n    (function (process){\n        'use strict';\n\n        module.exports = AlgoliaSearch;\n\n// default debug activated in dev environments\n// this is triggered in package.json, using the envify transform\n        if (false) {\n            require(6).enable('algoliasearch*');\n        }\n\n        var errors = require(66);\n\n        /*\n         * Algolia Search library initialization\n         * https://www.algolia.com/\n         *\n         * @param {string} applicationID - Your applicationID, found in your dashboard\n         * @param {string} apiKey - Your API key, found in your dashboard\n         * @param {Object} [opts]\n         * @param {number} [opts.timeout=2000] - The request timeout set in milliseconds,\n         * another request will be issued after this timeout\n         * @param {string} [opts.protocol='http:'] - The protocol used to query Algolia Search API.\n         *                                        Set to 'https:' to force using https.\n         *                                        Default to document.location.protocol in browsers\n         * @param {Object|Array} [opts.hosts={\n         *           read: [this.applicationID + '-dsn.algolia.net'].concat([\n         *             this.applicationID + '-1.algolianet.com',\n         *             this.applicationID + '-2.algolianet.com',\n         *             this.applicationID + '-3.algolianet.com']\n         *           ]),\n         *           write: [this.applicationID + '.algolia.net'].concat([\n         *             this.applicationID + '-1.algolianet.com',\n         *             this.applicationID + '-2.algolianet.com',\n         *             this.applicationID + '-3.algolianet.com']\n         *           ]) - The hosts to use for Algolia Search API.\n         *           If you provide them, you will less benefit from our HA implementation\n         */\n        function AlgoliaSearch(applicationID, apiKey, opts) {\n            var debug = require(6)('algoliasearch');\n\n            var clone = require(44);\n            var isArray = require(47);\n\n            var usage = 'Usage: algoliasearch(applicationID, apiKey, opts)';\n\n            if (!applicationID) {\n                throw new errors.AlgoliaSearchError('Please provide an application ID. ' + usage);\n            }\n\n            if (!apiKey) {\n                throw new errors.AlgoliaSearchError('Please provide an API key. ' + usage);\n            }\n\n            this.applicationID = applicationID;\n            this.apiKey = apiKey;\n\n            var defaultHosts = [\n                this.applicationID + '-1.algolianet.com',\n                this.applicationID + '-2.algolianet.com',\n                this.applicationID + '-3.algolianet.com'\n            ];\n            this.hosts = {\n                read: [],\n                write: []\n            };\n\n            this.hostIndex = {\n                read: 0,\n                write: 0\n            };\n\n            opts = opts || {};\n\n            var protocol = opts.protocol || 'https:';\n            var timeout = opts.timeout === undefined ? 2000 : opts.timeout;\n\n            // while we advocate for colon-at-the-end values: 'http:' for `opts.protocol`\n            // we also accept `http` and `https`. It's a common error.\n            if (!/:$/.test(protocol)) {\n                protocol = protocol + ':';\n            }\n\n            if (opts.protocol !== 'http:' && opts.protocol !== 'https:') {\n                throw new errors.AlgoliaSearchError('protocol must be `http:` or `https:` (was `' + opts.protocol + '`)');\n            }\n\n            // no hosts given, add defaults\n            if (!opts.hosts) {\n                this.hosts.read = [this.applicationID + '-dsn.algolia.net'].concat(defaultHosts);\n                this.hosts.write = [this.applicationID + '.algolia.net'].concat(defaultHosts);\n            } else if (isArray(opts.hosts)) {\n                this.hosts.read = clone(opts.hosts);\n                this.hosts.write = clone(opts.hosts);\n            } else {\n                this.hosts.read = clone(opts.hosts.read);\n                this.hosts.write = clone(opts.hosts.write);\n            }\n\n            // add protocol and lowercase hosts\n            this.hosts.read = map(this.hosts.read, prepareHost(protocol));\n            this.hosts.write = map(this.hosts.write, prepareHost(protocol));\n            this.requestTimeout = timeout;\n\n            this.extraHeaders = [];\n            this.cache = {};\n\n            this._ua = opts._ua;\n            this._useCache = opts._useCache === undefined ? true : opts._useCache;\n\n            this._setTimeout = opts._setTimeout;\n\n            debug('init done, %j', this);\n        }\n\n        AlgoliaSearch.prototype = {\n            /*\n             * Delete an index\n             *\n             * @param indexName the name of index to delete\n             * @param callback the result callback called with two arguments\n             *  error: null or Error('message')\n             *  content: the server answer that contains the task ID\n             */\n            deleteIndex: function(indexName, callback) {\n                return this._jsonRequest({\n                    method: 'DELETE',\n                    url: '/1/indexes/' + encodeURIComponent(indexName),\n                    hostType: 'write',\n                    callback: callback\n                });\n            },\n            /**\n             * Move an existing index.\n             * @param srcIndexName the name of index to copy.\n             * @param dstIndexName the new index name that will contains a copy of\n             * srcIndexName (destination will be overriten if it already exist).\n             * @param callback the result callback called with two arguments\n             *  error: null or Error('message')\n             *  content: the server answer that contains the task ID\n             */\n            moveIndex: function(srcIndexName, dstIndexName, callback) {\n                var postObj = {\n                    operation: 'move', destination: dstIndexName\n                };\n                return this._jsonRequest({\n                    method: 'POST',\n                    url: '/1/indexes/' + encodeURIComponent(srcIndexName) + '/operation',\n                    body: postObj,\n                    hostType: 'write',\n                    callback: callback\n                });\n            },\n            /**\n             * Copy an existing index.\n             * @param srcIndexName the name of index to copy.\n             * @param dstIndexName the new index name that will contains a copy\n             * of srcIndexName (destination will be overriten if it already exist).\n             * @param callback the result callback called with two arguments\n             *  error: null or Error('message')\n             *  content: the server answer that contains the task ID\n             */\n            copyIndex: function(srcIndexName, dstIndexName, callback) {\n                var postObj = {\n                    operation: 'copy', destination: dstIndexName\n                };\n                return this._jsonRequest({\n                    method: 'POST',\n                    url: '/1/indexes/' + encodeURIComponent(srcIndexName) + '/operation',\n                    body: postObj,\n                    hostType: 'write',\n                    callback: callback\n                });\n            },\n            /**\n             * Return last log entries.\n             * @param offset Specify the first entry to retrieve (0-based, 0 is the most recent log entry).\n             * @param length Specify the maximum number of entries to retrieve starting\n             * at offset. Maximum allowed value: 1000.\n             * @param callback the result callback called with two arguments\n             *  error: null or Error('message')\n             *  content: the server answer that contains the task ID\n             */\n            getLogs: function(offset, length, callback) {\n                if (arguments.length === 0 || typeof offset === 'function') {\n                    // getLogs([cb])\n                    callback = offset;\n                    offset = 0;\n                    length = 10;\n                } else if (arguments.length === 1 || typeof length === 'function') {\n                    // getLogs(1, [cb)]\n                    callback = length;\n                    length = 10;\n                }\n\n                return this._jsonRequest({\n                    method: 'GET',\n                    url: '/1/logs?offset=' + offset + '&length=' + length,\n                    hostType: 'read',\n                    callback: callback\n                });\n            },\n            /*\n             * List all existing indexes (paginated)\n             *\n             * @param page The page to retrieve, starting at 0.\n             * @param callback the result callback called with two arguments\n             *  error: null or Error('message')\n             *  content: the server answer with index list\n             */\n            listIndexes: function(page, callback) {\n                var params = '';\n\n                if (page === undefined || typeof page === 'function') {\n                    callback = page;\n                } else {\n                    params = '?page=' + page;\n                }\n\n                return this._jsonRequest({\n                    method: 'GET',\n                    url: '/1/indexes' + params,\n                    hostType: 'read',\n                    callback: callback\n                });\n            },\n\n            /*\n             * Get the index object initialized\n             *\n             * @param indexName the name of index\n             * @param callback the result callback with one argument (the Index instance)\n             */\n            initIndex: function(indexName) {\n                return new this.Index(this, indexName);\n            },\n            /*\n             * List all existing user keys with their associated ACLs\n             *\n             * @param callback the result callback called with two arguments\n             *  error: null or Error('message')\n             *  content: the server answer with user keys list\n             */\n            listUserKeys: function(callback) {\n                return this._jsonRequest({\n                    method: 'GET',\n                    url: '/1/keys',\n                    hostType: 'read',\n                    callback: callback\n                });\n            },\n            /*\n             * Get ACL of a user key\n             *\n             * @param key\n             * @param callback the result callback called with two arguments\n             *  error: null or Error('message')\n             *  content: the server answer with user keys list\n             */\n            getUserKeyACL: function(key, callback) {\n                return this._jsonRequest({\n                    method: 'GET',\n                    url: '/1/keys/' + key,\n                    hostType: 'read',\n                    callback: callback\n                });\n            },\n            /*\n             * Delete an existing user key\n             * @param key\n             * @param callback the result callback called with two arguments\n             *  error: null or Error('message')\n             *  content: the server answer with user keys list\n             */\n            deleteUserKey: function(key, callback) {\n                return this._jsonRequest({\n                    method: 'DELETE',\n                    url: '/1/keys/' + key,\n                    hostType: 'write',\n                    callback: callback\n                });\n            },\n            /*\n             * Add a new global API key\n             *\n             * @param {string[]} acls - The list of ACL for this key. Defined by an array of strings that\n             *   can contains the following values:\n             *     - search: allow to search (https and http)\n             *     - addObject: allows to add/update an object in the index (https only)\n             *     - deleteObject : allows to delete an existing object (https only)\n             *     - deleteIndex : allows to delete index content (https only)\n             *     - settings : allows to get index settings (https only)\n             *     - editSettings : allows to change index settings (https only)\n             * @param {Object} [params] - Optionnal parameters to set for the key\n             * @param {number} params.validity - Number of seconds after which the key will be automatically removed (0 means no time limit for this key)\n             * @param {number} params.maxQueriesPerIPPerHour - Number of API calls allowed from an IP address per hour\n             * @param {number} params.maxHitsPerQuery - Number of hits this API key can retrieve in one call\n             * @param {string[]} params.indexes - Allowed targeted indexes for this key\n             * @param {string} params.description - A description for your key\n             * @param {string[]} params.referers - A list of authorized referers\n             * @param {Object} params.queryParameters - Force the key to use specific query parameters\n             * @param {Function} callback - The result callback called with two arguments\n             *   error: null or Error('message')\n             *   content: the server answer with user keys list\n             * @return {Promise|undefined} Returns a promise if no callback given\n             * @example\n             * client.addUserKey(['search'], {\n             *   validity: 300,\n             *   maxQueriesPerIPPerHour: 2000,\n             *   maxHitsPerQuery: 3,\n             *   indexes: ['fruits'],\n             *   description: 'Eat three fruits',\n             *   referers: ['*.algolia.com'],\n             *   queryParameters: {\n             *     tagFilters: ['public'],\n             *   }\n             * })\n             * @see {@link https://www.algolia.com/doc/rest_api#AddKey|Algolia REST API Documentation}\n             */\n            addUserKey: function(acls, params, callback) {\n                if (arguments.length === 1 || typeof params === 'function') {\n                    callback = params;\n                    params = null;\n                }\n\n                var postObj = {\n                    acl: acls\n                };\n\n                if (params) {\n                    postObj.validity = params.validity;\n                    postObj.maxQueriesPerIPPerHour = params.maxQueriesPerIPPerHour;\n                    postObj.maxHitsPerQuery = params.maxHitsPerQuery;\n                    postObj.indexes = params.indexes;\n                    postObj.description = params.description;\n\n                    if (params.queryParameters) {\n                        postObj.queryParameters = this._getSearchParams(params.queryParameters, '');\n                    }\n\n                    postObj.referers = params.referers;\n                }\n\n                return this._jsonRequest({\n                    method: 'POST',\n                    url: '/1/keys',\n                    body: postObj,\n                    hostType: 'write',\n                    callback: callback\n                });\n            },\n            /**\n             * Add a new global API key\n             * @deprecated Please use client.addUserKey()\n             */\n            addUserKeyWithValidity: deprecate(function(acls, params, callback) {\n                return this.addUserKey(acls, params, callback);\n            }, deprecatedMessage('client.addUserKeyWithValidity()', 'client.addUserKey()')),\n\n            /**\n             * Update an existing API key\n             * @param {string} key - The key to update\n             * @param {string[]} acls - The list of ACL for this key. Defined by an array of strings that\n             *   can contains the following values:\n             *     - search: allow to search (https and http)\n             *     - addObject: allows to add/update an object in the index (https only)\n             *     - deleteObject : allows to delete an existing object (https only)\n             *     - deleteIndex : allows to delete index content (https only)\n             *     - settings : allows to get index settings (https only)\n             *     - editSettings : allows to change index settings (https only)\n             * @param {Object} [params] - Optionnal parameters to set for the key\n             * @param {number} params.validity - Number of seconds after which the key will be automatically removed (0 means no time limit for this key)\n             * @param {number} params.maxQueriesPerIPPerHour - Number of API calls allowed from an IP address per hour\n             * @param {number} params.maxHitsPerQuery - Number of hits this API key can retrieve in one call\n             * @param {string[]} params.indexes - Allowed targeted indexes for this key\n             * @param {string} params.description - A description for your key\n             * @param {string[]} params.referers - A list of authorized referers\n             * @param {Object} params.queryParameters - Force the key to use specific query parameters\n             * @param {Function} callback - The result callback called with two arguments\n             *   error: null or Error('message')\n             *   content: the server answer with user keys list\n             * @return {Promise|undefined} Returns a promise if no callback given\n             * @example\n             * client.updateUserKey('APIKEY', ['search'], {\n   *   validity: 300,\n   *   maxQueriesPerIPPerHour: 2000,\n   *   maxHitsPerQuery: 3,\n   *   indexes: ['fruits'],\n   *   description: 'Eat three fruits',\n   *   referers: ['*.algolia.com'],\n   *   queryParameters: {\n   *     tagFilters: ['public'],\n   *   }\n   * })\n             * @see {@link https://www.algolia.com/doc/rest_api#UpdateIndexKey|Algolia REST API Documentation}\n             */\n            updateUserKey: function(key, acls, params, callback) {\n                if (arguments.length === 2 || typeof params === 'function') {\n                    callback = params;\n                    params = null;\n                }\n\n                var putObj = {\n                    acl: acls\n                };\n\n                if (params) {\n                    putObj.validity = params.validity;\n                    putObj.maxQueriesPerIPPerHour = params.maxQueriesPerIPPerHour;\n                    putObj.maxHitsPerQuery = params.maxHitsPerQuery;\n                    putObj.indexes = params.indexes;\n                    putObj.description = params.description;\n\n                    if (params.queryParameters) {\n                        putObj.queryParameters = this._getSearchParams(params.queryParameters, '');\n                    }\n\n                    putObj.referers = params.referers;\n                }\n\n                return this._jsonRequest({\n                    method: 'PUT',\n                    url: '/1/keys/' + key,\n                    body: putObj,\n                    hostType: 'write',\n                    callback: callback\n                });\n            },\n\n            /**\n             * Set the extra security tagFilters header\n             * @param {string|array} tags The list of tags defining the current security filters\n             */\n            setSecurityTags: function(tags) {\n                if (Object.prototype.toString.call(tags) === '[object Array]') {\n                    var strTags = [];\n                    for (var i = 0; i < tags.length; ++i) {\n                        if (Object.prototype.toString.call(tags[i]) === '[object Array]') {\n                            var oredTags = [];\n                            for (var j = 0; j < tags[i].length; ++j) {\n                                oredTags.push(tags[i][j]);\n                            }\n                            strTags.push('(' + oredTags.join(',') + ')');\n                        } else {\n                            strTags.push(tags[i]);\n                        }\n                    }\n                    tags = strTags.join(',');\n                }\n\n                this.securityTags = tags;\n            },\n\n            /**\n             * Set the extra user token header\n             * @param {string} userToken The token identifying a uniq user (used to apply rate limits)\n             */\n            setUserToken: function(userToken) {\n                this.userToken = userToken;\n            },\n\n            /**\n             * Initialize a new batch of search queries\n             * @deprecated use client.search()\n             */\n            startQueriesBatch: deprecate(function startQueriesBatchDeprecated() {\n                this._batch = [];\n            }, deprecatedMessage('client.startQueriesBatch()', 'client.search()')),\n\n            /**\n             * Add a search query in the batch\n             * @deprecated use client.search()\n             */\n            addQueryInBatch: deprecate(function addQueryInBatchDeprecated(indexName, query, args) {\n                this._batch.push({\n                    indexName: indexName,\n                    query: query,\n                    params: args\n                });\n            }, deprecatedMessage('client.addQueryInBatch()', 'client.search()')),\n\n            /**\n             * Clear all queries in client's cache\n             * @return undefined\n             */\n            clearCache: function() {\n                this.cache = {};\n            },\n\n            /**\n             * Launch the batch of queries using XMLHttpRequest.\n             * @deprecated use client.search()\n             */\n            sendQueriesBatch: deprecate(function sendQueriesBatchDeprecated(callback) {\n                return this.search(this._batch, callback);\n            }, deprecatedMessage('client.sendQueriesBatch()', 'client.search()')),\n\n            /**\n             * Set the number of milliseconds a request can take before automatically being terminated.\n             *\n             * @param {Number} milliseconds\n             */\n            setRequestTimeout: function(milliseconds) {\n                if (milliseconds) {\n                    this.requestTimeout = parseInt(milliseconds, 10);\n                }\n            },\n\n            /**\n             * Search through multiple indices at the same time\n             * @param  {Object[]}   queries  An array of queries you want to run.\n             * @param {string} queries[].indexName The index name you want to target\n             * @param {string} [queries[].query] The query to issue on this index. Can also be passed into `params`\n             * @param {Object} queries[].params Any search param like hitsPerPage, ..\n             * @param  {Function} callback Callback to be called\n             * @return {Promise|undefined} Returns a promise if no callback given\n             */\n            search: function(queries, callback) {\n                var client = this;\n\n                var postObj = {\n                    requests: map(queries, function prepareRequest(query) {\n                        var params = '';\n\n                        // allow query.query\n                        // so we are mimicing the index.search(query, params) method\n                        // {indexName:, query:, params:}\n                        if (query.query !== undefined) {\n                            params += 'query=' + encodeURIComponent(query.query);\n                        }\n\n                        return {\n                            indexName: query.indexName,\n                            params: client._getSearchParams(query.params, params)\n                        };\n                    })\n                };\n\n                return this._jsonRequest({\n                    cache: this.cache,\n                    method: 'POST',\n                    url: '/1/indexes/*/queries',\n                    body: postObj,\n                    hostType: 'read',\n                    callback: callback\n                });\n            },\n\n            /**\n             * Perform write operations accross multiple indexes.\n             *\n             * To reduce the amount of time spent on network round trips,\n             * you can create, update, or delete several objects in one call,\n             * using the batch endpoint (all operations are done in the given order).\n             *\n             * Available actions:\n             *   - addObject\n             *   - updateObject\n             *   - partialUpdateObject\n             *   - partialUpdateObjectNoCreate\n             *   - deleteObject\n             *\n             * https://www.algolia.com/doc/rest_api#Indexes\n             * @param  {Object[]} operations An array of operations to perform\n             * @return {Promise|undefined} Returns a promise if no callback given\n             * @example\n             * client.batch([{\n   *   action: 'addObject',\n   *   indexName: 'clients',\n   *   body: {\n   *     name: 'Bill'\n   *   }\n   * }, {\n   *   action: 'udpateObject',\n   *   indexName: 'fruits',\n   *   body: {\n   *     objectID: '29138',\n   *     name: 'banana'\n   *   }\n   * }], cb)\n             */\n            batch: function(operations, callback) {\n                return this._jsonRequest({\n                    method: 'POST',\n                    url: '/1/indexes/*/batch',\n                    body: {\n                        requests: operations\n                    },\n                    hostType: 'write',\n                    callback: callback\n                });\n            },\n\n            // environment specific methods\n            destroy: notImplemented,\n            enableRateLimitForward: notImplemented,\n            disableRateLimitForward: notImplemented,\n            useSecuredAPIKey: notImplemented,\n            disableSecuredAPIKey: notImplemented,\n            generateSecuredApiKey: notImplemented,\n            /*\n             * Index class constructor.\n             * You should not use this method directly but use initIndex() function\n             */\n            Index: function(algoliasearch, indexName) {\n                this.indexName = indexName;\n                this.as = algoliasearch;\n                this.typeAheadArgs = null;\n                this.typeAheadValueOption = null;\n\n                // make sure every index instance has it's own cache\n                this.cache = {};\n            },\n            /**\n             * Add an extra field to the HTTP request\n             *\n             * @param name the header field name\n             * @param value the header field value\n             */\n            setExtraHeader: function(name, value) {\n                this.extraHeaders.push({\n                    name: name.toLowerCase(), value: value\n                });\n            },\n\n            _sendQueriesBatch: function(params, callback) {\n                function prepareParams() {\n                    var reqParams = '';\n                    for (var i = 0; i < params.requests.length; ++i) {\n                        var q = '/1/indexes/' +\n                            encodeURIComponent(params.requests[i].indexName) +\n                            '?' + params.requests[i].params;\n                        reqParams += i + '=' + encodeURIComponent(q) + '&';\n                    }\n                    return reqParams;\n                }\n\n                return this._jsonRequest({\n                    cache: this.cache,\n                    method: 'POST',\n                    url: '/1/indexes/*/queries',\n                    body: params,\n                    hostType: 'read',\n                    fallback: {\n                        method: 'GET',\n                        url: '/1/indexes/*',\n                        body: {\n                            params: prepareParams()\n                        }\n                    },\n                    callback: callback\n                });\n            },\n            /*\n             * Wrapper that try all hosts to maximize the quality of service\n             */\n            _jsonRequest: function(opts) {\n                var requestDebug = require(6)('algoliasearch:' + opts.url);\n\n                var body;\n                var cache = opts.cache;\n                var client = this;\n                var tries = 0;\n                var usingFallback = false;\n\n                if (opts.body !== undefined) {\n                    body = safeJSONStringify(opts.body);\n                }\n\n                requestDebug('request start');\n\n                function doRequest(requester, reqOpts) {\n                    var cacheID;\n\n                    if (client._useCache) {\n                        cacheID = opts.url;\n                    }\n\n                    // as we sometime use POST requests to pass parameters (like query='aa'),\n                    // the cacheID must also include the body to be different between calls\n                    if (client._useCache && body) {\n                        cacheID += '_body_' + reqOpts.body;\n                    }\n\n                    // handle cache existence\n                    if (client._useCache && cache && cache[cacheID] !== undefined) {\n                        requestDebug('serving response from cache');\n                        return client._promise.resolve(JSON.parse(safeJSONStringify(cache[cacheID])));\n                    }\n\n                    // if we reached max tries\n                    if (tries >= client.hosts[opts.hostType].length ||\n                            // or we need to switch to fallback\n                        client.useFallback && !usingFallback) {\n                        // and there's no fallback or we are already using a fallback\n                        if (!opts.fallback || !client._request.fallback || usingFallback) {\n                            requestDebug('could not get any response');\n                            // then stop\n                            return client._promise.reject(new errors.AlgoliaSearchError(\n                                'Cannot connect to the AlgoliaSearch API.' +\n                                ' Send an email to support@algolia.com to report and resolve the issue.' +\n                                ' Application id was: ' + client.applicationID\n                            ));\n                        }\n\n                        requestDebug('switching to fallback');\n\n                        // let's try the fallback starting from here\n                        tries = 0;\n\n                        // method, url and body are fallback dependent\n                        reqOpts.method = opts.fallback.method;\n                        reqOpts.url = opts.fallback.url;\n                        reqOpts.jsonBody = opts.fallback.body;\n                        if (reqOpts.jsonBody) {\n                            reqOpts.body = safeJSONStringify(reqOpts.jsonBody);\n                        }\n\n                        reqOpts.timeout = client.requestTimeout * (tries + 1);\n                        client.hostIndex[opts.hostType] = 0;\n                        usingFallback = true; // the current request is now using fallback\n                        return doRequest(client._request.fallback, reqOpts);\n                    }\n\n                    var url = client.hosts[opts.hostType][client.hostIndex[opts.hostType]] + reqOpts.url;\n                    var options = {\n                        body: body,\n                        jsonBody: opts.body,\n                        method: reqOpts.method,\n                        headers: client._computeRequestHeaders(),\n                        timeout: reqOpts.timeout,\n                        debug: requestDebug\n                    };\n\n                    requestDebug('method: %s, url: %s, headers: %j, timeout: %d',\n                        options.method, url, options.headers, options.timeout);\n\n                    if (requester === client._request.fallback) {\n                        requestDebug('using fallback');\n                    }\n\n                    // `requester` is any of this._request or this._request.fallback\n                    // thus it needs to be called using the client as context\n                    return requester.call(client, url, options).then(success, tryFallback);\n\n                    function success(httpResponse) {\n                        // compute the status of the response,\n                        //\n                        // When in browser mode, using XDR or JSONP, we have no statusCode available\n                        // So we rely on our API response `status` property.\n                        // But `waitTask` can set a `status` property which is not the statusCode (it's the task status)\n                        // So we check if there's a `message` along `status` and it means it's an error\n                        //\n                        // That's the only case where we have a response.status that's not the http statusCode\n                        var status = httpResponse && httpResponse.body && httpResponse.body.message && httpResponse.body.status ||\n\n                                // this is important to check the request statusCode AFTER the body eventual\n                                // statusCode because some implementations (jQuery XDomainRequest transport) may\n                                // send statusCode 200 while we had an error\n                            httpResponse.statusCode ||\n\n                                // When in browser mode, using XDR or JSONP\n                                // we default to success when no error (no response.status && response.message)\n                                // If there was a JSON.parse() error then body is null and it fails\n                            httpResponse && httpResponse.body && 200;\n\n                        requestDebug('received response: statusCode: %s, computed statusCode: %d, headers: %j',\n                            httpResponse.statusCode, status, httpResponse.headers);\n\n                        if (process.env.DEBUG && process.env.DEBUG.indexOf('debugBody') !== -1) {\n                            requestDebug('body: %j', httpResponse.body);\n                        }\n\n                        var ok = status === 200 || status === 201;\n                        var retry = !ok && Math.floor(status / 100) !== 4 && Math.floor(status / 100) !== 1;\n\n                        if (client._useCache && ok && cache) {\n                            cache[cacheID] = httpResponse.body;\n                        }\n\n                        if (ok) {\n                            return httpResponse.body;\n                        }\n\n                        if (retry) {\n                            tries += 1;\n                            return retryRequest();\n                        }\n\n                        var unrecoverableError = new errors.AlgoliaSearchError(\n                            httpResponse.body && httpResponse.body.message\n                        );\n\n                        return client._promise.reject(unrecoverableError);\n                    }\n\n                    function tryFallback(err) {\n                        // error cases:\n                        //  While not in fallback mode:\n                        //    - CORS not supported\n                        //    - network error\n                        //  While in fallback mode:\n                        //    - timeout\n                        //    - network error\n                        //    - badly formatted JSONP (script loaded, did not call our callback)\n                        //  In both cases:\n                        //    - uncaught exception occurs (TypeError)\n                        requestDebug('error: %s, stack: %s', err.message, err.stack);\n\n                        if (!(err instanceof errors.AlgoliaSearchError)) {\n                            err = new errors.Unknown(err && err.message, err);\n                        }\n\n                        tries += 1;\n\n                        // stop the request implementation when:\n                        if (\n                            // we did not generate this error,\n                        // it comes from a throw in some other piece of code\n                        err instanceof errors.Unknown ||\n\n                            // server sent unparsable JSON\n                        err instanceof errors.UnparsableJSON ||\n\n                            // no fallback and a network error occured (No CORS, bad APPID)\n                        !requester.fallback && err instanceof errors.Network ||\n\n                            // max tries and already using fallback or no fallback\n                        tries >= client.hosts[opts.hostType].length &&\n                        (usingFallback || !opts.fallback || !client._request.fallback)) {\n                            // stop request implementation for this command\n                            return client._promise.reject(err);\n                        }\n\n                        client.hostIndex[opts.hostType] = ++client.hostIndex[opts.hostType] % client.hosts[opts.hostType].length;\n\n                        if (err instanceof errors.RequestTimeout) {\n                            return retryRequest();\n                        } else if (client._request.fallback && !client.useFallback) {\n                            // if any error occured but timeout, use fallback for the rest\n                            // of the session\n                            client.useFallback = true;\n                        }\n\n                        return doRequest(requester, reqOpts);\n                    }\n\n                    function retryRequest() {\n                        client.hostIndex[opts.hostType] = ++client.hostIndex[opts.hostType] % client.hosts[opts.hostType].length;\n                        reqOpts.timeout = client.requestTimeout * (tries + 1);\n                        return doRequest(requester, reqOpts);\n                    }\n                }\n\n                // we can use a fallback if forced AND fallback parameters are available\n                var useFallback = client.useFallback && opts.fallback;\n                var requestOptions = useFallback ? opts.fallback : opts;\n\n                var promise = doRequest(\n                    // set the requester\n                    useFallback ? client._request.fallback : client._request, {\n                        url: requestOptions.url,\n                        method: requestOptions.method,\n                        body: body,\n                        jsonBody: opts.body,\n                        timeout: client.requestTimeout * (tries + 1)\n                    }\n                );\n\n                // either we have a callback\n                // either we are using promises\n                if (opts.callback) {\n                    promise.then(function okCb(content) {\n                        exitPromise(function() {\n                            opts.callback(null, content);\n                        }, client._setTimeout || setTimeout);\n                    }, function nookCb(err) {\n                        exitPromise(function() {\n                            opts.callback(err);\n                        }, client._setTimeout || setTimeout);\n                    });\n                } else {\n                    return promise;\n                }\n            },\n\n            /*\n             * Transform search param object in query string\n             */\n            _getSearchParams: function(args, params) {\n                if (this._isUndefined(args) || args === null) {\n                    return params;\n                }\n                for (var key in args) {\n                    if (key !== null && args[key] !== undefined && args.hasOwnProperty(key)) {\n                        params += params === '' ? '' : '&';\n                        params += key + '=' + encodeURIComponent(Object.prototype.toString.call(args[key]) === '[object Array]' ? safeJSONStringify(args[key]) : args[key]);\n                    }\n                }\n                return params;\n            },\n\n            _isUndefined: function(obj) {\n                return obj === void 0;\n            },\n\n            _computeRequestHeaders: function() {\n                var forEach = require(11);\n\n                var requestHeaders = {\n                    'x-algolia-api-key': this.apiKey,\n                    'x-algolia-application-id': this.applicationID,\n                    'x-algolia-agent': this._ua\n                };\n\n                if (this.userToken) {\n                    requestHeaders['x-algolia-usertoken'] = this.userToken;\n                }\n\n                if (this.securityTags) {\n                    requestHeaders['x-algolia-tagfilters'] = this.securityTags;\n                }\n\n                if (this.extraHeaders) {\n                    forEach(this.extraHeaders, function addToRequestHeaders(header) {\n                        requestHeaders[header.name] = header.value;\n                    });\n                }\n\n                return requestHeaders;\n            }\n        };\n\n        /*\n         * Contains all the functions related to one index\n         * You should use AlgoliaSearch.initIndex(indexName) to retrieve this object\n         */\n        AlgoliaSearch.prototype.Index.prototype = {\n            /*\n             * Clear all queries in cache\n             */\n            clearCache: function() {\n                this.cache = {};\n            },\n            /*\n             * Add an object in this index\n             *\n             * @param content contains the javascript object to add inside the index\n             * @param objectID (optional) an objectID you want to attribute to this object\n             * (if the attribute already exist the old object will be overwrite)\n             * @param callback (optional) the result callback called with two arguments:\n             *  error: null or Error('message')\n             *  content: the server answer that contains 3 elements: createAt, taskId and objectID\n             */\n            addObject: function(content, objectID, callback) {\n                var indexObj = this;\n\n                if (arguments.length === 1 || typeof objectID === 'function') {\n                    callback = objectID;\n                    objectID = undefined;\n                }\n\n                return this.as._jsonRequest({\n                    method: objectID !== undefined ?\n                        'PUT' : // update or create\n                        'POST', // create (API generates an objectID)\n                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + // create\n                    (objectID !== undefined ? '/' + encodeURIComponent(objectID) : ''), // update or create\n                    body: content,\n                    hostType: 'write',\n                    callback: callback\n                });\n            },\n            /*\n             * Add several objects\n             *\n             * @param objects contains an array of objects to add\n             * @param callback (optional) the result callback called with two arguments:\n             *  error: null or Error('message')\n             *  content: the server answer that updateAt and taskID\n             */\n            addObjects: function(objects, callback) {\n                var indexObj = this;\n                var postObj = {\n                    requests: []\n                };\n                for (var i = 0; i < objects.length; ++i) {\n                    var request = {\n                        action: 'addObject',\n                        body: objects[i]\n                    };\n                    postObj.requests.push(request);\n                }\n                return this.as._jsonRequest({\n                    method: 'POST',\n                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/batch',\n                    body: postObj,\n                    hostType: 'write',\n                    callback: callback\n                });\n            },\n            /*\n             * Get an object from this index\n             *\n             * @param objectID the unique identifier of the object to retrieve\n             * @param attrs (optional) if set, contains the array of attribute names to retrieve\n             * @param callback (optional) the result callback called with two arguments\n             *  error: null or Error('message')\n             *  content: the object to retrieve or the error message if a failure occured\n             */\n            getObject: function(objectID, attrs, callback) {\n                var indexObj = this;\n\n                if (arguments.length === 1 || typeof attrs === 'function') {\n                    callback = attrs;\n                    attrs = undefined;\n                }\n\n                var params = '';\n                if (attrs !== undefined) {\n                    params = '?attributes=';\n                    for (var i = 0; i < attrs.length; ++i) {\n                        if (i !== 0) {\n                            params += ',';\n                        }\n                        params += attrs[i];\n                    }\n                }\n\n                return this.as._jsonRequest({\n                    method: 'GET',\n                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(objectID) + params,\n                    hostType: 'read',\n                    callback: callback\n                });\n            },\n\n            /*\n             * Get several objects from this index\n             *\n             * @param objectIDs the array of unique identifier of objects to retrieve\n             */\n            getObjects: function(objectIDs, attributesToRetrieve, callback) {\n                var indexObj = this;\n\n                if (arguments.length === 1 || typeof attributesToRetrieve === 'function') {\n                    callback = attributesToRetrieve;\n                    attributesToRetrieve = undefined;\n                }\n\n                var body = {\n                    requests: map(objectIDs, function prepareRequest(objectID) {\n                        var request = {\n                            'indexName': indexObj.indexName,\n                            'objectID': objectID\n                        };\n\n                        if (attributesToRetrieve) {\n                            request.attributesToRetrieve = attributesToRetrieve.join(',');\n                        }\n\n                        return request;\n                    })\n                };\n\n                return this.as._jsonRequest({\n                    method: 'POST',\n                    url: '/1/indexes/*/objects',\n                    hostType: 'read',\n                    body: body,\n                    callback: callback\n                });\n            },\n\n            /*\n             * Update partially an object (only update attributes passed in argument)\n             *\n             * @param partialObject contains the javascript attributes to override, the\n             *  object must contains an objectID attribute\n             * @param callback (optional) the result callback called with two arguments:\n             *  error: null or Error('message')\n             *  content: the server answer that contains 3 elements: createAt, taskId and objectID\n             */\n            partialUpdateObject: function(partialObject, callback) {\n                var indexObj = this;\n                return this.as._jsonRequest({\n                    method: 'POST',\n                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(partialObject.objectID) + '/partial',\n                    body: partialObject,\n                    hostType: 'write',\n                    callback: callback\n                });\n            },\n            /*\n             * Partially Override the content of several objects\n             *\n             * @param objects contains an array of objects to update (each object must contains a objectID attribute)\n             * @param callback (optional) the result callback called with two arguments:\n             *  error: null or Error('message')\n             *  content: the server answer that updateAt and taskID\n             */\n            partialUpdateObjects: function(objects, callback) {\n                var indexObj = this;\n                var postObj = {\n                    requests: []\n                };\n                for (var i = 0; i < objects.length; ++i) {\n                    var request = {\n                        action: 'partialUpdateObject',\n                        objectID: objects[i].objectID,\n                        body: objects[i]\n                    };\n                    postObj.requests.push(request);\n                }\n                return this.as._jsonRequest({\n                    method: 'POST',\n                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/batch',\n                    body: postObj,\n                    hostType: 'write',\n                    callback: callback\n                });\n            },\n            /*\n             * Override the content of object\n             *\n             * @param object contains the javascript object to save, the object must contains an objectID attribute\n             * @param callback (optional) the result callback called with two arguments:\n             *  error: null or Error('message')\n             *  content: the server answer that updateAt and taskID\n             */\n            saveObject: function(object, callback) {\n                var indexObj = this;\n                return this.as._jsonRequest({\n                    method: 'PUT',\n                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(object.objectID),\n                    body: object,\n                    hostType: 'write',\n                    callback: callback\n                });\n            },\n            /*\n             * Override the content of several objects\n             *\n             * @param objects contains an array of objects to update (each object must contains a objectID attribute)\n             * @param callback (optional) the result callback called with two arguments:\n             *  error: null or Error('message')\n             *  content: the server answer that updateAt and taskID\n             */\n            saveObjects: function(objects, callback) {\n                var indexObj = this;\n                var postObj = {\n                    requests: []\n                };\n                for (var i = 0; i < objects.length; ++i) {\n                    var request = {\n                        action: 'updateObject',\n                        objectID: objects[i].objectID,\n                        body: objects[i]\n                    };\n                    postObj.requests.push(request);\n                }\n                return this.as._jsonRequest({\n                    method: 'POST',\n                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/batch',\n                    body: postObj,\n                    hostType: 'write',\n                    callback: callback\n                });\n            },\n            /*\n             * Delete an object from the index\n             *\n             * @param objectID the unique identifier of object to delete\n             * @param callback (optional) the result callback called with two arguments:\n             *  error: null or Error('message')\n             *  content: the server answer that contains 3 elements: createAt, taskId and objectID\n             */\n            deleteObject: function(objectID, callback) {\n                if (typeof objectID === 'function' || typeof objectID !== 'string' && typeof objectID !== 'number') {\n                    var err = new errors.AlgoliaSearchError('Cannot delete an object without an objectID');\n                    callback = objectID;\n                    if (typeof callback === 'function') {\n                        return callback(err);\n                    }\n\n                    return this.as._promise.reject(err);\n                }\n\n                var indexObj = this;\n                return this.as._jsonRequest({\n                    method: 'DELETE',\n                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/' + encodeURIComponent(objectID),\n                    hostType: 'write',\n                    callback: callback\n                });\n            },\n            /*\n             * Delete several objects from an index\n             *\n             * @param objectIDs contains an array of objectID to delete\n             * @param callback (optional) the result callback called with two arguments:\n             *  error: null or Error('message')\n             *  content: the server answer that contains 3 elements: createAt, taskId and objectID\n             */\n            deleteObjects: function(objectIDs, callback) {\n                var indexObj = this;\n                var postObj = {\n                    requests: map(objectIDs, function prepareRequest(objectID) {\n                        return {\n                            action: 'deleteObject',\n                            objectID: objectID,\n                            body: {\n                                objectID: objectID\n                            }\n                        };\n                    })\n                };\n\n                return this.as._jsonRequest({\n                    method: 'POST',\n                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/batch',\n                    body: postObj,\n                    hostType: 'write',\n                    callback: callback\n                });\n            },\n            /*\n             * Delete all objects matching a query\n             *\n             * @param query the query string\n             * @param params the optional query parameters\n             * @param callback (optional) the result callback called with one argument\n             *  error: null or Error('message')\n             */\n            deleteByQuery: function(query, params, callback) {\n                var indexObj = this;\n                var client = indexObj.as;\n\n                if (arguments.length === 1 || typeof params === 'function') {\n                    callback = params;\n                    params = {};\n                }\n\n                params.attributesToRetrieve = 'objectID';\n                params.hitsPerPage = 1000;\n\n                // when deleting, we should never use cache to get the\n                // search results\n                this.clearCache();\n\n                // there's a problem in how we use the promise chain,\n                // see how waitTask is done\n                var promise = this\n                    .search(query, params)\n                    .then(stopOrDelete);\n\n                function stopOrDelete(searchContent) {\n                    // stop here\n                    if (searchContent.nbHits === 0) {\n                        // return indexObj.as._request.resolve();\n                        return searchContent;\n                    }\n\n                    // continue and do a recursive call\n                    var objectIDs = map(searchContent.hits, function getObjectID(object) {\n                        return object.objectID;\n                    });\n\n                    return indexObj\n                        .deleteObjects(objectIDs)\n                        .then(waitTask)\n                        .then(doDeleteByQuery);\n                }\n\n                function waitTask(deleteObjectsContent) {\n                    return indexObj.waitTask(deleteObjectsContent.taskID);\n                }\n\n                function doDeleteByQuery() {\n                    return indexObj.deleteByQuery(query, params);\n                }\n\n                if (!callback) {\n                    return promise;\n                }\n\n                promise.then(success, failure);\n\n                function success() {\n                    exitPromise(function exit() {\n                        callback(null);\n                    }, client._setTimeout || setTimeout);\n                }\n\n                function failure(err) {\n                    exitPromise(function exit() {\n                        callback(err);\n                    }, client._setTimeout || setTimeout);\n                }\n            },\n            /*\n             * Search inside the index using XMLHttpRequest request (Using a POST query to\n             * minimize number of OPTIONS queries: Cross-Origin Resource Sharing).\n             *\n             * @param query the full text query\n             * @param args (optional) if set, contains an object with query parameters:\n             * - page: (integer) Pagination parameter used to select the page to retrieve.\n             *                   Page is zero-based and defaults to 0. Thus,\n             *                   to retrieve the 10th page you need to set page=9\n             * - hitsPerPage: (integer) Pagination parameter used to select the number of hits per page. Defaults to 20.\n             * - attributesToRetrieve: a string that contains the list of object attributes\n             * you want to retrieve (let you minimize the answer size).\n             *   Attributes are separated with a comma (for example \"name,address\").\n             *   You can also use an array (for example [\"name\",\"address\"]).\n             *   By default, all attributes are retrieved. You can also use '*' to retrieve all\n             *   values when an attributesToRetrieve setting is specified for your index.\n             * - attributesToHighlight: a string that contains the list of attributes you\n             *   want to highlight according to the query.\n             *   Attributes are separated by a comma. You can also use an array (for example [\"name\",\"address\"]).\n             *   If an attribute has no match for the query, the raw value is returned.\n             *   By default all indexed text attributes are highlighted.\n             *   You can use `*` if you want to highlight all textual attributes.\n             *   Numerical attributes are not highlighted.\n             *   A matchLevel is returned for each highlighted attribute and can contain:\n             *      - full: if all the query terms were found in the attribute,\n             *      - partial: if only some of the query terms were found,\n             *      - none: if none of the query terms were found.\n             * - attributesToSnippet: a string that contains the list of attributes to snippet alongside\n             * the number of words to return (syntax is `attributeName:nbWords`).\n             *    Attributes are separated by a comma (Example: attributesToSnippet=name:10,content:10).\n             *    You can also use an array (Example: attributesToSnippet: ['name:10','content:10']).\n             *    By default no snippet is computed.\n             * - minWordSizefor1Typo: the minimum number of characters in a query word to accept one typo in this word.\n             *D efaults to 3.\n             * - minWordSizefor2Typos: the minimum number of characters in a query word\n             * to accept two typos in this word. Defaults to 7.\n             * - getRankingInfo: if set to 1, the result hits will contain ranking\n             * information in _rankingInfo attribute.\n             * - aroundLatLng: search for entries around a given\n             * latitude/longitude (specified as two floats separated by a comma).\n             *   For example aroundLatLng=47.316669,5.016670).\n             *   You can specify the maximum distance in meters with the aroundRadius parameter (in meters)\n             *   and the precision for ranking with aroundPrecision\n             *   (for example if you set aroundPrecision=100, two objects that are distant of\n             *   less than 100m will be considered as identical for \"geo\" ranking parameter).\n             *   At indexing, you should specify geoloc of an object with the _geoloc attribute\n             *   (in the form {\"_geoloc\":{\"lat\":48.853409, \"lng\":2.348800}})\n             * - insideBoundingBox: search entries inside a given area defined by the two extreme points\n             * of a rectangle (defined by 4 floats: p1Lat,p1Lng,p2Lat,p2Lng).\n             *   For example insideBoundingBox=47.3165,4.9665,47.3424,5.0201).\n             *   At indexing, you should specify geoloc of an object with the _geoloc attribute\n             *   (in the form {\"_geoloc\":{\"lat\":48.853409, \"lng\":2.348800}})\n             * - numericFilters: a string that contains the list of numeric filters you want to\n             * apply separated by a comma.\n             *   The syntax of one filter is `attributeName` followed by `operand` followed by `value`.\n             *   Supported operands are `<`, `<=`, `=`, `>` and `>=`.\n             *   You can have multiple conditions on one attribute like for example numericFilters=price>100,price<1000.\n             *   You can also use an array (for example numericFilters: [\"price>100\",\"price<1000\"]).\n             * - tagFilters: filter the query by a set of tags. You can AND tags by separating them by commas.\n             *   To OR tags, you must add parentheses. For example, tags=tag1,(tag2,tag3) means tag1 AND (tag2 OR tag3).\n             *   You can also use an array, for example tagFilters: [\"tag1\",[\"tag2\",\"tag3\"]]\n             *   means tag1 AND (tag2 OR tag3).\n             *   At indexing, tags should be added in the _tags** attribute\n             *   of objects (for example {\"_tags\":[\"tag1\",\"tag2\"]}).\n             * - facetFilters: filter the query by a list of facets.\n             *   Facets are separated by commas and each facet is encoded as `attributeName:value`.\n             *   For example: `facetFilters=category:Book,author:John%20Doe`.\n             *   You can also use an array (for example `[\"category:Book\",\"author:John%20Doe\"]`).\n             * - facets: List of object attributes that you want to use for faceting.\n             *   Comma separated list: `\"category,author\"` or array `['category','author']`\n             *   Only attributes that have been added in **attributesForFaceting** index setting\n             *   can be used in this parameter.\n             *   You can also use `*` to perform faceting on all attributes specified in **attributesForFaceting**.\n             * - queryType: select how the query words are interpreted, it can be one of the following value:\n             *    - prefixAll: all query words are interpreted as prefixes,\n             *    - prefixLast: only the last word is interpreted as a prefix (default behavior),\n             *    - prefixNone: no query word is interpreted as a prefix. This option is not recommended.\n             * - optionalWords: a string that contains the list of words that should\n             * be considered as optional when found in the query.\n             *   Comma separated and array are accepted.\n             * - distinct: If set to 1, enable the distinct feature (disabled by default)\n             * if the attributeForDistinct index setting is set.\n             *   This feature is similar to the SQL \"distinct\" keyword: when enabled\n             *   in a query with the distinct=1 parameter,\n             *   all hits containing a duplicate value for the attributeForDistinct attribute are removed from results.\n             *   For example, if the chosen attribute is show_name and several hits have\n             *   the same value for show_name, then only the best\n             *   one is kept and others are removed.\n             * - restrictSearchableAttributes: List of attributes you want to use for\n             * textual search (must be a subset of the attributesToIndex index setting)\n             * either comma separated or as an array\n             * @param callback the result callback called with two arguments:\n             *  error: null or Error('message'). If false, the content contains the error.\n             *  content: the server answer that contains the list of results.\n             */\n            search: function(query, args, callback) {\n                // warn V2 users on how to search\n                if (typeof query === 'function' && typeof args === 'object' ||\n                    typeof callback === 'object') {\n                    // .search(query, params, cb)\n                    // .search(cb, params)\n                    throw new errors.AlgoliaSearchError('index.search usage is index.search(query, params, cb)');\n                }\n\n                if (arguments.length === 0 || typeof query === 'function') {\n                    // .search(), .search(cb)\n                    callback = query;\n                    query = '';\n                } else if (arguments.length === 1 || typeof args === 'function') {\n                    // .search(query/args), .search(query, cb)\n                    callback = args;\n                    args = undefined;\n                }\n\n                // .search(args), careful: typeof null === 'object'\n                if (typeof query === 'object' && query !== null) {\n                    args = query;\n                    query = undefined;\n                } else if (query === undefined || query === null) { // .search(undefined/null)\n                    query = '';\n                }\n\n                var params = '';\n\n                if (query !== undefined) {\n                    params += 'query=' + encodeURIComponent(query);\n                }\n\n                if (args !== undefined) {\n                    // `_getSearchParams` will augment params, do not be fooled by the = versus += from previous if\n                    params = this.as._getSearchParams(args, params);\n                }\n\n                return this._search(params, callback);\n            },\n\n            /*\n             * Browse index content. The response content will have a `cursor` property that you can use\n             * to browse subsequent pages for this query. Use `index.browseNext(cursor)` when you want.\n             *\n             * @param {string} query - The full text query\n             * @param {Object} [queryParameters] - Any search query parameter\n             * @param {Function} [callback] - The result callback called with two arguments\n             *   error: null or Error('message')\n             *   content: the server answer with the browse result\n             * @return {Promise|undefined} Returns a promise if no callback given\n             * @example\n             * index.browse('cool songs', {\n             *   tagFilters: 'public,comments',\n             *   hitsPerPage: 500\n             * }, callback);\n             * @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}\n             */\n            // pre 3.5.0 usage, backward compatible\n            // browse: function(page, hitsPerPage, callback) {\n            browse: function(query, queryParameters, callback) {\n                var merge = require(57);\n\n                var indexObj = this;\n\n                var page;\n                var hitsPerPage;\n\n                // we check variadic calls that are not the one defined\n                // .browse()/.browse(fn)\n                // => page = 0\n                if (arguments.length === 0 || arguments.length === 1 && typeof arguments[0] === 'function') {\n                    page = 0;\n                    callback = arguments[0];\n                    query = undefined;\n                } else if (typeof arguments[0] === 'number') {\n                    // .browse(2)/.browse(2, 10)/.browse(2, fn)/.browse(2, 10, fn)\n                    page = arguments[0];\n                    if (typeof arguments[1] === 'number') {\n                        hitsPerPage = arguments[1];\n                    } else if (typeof arguments[1] === 'function') {\n                        callback = arguments[1];\n                        hitsPerPage = undefined;\n                    }\n                    query = undefined;\n                    queryParameters = undefined;\n                } else if (typeof arguments[0] === 'object') {\n                    // .browse(queryParameters)/.browse(queryParameters, cb)\n                    if (typeof arguments[1] === 'function') {\n                        callback = arguments[1];\n                    }\n                    queryParameters = arguments[0];\n                    query = undefined;\n                } else if (typeof arguments[0] === 'string' && typeof arguments[1] === 'function') {\n                    // .browse(query, cb)\n                    callback = arguments[1];\n                    queryParameters = undefined;\n                }\n\n                // otherwise it's a .browse(query)/.browse(query, queryParameters)/.browse(query, queryParameters, cb)\n\n                // get search query parameters combining various possible calls\n                // to .browse();\n                queryParameters = merge({}, queryParameters || {}, {\n                    page: page,\n                    hitsPerPage: hitsPerPage,\n                    query: query\n                });\n\n                var params = this.as._getSearchParams(queryParameters, '');\n\n                return this.as._jsonRequest({\n                    method: 'GET',\n                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/browse?' + params,\n                    hostType: 'read',\n                    callback: callback\n                });\n            },\n\n            /*\n             * Continue browsing from a previous position (cursor), obtained via a call to `.browse()`.\n             *\n             * @param {string} query - The full text query\n             * @param {Object} [queryParameters] - Any search query parameter\n             * @param {Function} [callback] - The result callback called with two arguments\n             *   error: null or Error('message')\n             *   content: the server answer with the browse result\n             * @return {Promise|undefined} Returns a promise if no callback given\n             * @example\n             * index.browseFrom('14lkfsakl32', callback);\n             * @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}\n             */\n            browseFrom: function(cursor, callback) {\n                return this.as._jsonRequest({\n                    method: 'GET',\n                    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/browse?cursor=' + encodeURIComponent(cursor),\n                    hostType: 'read',\n                    callback: callback\n                });\n            },\n\n            /*\n             * Browse all content from an index using events. Basically this will do\n             * .browse() -> .browseFrom -> .browseFrom -> .. until all the results are returned\n             *\n             * @param {string} query - The full text query\n             * @param {Object} [queryParameters] - Any search query parameter\n             * @return {EventEmitter}\n             * @example\n             * var browser = index.browseAll('cool songs', {\n             *   tagFilters: 'public,comments',\n             *   hitsPerPage: 500\n             * });\n             *\n             * browser.on('result', function resultCallback(content) {\n             *   console.log(content.hits);\n             * });\n             *\n             * // if any error occurs, you get it\n             * browser.on('error', function(err) {\n             *   throw err;\n             * });\n             *\n             * // when you have browsed the whole index, you get this event\n             * browser.on('end', function() {\n             *   console.log('finished');\n             * });\n             *\n             * // at any point if you want to stop the browsing process, you can stop it manually\n             * // otherwise it will go on and on\n             * browser.stop();\n             *\n             * @see {@link https://www.algolia.com/doc/rest_api#Browse|Algolia REST API Documentation}\n             */\n            browseAll: function(query, queryParameters) {\n                if (typeof query === 'object') {\n                    queryParameters = query;\n                    query = undefined;\n                }\n\n                var merge = require(57);\n\n                var IndexBrowser = require(61);\n\n                var browser = new IndexBrowser();\n                var client = this.as;\n                var index = this;\n                var params = client._getSearchParams(\n                    merge({}, queryParameters || {}, {\n                        query: query\n                    }), ''\n                );\n\n                // start browsing\n                browseLoop();\n\n                function browseLoop(cursor) {\n                    if (browser._stopped) {\n                        return;\n                    }\n\n                    var queryString;\n\n                    if (cursor !== undefined) {\n                        queryString = 'cursor=' + encodeURIComponent(cursor);\n                    } else {\n                        queryString = params;\n                    }\n\n                    client._jsonRequest({\n                        method: 'GET',\n                        url: '/1/indexes/' + encodeURIComponent(index.indexName) + '/browse?' + queryString,\n                        hostType: 'read',\n                        callback: browseCallback\n                    });\n                }\n\n                function browseCallback(err, content) {\n                    if (browser._stopped) {\n                        return;\n                    }\n\n                    if (err) {\n                        browser._error(err);\n                        return;\n                    }\n\n                    browser._result(content);\n\n                    // no cursor means we are finished browsing\n                    if (content.cursor === undefined) {\n                        browser._end();\n                        return;\n                    }\n\n                    browseLoop(content.cursor);\n                }\n\n                return browser;\n            },\n\n            /*\n             * Get a Typeahead.js adapter\n             * @param searchParams contains an object with query parameters (see search for details)\n             */\n            ttAdapter: function(params) {\n                var self = this;\n                return function ttAdapter(query, syncCb, asyncCb) {\n                    var cb;\n\n                    if (typeof asyncCb === 'function') {\n                        // typeahead 0.11\n                        cb = asyncCb;\n                    } else {\n                        // pre typeahead 0.11\n                        cb = syncCb;\n                    }\n\n                    self.search(query, params, function searchDone(err, content) {\n                        if (err) {\n                            cb(err);\n                            return;\n                        }\n\n                        cb(content.hits);\n                    });\n                };\n            },\n\n            /*\n             * Wait the publication of a task on the server.\n             * All server task are asynchronous and you can check with this method that the task is published.\n             *\n             * @param taskID the id of the task returned by server\n             * @param callback the result callback with with two arguments:\n             *  error: null or Error('message')\n             *  content: the server answer that contains the list of results\n             */\n            waitTask: function(taskID, callback) {\n                // wait minimum 100ms before retrying\n                var baseDelay = 100;\n                // wait maximum 5s before retrying\n                var maxDelay = 5000;\n                var loop = 0;\n\n                // waitTask() must be handled differently from other methods,\n                // it's a recursive method using a timeout\n                var indexObj = this;\n                var client = indexObj.as;\n\n                var promise = retryLoop();\n\n                function retryLoop() {\n                    return client._jsonRequest({\n                        method: 'GET',\n                        hostType: 'read',\n                        url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/task/' + taskID\n                    }).then(function success(content) {\n                        loop++;\n                        var delay = baseDelay * loop * loop;\n                        if (delay > maxDelay) {\n                            delay = maxDelay;\n                        }\n\n                        if (content.status !== 'published') {\n                            return client._promise.delay(delay).then(retryLoop);\n                        }\n\n                        return content;\n                    });\n                }\n\n                if (!callback) {\n                    return promise;\n                }\n\n                promise.then(successCb, failureCb);\n\n                function successCb(content) {\n                    exitPromise(function exit() {\n                        callback(null, content);\n                    }, client._setTimeout || setTimeout);\n                }\n\n                function failureCb(err) {\n                    exitPromise(function exit() {\n                        callback(err);\n                    }, client._setTimeout || setTimeout);\n                }\n            },\n\n            /*\n             * This function deletes the index content. Settings and index specific API keys are kept untouched.\n             *\n             * @param callback (optional) the result callback called with two arguments\n             *  error: null or Error('message')\n             *  content: the settings object or the error message if a failure occured\n             */\n            clearIndex: function(callback) {\n                var indexObj = this;\n                return this.as._jsonRequest({\n                    method: 'POST',\n                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/clear',\n                    hostType: 'write',\n                    callback: callback\n                });\n            },\n            /*\n             * Get settings of this index\n             *\n             * @param callback (optional) the result callback called with two arguments\n             *  error: null or Error('message')\n             *  content: the settings object or the error message if a failure occured\n             */\n            getSettings: function(callback) {\n                var indexObj = this;\n                return this.as._jsonRequest({\n                    method: 'GET',\n                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/settings',\n                    hostType: 'read',\n                    callback: callback\n                });\n            },\n\n            /*\n             * Set settings for this index\n             *\n             * @param settigns the settings object that can contains :\n             * - minWordSizefor1Typo: (integer) the minimum number of characters to accept one typo (default = 3).\n             * - minWordSizefor2Typos: (integer) the minimum number of characters to accept two typos (default = 7).\n             * - hitsPerPage: (integer) the number of hits per page (default = 10).\n             * - attributesToRetrieve: (array of strings) default list of attributes to retrieve in objects.\n             *   If set to null, all attributes are retrieved.\n             * - attributesToHighlight: (array of strings) default list of attributes to highlight.\n             *   If set to null, all indexed attributes are highlighted.\n             * - attributesToSnippet**: (array of strings) default list of attributes to snippet alongside the number\n             * of words to return (syntax is attributeName:nbWords).\n             *   By default no snippet is computed. If set to null, no snippet is computed.\n             * - attributesToIndex: (array of strings) the list of fields you want to index.\n             *   If set to null, all textual and numerical attributes of your objects are indexed,\n             *   but you should update it to get optimal results.\n             *   This parameter has two important uses:\n             *     - Limit the attributes to index: For example if you store a binary image in base64,\n             *     you want to store it and be able to\n             *       retrieve it but you don't want to search in the base64 string.\n             *     - Control part of the ranking*: (see the ranking parameter for full explanation)\n             *     Matches in attributes at the beginning of\n             *       the list will be considered more important than matches in attributes further down the list.\n             *       In one attribute, matching text at the beginning of the attribute will be\n             *       considered more important than text after, you can disable\n             *       this behavior if you add your attribute inside `unordered(AttributeName)`,\n             *       for example attributesToIndex: [\"title\", \"unordered(text)\"].\n             * - attributesForFaceting: (array of strings) The list of fields you want to use for faceting.\n             *   All strings in the attribute selected for faceting are extracted and added as a facet.\n             *   If set to null, no attribute is used for faceting.\n             * - attributeForDistinct: (string) The attribute name used for the Distinct feature.\n             * This feature is similar to the SQL \"distinct\" keyword: when enabled\n             *   in query with the distinct=1 parameter, all hits containing a duplicate\n             *   value for this attribute are removed from results.\n             *   For example, if the chosen attribute is show_name and several hits have\n             *   the same value for show_name, then only the best one is kept and others are removed.\n             * - ranking: (array of strings) controls the way results are sorted.\n             *   We have six available criteria:\n             *    - typo: sort according to number of typos,\n             *    - geo: sort according to decreassing distance when performing a geo-location based search,\n             *    - proximity: sort according to the proximity of query words in hits,\n             *    - attribute: sort according to the order of attributes defined by attributesToIndex,\n             *    - exact:\n             *        - if the user query contains one word: sort objects having an attribute\n             *        that is exactly the query word before others.\n             *          For example if you search for the \"V\" TV show, you want to find it\n             *          with the \"V\" query and avoid to have all popular TV\n             *          show starting by the v letter before it.\n             *        - if the user query contains multiple words: sort according to the\n             *        number of words that matched exactly (and not as a prefix).\n             *    - custom: sort according to a user defined formula set in **customRanking** attribute.\n             *   The standard order is [\"typo\", \"geo\", \"proximity\", \"attribute\", \"exact\", \"custom\"]\n             * - customRanking: (array of strings) lets you specify part of the ranking.\n             *   The syntax of this condition is an array of strings containing attributes\n             *   prefixed by asc (ascending order) or desc (descending order) operator.\n             *   For example `\"customRanking\" => [\"desc(population)\", \"asc(name)\"]`\n             * - queryType: Select how the query words are interpreted, it can be one of the following value:\n             *   - prefixAll: all query words are interpreted as prefixes,\n             *   - prefixLast: only the last word is interpreted as a prefix (default behavior),\n             *   - prefixNone: no query word is interpreted as a prefix. This option is not recommended.\n             * - highlightPreTag: (string) Specify the string that is inserted before\n             * the highlighted parts in the query result (default to \"<em>\").\n             * - highlightPostTag: (string) Specify the string that is inserted after\n             * the highlighted parts in the query result (default to \"</em>\").\n             * - optionalWords: (array of strings) Specify a list of words that should\n             * be considered as optional when found in the query.\n             * @param callback (optional) the result callback called with two arguments\n             *  error: null or Error('message')\n             *  content: the server answer or the error message if a failure occured\n             */\n            setSettings: function(settings, callback) {\n                var indexObj = this;\n                return this.as._jsonRequest({\n                    method: 'PUT',\n                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/settings',\n                    hostType: 'write',\n                    body: settings,\n                    callback: callback\n                });\n            },\n            /*\n             * List all existing user keys associated to this index\n             *\n             * @param callback the result callback called with two arguments\n             *  error: null or Error('message')\n             *  content: the server answer with user keys list\n             */\n            listUserKeys: function(callback) {\n                var indexObj = this;\n                return this.as._jsonRequest({\n                    method: 'GET',\n                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/keys',\n                    hostType: 'read',\n                    callback: callback\n                });\n            },\n            /*\n             * Get ACL of a user key associated to this index\n             *\n             * @param key\n             * @param callback the result callback called with two arguments\n             *  error: null or Error('message')\n             *  content: the server answer with user keys list\n             */\n            getUserKeyACL: function(key, callback) {\n                var indexObj = this;\n                return this.as._jsonRequest({\n                    method: 'GET',\n                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/keys/' + key,\n                    hostType: 'read',\n                    callback: callback\n                });\n            },\n            /*\n             * Delete an existing user key associated to this index\n             *\n             * @param key\n             * @param callback the result callback called with two arguments\n             *  error: null or Error('message')\n             *  content: the server answer with user keys list\n             */\n            deleteUserKey: function(key, callback) {\n                var indexObj = this;\n                return this.as._jsonRequest({\n                    method: 'DELETE',\n                    url: '/1/indexes/' + encodeURIComponent(indexObj.indexName) + '/keys/' + key,\n                    hostType: 'write',\n                    callback: callback\n                });\n            },\n            /*\n             * Add a new API key to this index\n             *\n             * @param {string[]} acls - The list of ACL for this key. Defined by an array of strings that\n             *   can contains the following values:\n             *     - search: allow to search (https and http)\n             *     - addObject: allows to add/update an object in the index (https only)\n             *     - deleteObject : allows to delete an existing object (https only)\n             *     - deleteIndex : allows to delete index content (https only)\n             *     - settings : allows to get index settings (https only)\n             *     - editSettings : allows to change index settings (https only)\n             * @param {Object} [params] - Optionnal parameters to set for the key\n             * @param {number} params.validity - Number of seconds after which the key will\n             * be automatically removed (0 means no time limit for this key)\n             * @param {number} params.maxQueriesPerIPPerHour - Number of API calls allowed from an IP address per hour\n             * @param {number} params.maxHitsPerQuery - Number of hits this API key can retrieve in one call\n             * @param {string} params.description - A description for your key\n             * @param {string[]} params.referers - A list of authorized referers\n             * @param {Object} params.queryParameters - Force the key to use specific query parameters\n             * @param {Function} callback - The result callback called with two arguments\n             *   error: null or Error('message')\n             *   content: the server answer with user keys list\n             * @return {Promise|undefined} Returns a promise if no callback given\n             * @example\n             * index.addUserKey(['search'], {\n             *   validity: 300,\n             *   maxQueriesPerIPPerHour: 2000,\n             *   maxHitsPerQuery: 3,\n             *   description: 'Eat three fruits',\n             *   referers: ['*.algolia.com'],\n             *   queryParameters: {\n             *     tagFilters: ['public'],\n             *   }\n             * })\n             * @see {@link https://www.algolia.com/doc/rest_api#AddIndexKey|Algolia REST API Documentation}\n             */\n            addUserKey: function(acls, params, callback) {\n                if (arguments.length === 1 || typeof params === 'function') {\n                    callback = params;\n                    params = null;\n                }\n\n                var postObj = {\n                    acl: acls\n                };\n\n                if (params) {\n                    postObj.validity = params.validity;\n                    postObj.maxQueriesPerIPPerHour = params.maxQueriesPerIPPerHour;\n                    postObj.maxHitsPerQuery = params.maxHitsPerQuery;\n                    postObj.description = params.description;\n\n                    if (params.queryParameters) {\n                        postObj.queryParameters = this.as._getSearchParams(params.queryParameters, '');\n                    }\n\n                    postObj.referers = params.referers;\n                }\n\n                return this.as._jsonRequest({\n                    method: 'POST',\n                    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/keys',\n                    body: postObj,\n                    hostType: 'write',\n                    callback: callback\n                });\n            },\n\n            /**\n             * Add an existing user key associated to this index\n             * @deprecated use index.addUserKey()\n             */\n            addUserKeyWithValidity: deprecate(function deprecatedAddUserKeyWithValidity(acls, params, callback) {\n                return this.addUserKey(acls, params, callback);\n            }, deprecatedMessage('index.addUserKeyWithValidity()', 'index.addUserKey()')),\n\n            /**\n             * Update an existing API key of this index\n             * @param {string} key - The key to update\n             * @param {string[]} acls - The list of ACL for this key. Defined by an array of strings that\n             *   can contains the following values:\n             *     - search: allow to search (https and http)\n             *     - addObject: allows to add/update an object in the index (https only)\n             *     - deleteObject : allows to delete an existing object (https only)\n             *     - deleteIndex : allows to delete index content (https only)\n             *     - settings : allows to get index settings (https only)\n             *     - editSettings : allows to change index settings (https only)\n             * @param {Object} [params] - Optionnal parameters to set for the key\n             * @param {number} params.validity - Number of seconds after which the key will\n             * be automatically removed (0 means no time limit for this key)\n             * @param {number} params.maxQueriesPerIPPerHour - Number of API calls allowed from an IP address per hour\n             * @param {number} params.maxHitsPerQuery - Number of hits this API key can retrieve in one call\n             * @param {string} params.description - A description for your key\n             * @param {string[]} params.referers - A list of authorized referers\n             * @param {Object} params.queryParameters - Force the key to use specific query parameters\n             * @param {Function} callback - The result callback called with two arguments\n             *   error: null or Error('message')\n             *   content: the server answer with user keys list\n             * @return {Promise|undefined} Returns a promise if no callback given\n             * @example\n             * index.updateUserKey('APIKEY', ['search'], {\n   *   validity: 300,\n   *   maxQueriesPerIPPerHour: 2000,\n   *   maxHitsPerQuery: 3,\n   *   description: 'Eat three fruits',\n   *   referers: ['*.algolia.com'],\n   *   queryParameters: {\n   *     tagFilters: ['public'],\n   *   }\n   * })\n             * @see {@link https://www.algolia.com/doc/rest_api#UpdateIndexKey|Algolia REST API Documentation}\n             */\n            updateUserKey: function(key, acls, params, callback) {\n                if (arguments.length === 2 || typeof params === 'function') {\n                    callback = params;\n                    params = null;\n                }\n\n                var putObj = {\n                    acl: acls\n                };\n\n                if (params) {\n                    putObj.validity = params.validity;\n                    putObj.maxQueriesPerIPPerHour = params.maxQueriesPerIPPerHour;\n                    putObj.maxHitsPerQuery = params.maxHitsPerQuery;\n                    putObj.description = params.description;\n\n                    if (params.queryParameters) {\n                        putObj.queryParameters = this.as._getSearchParams(params.queryParameters, '');\n                    }\n\n                    putObj.referers = params.referers;\n                }\n\n                return this.as._jsonRequest({\n                    method: 'PUT',\n                    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/keys/' + key,\n                    body: putObj,\n                    hostType: 'write',\n                    callback: callback\n                });\n            },\n\n            _search: function(params, callback) {\n                return this.as._jsonRequest({\n                    cache: this.cache,\n                    method: 'POST',\n                    url: '/1/indexes/' + encodeURIComponent(this.indexName) + '/query',\n                    body: {params: params},\n                    hostType: 'read',\n                    fallback: {\n                        method: 'GET',\n                        url: '/1/indexes/' + encodeURIComponent(this.indexName),\n                        body: {params: params}\n                    },\n                    callback: callback\n                });\n            },\n\n            as: null,\n            indexName: null,\n            typeAheadArgs: null,\n            typeAheadValueOption: null\n        };\n\n// extracted from https://github.com/component/map/blob/master/index.js\n// without the crazy toFunction thing\n        function map(arr, fn) {\n            var ret = [];\n            for (var i = 0; i < arr.length; ++i) {\n                ret.push(fn(arr[i], i));\n            }\n            return ret;\n        }\n\n        function prepareHost(protocol) {\n            return function prepare(host) {\n                return protocol + '//' + host.toLowerCase();\n            };\n        }\n\n        function notImplemented() {\n            var message = 'Not implemented in this environment.\\n' +\n                'If you feel this is a mistake, write to support@algolia.com';\n\n            throw new errors.AlgoliaSearchError(message);\n        }\n\n        function deprecatedMessage(previousUsage, newUsage) {\n            var githubAnchorLink = previousUsage.toLowerCase()\n                .replace('.', '')\n                .replace('()', '');\n\n            return 'algoliasearch: `' + previousUsage + '` was replaced by `' + newUsage +\n                '`. Please see https://github.com/algolia/algoliasearch-client-js/wiki/Deprecated#' + githubAnchorLink;\n        }\n\n// Parse cloud does not supports setTimeout\n// We do not store a setTimeout reference in the client everytime\n// We only fallback to a fake setTimeout when not available\n// setTimeout cannot be override globally sadly\n        function exitPromise(fn, _setTimeout) {\n            _setTimeout(fn, 0);\n        }\n\n        function deprecate(fn, message) {\n            var warned = false;\n\n            function deprecated() {\n                if (!warned) {\n                    /* eslint no-console:0 */\n                    console.log(message);\n                    warned = true;\n                }\n\n                return fn.apply(this, arguments);\n            }\n\n            return deprecated;\n        }\n\n// Prototype.js < 1.7, a widely used library, defines a weird\n// Array.prototype.toJSON function that will fail to stringify our content\n// appropriately\n// refs:\n//   - https://groups.google.com/forum/#!topic/prototype-core/E-SAVvV_V9Q\n//   - https://github.com/sstephenson/prototype/commit/038a2985a70593c1a86c230fadbdfe2e4898a48c\n//   - http://stackoverflow.com/a/3148441/147079\n        function safeJSONStringify(obj) {\n            /* eslint no-extend-native:0 */\n\n            if (Array.prototype.toJSON === undefined) {\n                return JSON.stringify(obj);\n            }\n\n            var toJSON = Array.prototype.toJSON;\n            delete Array.prototype.toJSON;\n            var out = JSON.stringify(obj);\n            Array.prototype.toJSON = toJSON;\n\n            return out;\n        }\n\n    }).call(this,require(2))\n},{\"11\":11,\"2\":2,\"44\":44,\"47\":47,\"57\":57,\"6\":6,\"61\":61,\"66\":66}],61:[function(require,module,exports){\n    'use strict';\n\n// This is the object returned by the `index.browseAll()` method\n\n    module.exports = IndexBrowser;\n\n    var inherits = require(10);\n    var EventEmitter = require(1).EventEmitter;\n\n    function IndexBrowser() {\n    }\n\n    inherits(IndexBrowser, EventEmitter);\n\n    IndexBrowser.prototype.stop = function() {\n        this._stopped = true;\n        this._clean();\n    };\n\n    IndexBrowser.prototype._end = function() {\n        this.emit('end');\n        this._clean();\n    };\n\n    IndexBrowser.prototype._error = function(err) {\n        this.emit('error', err);\n        this._clean();\n    };\n\n    IndexBrowser.prototype._result = function(content) {\n        this.emit('result', content);\n    };\n\n    IndexBrowser.prototype._clean = function() {\n        this.removeAllListeners('stop');\n        this.removeAllListeners('end');\n        this.removeAllListeners('error');\n        this.removeAllListeners('result');\n    };\n\n},{\"1\":1,\"10\":10}],62:[function(require,module,exports){\n    'use strict';\n\n// This is the standalone browser build entry point\n// Browser implementation of the Algolia Search JavaScript client,\n// using XMLHttpRequest, XDomainRequest and JSONP as fallback\n    module.exports = algoliasearch;\n\n    var inherits = require(10);\n    var Promise = window.Promise || require(9).Promise;\n\n    var AlgoliaSearch = require(60);\n    var errors = require(66);\n    var inlineHeaders = require(64);\n    var jsonpRequest = require(65);\n\n    function algoliasearch(applicationID, apiKey, opts) {\n        var cloneDeep = require(45);\n\n        var getDocumentProtocol = require(63);\n\n        opts = cloneDeep(opts || {});\n\n        if (opts.protocol === undefined) {\n            opts.protocol = getDocumentProtocol();\n        }\n\n        opts._ua = opts._ua || algoliasearch.ua;\n\n        return new AlgoliaSearchBrowser(applicationID, apiKey, opts);\n    }\n\n    algoliasearch.version = require(67);\n    algoliasearch.ua = 'Algolia for vanilla JavaScript ' + algoliasearch.version;\n\n// we expose into window no matter how we are used, this will allow\n// us to easily debug any website running algolia\n    window.__algolia = {\n        debug: require(6),\n        algoliasearch: algoliasearch\n    };\n\n    var support = {\n        hasXMLHttpRequest: 'XMLHttpRequest' in window,\n        hasXDomainRequest: 'XDomainRequest' in window,\n        cors: 'withCredentials' in new XMLHttpRequest(),\n        timeout: 'timeout' in new XMLHttpRequest()\n    };\n\n    function AlgoliaSearchBrowser() {\n        // call AlgoliaSearch constructor\n        AlgoliaSearch.apply(this, arguments);\n    }\n\n    inherits(AlgoliaSearchBrowser, AlgoliaSearch);\n\n    AlgoliaSearchBrowser.prototype._request = function request(url, opts) {\n        return new Promise(function wrapRequest(resolve, reject) {\n            // no cors or XDomainRequest, no request\n            if (!support.cors && !support.hasXDomainRequest) {\n                // very old browser, not supported\n                reject(new errors.Network('CORS not supported'));\n                return;\n            }\n\n            url = inlineHeaders(url, opts.headers);\n\n            var body = opts.body;\n            var req = support.cors ? new XMLHttpRequest() : new XDomainRequest();\n            var ontimeout;\n            var timedOut;\n\n            // do not rely on default XHR async flag, as some analytics code like hotjar\n            // breaks it and set it to false by default\n            if (req instanceof XMLHttpRequest) {\n                req.open(opts.method, url, true);\n            } else {\n                req.open(opts.method, url);\n            }\n\n            if (support.cors) {\n                if (body) {\n                    if (opts.method === 'POST') {\n                        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Simple_requests\n                        req.setRequestHeader('content-type', 'application/x-www-form-urlencoded');\n                    } else {\n                        req.setRequestHeader('content-type', 'application/json');\n                    }\n                }\n                req.setRequestHeader('accept', 'application/json');\n            }\n\n            // we set an empty onprogress listener\n            // so that XDomainRequest on IE9 is not aborted\n            // refs:\n            //  - https://github.com/algolia/algoliasearch-client-js/issues/76\n            //  - https://social.msdn.microsoft.com/Forums/ie/en-US/30ef3add-767c-4436-b8a9-f1ca19b4812e/ie9-rtm-xdomainrequest-issued-requests-may-abort-if-all-event-handlers-not-specified?forum=iewebdevelopment\n            req.onprogress = function noop() {};\n\n            req.onload = load;\n            req.onerror = error;\n\n            if (support.timeout) {\n                // .timeout supported by both XHR and XDR,\n                // we do receive timeout event, tested\n                req.timeout = opts.timeout;\n\n                req.ontimeout = timeout;\n            } else {\n                ontimeout = setTimeout(timeout, opts.timeout);\n            }\n\n            req.send(body);\n\n            // event object not received in IE8, at least\n            // but we do not use it, still important to note\n            function load(/*event*/) {\n                // When browser does not supports req.timeout, we can\n                // have both a load and timeout event, since handled by a dumb setTimeout\n                if (timedOut) {\n                    return;\n                }\n\n                if (!support.timeout) {\n                    clearTimeout(ontimeout);\n                }\n\n                var out;\n\n                try {\n                    out = {\n                        body: JSON.parse(req.responseText),\n                        statusCode: req.status,\n                        // XDomainRequest does not have any response headers\n                        headers: req.getAllResponseHeaders && req.getAllResponseHeaders() || {}\n                    };\n                } catch (e) {\n                    out = new errors.UnparsableJSON({\n                        more: req.responseText\n                    });\n                }\n\n                if (out instanceof errors.UnparsableJSON) {\n                    reject(out);\n                } else {\n                    resolve(out);\n                }\n            }\n\n            function error(event) {\n                if (timedOut) {\n                    return;\n                }\n\n                if (!support.timeout) {\n                    clearTimeout(ontimeout);\n                }\n\n                // error event is trigerred both with XDR/XHR on:\n                //   - DNS error\n                //   - unallowed cross domain request\n                reject(\n                    new errors.Network({\n                        more: event\n                    })\n                );\n            }\n\n            function timeout() {\n                if (!support.timeout) {\n                    timedOut = true;\n                    req.abort();\n                }\n\n                reject(new errors.RequestTimeout());\n            }\n        });\n    };\n\n    AlgoliaSearchBrowser.prototype._request.fallback = function requestFallback(url, opts) {\n        url = inlineHeaders(url, opts.headers);\n\n        return new Promise(function wrapJsonpRequest(resolve, reject) {\n            jsonpRequest(url, opts, function jsonpRequestDone(err, content) {\n                if (err) {\n                    reject(err);\n                    return;\n                }\n\n                resolve(content);\n            });\n        });\n    };\n\n    AlgoliaSearchBrowser.prototype._promise = {\n        reject: function rejectPromise(val) {\n            return Promise.reject(val);\n        },\n        resolve: function resolvePromise(val) {\n            return Promise.resolve(val);\n        },\n        delay: function delayPromise(ms) {\n            return new Promise(function resolveOnTimeout(resolve/*, reject*/) {\n                setTimeout(resolve, ms);\n            });\n        }\n    };\n\n},{\"10\":10,\"45\":45,\"6\":6,\"60\":60,\"63\":63,\"64\":64,\"65\":65,\"66\":66,\"67\":67,\"9\":9}],63:[function(require,module,exports){\n    'use strict';\n\n    module.exports = getDocumentProtocol;\n\n    function getDocumentProtocol() {\n        var protocol = window.document.location.protocol;\n\n        // when in `file:` mode (local html file), default to `http:`\n        if (protocol !== 'http:' && protocol !== 'https:') {\n            protocol = 'http:';\n        }\n\n        return protocol;\n    }\n\n},{}],64:[function(require,module,exports){\n    'use strict';\n\n    module.exports = inlineHeaders;\n\n    var querystring = require(5);\n\n    function inlineHeaders(url, headers) {\n        if (/\\?/.test(url)) {\n            url += '&';\n        } else {\n            url += '?';\n        }\n\n        return url + querystring.encode(headers);\n    }\n\n},{\"5\":5}],65:[function(require,module,exports){\n    'use strict';\n\n    module.exports = jsonpRequest;\n\n    var errors = require(66);\n\n    var JSONPCounter = 0;\n\n    function jsonpRequest(url, opts, cb) {\n        if (opts.method !== 'GET') {\n            cb(new Error('Method ' + opts.method + ' ' + url + ' is not supported by JSONP.'));\n            return;\n        }\n\n        opts.debug('JSONP: start');\n\n        var cbCalled = false;\n        var timedOut = false;\n\n        JSONPCounter += 1;\n        var head = document.getElementsByTagName('head')[0];\n        var script = document.createElement('script');\n        var cbName = 'algoliaJSONP_' + JSONPCounter;\n        var done = false;\n\n        window[cbName] = function(data) {\n            try {\n                delete window[cbName];\n            } catch (e) {\n                window[cbName] = undefined;\n            }\n\n            if (timedOut) {\n                return;\n            }\n\n            cbCalled = true;\n\n            clean();\n\n            cb(null, {\n                body: data/*,\n                 // We do not send the statusCode, there's no statusCode in JSONP, it will be\n                 // computed using data.status && data.message like with XDR\n                 statusCode*/\n            });\n        };\n\n        // add callback by hand\n        url += '&callback=' + cbName;\n\n        // add body params manually\n        if (opts.jsonBody && opts.jsonBody.params) {\n            url += '&' + opts.jsonBody.params;\n        }\n\n        var ontimeout = setTimeout(timeout, opts.timeout);\n\n        // script onreadystatechange needed only for\n        // <= IE8\n        // https://github.com/angular/angular.js/issues/4523\n        script.onreadystatechange = readystatechange;\n        script.onload = success;\n        script.onerror = error;\n\n        script.async = true;\n        script.defer = true;\n        script.src = url;\n        head.appendChild(script);\n\n        function success() {\n            opts.debug('JSONP: success');\n\n            if (done || timedOut) {\n                return;\n            }\n\n            done = true;\n\n            // script loaded but did not call the fn => script loading error\n            if (!cbCalled) {\n                opts.debug('JSONP: Fail. Script loaded but did not call the callback');\n                clean();\n                cb(new errors.JSONPScriptFail());\n            }\n        }\n\n        function readystatechange() {\n            if (this.readyState === 'loaded' || this.readyState === 'complete') {\n                success();\n            }\n        }\n\n        function clean() {\n            clearTimeout(ontimeout);\n            script.onload = null;\n            script.onreadystatechange = null;\n            script.onerror = null;\n            head.removeChild(script);\n\n            try {\n                delete window[cbName];\n                delete window[cbName + '_loaded'];\n            } catch (e) {\n                window[cbName] = null;\n                window[cbName + '_loaded'] = null;\n            }\n        }\n\n        function timeout() {\n            opts.debug('JSONP: Script timeout');\n\n            timedOut = true;\n            clean();\n            cb(new errors.RequestTimeout());\n        }\n\n        function error() {\n            opts.debug('JSONP: Script error');\n\n            if (done || timedOut) {\n                return;\n            }\n\n            clean();\n            cb(new errors.JSONPScriptError());\n        }\n    }\n\n},{\"66\":66}],66:[function(require,module,exports){\n    'use strict';\n\n// This file hosts our error definitions\n// We use custom error \"types\" so that we can act on them when we need it\n// e.g.: if error instanceof errors.UnparsableJSON then..\n\n    var inherits = require(10);\n\n    function AlgoliaSearchError(message, extraProperties) {\n        var forEach = require(11);\n\n        var error = this;\n\n        // try to get a stacktrace\n        if (typeof Error.captureStackTrace === 'function') {\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            error.stack = (new Error()).stack || 'Cannot get a stacktrace, browser is too old';\n        }\n\n        this.name = this.constructor.name;\n        this.message = message || 'Unknown error';\n\n        if (extraProperties) {\n            forEach(extraProperties, function addToErrorObject(value, key) {\n                error[key] = value;\n            });\n        }\n    }\n\n    inherits(AlgoliaSearchError, Error);\n\n    function createCustomError(name, message) {\n        function AlgoliaSearchCustomError() {\n            var args = Array.prototype.slice.call(arguments, 0);\n\n            // custom message not set, use default\n            if (typeof args[0] !== 'string') {\n                args.unshift(message);\n            }\n\n            AlgoliaSearchError.apply(this, args);\n            this.name = 'AlgoliaSearch' + name + 'Error';\n        }\n\n        inherits(AlgoliaSearchCustomError, AlgoliaSearchError);\n\n        return AlgoliaSearchCustomError;\n    }\n\n// late exports to let various fn defs and inherits take place\n    module.exports = {\n        AlgoliaSearchError: AlgoliaSearchError,\n        UnparsableJSON: createCustomError(\n            'UnparsableJSON',\n            'Could not parse the incoming response as JSON, see err.more for details'\n        ),\n        RequestTimeout: createCustomError(\n            'RequestTimeout',\n            'Request timedout before getting a response'\n        ),\n        Network: createCustomError(\n            'Network',\n            'Network issue, see err.more for details'\n        ),\n        JSONPScriptFail: createCustomError(\n            'JSONPScriptFail',\n            '<script> was loaded but did not call our provided callback'\n        ),\n        JSONPScriptError: createCustomError(\n            'JSONPScriptError',\n            '<script> unable to load due to an `error` event on it'\n        ),\n        Unknown: createCustomError(\n            'Unknown',\n            'Unknown error occured'\n        )\n    };\n\n},{\"10\":10,\"11\":11}],67:[function(require,module,exports){\n    module.exports=\"3.7.7\"\n},{}]},{},[62])(62)\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13), __webpack_require__(0).setImmediate))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9yZXNvdXJjZXMvYXNzZXRzL2pzL3ZlbmRvci9hbGdvbGlhc2VhcmNoLmpzPzU0YTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIGFsZ29saWFzZWFyY2ggMy43LjcgfCDCqSAyMDE0LCAyMDE1IEFsZ29saWEgU0FTIHwgZ2l0aHViLmNvbS9hbGdvbGlhL2FsZ29saWFzZWFyY2gtY2xpZW50LWpzICovXG4oZnVuY3Rpb24oZil7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PSd1bmRlZmluZWQnKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBzZWxmIT09J3VuZGVmaW5lZCcpe2c9c2VsZn1nLkFMR09MSUFfTUlHUkFUSU9OX0xBWUVSPWYoKX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsb2FkIChzcmMsIG9wdHMsIGNiKSB7XG4gICAgICAgIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdXG4gICAgICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2IgPSBvcHRzXG4gICAgICAgICAgICBvcHRzID0ge31cbiAgICAgICAgfVxuXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9XG4gICAgICAgIGNiID0gY2IgfHwgZnVuY3Rpb24oKSB7fVxuXG4gICAgICAgIHNjcmlwdC50eXBlID0gb3B0cy50eXBlIHx8ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgICAgIHNjcmlwdC5jaGFyc2V0ID0gb3B0cy5jaGFyc2V0IHx8ICd1dGY4JztcbiAgICAgICAgc2NyaXB0LmFzeW5jID0gJ2FzeW5jJyBpbiBvcHRzID8gISFvcHRzLmFzeW5jIDogdHJ1ZVxuICAgICAgICBzY3JpcHQuc3JjID0gc3JjXG5cbiAgICAgICAgaWYgKG9wdHMuYXR0cnMpIHtcbiAgICAgICAgICAgIHNldEF0dHJpYnV0ZXMoc2NyaXB0LCBvcHRzLmF0dHJzKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdHMudGV4dCkge1xuICAgICAgICAgICAgc2NyaXB0LnRleHQgPSAnJyArIG9wdHMudGV4dFxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9uZW5kID0gJ29ubG9hZCcgaW4gc2NyaXB0ID8gc3RkT25FbmQgOiBpZU9uRW5kXG4gICAgICAgIG9uZW5kKHNjcmlwdCwgY2IpXG5cbiAgICAgICAgLy8gc29tZSBnb29kIGxlZ2FjeSBicm93c2VycyAoZmlyZWZveCkgZmFpbCB0aGUgJ2luJyBkZXRlY3Rpb24gYWJvdmVcbiAgICAgICAgLy8gc28gYXMgYSBmYWxsYmFjayB3ZSBhbHdheXMgc2V0IG9ubG9hZFxuICAgICAgICAvLyBvbGQgSUUgd2lsbCBpZ25vcmUgdGhpcyBhbmQgbmV3IElFIHdpbGwgc2V0IG9ubG9hZFxuICAgICAgICBpZiAoIXNjcmlwdC5vbmxvYWQpIHtcbiAgICAgICAgICAgIHN0ZE9uRW5kKHNjcmlwdCwgY2IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhzY3JpcHQsIGF0dHJzKSB7XG4gICAgICAgIGZvciAodmFyIGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cnNbYXR0cl0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RkT25FbmQgKHNjcmlwdCwgY2IpIHtcbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMub25lcnJvciA9IHRoaXMub25sb2FkID0gbnVsbFxuICAgICAgICAgICAgY2IobnVsbCwgc2NyaXB0KVxuICAgICAgICB9XG4gICAgICAgIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gdGhpcy5vbmxvYWQgPSBudWxsIGhlcmUgaXMgbmVjZXNzYXJ5XG4gICAgICAgICAgICAvLyBiZWNhdXNlIGV2ZW4gSUU5IHdvcmtzIG5vdCBsaWtlIG90aGVyc1xuICAgICAgICAgICAgdGhpcy5vbmVycm9yID0gdGhpcy5vbmxvYWQgPSBudWxsXG4gICAgICAgICAgICBjYihuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkICcgKyB0aGlzLnNyYyksIHNjcmlwdClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGllT25FbmQgKHNjcmlwdCwgY2IpIHtcbiAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT0gJ2NvbXBsZXRlJyAmJiB0aGlzLnJlYWR5U3RhdGUgIT0gJ2xvYWRlZCcpIHJldHVyblxuICAgICAgICAgICAgdGhpcy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsXG4gICAgICAgICAgICBjYihudWxsLCBzY3JpcHQpIC8vIHRoZXJlIGlzIG5vIHdheSB0byBjYXRjaCBsb2FkaW5nIGVycm9ycyBpbiBJRThcbiAgICAgICAgfVxuICAgIH1cblxufSx7fV0sMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4vLyB0aGlzIG1vZHVsZSBoZWxwcyBmaW5kaW5nIGlmIHRoZSBjdXJyZW50IHBhZ2UgaXMgdXNpbmdcbi8vIHRoZSBjZG4uanNkZWxpdnIubmV0L2FsZ29saWFzZWFyY2gvbGF0ZXN0LyRCVUlMRE5BTUUubWluLmpzIHZlcnNpb25cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNVc2luZ0xhdGVzdDtcblxuICAgIGZ1bmN0aW9uIGlzVXNpbmdMYXRlc3QoYnVpbGROYW1lKSB7XG4gICAgICAgIHZhciB0b0ZpbmQgPSBuZXcgUmVnRXhwKCdjZG5cXFxcLmpzZGVsaXZyXFxcXC5uZXQvYWxnb2xpYXNlYXJjaC9sYXRlc3QvJyArXG4gICAgICAgICAgICBidWlsZE5hbWUucmVwbGFjZSgnLicsICdcXFxcLicpICsgLy8gYWxnb2xpYXNlYXJjaCwgYWxnb2xpYXNlYXJjaC5hbmd1bGFyXG4gICAgICAgICAgICAnKD86XFxcXC5taW4pP1xcXFwuanMkJyk7IC8vIFsubWluXS5qc1xuXG4gICAgICAgIHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgY3VycmVudFNjcmlwdCA9IDAsIG5iU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoOyBjdXJyZW50U2NyaXB0IDwgbmJTY3JpcHRzOyBjdXJyZW50U2NyaXB0KyspIHtcbiAgICAgICAgICAgIGlmIChzY3JpcHRzW2N1cnJlbnRTY3JpcHRdLnNyYyAmJiB0b0ZpbmQudGVzdChzY3JpcHRzW2N1cnJlbnRTY3JpcHRdLnNyYykpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuXG59LHt9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGxvYWRWMjtcblxuICAgIGZ1bmN0aW9uIGxvYWRWMihidWlsZE5hbWUpIHtcbiAgICAgICAgdmFyIGxvYWRTY3JpcHQgPSByZXF1aXJlKDEpO1xuICAgICAgICB2YXIgdjJTY3JpcHRVcmwgPSAnLy9jZG4uanNkZWxpdnIubmV0L2FsZ29saWFzZWFyY2gvMi8nICsgYnVpbGROYW1lICsgJy5taW4uanMnO1xuXG4gICAgICAgIHZhciBtZXNzYWdlID0gJy0tIEFsZ29saWFTZWFyY2ggYGxhdGVzdGAgd2FybmluZyAtLVxcbicgK1xuICAgICAgICAgICAgJ1dhcm5pbmcsIHlvdSBhcmUgdXNpbmcgdGhlIGBsYXRlc3RgIHZlcnNpb24gc3RyaW5nIGZyb20ganNEZWxpdnIgdG8gbG9hZCB0aGUgQWxnb2xpYVNlYXJjaCBsaWJyYXJ5LlxcbicgK1xuICAgICAgICAgICAgJ1VzaW5nIGBsYXRlc3RgIGlzIG5vIG1vcmUgcmVjb21tZW5kZWQsIHlvdSBzaG91bGQgbG9hZCAvL2Nkbi5qc2RlbGl2ci5uZXQvYWxnb2xpYXNlYXJjaC8yL2FsZ29saWFzZWFyY2gubWluLmpzXFxuXFxuJyArXG4gICAgICAgICAgICAnQWxzbywgd2UgdXBkYXRlZCB0aGUgQWxnb2xpYVNlYXJjaCBKYXZhU2NyaXB0IGNsaWVudCB0byBWMy4gSWYgeW91IHdhbnQgdG8gdXBncmFkZSxcXG4nICtcbiAgICAgICAgICAgICdwbGVhc2UgcmVhZCBvdXIgbWlncmF0aW9uIGd1aWRlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9hbGdvbGlhL2FsZ29saWFzZWFyY2gtY2xpZW50LWpzL3dpa2kvTWlncmF0aW9uLWd1aWRlLWZyb20tMi54LngtdG8tMy54LnhcXG4nICtcbiAgICAgICAgICAgICctLSAvQWxnb2xpYVNlYXJjaCAgYGxhdGVzdGAgd2FybmluZyAtLSc7XG5cbiAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlKSB7XG4gICAgICAgICAgICBpZiAod2luZG93LmNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHdpbmRvdy5jb25zb2xlLmxvZykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGN1cnJlbnQgc2NyaXB0IGxvYWRlZCBhc3luY2hyb25vdXNseSxcbiAgICAgICAgLy8gaXQgd2lsbCBsb2FkIHRoZSBzY3JpcHQgd2l0aCBET01FbGVtZW50XG4gICAgICAgIC8vIG90aGVyd2lzZSwgaXQgd2lsbCBsb2FkIHRoZSBzY3JpcHQgd2l0aCBkb2N1bWVudC53cml0ZVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gd2h5IFxceDNjPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMzYxMDYvMTQ3MDc5XG4gICAgICAgICAgICBkb2N1bWVudC53cml0ZSgnXFx4M0NzY3JpcHQ+d2luZG93LkFMR09MSUFfU1VQUE9SVFNfRE9DV1JJVEUgPSB0cnVlXFx4M0Mvc2NyaXB0PicpO1xuXG4gICAgICAgICAgICBpZiAod2luZG93LkFMR09MSUFfU1VQUE9SVFNfRE9DV1JJVEUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC53cml0ZSgnXFx4M0NzY3JpcHQgc3JjPVwiJyArIHYyU2NyaXB0VXJsICsgJ1wiPlxceDNDL3NjcmlwdD4nKTtcbiAgICAgICAgICAgICAgICBzY3JpcHRMb2FkZWQoJ2RvY3VtZW50LndyaXRlJykoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9hZFNjcmlwdCh2MlNjcmlwdFVybCwgc2NyaXB0TG9hZGVkKCdET01FbGVtZW50JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2FkU2NyaXB0KHYyU2NyaXB0VXJsLCBzY3JpcHRMb2FkZWQoJ0RPTUVsZW1lbnQnKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY3JpcHRMb2FkZWQobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBsb2coKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9ICdBbGdvbGlhU2VhcmNoOiBsb2FkZWQgVjIgc2NyaXB0IHVzaW5nICcgKyBtZXRob2Q7XG5cbiAgICAgICAgICAgIGlmICh3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS5sb2cpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG59LHtcIjFcIjoxfV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyplc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJ2YXJzXCI6IFwibG9jYWxcIn1dKi9cblxuICAgIG1vZHVsZS5leHBvcnRzID0gb2xkR2xvYmFscztcblxuLy8gcHV0IG9sZCB3aW5kb3cuQWxnb2xpYVNlYXJjaC4uIGludG8gd2luZG93LiBhZ2FpbiBzbyB0aGF0XG4vLyB1c2VycyB1cGdyYWRpbmcgdG8gVjMgd2l0aG91dCBjaGFuZ2luZyB0aGVpciBjb2RlLCB3aWxsIGJlIHdhcm5lZFxuICAgIGZ1bmN0aW9uIG9sZEdsb2JhbHMoKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gJy0tIEFsZ29saWFTZWFyY2ggVjIgPT4gVjMgZXJyb3IgLS1cXG4nICtcbiAgICAgICAgICAgICdZb3UgYXJlIHRyeWluZyB0byB1c2UgYSBuZXcgdmVyc2lvbiBvZiB0aGUgQWxnb2xpYVNlYXJjaCBKYXZhU2NyaXB0IGNsaWVudCB3aXRoIGFuIG9sZCBub3RhdGlvbi5cXG4nICtcbiAgICAgICAgICAgICdQbGVhc2UgcmVhZCBvdXIgbWlncmF0aW9uIGd1aWRlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9hbGdvbGlhL2FsZ29saWFzZWFyY2gtY2xpZW50LWpzL3dpa2kvTWlncmF0aW9uLWd1aWRlLWZyb20tMi54LngtdG8tMy54LnhcXG4nICtcbiAgICAgICAgICAgICctLSAvQWxnb2xpYVNlYXJjaCBWMiA9PiBWMyBlcnJvciAtLSc7XG5cbiAgICAgICAgd2luZG93LkFsZ29saWFTZWFyY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB3aW5kb3cuQWxnb2xpYVNlYXJjaEhlbHBlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHdpbmRvdy5BbGdvbGlhRXhwbGFpblJlc3VsdHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbn0se31dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuICAgICd1c2Ugc3RyaWN0JztcblxuLy8gVGhpcyBzY3JpcHQgd2lsbCBiZSBicm93c2VyaWZpZWQgYW5kIHByZXBlbmRlZCB0byB0aGUgbm9ybWFsIGJ1aWxkXG4vLyBkaXJlY3RseSBpbiB3aW5kb3csIG5vdCB3cmFwcGVkIGluIGFueSBtb2R1bGUgZGVmaW5pdGlvblxuLy8gVG8gYXZvaWQgY2FzZXMgd2hlcmUgd2UgYXJlIGxvYWRlZCB3aXRoIC9sYXRlc3QvIGFsb25nIHdpdGhcbiAgICBtaWdyYXRpb25MYXllcihcImFsZ29saWFzZWFyY2hcIik7XG5cbi8vIE5vdyBvbnRvIHRoZSBWMiByZWxhdGVkIGNvZGU6XG4vLyAgSWYgdGhlIGNsaWVudCBpcyB1c2luZyAvbGF0ZXN0LyRCVUlMRE5BTUUubWluLmpzLCBsb2FkIFYyIG9mIHRoZSBsaWJyYXJ5XG4vL1xuLy8gIE90aGVyd2lzZSwgc2V0dXAgYSBtaWdyYXRpb24gbGF5ZXIgdGhhdCB3aWxsIHRocm93IG9uIG9sZCBjb25zdHJ1Y3RvcnMgbGlrZVxuLy8gIG5ldyBBbGdvbGlhU2VhcmNoKCkuXG4vLyAgU28gdGhhdCB1c2VycyB1cGdyYWRpbmcgZnJvbSB2MiB0byB2MyB3aWxsIGhhdmUgYSBjbGVhciBpbmZvcm1hdGlvblxuLy8gIG1lc3NhZ2Ugb24gd2hhdCB0byBkbyBpZiB0aGV5IGRpZCBub3QgcmVhZCB0aGUgbWlncmF0aW9uIGd1aWRlXG4gICAgZnVuY3Rpb24gbWlncmF0aW9uTGF5ZXIoYnVpbGROYW1lKSB7XG4gICAgICAgIHZhciBpc1VzaW5nTGF0ZXN0ID0gcmVxdWlyZSgyKTtcbiAgICAgICAgdmFyIGxvYWRWMiA9IHJlcXVpcmUoMyk7XG4gICAgICAgIHZhciBvbGRHbG9iYWxzID0gcmVxdWlyZSg0KTtcblxuICAgICAgICBpZiAoaXNVc2luZ0xhdGVzdChidWlsZE5hbWUpKSB7XG4gICAgICAgICAgICBsb2FkVjIoYnVpbGROYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9sZEdsb2JhbHMoKTtcbiAgICAgICAgfVxuICAgIH1cblxufSx7XCIyXCI6MixcIjNcIjozLFwiNFwiOjR9XX0se30sWzVdKSg1KVxufSk7KGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuYWxnb2xpYXNlYXJjaCA9IGYoKX19KShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4gICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gICAgICAgIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbiAgICBFdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuICAgIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgICAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gICAgICAgIGlmICghdGhpcy5fZXZlbnRzKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICAgICAgICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgICAgICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAvLyBzbG93ZXJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgICAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICAgICAgICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgbTtcblxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gICAgICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAgICAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgICAgICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgICAgICAgICAgdmFyIG07XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgICAgICAgICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgICAgIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gICAgICAgIGZ1bmN0aW9uIGcoKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgICAgICAgICBpZiAoIWZpcmVkKSB7XG4gICAgICAgICAgICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMub24odHlwZSwgZyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgICAgIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHZhciBrZXksIGxpc3RlbmVycztcblxuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgICAgICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgICAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB2YXIgcmV0O1xuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgICAgICAgcmV0ID0gW107XG4gICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAgICAgICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gICAgICAgIHZhciByZXQ7XG4gICAgICAgIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbdHlwZV0pXG4gICAgICAgICAgICByZXQgPSAwO1xuICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVtaXR0ZXIuX2V2ZW50c1t0eXBlXSkpXG4gICAgICAgICAgICByZXQgPSAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXQgPSBlbWl0dGVyLl9ldmVudHNbdHlwZV0ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICAgICAgICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG4gICAgfVxuXG59LHt9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG4gICAgdmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgIHZhciBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHZhciBjdXJyZW50UXVldWU7XG4gICAgdmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuICAgIGZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICAgICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICAgICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgICAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgICAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICAgICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIH1cblxuICAgIHByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgICAgICB9XG4gICAgfTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuICAgIGZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgICAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICAgICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICAgIH1cbiAgICBJdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xuICAgIH07XG4gICAgcHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbiAgICBwcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52ID0ge307XG4gICAgcHJvY2Vzcy5hcmd2ID0gW107XG4gICAgcHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG4gICAgcHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gbm9vcCgpIHt9XG5cbiAgICBwcm9jZXNzLm9uID0gbm9vcDtcbiAgICBwcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbiAgICBwcm9jZXNzLm9uY2UgPSBub29wO1xuICAgIHByb2Nlc3Mub2ZmID0gbm9vcDtcbiAgICBwcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbiAgICBwcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG4gICAgcHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxuICAgIHByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9O1xuXG4vLyBUT0RPKHNodHlsbWFuKVxuICAgIHByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG4gICAgcHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9O1xuICAgIHByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cbn0se31dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbiAgICAndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbiAgICBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgICAgICAgc2VwID0gc2VwIHx8ICcmJztcbiAgICAgICAgZXEgPSBlcSB8fCAnPSc7XG4gICAgICAgIHZhciBvYmogPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICAgICAgICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgICAgICAgdmFyIG1heEtleXMgPSAxMDAwO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gICAgICAgIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICAgICAgICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgICAgICAgICAgbGVuID0gbWF4S2V5cztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICAgICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgICAgICAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAga3N0ciA9IHg7XG4gICAgICAgICAgICAgICAgdnN0ciA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgICAgICAgICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICAgICAgICAgICAgb2JqW2tdID0gdjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgICAgICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgICAgIH07XG5cbn0se31dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuXG4gICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICAgICAgICBzZXAgPSBzZXAgfHwgJyYnO1xuICAgICAgICBlcSA9IGVxIHx8ICc9JztcbiAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgb2JqID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmpvaW4oc2VwKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG4gICAgfTtcblxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgICAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWFwICh4cywgZikge1xuICAgICAgICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIHZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcblxufSx7fV0sNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgzKTtcbiAgICBleHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSg0KTtcblxufSx7XCIzXCI6MyxcIjRcIjo0fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gICAgICpcbiAgICAgKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gICAgICovXG5cbiAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKDcpO1xuICAgIGV4cG9ydHMubG9nID0gbG9nO1xuICAgIGV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG4gICAgZXhwb3J0cy5zYXZlID0gc2F2ZTtcbiAgICBleHBvcnRzLmxvYWQgPSBsb2FkO1xuICAgIGV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuICAgIGV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4gICAgLyoqXG4gICAgICogQ29sb3JzLlxuICAgICAqL1xuXG4gICAgZXhwb3J0cy5jb2xvcnMgPSBbXG4gICAgICAgICdsaWdodHNlYWdyZWVuJyxcbiAgICAgICAgJ2ZvcmVzdGdyZWVuJyxcbiAgICAgICAgJ2dvbGRlbnJvZCcsXG4gICAgICAgICdkb2RnZXJibHVlJyxcbiAgICAgICAgJ2RhcmtvcmNoaWQnLFxuICAgICAgICAnY3JpbXNvbidcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAgICAgKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAgICAgKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAgICAgICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAgICAgICByZXR1cm4gKCdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpIHx8XG4gICAgICAgICAgICAgICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICAgICAgICAgKHdpbmRvdy5jb25zb2xlICYmIChjb25zb2xlLmZpcmVidWcgfHwgKGNvbnNvbGUuZXhjZXB0aW9uICYmIGNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAgICAgICAgICAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAgICAgICAgIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICAgICAqL1xuXG4gICAgZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gZm9ybWF0QXJncygpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICAgICAgICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICAgICAgICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICAgICAgICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICAgICAgICAgKyBhcmdzWzBdXG4gICAgICAgICAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICAgICAgICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gICAgICAgIGlmICghdXNlQ29sb3JzKSByZXR1cm4gYXJncztcblxuICAgICAgICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gICAgICAgIGFyZ3MgPSBbYXJnc1swXSwgYywgJ2NvbG9yOiBpbmhlcml0J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcblxuICAgICAgICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAgICAgICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgbGFzdEMgPSAwO1xuICAgICAgICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16JV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgICAgICAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgICAgICAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICAgICAgICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xuICAgICAgICByZXR1cm4gYXJncztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAgICAgKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICAgICAqXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGxvZygpIHtcbiAgICAgICAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgICAgICAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgICAgICAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICAgICAgICAgJiYgY29uc29sZS5sb2dcbiAgICAgICAgICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgICAgICAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoKGUpIHt9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBsb2FkKCkge1xuICAgICAgICB2YXIgcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gICAgICAgIH0gY2F0Y2goZSkge31cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAgICAgKi9cblxuICAgIGV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbiAgICAvKipcbiAgICAgKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAgICAgKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICAgICAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxufSx7XCI3XCI6N31dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICAgICAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gICAgICpcbiAgICAgKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gICAgICovXG5cbiAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBkZWJ1ZztcbiAgICBleHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbiAgICBleHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuICAgIGV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuICAgIGV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoOCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAgICAgKi9cblxuICAgIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgICBleHBvcnRzLnNraXBzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gICAgICpcbiAgICAgKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlcmNhc2VkIGxldHRlciwgaS5lLiBcIm5cIi5cbiAgICAgKi9cblxuICAgIGV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogUHJldmlvdXNseSBhc3NpZ25lZCBjb2xvci5cbiAgICAgKi9cblxuICAgIHZhciBwcmV2Q29sb3IgPSAwO1xuXG4gICAgLyoqXG4gICAgICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAgICAgKi9cblxuICAgIHZhciBwcmV2VGltZTtcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBhIGNvbG9yLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gc2VsZWN0Q29sb3IoKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmNvbG9yc1twcmV2Q29sb3IrKyAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGRlYnVnKG5hbWVzcGFjZSkge1xuXG4gICAgICAgIC8vIGRlZmluZSB0aGUgYGRpc2FibGVkYCB2ZXJzaW9uXG4gICAgICAgIGZ1bmN0aW9uIGRpc2FibGVkKCkge1xuICAgICAgICB9XG4gICAgICAgIGRpc2FibGVkLmVuYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBkZWZpbmUgdGhlIGBlbmFibGVkYCB2ZXJzaW9uXG4gICAgICAgIGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gZW5hYmxlZDtcblxuICAgICAgICAgICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICAgICAgICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgICAgICAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgICAgICAgICAgc2VsZi5kaWZmID0gbXM7XG4gICAgICAgICAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICAgICAgICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgICAgICAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgYGNvbG9yYCBpZiBub3Qgc2V0XG4gICAgICAgICAgICBpZiAobnVsbCA9PSBzZWxmLnVzZUNvbG9ycykgc2VsZi51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICAgICAgICAgICAgaWYgKG51bGwgPT0gc2VsZi5jb2xvciAmJiBzZWxmLnVzZUNvbG9ycykgc2VsZi5jb2xvciA9IHNlbGVjdENvbG9yKCk7XG5cbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAgICAgICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJW9cbiAgICAgICAgICAgICAgICBhcmdzID0gWyclbyddLmNvbmNhdChhcmdzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgICAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgICAgICAgICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgICAgICAgICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5mb3JtYXRBcmdzKSB7XG4gICAgICAgICAgICAgICAgYXJncyA9IGV4cG9ydHMuZm9ybWF0QXJncy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsb2dGbiA9IGVuYWJsZWQubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgICAgICAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbmFibGVkLmVuYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgIHZhciBmbiA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpID8gZW5hYmxlZCA6IGRpc2FibGVkO1xuXG4gICAgICAgIGZuLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblxuICAgICAgICByZXR1cm4gZm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICAgICAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICAgICAgICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgICAgICAgdmFyIHNwbGl0ID0gKG5hbWVzcGFjZXMgfHwgJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gICAgICAgIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgICAgICAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICAgICAgICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgICBleHBvcnRzLmVuYWJsZSgnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgICAgICAgdmFyIGksIGxlbjtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvZXJjZSBgdmFsYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICAgICAqIEByZXR1cm4ge01peGVkfVxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG59LHtcIjhcIjo4fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gICAgLyoqXG4gICAgICogSGVscGVycy5cbiAgICAgKi9cblxuICAgIHZhciBzID0gMTAwMDtcbiAgICB2YXIgbSA9IHMgKiA2MDtcbiAgICB2YXIgaCA9IG0gKiA2MDtcbiAgICB2YXIgZCA9IGggKiAyNDtcbiAgICB2YXIgeSA9IGQgKiAzNjUuMjU7XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICAgICAqXG4gICAgICogT3B0aW9uczpcbiAgICAgKlxuICAgICAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKXtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdmFsKSByZXR1cm4gcGFyc2UodmFsKTtcbiAgICAgICAgLy8gbG9uZywgc2hvcnQgd2VyZSBcImZ1dHVyZSByZXNlcnZlZCB3b3JkcyBpbiBqc1wiLCBZVUkgY29tcHJlc3NvciBmYWlsIG9uIHRoZW1cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29saWEvYWxnb2xpYXNlYXJjaC1jbGllbnQtanMvaXNzdWVzLzExMyNpc3N1ZWNvbW1lbnQtMTExOTc4NjA2XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS95dWkveXVpY29tcHJlc3Nvci9pc3N1ZXMvNDdcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JhdWNoZy9tcy5qcy9wdWxsLzQwXG4gICAgICAgIHJldHVybiBvcHRpb25zWydsb25nJ11cbiAgICAgICAgICAgID8gX2xvbmcodmFsKVxuICAgICAgICAgICAgOiBfc2hvcnQodmFsKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICAgICAgICBzdHIgPSAnJyArIHN0cjtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPiAxMDAwMCkgcmV0dXJuO1xuICAgICAgICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKHN0cik7XG4gICAgICAgIGlmICghbWF0Y2gpIHJldHVybjtcbiAgICAgICAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgICAgICAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFycyc6XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgIGNhc2UgJ3lycyc6XG4gICAgICAgICAgICBjYXNlICd5cic6XG4gICAgICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbiAqIHk7XG4gICAgICAgICAgICBjYXNlICdkYXlzJzpcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbiAqIGQ7XG4gICAgICAgICAgICBjYXNlICdob3Vycyc6XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgIGNhc2UgJ2hycyc6XG4gICAgICAgICAgICBjYXNlICdocic6XG4gICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbiAqIGg7XG4gICAgICAgICAgICBjYXNlICdtaW51dGVzJzpcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICBjYXNlICdtaW5zJzpcbiAgICAgICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbiAqIG07XG4gICAgICAgICAgICBjYXNlICdzZWNvbmRzJzpcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICBjYXNlICdzZWNzJzpcbiAgICAgICAgICAgIGNhc2UgJ3NlYyc6XG4gICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbiAqIHM7XG4gICAgICAgICAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICAgICAgY2FzZSAnbXNlY3MnOlxuICAgICAgICAgICAgY2FzZSAnbXNlYyc6XG4gICAgICAgICAgICBjYXNlICdtcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbXNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBfc2hvcnQobXMpIHtcbiAgICAgICAgaWYgKG1zID49IGQpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gICAgICAgIGlmIChtcyA+PSBoKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICAgICAgICBpZiAobXMgPj0gbSkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgICAgICAgaWYgKG1zID49IHMpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gICAgICAgIHJldHVybiBtcyArICdtcyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbXNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBfbG9uZyhtcykge1xuICAgICAgICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JylcbiAgICAgICAgICAgIHx8IHBsdXJhbChtcywgaCwgJ2hvdXInKVxuICAgICAgICAgICAgfHwgcGx1cmFsKG1zLCBtLCAnbWludXRlJylcbiAgICAgICAgICAgIHx8IHBsdXJhbChtcywgcywgJ3NlY29uZCcpXG4gICAgICAgICAgICB8fCBtcyArICcgbXMnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gICAgICAgIGlmIChtcyA8IG4pIHJldHVybjtcbiAgICAgICAgaWYgKG1zIDwgbiAqIDEuNSkgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG4gICAgfVxuXG59LHt9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgICAoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbiAgICAgICAgLyohXG4gICAgICAgICAqIEBvdmVydmlldyBlczYtcHJvbWlzZSAtIGEgdGlueSBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlcy9BKy5cbiAgICAgICAgICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQgWWVodWRhIEthdHosIFRvbSBEYWxlLCBTdGVmYW4gUGVubmVyIGFuZCBjb250cmlidXRvcnMgKENvbnZlcnNpb24gdG8gRVM2IEFQSSBieSBKYWtlIEFyY2hpYmFsZClcbiAgICAgICAgICogQGxpY2Vuc2UgICBMaWNlbnNlZCB1bmRlciBNSVQgbGljZW5zZVxuICAgICAgICAgKiAgICAgICAgICAgIFNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vamFrZWFyY2hpYmFsZC9lczYtcHJvbWlzZS9tYXN0ZXIvTElDRU5TRVxuICAgICAgICAgKiBAdmVyc2lvbiAgIDIuMy4wXG4gICAgICAgICAqL1xuXG4gICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRvYmplY3RPckZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0Z1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNNYXliZVRoZW5hYmxlKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsaWIkZXM2JHByb21pc2UkdXRpbHMkJF9pc0FycmF5O1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJHV0aWxzJCRfaXNBcnJheSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJHV0aWxzJCRfaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzQXJyYXkgPSBsaWIkZXM2JHByb21pc2UkdXRpbHMkJF9pc0FycmF5O1xuICAgICAgICAgICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gPSAwO1xuICAgICAgICAgICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuICAgICAgICAgICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR2ZXJ0eE5leHQ7XG4gICAgICAgICAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGN1c3RvbVNjaGVkdWxlckZuO1xuXG4gICAgICAgICAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAgPSBmdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBhcmcpIHtcbiAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbl0gPSBjYWxsYmFjaztcbiAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiArIDFdID0gYXJnO1xuICAgICAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gKz0gMjtcbiAgICAgICAgICAgICAgICBpZiAobGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBsZW4gaXMgMiwgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gYXN5bmMgZmx1c2guXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGFkZGl0aW9uYWwgY2FsbGJhY2tzIGFyZSBxdWV1ZWQgYmVmb3JlIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLCB0aGV5XG4gICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IHRoaXMgZmx1c2ggdGhhdCB3ZSBhcmUgc2NoZWR1bGluZy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRjdXN0b21TY2hlZHVsZXJGbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGN1c3RvbVNjaGVkdWxlckZuKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2V0U2NoZWR1bGVyKHNjaGVkdWxlRm4pIHtcbiAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkY3VzdG9tU2NoZWR1bGVyRm4gPSBzY2hlZHVsZUZuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2V0QXNhcChhc2FwRm4pIHtcbiAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcCA9IGFzYXBGbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyV2luZG93ID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3Nlckdsb2JhbCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyV2luZG93IHx8IHt9O1xuICAgICAgICAgICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbiAgICAgICAgICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNOb2RlID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHt9LnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJztcblxuICAgICAgICAgICAgLy8gdGVzdCBmb3Igd2ViIHdvcmtlciBidXQgbm90IGluIElFMTBcbiAgICAgICAgICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJztcblxuICAgICAgICAgICAgLy8gbm9kZVxuICAgICAgICAgICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU5leHRUaWNrKCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0VGljayA9IHByb2Nlc3MubmV4dFRpY2s7XG4gICAgICAgICAgICAgICAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICAgICAgLy8gc2V0SW1tZWRpYXRlIHNob3VsZCBiZSB1c2VkIGluc3RlYWQgaW5zdGVhZFxuICAgICAgICAgICAgICAgIHZhciB2ZXJzaW9uID0gcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLm1hdGNoKC9eKD86KFxcZCspXFwuKT8oPzooXFxkKylcXC4pPyhcXCp8XFxkKykkLyk7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmVyc2lvbikgJiYgdmVyc2lvblsxXSA9PT0gJzAnICYmIHZlcnNpb25bMl0gPT09ICcxMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRpY2sgPSBzZXRJbW1lZGlhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRpY2sobGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB2ZXJ0eFxuICAgICAgICAgICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZVZlcnR4VGltZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkdmVydHhOZXh0KGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBsaWIkZXM2JHByb21pc2UkYXNhcCQkQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIobGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gKGl0ZXJhdGlvbnMgPSArK2l0ZXJhdGlvbnMgJSAyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB3ZWIgd29ya2VyXG4gICAgICAgICAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTWVzc2FnZUNoYW5uZWwoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VTZXRUaW1lb3V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gsIDEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWUgPSBuZXcgQXJyYXkoMTAwMCk7XG4gICAgICAgICAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2goKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuOyBpKz0yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtpKzFdO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGFyZyk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbaSsxXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJGF0dGVtcHRWZXJ0ZXgoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSByZXF1aXJlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmVydHggPSByKCd2ZXJ0eCcpO1xuICAgICAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkdmVydHhOZXh0ID0gdmVydHgucnVuT25Mb29wIHx8IHZlcnR4LnJ1bk9uQ29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VWZXJ0eFRpbWVyKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlU2V0VGltZW91dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoO1xuICAgICAgICAgICAgLy8gRGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczpcbiAgICAgICAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNOb2RlKSB7XG4gICAgICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTmV4dFRpY2soKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGliJGVzNiRwcm9taXNlJGFzYXAkJEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTXV0YXRpb25PYnNlcnZlcigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNXb3JrZXIpIHtcbiAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3NlcldpbmRvdyA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXR0ZW1wdFZlcnRleCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VTZXRUaW1lb3V0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3AoKSB7fVxuXG4gICAgICAgICAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORyAgID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCA9IDE7XG4gICAgICAgICAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQgID0gMjtcblxuICAgICAgICAgICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SID0gbmV3IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEVycm9yT2JqZWN0KCk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHNlbGZGdWxsZmlsbG1lbnQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJZb3UgY2Fubm90IHJlc29sdmUgYSBwcm9taXNlIHdpdGggaXRzZWxmXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRjYW5ub3RSZXR1cm5Pd24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZ2V0VGhlbihwcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbjtcbiAgICAgICAgICAgICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHRyeVRoZW4odGhlbiwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUsIHRoZW4pIHtcbiAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWFsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkdHJ5VGhlbih0aGVuLCB0aGVuYWJsZSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWFsZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoZW5hYmxlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VhbGVkKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VhbGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgIH0sICdTZXR0bGU6ICcgKyAocHJvbWlzZS5fbGFiZWwgfHwgJyB1bmtub3duIHByb21pc2UnKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUodGhlbmFibGUsIHVuZGVmaW5lZCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSkge1xuICAgICAgICAgICAgICAgIGlmIChtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yID09PSBwcm9taXNlLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGVuID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZ2V0VGhlbihtYXliZVRoZW5hYmxlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhlbiA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUi5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNGdW5jdGlvbih0aGVuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc2VsZkZ1bGxmaWxsbWVudCgpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSR1dGlscyQkb2JqZWN0T3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvbWlzZS5fb25lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9vbmVycm9yKHByb21pc2UuX3Jlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaChwcm9taXNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgICAgIHByb21pc2UuX3Jlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHByb21pc2UuX3N0YXRlID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVEO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fc3RhdGUgPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRDtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9yZXN1bHQgPSByZWFzb247XG5cbiAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoUmVqZWN0aW9uLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gc3Vic2NyaWJlcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgcGFyZW50Ll9vbmVycm9yID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzW2xlbmd0aF0gPSBjaGlsZDtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyc1tsZW5ndGggKyBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyc1tsZW5ndGggKyBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRF0gID0gb25SZWplY3Rpb247XG5cbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwICYmIHBhcmVudC5fc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaCwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2gocHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHZhciBzdWJzY3JpYmVycyA9IHByb21pc2UuX3N1YnNjcmliZXJzO1xuICAgICAgICAgICAgICAgIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlcnMubGVuZ3RoID09PSAwKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHN1YnNjcmliZXJzW2kgKyBzZXR0bGVkXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGludm9rZUNhbGxiYWNrKHNldHRsZWQsIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRFcnJvck9iamVjdCgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUiA9IG5ldyBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRFcnJvck9iamVjdCgpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCR0cnlDYXRjaChjYWxsYmFjaywgZGV0YWlsKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUi5lcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRUUllfQ0FUQ0hfRVJST1I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBwcm9taXNlLCBjYWxsYmFjaywgZGV0YWlsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhc0NhbGxiYWNrID0gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsIGVycm9yLCBzdWNjZWVkZWQsIGZhaWxlZDtcblxuICAgICAgICAgICAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB2YWx1ZS5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRjYW5ub3RSZXR1cm5Pd24oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZGV0YWlsO1xuICAgICAgICAgICAgICAgICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICAgICAgICAgICAgICAvLyBub29wXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmYWlsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCkge1xuICAgICAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbml0aWFsaXplUHJvbWlzZShwcm9taXNlLCByZXNvbHZlcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVyKGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiByZWplY3RQcm9taXNlKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvcihDb25zdHJ1Y3RvciwgaW5wdXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICBlbnVtZXJhdG9yLl9pbnN0YW5jZUNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgICAgICAgICAgICAgZW51bWVyYXRvci5wcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVudW1lcmF0b3IuX3ZhbGlkYXRlSW5wdXQoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmF0b3IuX2lucHV0ICAgICA9IGlucHV0O1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhdG9yLmxlbmd0aCAgICAgPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmF0b3IuX3JlbWFpbmluZyA9IGlucHV0Lmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhdG9yLl9pbml0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudW1lcmF0b3IubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKGVudW1lcmF0b3IucHJvbWlzZSwgZW51bWVyYXRvci5fcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmF0b3IubGVuZ3RoID0gZW51bWVyYXRvci5sZW5ndGggfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmF0b3IuX2VudW1lcmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudW1lcmF0b3IuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwoZW51bWVyYXRvci5wcm9taXNlLCBlbnVtZXJhdG9yLl9yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KGVudW1lcmF0b3IucHJvbWlzZSwgZW51bWVyYXRvci5fdmFsaWRhdGlvbkVycm9yKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0ZUlucHV0ID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0FycmF5KGlucHV0KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGlvbkVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignQXJyYXkgTWV0aG9kcyBtdXN0IGJlIHByb3ZpZGVkIGFuIEFycmF5Jyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3I7XG5cbiAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCAgPSBlbnVtZXJhdG9yLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGVudW1lcmF0b3IucHJvbWlzZTtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgICA9IGVudW1lcmF0b3IuX2lucHV0O1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IHByb21pc2UuX3N0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HICYmIGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhdG9yLl9lYWNoRW50cnkoaW5wdXRbaV0sIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fZWFjaEVudHJ5ID0gZnVuY3Rpb24oZW50cnksIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBlbnVtZXJhdG9yLl9pbnN0YW5jZUNvbnN0cnVjdG9yO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNNYXliZVRoZW5hYmxlKGVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuY29uc3RydWN0b3IgPT09IGMgJiYgZW50cnkuX3N0YXRlICE9PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5fb25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmF0b3IuX3dpbGxTZXR0bGVBdChjLnJlc29sdmUoZW50cnkpLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmF0b3IuX3JlbWFpbmluZy0tO1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhdG9yLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3NldHRsZWRBdCA9IGZ1bmN0aW9uKHN0YXRlLCBpLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBlbnVtZXJhdG9yID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGVudW1lcmF0b3IucHJvbWlzZTtcblxuICAgICAgICAgICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhdG9yLl9yZW1haW5pbmctLTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYXRvci5fcmVzdWx0W2ldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZW51bWVyYXRvci5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgZW51bWVyYXRvci5fcmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3dpbGxTZXR0bGVBdCA9IGZ1bmN0aW9uKHByb21pc2UsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUocHJvbWlzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhdG9yLl9zZXR0bGVkQXQobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVELCBpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmF0b3IuX3NldHRsZWRBdChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCwgaSwgcmVhc29uKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRhbGwkJGFsbChlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkZGVmYXVsdCh0aGlzLCBlbnRyaWVzKS5wcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJGFsbCQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJGFsbCQkYWxsO1xuICAgICAgICAgICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmFjZSQkcmFjZShlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNBcnJheShlbnRyaWVzKSkge1xuICAgICAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gb25GdWxmaWxsbWVudCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBvblJlamVjdGlvbihyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IHByb21pc2UuX3N0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HICYmIGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUoQ29uc3RydWN0b3IucmVzb2x2ZShlbnRyaWVzW2ldKSwgdW5kZWZpbmVkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmFjZSQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJhY2UkJHJhY2U7XG4gICAgICAgICAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRyZXNvbHZlKG9iamVjdCkge1xuICAgICAgICAgICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgICAgICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgICAgICAgICAgICAgIGlmIChvYmplY3QgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0LmNvbnN0cnVjdG9yID09PSBDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuICAgICAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVzb2x2ZSQkcmVzb2x2ZTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlamVjdCQkcmVqZWN0KHJlYXNvbikge1xuICAgICAgICAgICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgICAgICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3RvcihsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wKTtcbiAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZWplY3QkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZWplY3QkJHJlamVjdDtcblxuICAgICAgICAgICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRjb3VudGVyID0gMDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzUmVzb2x2ZXIoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkbmVlZHNOZXcoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICBQcm9taXNlIG9iamVjdHMgcmVwcmVzZW50IHRoZSBldmVudHVhbCByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gVGhlXG4gICAgICAgICAgICAgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCwgd2hpY2hcbiAgICAgICAgICAgICByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZSByZWFzb25cbiAgICAgICAgICAgICB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICAgICAgICAgICAgIFRlcm1pbm9sb2d5XG4gICAgICAgICAgICAgLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgIC0gYHByb21pc2VgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB3aXRoIGEgYHRoZW5gIG1ldGhvZCB3aG9zZSBiZWhhdmlvciBjb25mb3JtcyB0byB0aGlzIHNwZWNpZmljYXRpb24uXG4gICAgICAgICAgICAgLSBgdGhlbmFibGVgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IGRlZmluZXMgYSBgdGhlbmAgbWV0aG9kLlxuICAgICAgICAgICAgIC0gYHZhbHVlYCBpcyBhbnkgbGVnYWwgSmF2YVNjcmlwdCB2YWx1ZSAoaW5jbHVkaW5nIHVuZGVmaW5lZCwgYSB0aGVuYWJsZSwgb3IgYSBwcm9taXNlKS5cbiAgICAgICAgICAgICAtIGBleGNlcHRpb25gIGlzIGEgdmFsdWUgdGhhdCBpcyB0aHJvd24gdXNpbmcgdGhlIHRocm93IHN0YXRlbWVudC5cbiAgICAgICAgICAgICAtIGByZWFzb25gIGlzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2h5IGEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQuXG4gICAgICAgICAgICAgLSBgc2V0dGxlZGAgdGhlIGZpbmFsIHJlc3Rpbmcgc3RhdGUgb2YgYSBwcm9taXNlLCBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG5cbiAgICAgICAgICAgICBBIHByb21pc2UgY2FuIGJlIGluIG9uZSBvZiB0aHJlZSBzdGF0ZXM6IHBlbmRpbmcsIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQuXG5cbiAgICAgICAgICAgICBQcm9taXNlcyB0aGF0IGFyZSBmdWxmaWxsZWQgaGF2ZSBhIGZ1bGZpbGxtZW50IHZhbHVlIGFuZCBhcmUgaW4gdGhlIGZ1bGZpbGxlZFxuICAgICAgICAgICAgIHN0YXRlLiAgUHJvbWlzZXMgdGhhdCBhcmUgcmVqZWN0ZWQgaGF2ZSBhIHJlamVjdGlvbiByZWFzb24gYW5kIGFyZSBpbiB0aGVcbiAgICAgICAgICAgICByZWplY3RlZCBzdGF0ZS4gIEEgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmV2ZXIgYSB0aGVuYWJsZS5cblxuICAgICAgICAgICAgIFByb21pc2VzIGNhbiBhbHNvIGJlIHNhaWQgdG8gKnJlc29sdmUqIGEgdmFsdWUuICBJZiB0aGlzIHZhbHVlIGlzIGFsc28gYVxuICAgICAgICAgICAgIHByb21pc2UsIHRoZW4gdGhlIG9yaWdpbmFsIHByb21pc2UncyBzZXR0bGVkIHN0YXRlIHdpbGwgbWF0Y2ggdGhlIHZhbHVlJ3NcbiAgICAgICAgICAgICBzZXR0bGVkIHN0YXRlLiAgU28gYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCByZWplY3RzIHdpbGxcbiAgICAgICAgICAgICBpdHNlbGYgcmVqZWN0LCBhbmQgYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aWxsXG4gICAgICAgICAgICAgaXRzZWxmIGZ1bGZpbGwuXG5cblxuICAgICAgICAgICAgIEJhc2ljIFVzYWdlOlxuICAgICAgICAgICAgIC0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgYGBganNcbiAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBvbiBzdWNjZXNzXG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgICAgIC8vIG9uIGZhaWx1cmVcbiAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICB9KTtcblxuICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAvLyBvbiBmdWxmaWxsbWVudFxuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIC8vIG9uIHJlamVjdGlvblxuICAgICAgfSk7XG4gICAgICAgICAgICAgYGBgXG5cbiAgICAgICAgICAgICBBZHZhbmNlZCBVc2FnZTpcbiAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgIFByb21pc2VzIHNoaW5lIHdoZW4gYWJzdHJhY3RpbmcgYXdheSBhc3luY2hyb25vdXMgaW50ZXJhY3Rpb25zIHN1Y2ggYXNcbiAgICAgICAgICAgICBgWE1MSHR0cFJlcXVlc3Rgcy5cblxuICAgICAgICAgICAgIGBgYGpzXG4gICAgICAgICAgICAgZnVuY3Rpb24gZ2V0SlNPTih1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZXI7XG4gICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgICB4aHIuc2VuZCgpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuRE9ORSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignZ2V0SlNPTjogYCcgKyB1cmwgKyAnYCBmYWlsZWQgd2l0aCBzdGF0dXM6IFsnICsgdGhpcy5zdGF0dXMgKyAnXScpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAgICAgICAgZ2V0SlNPTignL3Bvc3RzLmpzb24nKS50aGVuKGZ1bmN0aW9uKGpzb24pIHtcbiAgICAgICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAvLyBvbiByZWplY3Rpb25cbiAgICAgIH0pO1xuICAgICAgICAgICAgIGBgYFxuXG4gICAgICAgICAgICAgVW5saWtlIGNhbGxiYWNrcywgcHJvbWlzZXMgYXJlIGdyZWF0IGNvbXBvc2FibGUgcHJpbWl0aXZlcy5cblxuICAgICAgICAgICAgIGBgYGpzXG4gICAgICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgIGdldEpTT04oJy9wb3N0cycpLFxuICAgICAgICAgICAgIGdldEpTT04oJy9jb21tZW50cycpXG4gICAgICAgICAgICAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgICAgICB2YWx1ZXNbMF0gLy8gPT4gcG9zdHNKU09OXG4gICAgICAgIHZhbHVlc1sxXSAvLyA9PiBjb21tZW50c0pTT05cblxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfSk7XG4gICAgICAgICAgICAgYGBgXG5cbiAgICAgICAgICAgICBAY2xhc3MgUHJvbWlzZVxuICAgICAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IHJlc29sdmVyXG4gICAgICAgICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgICAgICAgICAgIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZShyZXNvbHZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lkID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJGNvdW50ZXIrKztcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wICE9PSByZXNvbHZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNGdW5jdGlvbihyZXNvbHZlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc1Jlc29sdmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkbmVlZHNOZXcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGluaXRpYWxpemVQcm9taXNlKHRoaXMsIHJlc29sdmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLmFsbCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJGFsbCQkZGVmYXVsdDtcbiAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJhY2UgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyYWNlJCRkZWZhdWx0O1xuICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UucmVzb2x2ZSA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlc29sdmUkJGRlZmF1bHQ7XG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5yZWplY3QgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZWplY3QkJGRlZmF1bHQ7XG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5fc2V0U2NoZWR1bGVyID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHNldFNjaGVkdWxlcjtcbiAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLl9zZXRBc2FwID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHNldEFzYXA7XG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5fYXNhcCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwO1xuXG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgIFRoZSBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLFxuICAgICAgICAgICAgICAgICB3aGljaCByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZVxuICAgICAgICAgICAgICAgICByZWFzb24gd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG5cbiAgICAgICAgICAgICAgICAgYGBganNcbiAgICAgICAgICAgICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uKHVzZXIpe1xuICAgICAgICAvLyB1c2VyIGlzIGF2YWlsYWJsZVxuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gdXNlciBpcyB1bmF2YWlsYWJsZSwgYW5kIHlvdSBhcmUgZ2l2ZW4gdGhlIHJlYXNvbiB3aHlcbiAgICAgIH0pO1xuICAgICAgICAgICAgICAgICBgYGBcblxuICAgICAgICAgICAgICAgICBDaGFpbmluZ1xuICAgICAgICAgICAgICAgICAtLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgIFRoZSByZXR1cm4gdmFsdWUgb2YgYHRoZW5gIGlzIGl0c2VsZiBhIHByb21pc2UuICBUaGlzIHNlY29uZCwgJ2Rvd25zdHJlYW0nXG4gICAgICAgICAgICAgICAgIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmaXJzdCBwcm9taXNlJ3MgZnVsZmlsbG1lbnRcbiAgICAgICAgICAgICAgICAgb3IgcmVqZWN0aW9uIGhhbmRsZXIsIG9yIHJlamVjdGVkIGlmIHRoZSBoYW5kbGVyIHRocm93cyBhbiBleGNlcHRpb24uXG5cbiAgICAgICAgICAgICAgICAgYGBganNcbiAgICAgICAgICAgICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiB1c2VyLm5hbWU7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgICAgIC8vIElmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgdXNlck5hbWVgIHdpbGwgYmUgdGhlIHVzZXIncyBuYW1lLCBvdGhlcndpc2UgaXRcbiAgICAgICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gICAgICB9KTtcblxuICAgICAgICAgICAgICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScpO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gaWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGByZWFzb25gIHdpbGwgYmUgJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jy5cbiAgICAgICAgLy8gSWYgYGZpbmRVc2VyYCByZWplY3RlZCwgYHJlYXNvbmAgd2lsbCBiZSAnYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScuXG4gICAgICB9KTtcbiAgICAgICAgICAgICAgICAgYGBgXG4gICAgICAgICAgICAgICAgIElmIHRoZSBkb3duc3RyZWFtIHByb21pc2UgZG9lcyBub3Qgc3BlY2lmeSBhIHJlamVjdGlvbiBoYW5kbGVyLCByZWplY3Rpb24gcmVhc29ucyB3aWxsIGJlIHByb3BhZ2F0ZWQgZnVydGhlciBkb3duc3RyZWFtLlxuXG4gICAgICAgICAgICAgICAgIGBgYGpzXG4gICAgICAgICAgICAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICB0aHJvdyBuZXcgUGVkYWdvZ2ljYWxFeGNlcHRpb24oJ1Vwc3RyZWFtIGVycm9yJyk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIFRoZSBgUGVkZ2Fnb2NpYWxFeGNlcHRpb25gIGlzIHByb3BhZ2F0ZWQgYWxsIHRoZSB3YXkgZG93biB0byBoZXJlXG4gICAgICB9KTtcbiAgICAgICAgICAgICAgICAgYGBgXG5cbiAgICAgICAgICAgICAgICAgQXNzaW1pbGF0aW9uXG4gICAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG4gICAgICAgICAgICAgICAgIHJldHJpZXZlZCBhc3luY2hyb25vdXNseS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmV0dXJuaW5nIGEgcHJvbWlzZSBpbiB0aGVcbiAgICAgICAgICAgICAgICAgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIGhhbmRsZXIuIFRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCB0aGVuIGJlIHBlbmRpbmdcbiAgICAgICAgICAgICAgICAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG5cbiAgICAgICAgICAgICAgICAgYGBganNcbiAgICAgICAgICAgICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAgIC8vIFRoZSB1c2VyJ3MgY29tbWVudHMgYXJlIG5vdyBhdmFpbGFibGVcbiAgICAgIH0pO1xuICAgICAgICAgICAgICAgICBgYGBcblxuICAgICAgICAgICAgICAgICBJZiB0aGUgYXNzaW1saWF0ZWQgcHJvbWlzZSByZWplY3RzLCB0aGVuIHRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCBhbHNvIHJlamVjdC5cblxuICAgICAgICAgICAgICAgICBgYGBqc1xuICAgICAgICAgICAgICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCBmdWxmaWxscywgd2UnbGwgaGF2ZSB0aGUgdmFsdWUgaGVyZVxuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG4gICAgICB9KTtcbiAgICAgICAgICAgICAgICAgYGBgXG5cbiAgICAgICAgICAgICAgICAgU2ltcGxlIEV4YW1wbGVcbiAgICAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG5cbiAgICAgICAgICAgICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGZpbmRSZXN1bHQoKTtcbiAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgfVxuICAgICAgICAgICAgICAgICBgYGBcblxuICAgICAgICAgICAgICAgICBFcnJiYWNrIEV4YW1wbGVcblxuICAgICAgICAgICAgICAgICBgYGBqc1xuICAgICAgICAgICAgICAgICBmaW5kUmVzdWx0KGZ1bmN0aW9uKHJlc3VsdCwgZXJyKXtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIC8vIGZhaWx1cmVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzdWNjZXNzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgICAgICAgICAgICBgYGBcblxuICAgICAgICAgICAgICAgICBQcm9taXNlIEV4YW1wbGU7XG5cbiAgICAgICAgICAgICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgICAgICAgICAgICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9KTtcbiAgICAgICAgICAgICAgICAgYGBgXG5cbiAgICAgICAgICAgICAgICAgQWR2YW5jZWQgRXhhbXBsZVxuICAgICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcblxuICAgICAgICAgICAgICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICAgICAgICAgICAgIHZhciBhdXRob3IsIGJvb2tzO1xuXG4gICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgIGF1dGhvciA9IGZpbmRBdXRob3IoKTtcbiAgICAgICAgYm9va3MgID0gZmluZEJvb2tzQnlBdXRob3IoYXV0aG9yKTtcbiAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgfVxuICAgICAgICAgICAgICAgICBgYGBcblxuICAgICAgICAgICAgICAgICBFcnJiYWNrIEV4YW1wbGVcblxuICAgICAgICAgICAgICAgICBgYGBqc1xuXG4gICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZvdW5kQm9va3MoYm9va3MpIHtcblxuICAgICAgfVxuXG4gICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZhaWx1cmUocmVhc29uKSB7XG5cbiAgICAgIH1cblxuICAgICAgICAgICAgICAgICBmaW5kQXV0aG9yKGZ1bmN0aW9uKGF1dGhvciwgZXJyKXtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICAvLyBmYWlsdXJlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpbmRCb29va3NCeUF1dGhvcihhdXRob3IsIGZ1bmN0aW9uKGJvb2tzLCBlcnIpIHtcbiAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgZm91bmRCb29rcyhib29rcyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgIGZhaWx1cmUocmVhc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgICAgICAgICAgICAgYGBgXG5cbiAgICAgICAgICAgICAgICAgUHJvbWlzZSBFeGFtcGxlO1xuXG4gICAgICAgICAgICAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgICAgICAgICAgICAgZmluZEF1dGhvcigpLlxuICAgICAgICAgICAgICAgICB0aGVuKGZpbmRCb29rc0J5QXV0aG9yKS5cbiAgICAgICAgICAgICAgICAgdGhlbihmdW5jdGlvbihib29rcyl7XG4gICAgICAgICAgLy8gZm91bmQgYm9va3NcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICB9KTtcbiAgICAgICAgICAgICAgICAgYGBgXG5cbiAgICAgICAgICAgICAgICAgQG1ldGhvZCB0aGVuXG4gICAgICAgICAgICAgICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uRnVsZmlsbGVkXG4gICAgICAgICAgICAgICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgICAgICAgICAgICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgICAgICAgICAgICAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoZW46IGZ1bmN0aW9uKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVEICYmICFvbkZ1bGZpbGxtZW50IHx8IHN0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCAmJiAhb25SZWplY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gbmV3IHRoaXMuY29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBwYXJlbnQuX3Jlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1tzdGF0ZSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbnZva2VDYWxsYmFjayhzdGF0ZSwgY2hpbGQsIGNhbGxiYWNrLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgYGNhdGNoYCBpcyBzaW1wbHkgc3VnYXIgZm9yIGB0aGVuKHVuZGVmaW5lZCwgb25SZWplY3Rpb24pYCB3aGljaCBtYWtlcyBpdCB0aGUgc2FtZVxuICAgICAgICAgICAgICAgICBhcyB0aGUgY2F0Y2ggYmxvY2sgb2YgYSB0cnkvY2F0Y2ggc3RhdGVtZW50LlxuXG4gICAgICAgICAgICAgICAgIGBgYGpzXG4gICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRBdXRob3IoKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gICAgICB9XG5cbiAgICAgICAgICAgICAgICAgLy8gc3luY2hyb25vdXNcbiAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgZmluZEF1dGhvcigpO1xuICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgIH1cblxuICAgICAgICAgICAgICAgICAvLyBhc3luYyB3aXRoIHByb21pc2VzXG4gICAgICAgICAgICAgICAgIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgfSk7XG4gICAgICAgICAgICAgICAgIGBgYFxuXG4gICAgICAgICAgICAgICAgIEBtZXRob2QgY2F0Y2hcbiAgICAgICAgICAgICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3Rpb25cbiAgICAgICAgICAgICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgICAgICAgICAgICAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcG9seWZpbGwkJHBvbHlmaWxsKCkge1xuICAgICAgICAgICAgICAgIHZhciBsb2NhbDtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbCA9IGdsb2JhbDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbCA9IHNlbGY7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2x5ZmlsbCBmYWlsZWQgYmVjYXVzZSBnbG9iYWwgb2JqZWN0IGlzIHVuYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBQID0gbG9jYWwuUHJvbWlzZTtcblxuICAgICAgICAgICAgICAgIGlmIChQICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQLnJlc29sdmUoKSkgPT09ICdbb2JqZWN0IFByb21pc2VdJyAmJiAhUC5jYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsb2NhbC5Qcm9taXNlID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJGRlZmF1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGliJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRwb2x5ZmlsbDtcblxuICAgICAgICAgICAgdmFyIGxpYiRlczYkcHJvbWlzZSR1bWQkJEVTNlByb21pc2UgPSB7XG4gICAgICAgICAgICAgICAgJ1Byb21pc2UnOiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAncG9seWZpbGwnOiBsaWIkZXM2JHByb21pc2UkcG9seWZpbGwkJGRlZmF1bHRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qIGdsb2JhbCBkZWZpbmU6dHJ1ZSBtb2R1bGU6dHJ1ZSB3aW5kb3c6IHRydWUgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZVsnYW1kJ10pIHtcbiAgICAgICAgICAgICAgICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBsaWIkZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlOyB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlWydleHBvcnRzJ10pIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVbJ2V4cG9ydHMnXSA9IGxpYiRlczYkcHJvbWlzZSR1bWQkJEVTNlByb21pc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRoaXNbJ0VTNlByb21pc2UnXSA9IGxpYiRlczYkcHJvbWlzZSR1bWQkJEVTNlByb21pc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkZGVmYXVsdCgpO1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuXG5cbiAgICB9KS5jYWxsKHRoaXMscmVxdWlyZSgyKSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIyXCI6Mn1dLDEwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICAgICAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICAgICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgICAgICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgICAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgICAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgICAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgICAgICB9XG4gICAgfVxuXG59LHt9XSwxMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gICAgdmFyIGFycmF5RWFjaCA9IHJlcXVpcmUoMTQpLFxuICAgICAgICBiYXNlRWFjaCA9IHJlcXVpcmUoMTgpLFxuICAgICAgICBjcmVhdGVGb3JFYWNoID0gcmVxdWlyZSgzMCk7XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBpbnZva2luZyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gICAgICogVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseVxuICAgICAqIGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgXCJsZW5ndGhcIiBwcm9wZXJ0eVxuICAgICAqIGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciBgXy5mb3JJbmAgb3IgYF8uZm9yT3duYFxuICAgICAqIG1heSBiZSB1c2VkIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGVhY2hcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyXSkuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gKiAgIGNvbnNvbGUubG9nKG4pO1xuICogfSkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBsb2dzIGVhY2ggdmFsdWUgZnJvbSBsZWZ0IHRvIHJpZ2h0IGFuZCByZXR1cm5zIHRoZSBhcnJheVxuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24obiwga2V5KSB7XG4gKiAgIGNvbnNvbGUubG9nKG4sIGtleSk7XG4gKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzIGVhY2ggdmFsdWUta2V5IHBhaXIgYW5kIHJldHVybnMgdGhlIG9iamVjdCAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciBmb3JFYWNoID0gY3JlYXRlRm9yRWFjaChhcnJheUVhY2gsIGJhc2VFYWNoKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZm9yRWFjaDtcblxufSx7XCIxNFwiOjE0LFwiMThcIjoxOCxcIjMwXCI6MzB9XSwxMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gICAgLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbiAgICB2YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4gICAgLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbiAgICB2YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uIGFuZCBhcmd1bWVudHMgZnJvbSBgc3RhcnRgIGFuZCBiZXlvbmQgcHJvdmlkZWQgYXMgYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlIFtyZXN0IHBhcmFtZXRlcl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRnVuY3Rpb25zL3Jlc3RfcGFyYW1ldGVycykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNheSA9IF8ucmVzdFBhcmFtKGZ1bmN0aW9uKHdoYXQsIG5hbWVzKSB7XG4gKiAgIHJldHVybiB3aGF0ICsgJyAnICsgXy5pbml0aWFsKG5hbWVzKS5qb2luKCcsICcpICtcbiAqICAgICAoXy5zaXplKG5hbWVzKSA+IDEgPyAnLCAmICcgOiAnJykgKyBfLmxhc3QobmFtZXMpO1xuICogfSk7XG4gICAgICpcbiAgICAgKiBzYXkoJ2hlbGxvJywgJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdFBhcmFtKGZ1bmMsIHN0YXJ0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogKCtzdGFydCB8fCAwKSwgMCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICAgICAgICAgIHJlc3QgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3RbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpcywgcmVzdCk7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3NbMF0sIHJlc3QpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdLCByZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdGhlckFyZ3Nbc3RhcnRdID0gcmVzdDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIG90aGVyQXJncyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXN0UGFyYW07XG5cbn0se31dLDEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgICAvKipcbiAgICAgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlDb3B5KHNvdXJjZSwgYXJyYXkpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gICAgICAgIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBhcnJheUNvcHk7XG5cbn0se31dLDE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGFycmF5RWFjaDtcblxufSx7fV0sMTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuICAgIHZhciBiYXNlQ29weSA9IHJlcXVpcmUoMTcpLFxuICAgICAgICBrZXlzID0gcmVxdWlyZSg1NSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmcsXG4gICAgICogbXVsdGlwbGUgc291cmNlcywgYW5kIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlID09IG51bGxcbiAgICAgICAgICAgID8gb2JqZWN0XG4gICAgICAgICAgICA6IGJhc2VDb3B5KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbjtcblxufSx7XCIxN1wiOjE3LFwiNTVcIjo1NX1dLDE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgICB2YXIgYXJyYXlDb3B5ID0gcmVxdWlyZSgxMyksXG4gICAgICAgIGFycmF5RWFjaCA9IHJlcXVpcmUoMTQpLFxuICAgICAgICBiYXNlQXNzaWduID0gcmVxdWlyZSgxNSksXG4gICAgICAgIGJhc2VGb3JPd24gPSByZXF1aXJlKDIxKSxcbiAgICAgICAgaW5pdENsb25lQXJyYXkgPSByZXF1aXJlKDMzKSxcbiAgICAgICAgaW5pdENsb25lQnlUYWcgPSByZXF1aXJlKDM0KSxcbiAgICAgICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgzNSksXG4gICAgICAgIGlzQXJyYXkgPSByZXF1aXJlKDQ3KSxcbiAgICAgICAgaXNIb3N0T2JqZWN0ID0gcmVxdWlyZSgzNyksXG4gICAgICAgIGlzT2JqZWN0ID0gcmVxdWlyZSg1MCk7XG5cbiAgICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG4gICAgdmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICAgICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgICAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgICAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICAgICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgICAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgICAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG4gICAgdmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICAgICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuICAgIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG4gICAgdmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbiAgICBjbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuICAgICAgICBjbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPVxuICAgICAgICAgICAgY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPVxuICAgICAgICAgICAgICAgIGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDhUYWddID1cbiAgICAgICAgICAgICAgICAgICAgY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gICAgY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbiAgICAgICAgY2xvbmVhYmxlVGFnc1ttYXBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbiAgICAgICAgICAgIGNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuICAgIC8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gICAgICogb2YgdmFsdWVzLlxuICAgICAqL1xuICAgIHZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmdcbiAgICAgKiBhbmQgYHRoaXNgIGJpbmRpbmcgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IGB2YWx1ZWAgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgY2xvbmVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0KSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICAgICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5Q29weSh2YWx1ZSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZztcblxuICAgICAgICAgICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0hvc3RPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVPYmplY3QoaXNGdW5jID8ge30gOiB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVhYmxlVGFnc1t0YWddXG4gICAgICAgICAgICAgICAgICAgID8gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKVxuICAgICAgICAgICAgICAgICAgICA6IChvYmplY3QgPyB2YWx1ZSA6IHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICAgICAgICBzdGFja0EgfHwgKHN0YWNrQSA9IFtdKTtcbiAgICAgICAgc3RhY2tCIHx8IChzdGFja0IgPSBbXSk7XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgc291cmNlIHZhbHVlIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgYXNzb2NpYXRlIGl0IHdpdGggaXRzIGNsb25lLlxuICAgICAgICBzdGFja0EucHVzaCh2YWx1ZSk7XG4gICAgICAgIHN0YWNrQi5wdXNoKHJlc3VsdCk7XG5cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgKGlzQXJyID8gYXJyYXlFYWNoIDogYmFzZUZvck93bikodmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gYmFzZUNsb25lKHN1YlZhbHVlLCBpc0RlZXAsIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBiYXNlQ2xvbmU7XG5cbn0se1wiMTNcIjoxMyxcIjE0XCI6MTQsXCIxNVwiOjE1LFwiMjFcIjoyMSxcIjMzXCI6MzMsXCIzNFwiOjM0LFwiMzVcIjozNSxcIjM3XCI6MzcsXCI0N1wiOjQ3LFwiNTBcIjo1MH1dLDE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgICAvKipcbiAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBjb3B5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDb3B5KHNvdXJjZSwgcHJvcHMsIG9iamVjdCkge1xuICAgICAgICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGJhc2VDb3B5O1xuXG59LHt9XSwxODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gICAgdmFyIGJhc2VGb3JPd24gPSByZXF1aXJlKDIxKSxcbiAgICAgICAgY3JlYXRlQmFzZUVhY2ggPSByZXF1aXJlKDI4KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gYmFzZUVhY2g7XG5cbn0se1wiMjFcIjoyMSxcIjI4XCI6Mjh9XSwxOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gICAgdmFyIGNyZWF0ZUJhc2VGb3IgPSByZXF1aXJlKDI5KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9ySW5gIGFuZCBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXNcbiAgICAgKiBvdmVyIGBvYmplY3RgIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBpbnZva2luZyBgaXRlcmF0ZWVgIGZvclxuICAgICAqIGVhY2ggcHJvcGVydHkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseVxuICAgICAqIHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuXG59LHtcIjI5XCI6Mjl9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gICAgdmFyIGJhc2VGb3IgPSByZXF1aXJlKDE5KSxcbiAgICAgICAga2V5c0luID0gcmVxdWlyZSg1Nik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRm9ySW4ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgICByZXR1cm4gYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzSW4pO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gYmFzZUZvckluO1xuXG59LHtcIjE5XCI6MTksXCI1NlwiOjU2fV0sMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuICAgIHZhciBiYXNlRm9yID0gcmVxdWlyZSgxOSksXG4gICAgICAgIGtleXMgPSByZXF1aXJlKDU1KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yT3duO1xuXG59LHtcIjE5XCI6MTksXCI1NVwiOjU1fV0sMjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuICAgIHZhciBhcnJheUVhY2ggPSByZXF1aXJlKDE0KSxcbiAgICAgICAgYmFzZU1lcmdlRGVlcCA9IHJlcXVpcmUoMjMpLFxuICAgICAgICBpc0FycmF5ID0gcmVxdWlyZSg0NyksXG4gICAgICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgzNiksXG4gICAgICAgIGlzT2JqZWN0ID0gcmVxdWlyZSg1MCksXG4gICAgICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoNDEpLFxuICAgICAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKDUzKSxcbiAgICAgICAga2V5cyA9IHJlcXVpcmUoNTUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmcsXG4gICAgICogbXVsdGlwbGUgc291cmNlcywgYW5kIGB0aGlzYCBiaW5kaW5nIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBBc3NvY2lhdGVzIHZhbHVlcyB3aXRoIHNvdXJjZSBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIsIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNTcmNBcnIgPSBpc0FycmF5TGlrZShzb3VyY2UpICYmIChpc0FycmF5KHNvdXJjZSkgfHwgaXNUeXBlZEFycmF5KHNvdXJjZSkpLFxuICAgICAgICAgICAgcHJvcHMgPSBpc1NyY0FyciA/IHVuZGVmaW5lZCA6IGtleXMoc291cmNlKTtcblxuICAgICAgICBhcnJheUVhY2gocHJvcHMgfHwgc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBzcmNWYWx1ZTtcbiAgICAgICAgICAgICAgICBzcmNWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzT2JqZWN0TGlrZShzcmNWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBzdGFja0EgfHwgKHN0YWNrQSA9IFtdKTtcbiAgICAgICAgICAgICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IFtdKTtcbiAgICAgICAgICAgICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKHZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGlzQ29tbW9uID0gcmVzdWx0ID09PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc3JjVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgocmVzdWx0ICE9PSB1bmRlZmluZWQgfHwgKGlzU3JjQXJyICYmICEoa2V5IGluIG9iamVjdCkpKSAmJlxuICAgICAgICAgICAgICAgICAgICAoaXNDb21tb24gfHwgKHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlc3VsdCAhPT0gdmFsdWUpIDogKHZhbHVlID09PSB2YWx1ZSkpKSkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlO1xuXG59LHtcIjE0XCI6MTQsXCIyM1wiOjIzLFwiMzZcIjozNixcIjQxXCI6NDEsXCI0N1wiOjQ3LFwiNTBcIjo1MCxcIjUzXCI6NTMsXCI1NVwiOjU1fV0sMjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuICAgIHZhciBhcnJheUNvcHkgPSByZXF1aXJlKDEzKSxcbiAgICAgICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKDQ2KSxcbiAgICAgICAgaXNBcnJheSA9IHJlcXVpcmUoNDcpLFxuICAgICAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoMzYpLFxuICAgICAgICBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSg1MSksXG4gICAgICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoNTMpLFxuICAgICAgICB0b1BsYWluT2JqZWN0ID0gcmVxdWlyZSg1NCk7XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgICAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgdmFsdWVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHN0YWNrQS5sZW5ndGgsXG4gICAgICAgICAgICBzcmNWYWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IHNyY1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0W2tleV0gPSBzdGFja0JbbGVuZ3RoXTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaXNDb21tb24gPSByZXN1bHQgPT09IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNyY1ZhbHVlO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXlMaWtlKHNyY1ZhbHVlKSAmJiAoaXNBcnJheShzcmNWYWx1ZSkgfHwgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpc0FycmF5KHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogKGlzQXJyYXlMaWtlKHZhbHVlKSA/IGFycmF5Q29weSh2YWx1ZSkgOiBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpc0FyZ3VtZW50cyh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgPyB0b1BsYWluT2JqZWN0KHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA6IChpc1BsYWluT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDoge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIHNvdXJjZSB2YWx1ZSB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMgYW5kIGFzc29jaWF0ZVxuICAgICAgICAvLyBpdCB3aXRoIGl0cyBtZXJnZWQgdmFsdWUuXG4gICAgICAgIHN0YWNrQS5wdXNoKHNyY1ZhbHVlKTtcbiAgICAgICAgc3RhY2tCLnB1c2gocmVzdWx0KTtcblxuICAgICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgICAgb2JqZWN0W2tleV0gPSBtZXJnZUZ1bmMocmVzdWx0LCBzcmNWYWx1ZSwgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlc3VsdCAhPT0gdmFsdWUpIDogKHZhbHVlID09PSB2YWx1ZSkpIHtcbiAgICAgICAgICAgIG9iamVjdFtrZXldID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBiYXNlTWVyZ2VEZWVwO1xuXG59LHtcIjEzXCI6MTMsXCIzNlwiOjM2LFwiNDZcIjo0NixcIjQ3XCI6NDcsXCI1MVwiOjUxLFwiNTNcIjo1MyxcIjU0XCI6NTR9XSwyNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gICAgdmFyIHRvT2JqZWN0ID0gcmVxdWlyZSg0Myk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHRvT2JqZWN0KG9iamVjdClba2V5XTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eTtcblxufSx7XCI0M1wiOjQzfV0sMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuICAgIHZhciBpZGVudGl0eSA9IHJlcXVpcmUoNTkpO1xuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlQ2FsbGJhY2tgIHdoaWNoIG9ubHkgc3VwcG9ydHMgYHRoaXNgIGJpbmRpbmdcbiAgICAgKiBhbmQgc3BlY2lmeWluZyB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmRDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzQXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYXJnQ291bnQpIHtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlciwga2V5LCBvYmplY3QsIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUsIG90aGVyLCBrZXksIG9iamVjdCwgc291cmNlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGJpbmRDYWxsYmFjaztcblxufSx7XCI1OVwiOjU5fV0sMjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuICAgIChmdW5jdGlvbiAoZ2xvYmFsKXtcbiAgICAgICAgLyoqIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICAgICAgdmFyIEFycmF5QnVmZmVyID0gZ2xvYmFsLkFycmF5QnVmZmVyLFxuICAgICAgICAgICAgVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGdpdmVuIGFycmF5IGJ1ZmZlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1ZmZlcikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXIuYnl0ZUxlbmd0aCksXG4gICAgICAgICAgICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG5cbiAgICAgICAgICAgIHZpZXcuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyQ2xvbmU7XG5cbiAgICB9KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se31dLDI3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgICB2YXIgYmluZENhbGxiYWNrID0gcmVxdWlyZSgyNSksXG4gICAgICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgzOSksXG4gICAgICAgIHJlc3RQYXJhbSA9IHJlcXVpcmUoMTIpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmFzc2lnbmAsIGBfLmRlZmF1bHRzYCwgb3IgYF8ubWVyZ2VgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICAgICAgICByZXR1cm4gcmVzdFBhcmFtKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogc291cmNlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzW2xlbmd0aCAtIDJdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdGhpc0FyZyA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGN1c3RvbWl6ZXIgPSBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgNSk7XG4gICAgICAgICAgICAgICAgbGVuZ3RoIC09IDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgdGhpc0FyZyA9PSAnZnVuY3Rpb24nID8gdGhpc0FyZyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsZW5ndGggLT0gKGN1c3RvbWl6ZXIgPyAxIDogMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFzc2lnbmVyO1xuXG59LHtcIjEyXCI6MTIsXCIyNVwiOjI1LFwiMzlcIjozOX1dLDI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgICB2YXIgZ2V0TGVuZ3RoID0gcmVxdWlyZSgzMSksXG4gICAgICAgIGlzTGVuZ3RoID0gcmVxdWlyZSg0MCksXG4gICAgICAgIHRvT2JqZWN0ID0gcmVxdWlyZSg0Myk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gZ2V0TGVuZ3RoKGNvbGxlY3Rpb24pIDogMDtcbiAgICAgICAgICAgIGlmICghaXNMZW5ndGgobGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgICAgICAgICBpdGVyYWJsZSA9IHRvT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgICAgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUVhY2g7XG5cbn0se1wiMzFcIjozMSxcIjQwXCI6NDAsXCI0M1wiOjQzfV0sMjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuICAgIHZhciB0b09iamVjdCA9IHJlcXVpcmUoNDMpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIGBfLmZvckluYCBvciBgXy5mb3JJblJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICAgICAgICAgIHZhciBpdGVyYWJsZSA9IHRvT2JqZWN0KG9iamVjdCksXG4gICAgICAgICAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xO1xuXG4gICAgICAgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUZvcjtcblxufSx7XCI0M1wiOjQzfV0sMzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuICAgIHZhciBiaW5kQ2FsbGJhY2sgPSByZXF1aXJlKDI1KSxcbiAgICAgICAgaXNBcnJheSA9IHJlcXVpcmUoNDcpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGZvciBgXy5mb3JFYWNoYCBvciBgXy5mb3JFYWNoUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhcnJheUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhbiBhcnJheS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBlYWNoIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZvckVhY2goYXJyYXlGdW5jLCBlYWNoRnVuYykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgJiYgdGhpc0FyZyA9PT0gdW5kZWZpbmVkICYmIGlzQXJyYXkoY29sbGVjdGlvbikpXG4gICAgICAgICAgICAgICAgPyBhcnJheUZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpXG4gICAgICAgICAgICAgICAgOiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBiaW5kQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUZvckVhY2g7XG5cbn0se1wiMjVcIjoyNSxcIjQ3XCI6NDd9XSwzMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gICAgdmFyIGJhc2VQcm9wZXJ0eSA9IHJlcXVpcmUoMjQpO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSB2YWx1ZSBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYXZvaWQgYSBbSklUIGJ1Z10oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE0Mjc5MilcbiAgICAgKiB0aGF0IGFmZmVjdHMgU2FmYXJpIG9uIGF0IGxlYXN0IGlPUyA4LjEtOC4zIEFSTTY0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIFwibGVuZ3RoXCIgdmFsdWUuXG4gICAgICovXG4gICAgdmFyIGdldExlbmd0aCA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdldExlbmd0aDtcblxufSx7XCIyNFwiOjI0fV0sMzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuICAgIHZhciBpc05hdGl2ZSA9IHJlcXVpcmUoNDkpO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICAgICAgcmV0dXJuIGlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuXG59LHtcIjQ5XCI6NDl9XSwzMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gICAgLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gICAgICAgIC8vIEFkZCBhcnJheSBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gICAgICAgIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgICAgICAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICAgICAgICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVBcnJheTtcblxufSx7fV0sMzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuICAgIChmdW5jdGlvbiAoZ2xvYmFsKXtcbiAgICAgICAgdmFyIGJ1ZmZlckNsb25lID0gcmVxdWlyZSgyNik7XG5cbiAgICAgICAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuICAgICAgICB2YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICAgICAgICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgICAgICAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgICAgICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgICAgICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbiAgICAgICAgdmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICAgICAgICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgICAgICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICAgICAgICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgICAgICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgICAgICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICAgICAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgICAgICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICAgICAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgICAgICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuICAgICAgICAvKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbiAgICAgICAgdmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4gICAgICAgIC8qKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gICAgICAgIHZhciBVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXk7XG5cbiAgICAgICAgLyoqIFVzZWQgdG8gbG9va3VwIGEgdHlwZSBhcnJheSBjb25zdHJ1Y3RvcnMgYnkgYHRvU3RyaW5nVGFnYC4gKi9cbiAgICAgICAgdmFyIGN0b3JCeVRhZyA9IHt9O1xuICAgICAgICBjdG9yQnlUYWdbZmxvYXQzMlRhZ10gPSBnbG9iYWwuRmxvYXQzMkFycmF5O1xuICAgICAgICBjdG9yQnlUYWdbZmxvYXQ2NFRhZ10gPSBnbG9iYWwuRmxvYXQ2NEFycmF5O1xuICAgICAgICBjdG9yQnlUYWdbaW50OFRhZ10gPSBnbG9iYWwuSW50OEFycmF5O1xuICAgICAgICBjdG9yQnlUYWdbaW50MTZUYWddID0gZ2xvYmFsLkludDE2QXJyYXk7XG4gICAgICAgIGN0b3JCeVRhZ1tpbnQzMlRhZ10gPSBnbG9iYWwuSW50MzJBcnJheTtcbiAgICAgICAgY3RvckJ5VGFnW3VpbnQ4VGFnXSA9IFVpbnQ4QXJyYXk7XG4gICAgICAgIGN0b3JCeVRhZ1t1aW50OENsYW1wZWRUYWddID0gZ2xvYmFsLlVpbnQ4Q2xhbXBlZEFycmF5O1xuICAgICAgICBjdG9yQnlUYWdbdWludDE2VGFnXSA9IGdsb2JhbC5VaW50MTZBcnJheTtcbiAgICAgICAgY3RvckJ5VGFnW3VpbnQzMlRhZ10gPSBnbG9iYWwuVWludDMyQXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAgICAgICAgICpcbiAgICAgICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBpc0RlZXApIHtcbiAgICAgICAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyQ2xvbmUob2JqZWN0KTtcblxuICAgICAgICAgICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgICAgICAgICAgICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgICAgICAgICAgICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICAgICAgICAgICAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA1IG1vYmlsZSBpbmNvcnJlY3RseSBoYXMgYE9iamVjdGAgYXMgdGhlIGNvbnN0cnVjdG9yIG9mIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgICAgICBpZiAoQ3RvciBpbnN0YW5jZW9mIEN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgQ3RvciA9IGN0b3JCeVRhZ1t0YWddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoaXNEZWVwID8gYnVmZmVyQ2xvbmUoYnVmZmVyKSA6IGJ1ZmZlciwgb2JqZWN0LmJ5dGVPZmZzZXQsIG9iamVjdC5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgICAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgICAgICAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgQ3RvcihvYmplY3Quc291cmNlLCByZUZsYWdzLmV4ZWMob2JqZWN0KSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5sYXN0SW5kZXggPSBvYmplY3QubGFzdEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQnlUYWc7XG5cbiAgICB9KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiMjZcIjoyNn1dLDM1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgICBpZiAoISh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yKSkge1xuICAgICAgICAgICAgQ3RvciA9IE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEN0b3I7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVPYmplY3Q7XG5cbn0se31dLDM2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgICB2YXIgZ2V0TGVuZ3RoID0gcmVxdWlyZSgzMSksXG4gICAgICAgIGlzTGVuZ3RoID0gcmVxdWlyZSg0MCk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgoZ2V0TGVuZ3RoKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcblxufSx7XCIzMVwiOjMxLFwiNDBcIjo0MH1dLDM3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0IGluIElFIDwgOS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIHZhciBpc0hvc3RPYmplY3QgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBPYmplY3QoeyAndG9TdHJpbmcnOiAwIH0gKyAnJyk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBJRSA8IDkgcHJlc2VudHMgbWFueSBob3N0IG9iamVjdHMgYXMgYE9iamVjdGAgb2JqZWN0cyB0aGF0IGNhbiBjb2VyY2VcbiAgICAgICAgICAgIC8vIHRvIHN0cmluZ3MgZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgKHZhbHVlICsgJycpID09ICdzdHJpbmcnO1xuICAgICAgICB9O1xuICAgIH0oKSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzSG9zdE9iamVjdDtcblxufSx7fV0sMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuICAgIC8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbiAgICB2YXIgcmVJc1VpbnQgPSAvXlxcZCskLztcblxuICAgIC8qKlxuICAgICAqIFVzZWQgYXMgdGhlIFttYXhpbXVtIGxlbmd0aF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXIpXG4gICAgICogb2YgYW4gYXJyYXktbGlrZSB2YWx1ZS5cbiAgICAgKi9cbiAgICB2YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlID0gKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgPyArdmFsdWUgOiAtMTtcbiAgICAgICAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICAgICAgICByZXR1cm4gdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG5cbn0se31dLDM5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgICB2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKDM2KSxcbiAgICAgICAgaXNJbmRleCA9IHJlcXVpcmUoMzgpLFxuICAgICAgICBpc09iamVjdCA9IHJlcXVpcmUoNTApO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBwcm92aWRlZCBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICAgICAgICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBvYmplY3RbaW5kZXhdO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/ICh2YWx1ZSA9PT0gb3RoZXIpIDogKG90aGVyICE9PSBvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNJdGVyYXRlZUNhbGw7XG5cbn0se1wiMzZcIjozNixcIjM4XCI6MzgsXCI1MFwiOjUwfV0sNDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuICAgIC8qKlxuICAgICAqIFVzZWQgYXMgdGhlIFttYXhpbXVtIGxlbmd0aF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXIpXG4gICAgICogb2YgYW4gYXJyYXktbGlrZSB2YWx1ZS5cbiAgICAgKi9cbiAgICB2YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvbGVuZ3RoKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuXG59LHt9XSw0MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcblxufSx7fV0sNDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuICAgIHZhciBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoNDYpLFxuICAgICAgICBpc0FycmF5ID0gcmVxdWlyZSg0NyksXG4gICAgICAgIGlzSW5kZXggPSByZXF1aXJlKDM4KSxcbiAgICAgICAgaXNMZW5ndGggPSByZXF1aXJlKDQwKSxcbiAgICAgICAgaXNTdHJpbmcgPSByZXF1aXJlKDUyKSxcbiAgICAgICAga2V5c0luID0gcmVxdWlyZSg1Nik7XG5cbiAgICAvKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbiAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIC8qKlxuICAgICAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYE9iamVjdC5rZXlzYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5IG9mIHRoZVxuICAgICAqIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaGltS2V5cyhvYmplY3QpIHtcbiAgICAgICAgdmFyIHByb3BzID0ga2V5c0luKG9iamVjdCksXG4gICAgICAgICAgICBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzTGVuZ3RoICYmIG9iamVjdC5sZW5ndGg7XG5cbiAgICAgICAgdmFyIGFsbG93SW5kZXhlcyA9ICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiZcbiAgICAgICAgICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSB8fCBpc1N0cmluZyhvYmplY3QpKTtcblxuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoKGFsbG93SW5kZXhlcyAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSkgfHwgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzaGltS2V5cztcblxufSx7XCIzOFwiOjM4LFwiNDBcIjo0MCxcIjQ2XCI6NDYsXCI0N1wiOjQ3LFwiNTJcIjo1MixcIjU2XCI6NTZ9XSw0MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gICAgdmFyIGlzT2JqZWN0ID0gcmVxdWlyZSg1MCksXG4gICAgICAgIGlzU3RyaW5nID0gcmVxdWlyZSg1MiksXG4gICAgICAgIHN1cHBvcnQgPSByZXF1aXJlKDU4KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gb2JqZWN0IGlmIGl0J3Mgbm90IG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9PYmplY3QodmFsdWUpIHtcbiAgICAgICAgaWYgKHN1cHBvcnQudW5pbmRleGVkQ2hhcnMgJiYgaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gT2JqZWN0KHZhbHVlKTtcblxuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWUuY2hhckF0KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDogT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRvT2JqZWN0O1xuXG59LHtcIjUwXCI6NTAsXCI1MlwiOjUyLFwiNThcIjo1OH1dLDQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgICB2YXIgYmFzZUNsb25lID0gcmVxdWlyZSgxNiksXG4gICAgICAgIGJpbmRDYWxsYmFjayA9IHJlcXVpcmUoMjUpLFxuICAgICAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoMzkpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB2YWx1ZWAuIElmIGBpc0RlZXBgIGlzIGB0cnVlYCBuZXN0ZWQgb2JqZWN0cyBhcmUgY2xvbmVkLFxuICAgICAqIG90aGVyd2lzZSB0aGV5IGFyZSBhc3NpZ25lZCBieSByZWZlcmVuY2UuIElmIGBjdXN0b21pemVyYCBpcyBwcm92aWRlZCBpdCBpc1xuICAgICAqIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBjbG9uaW5nIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGJvdW5kIHRvXG4gICAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50OyAodmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3RdKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICAgICAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNpbnRlcm5hbC1zdHJ1Y3R1cmVkLWNsb25pbmctYWxnb3JpdGhtKS5cbiAgICAgKiBUaGUgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYW5kIG9iamVjdHMgY3JlYXRlZCBieVxuICAgICAqIGNvbnN0cnVjdG9ycyBvdGhlciB0aGFuIGBPYmplY3RgIGFyZSBjbG9uZWQgdG8gcGxhaW4gYE9iamVjdGAgb2JqZWN0cy4gQW5cbiAgICAgKiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoIGFzIGZ1bmN0aW9ucywgRE9NIG5vZGVzLFxuICAgICAqIE1hcHMsIFNldHMsIGFuZCBXZWFrTWFwcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBzaGFsbG93ID0gXy5jbG9uZSh1c2Vycyk7XG4gICAgICogc2hhbGxvd1swXSA9PT0gdXNlcnNbMF07XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lKHVzZXJzLCB0cnVlKTtcbiAgICAgKiBkZWVwWzBdID09PSB1c2Vyc1swXTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gICAgICogdmFyIGVsID0gXy5jbG9uZShkb2N1bWVudC5ib2R5LCBmdW5jdGlvbih2YWx1ZSkge1xuICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZShmYWxzZSk7XG4gKiAgIH1cbiAqIH0pO1xuICAgICAqXG4gICAgICogZWwgPT09IGRvY3VtZW50LmJvZHlcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqIGVsLm5vZGVOYW1lXG4gICAgICogLy8gPT4gQk9EWVxuICAgICAqIGVsLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZSh2YWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCB0aGlzQXJnKSB7XG4gICAgICAgIGlmIChpc0RlZXAgJiYgdHlwZW9mIGlzRGVlcCAhPSAnYm9vbGVhbicgJiYgaXNJdGVyYXRlZUNhbGwodmFsdWUsIGlzRGVlcCwgY3VzdG9taXplcikpIHtcbiAgICAgICAgICAgIGlzRGVlcCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpc0RlZXAgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpc0FyZyA9IGN1c3RvbWl6ZXI7XG4gICAgICAgICAgICBjdXN0b21pemVyID0gaXNEZWVwO1xuICAgICAgICAgICAgaXNEZWVwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gYmFzZUNsb25lKHZhbHVlLCBpc0RlZXAsIGJpbmRDYWxsYmFjayhjdXN0b21pemVyLCB0aGlzQXJnLCAxKSlcbiAgICAgICAgICAgIDogYmFzZUNsb25lKHZhbHVlLCBpc0RlZXApO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG5cbn0se1wiMTZcIjoxNixcIjI1XCI6MjUsXCIzOVwiOjM5fV0sNDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuICAgIHZhciBiYXNlQ2xvbmUgPSByZXF1aXJlKDE2KSxcbiAgICAgICAgYmluZENhbGxiYWNrID0gcmVxdWlyZSgyNSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVlcCBjbG9uZSBvZiBgdmFsdWVgLiBJZiBgY3VzdG9taXplcmAgaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZFxuICAgICAqIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgIGNsb25pbmdcbiAgICAgKiBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudDsgKHZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0XSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAgICAgKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjaW50ZXJuYWwtc3RydWN0dXJlZC1jbG9uaW5nLWFsZ29yaXRobSkuXG4gICAgICogVGhlIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFuZCBvYmplY3RzIGNyZWF0ZWQgYnlcbiAgICAgKiBjb25zdHJ1Y3RvcnMgb3RoZXIgdGhhbiBgT2JqZWN0YCBhcmUgY2xvbmVkIHRvIHBsYWluIGBPYmplY3RgIG9iamVjdHMuIEFuXG4gICAgICogZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaCBhcyBmdW5jdGlvbnMsIERPTSBub2RlcyxcbiAgICAgKiBNYXBzLCBTZXRzLCBhbmQgV2Vha01hcHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAodXNlcnMpO1xuICAgICAqIGRlZXBbMF0gPT09IHVzZXJzWzBdO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lRGVlcChkb2N1bWVudC5ib2R5LCBmdW5jdGlvbih2YWx1ZSkge1xuICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZSh0cnVlKTtcbiAqICAgfVxuICogfSk7XG4gICAgICpcbiAgICAgKiBlbCA9PT0gZG9jdW1lbnQuYm9keVxuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogZWwubm9kZU5hbWVcbiAgICAgKiAvLyA9PiBCT0RZXG4gICAgICogZWwuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXAodmFsdWUsIGN1c3RvbWl6ZXIsIHRoaXNBcmcpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gYmFzZUNsb25lKHZhbHVlLCB0cnVlLCBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgMSkpXG4gICAgICAgICAgICA6IGJhc2VDbG9uZSh2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjbG9uZURlZXA7XG5cbn0se1wiMTZcIjoxNixcIjI1XCI6MjV9XSw0NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gICAgdmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgzNiksXG4gICAgICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoNDEpO1xuXG4gICAgLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgICAvKiogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiYgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuXG59LHtcIjM2XCI6MzYsXCI0MVwiOjQxfV0sNDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuICAgIHZhciBnZXROYXRpdmUgPSByZXF1aXJlKDMyKSxcbiAgICAgICAgaXNMZW5ndGggPSByZXF1aXJlKDQwKSxcbiAgICAgICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSg0MSk7XG5cbiAgICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG4gICAgdmFyIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJztcblxuICAgIC8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gICAgICogb2YgdmFsdWVzLlxuICAgICAqL1xuICAgIHZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gICAgLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbiAgICB2YXIgbmF0aXZlSXNBcnJheSA9IGdldE5hdGl2ZShBcnJheSwgJ2lzQXJyYXknKTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcnJheVRhZztcbiAgICAgICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcblxufSx7XCIzMlwiOjMyLFwiNDBcIjo0MCxcIjQxXCI6NDF9XSw0ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gICAgdmFyIGlzT2JqZWN0ID0gcmVxdWlyZSg1MCk7XG5cbiAgICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG4gICAgdmFyIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG4gICAgLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICAgKiBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgdmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbihfKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgICAgICAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmkgd2hpY2ggcmV0dXJuICdmdW5jdGlvbicgZm9yIHJlZ2V4ZXNcbiAgICAgICAgLy8gYW5kIFNhZmFyaSA4IGVxdWl2YWxlbnRzIHdoaWNoIHJldHVybiAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgY29uc3RydWN0b3JzLlxuICAgICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGZ1bmNUYWc7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuXG59LHtcIjUwXCI6NTB9XSw0OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gICAgdmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKDQ4KSxcbiAgICAgICAgaXNIb3N0T2JqZWN0ID0gcmVxdWlyZSgzNyksXG4gICAgICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoNDEpO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkgPiA1KS4gKi9cbiAgICB2YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuICAgIC8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbiAgICB2YXIgZm5Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcblxuICAgIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbiAgICB2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICAgICAgICBmblRvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCAnXFxcXCQmJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShfKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVJc05hdGl2ZS50ZXN0KGZuVG9TdHJpbmcuY2FsbCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIChpc0hvc3RPYmplY3QodmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcikudGVzdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc05hdGl2ZTtcblxufSx7XCIzN1wiOjM3LFwiNDFcIjo0MSxcIjQ4XCI6NDh9XSw1MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAgICAgKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3Qoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgICAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG5cbn0se31dLDUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgICB2YXIgYmFzZUZvckluID0gcmVxdWlyZSgyMCksXG4gICAgICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSg0NiksXG4gICAgICAgIGlzSG9zdE9iamVjdCA9IHJlcXVpcmUoMzcpLFxuICAgICAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKDQxKSxcbiAgICAgICAgc3VwcG9ydCA9IHJlcXVpcmUoNTgpO1xuXG4gICAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuICAgIC8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAgIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICAgKiBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgdmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gICAgICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGFzc3VtZXMgb2JqZWN0cyBjcmVhdGVkIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3RvclxuICAgICAqIGhhdmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIHZhciBDdG9yO1xuXG4gICAgICAgIC8vIEV4aXQgZWFybHkgZm9yIG5vbiBgT2JqZWN0YCBvYmplY3RzLlxuICAgICAgICBpZiAoIShpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IG9iamVjdFRhZyAmJiAhaXNIb3N0T2JqZWN0KHZhbHVlKSAmJiAhaXNBcmd1bWVudHModmFsdWUpKSB8fFxuICAgICAgICAgICAgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY29uc3RydWN0b3InKSAmJiAoQ3RvciA9IHZhbHVlLmNvbnN0cnVjdG9yLCB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmICEoQ3RvciBpbnN0YW5jZW9mIEN0b3IpKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJRSA8IDkgaXRlcmF0ZXMgaW5oZXJpdGVkIHByb3BlcnRpZXMgYmVmb3JlIG93biBwcm9wZXJ0aWVzLiBJZiB0aGUgZmlyc3RcbiAgICAgICAgLy8gaXRlcmF0ZWQgcHJvcGVydHkgaXMgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnR5IHRoZW4gdGhlcmUgYXJlIG5vIGluaGVyaXRlZFxuICAgICAgICAvLyBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmIChzdXBwb3J0Lm93bkxhc3QpIHtcbiAgICAgICAgICAgIGJhc2VGb3JJbih2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICE9PSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbiBtb3N0IGVudmlyb25tZW50cyBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcyBhcmUgaXRlcmF0ZWQgYmVmb3JlXG4gICAgICAgIC8vIGl0cyBpbmhlcml0ZWQgcHJvcGVydGllcy4gSWYgdGhlIGxhc3QgaXRlcmF0ZWQgcHJvcGVydHkgaXMgYW4gb2JqZWN0J3NcbiAgICAgICAgLy8gb3duIHByb3BlcnR5IHRoZW4gdGhlcmUgYXJlIG5vIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICAgIGJhc2VGb3JJbih2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuXG59LHtcIjIwXCI6MjAsXCIzN1wiOjM3LFwiNDFcIjo0MSxcIjQ2XCI6NDYsXCI1OFwiOjU4fV0sNTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuICAgIHZhciBpc09iamVjdExpa2UgPSByZXF1aXJlKDQxKTtcblxuICAgIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbiAgICAvKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICAgICAqIG9mIHZhbHVlcy5cbiAgICAgKi9cbiAgICB2YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaXNTdHJpbmc7XG5cbn0se1wiNDFcIjo0MX1dLDUzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgICB2YXIgaXNMZW5ndGggPSByZXF1aXJlKDQwKSxcbiAgICAgICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSg0MSk7XG5cbiAgICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG4gICAgdmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICAgICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgICAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgICAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICAgICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgICAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgICAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG4gICAgdmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICAgICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuICAgIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbiAgICB2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbiAgICB0eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbiAgICAgICAgdHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxuICAgICAgICAgICAgdHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbiAgICAgICAgICAgICAgICB0eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICAgIHR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbiAgICAgICAgdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxuICAgICAgICAgICAgdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPSB0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPVxuICAgICAgICAgICAgICAgIHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID0gdHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzZXRUYWddID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID0gdHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuICAgIC8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gICAgICogb2YgdmFsdWVzLlxuICAgICAqL1xuICAgIHZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tvYmpUb1N0cmluZy5jYWxsKHZhbHVlKV07XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG5cbn0se1wiNDBcIjo0MCxcIjQxXCI6NDF9XSw1NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gICAgdmFyIGJhc2VDb3B5ID0gcmVxdWlyZSgxNyksXG4gICAgICAgIGtleXNJbiA9IHJlcXVpcmUoNTYpO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlXG4gICAgICogcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VDb3B5KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRvUGxhaW5PYmplY3Q7XG5cbn0se1wiMTdcIjoxNyxcIjU2XCI6NTZ9XSw1NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gICAgdmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoMzIpLFxuICAgICAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoMzYpLFxuICAgICAgICBpc09iamVjdCA9IHJlcXVpcmUoNTApLFxuICAgICAgICBzaGltS2V5cyA9IHJlcXVpcmUoNDIpLFxuICAgICAgICBzdXBwb3J0ID0gcmVxdWlyZSg1OCk7XG5cbiAgICAvKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuICAgIHZhciBuYXRpdmVLZXlzID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2tleXMnKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAgICAgKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5cyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLmtleXMoJ2hpJyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnXVxuICAgICAqL1xuICAgIHZhciBrZXlzID0gIW5hdGl2ZUtleXMgPyBzaGltS2V5cyA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB2YXIgQ3RvciA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgICBpZiAoKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgPT09IG9iamVjdCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygb2JqZWN0ID09ICdmdW5jdGlvbicgPyBzdXBwb3J0LmVudW1Qcm90b3R5cGVzIDogaXNBcnJheUxpa2Uob2JqZWN0KSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzaGltS2V5cyhvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc09iamVjdChvYmplY3QpID8gbmF0aXZlS2V5cyhvYmplY3QpIDogW107XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ga2V5cztcblxufSx7XCIzMlwiOjMyLFwiMzZcIjozNixcIjQyXCI6NDIsXCI1MFwiOjUwLFwiNThcIjo1OH1dLDU2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgICB2YXIgYXJyYXlFYWNoID0gcmVxdWlyZSgxNCksXG4gICAgICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSg0NiksXG4gICAgICAgIGlzQXJyYXkgPSByZXF1aXJlKDQ3KSxcbiAgICAgICAgaXNGdW5jdGlvbiA9IHJlcXVpcmUoNDgpLFxuICAgICAgICBpc0luZGV4ID0gcmVxdWlyZSgzOCksXG4gICAgICAgIGlzTGVuZ3RoID0gcmVxdWlyZSg0MCksXG4gICAgICAgIGlzT2JqZWN0ID0gcmVxdWlyZSg1MCksXG4gICAgICAgIGlzU3RyaW5nID0gcmVxdWlyZSg1MiksXG4gICAgICAgIHN1cHBvcnQgPSByZXF1aXJlKDU4KTtcblxuICAgIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgICAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgICAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJztcblxuICAgIC8qKiBVc2VkIHRvIGZpeCB0aGUgSlNjcmlwdCBgW1tEb250RW51bV1dYCBidWcuICovXG4gICAgdmFyIHNoYWRvd1Byb3BzID0gW1xuICAgICAgICAnY29uc3RydWN0b3InLCAnaGFzT3duUHJvcGVydHknLCAnaXNQcm90b3R5cGVPZicsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICAgICAgICd0b0xvY2FsZVN0cmluZycsICd0b1N0cmluZycsICd2YWx1ZU9mJ1xuICAgIF07XG5cbiAgICAvKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBlcnJvclByb3RvID0gRXJyb3IucHJvdG90eXBlLFxuICAgICAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgIHN0cmluZ1Byb3RvID0gU3RyaW5nLnByb3RvdHlwZTtcblxuICAgIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICAgKiBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgdmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBhdm9pZCBpdGVyYXRpbmcgb3ZlciBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGluIElFIDwgOS4gKi9cbiAgICB2YXIgbm9uRW51bVByb3BzID0ge307XG4gICAgbm9uRW51bVByb3BzW2FycmF5VGFnXSA9IG5vbkVudW1Qcm9wc1tkYXRlVGFnXSA9IG5vbkVudW1Qcm9wc1tudW1iZXJUYWddID0geyAnY29uc3RydWN0b3InOiB0cnVlLCAndG9Mb2NhbGVTdHJpbmcnOiB0cnVlLCAndG9TdHJpbmcnOiB0cnVlLCAndmFsdWVPZic6IHRydWUgfTtcbiAgICBub25FbnVtUHJvcHNbYm9vbFRhZ10gPSBub25FbnVtUHJvcHNbc3RyaW5nVGFnXSA9IHsgJ2NvbnN0cnVjdG9yJzogdHJ1ZSwgJ3RvU3RyaW5nJzogdHJ1ZSwgJ3ZhbHVlT2YnOiB0cnVlIH07XG4gICAgbm9uRW51bVByb3BzW2Vycm9yVGFnXSA9IG5vbkVudW1Qcm9wc1tmdW5jVGFnXSA9IG5vbkVudW1Qcm9wc1tyZWdleHBUYWddID0geyAnY29uc3RydWN0b3InOiB0cnVlLCAndG9TdHJpbmcnOiB0cnVlIH07XG4gICAgbm9uRW51bVByb3BzW29iamVjdFRhZ10gPSB7ICdjb25zdHJ1Y3Rvcic6IHRydWUgfTtcblxuICAgIGFycmF5RWFjaChzaGFkb3dQcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGZvciAodmFyIHRhZyBpbiBub25FbnVtUHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG5vbkVudW1Qcm9wcywgdGFnKSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wcyA9IG5vbkVudW1Qcm9wc1t0YWddO1xuICAgICAgICAgICAgICAgIHByb3BzW2tleV0gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmtleXNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7XG5cbiAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmXG4gICAgICAgICAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkgfHwgaXNTdHJpbmcob2JqZWN0KSkgJiYgbGVuZ3RoKSB8fCAwO1xuXG4gICAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIHByb3RvID0gKGlzRnVuY3Rpb24oQ3RvcikgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvLFxuICAgICAgICAgICAgaXNQcm90byA9IHByb3RvID09PSBvYmplY3QsXG4gICAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgICAgc2tpcEluZGV4ZXMgPSBsZW5ndGggPiAwLFxuICAgICAgICAgICAgc2tpcEVycm9yUHJvcHMgPSBzdXBwb3J0LmVudW1FcnJvclByb3BzICYmIChvYmplY3QgPT09IGVycm9yUHJvdG8gfHwgb2JqZWN0IGluc3RhbmNlb2YgRXJyb3IpLFxuICAgICAgICAgICAgc2tpcFByb3RvID0gc3VwcG9ydC5lbnVtUHJvdG90eXBlcyAmJiBpc0Z1bmN0aW9uKG9iamVjdCk7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSAoaW5kZXggKyAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9kYXNoIHNraXBzIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHdoZW4gaXQgaW5mZXJzIGl0IGlzIGl0ZXJhdGluZ1xuICAgICAgICAvLyBvdmVyIGEgYHByb3RvdHlwZWAgb2JqZWN0IGJlY2F1c2UgSUUgPCA5IGNhbid0IHNldCB0aGUgYFtbRW51bWVyYWJsZV1dYFxuICAgICAgICAvLyBhdHRyaWJ1dGUgb2YgYW4gZXhpc3RpbmcgcHJvcGVydHkgYW5kIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IG9mIGFcbiAgICAgICAgLy8gcHJvdG90eXBlIGRlZmF1bHRzIHRvIG5vbi1lbnVtZXJhYmxlLlxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoIShza2lwUHJvdG8gJiYga2V5ID09ICdwcm90b3R5cGUnKSAmJlxuICAgICAgICAgICAgICAgICEoc2tpcEVycm9yUHJvcHMgJiYgKGtleSA9PSAnbWVzc2FnZScgfHwga2V5ID09ICduYW1lJykpICYmXG4gICAgICAgICAgICAgICAgIShza2lwSW5kZXhlcyAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSkgJiZcbiAgICAgICAgICAgICAgICAhKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VwcG9ydC5ub25FbnVtU2hhZG93cyAmJiBvYmplY3QgIT09IG9iamVjdFByb3RvKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gb2JqZWN0ID09PSBzdHJpbmdQcm90byA/IHN0cmluZ1RhZyA6IChvYmplY3QgPT09IGVycm9yUHJvdG8gPyBlcnJvclRhZyA6IG9ialRvU3RyaW5nLmNhbGwob2JqZWN0KSksXG4gICAgICAgICAgICAgICAgbm9uRW51bXMgPSBub25FbnVtUHJvcHNbdGFnXSB8fCBub25FbnVtUHJvcHNbb2JqZWN0VGFnXTtcblxuICAgICAgICAgICAgaWYgKHRhZyA9PSBvYmplY3RUYWcpIHtcbiAgICAgICAgICAgICAgICBwcm90byA9IG9iamVjdFByb3RvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVuZ3RoID0gc2hhZG93UHJvcHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gc2hhZG93UHJvcHNbbGVuZ3RoXTtcbiAgICAgICAgICAgICAgICB2YXIgbm9uRW51bSA9IG5vbkVudW1zW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKCEoaXNQcm90byAmJiBub25FbnVtKSAmJlxuICAgICAgICAgICAgICAgICAgICAobm9uRW51bSA/IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpIDogb2JqZWN0W2tleV0gIT09IHByb3RvW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBrZXlzSW47XG5cbn0se1wiMTRcIjoxNCxcIjM4XCI6MzgsXCI0MFwiOjQwLFwiNDZcIjo0NixcIjQ3XCI6NDcsXCI0OFwiOjQ4LFwiNTBcIjo1MCxcIjUyXCI6NTIsXCI1OFwiOjU4fV0sNTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuICAgIHZhciBiYXNlTWVyZ2UgPSByZXF1aXJlKDIyKSxcbiAgICAgICAgY3JlYXRlQXNzaWduZXIgPSByZXF1aXJlKDI3KTtcblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0KHMpLCB0aGF0XG4gICAgICogZG9uJ3QgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlc1xuICAgICAqIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLiBJZiBgY3VzdG9taXplcmAgaXNcbiAgICAgKiBwcm92aWRlZCBpdCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZFxuICAgICAqIHNvdXJjZSBwcm9wZXJ0aWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCBtZXJnaW5nIGlzIGhhbmRsZWRcbiAgICAgKiBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCBmaXZlIGFyZ3VtZW50czogKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAqICAgJ2RhdGEnOiBbeyAndXNlcic6ICdiYXJuZXknIH0sIHsgJ3VzZXInOiAnZnJlZCcgfV1cbiAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgYWdlcyA9IHtcbiAqICAgJ2RhdGEnOiBbeyAnYWdlJzogMzYgfSwgeyAnYWdlJzogNDAgfV1cbiAqIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlKHVzZXJzLCBhZ2VzKTtcbiAgICAgKiAvLyA9PiB7ICdkYXRhJzogW3sgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sIHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XSB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICogICAnZnJ1aXRzJzogWydhcHBsZSddLFxuICogICAndmVnZXRhYmxlcyc6IFsnYmVldCddXG4gKiB9O1xuICAgICAqXG4gICAgICogdmFyIG90aGVyID0ge1xuICogICAnZnJ1aXRzJzogWydiYW5hbmEnXSxcbiAqICAgJ3ZlZ2V0YWJsZXMnOiBbJ2NhcnJvdCddXG4gKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZShvYmplY3QsIG90aGVyLCBmdW5jdGlvbihhLCBiKSB7XG4gKiAgIGlmIChfLmlzQXJyYXkoYSkpIHtcbiAqICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gKiAgIH1cbiAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2ZydWl0cyc6IFsnYXBwbGUnLCAnYmFuYW5hJ10sICd2ZWdldGFibGVzJzogWydiZWV0JywgJ2NhcnJvdCddIH1cbiAgICAgKi9cbiAgICB2YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihiYXNlTWVyZ2UpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtZXJnZTtcblxufSx7XCIyMlwiOjIyLFwiMjdcIjoyN31dLDU4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgICAvKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgICAgICBlcnJvclByb3RvID0gRXJyb3IucHJvdG90eXBlLFxuICAgICAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAvKiogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgICAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBlbnZpcm9ubWVudCBmZWF0dXJlIGZsYWdzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgdmFyIHN1cHBvcnQgPSB7fTtcblxuICAgIChmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciBDdG9yID0gZnVuY3Rpb24oKSB7IHRoaXMueCA9IHg7IH0sXG4gICAgICAgICAgICBvYmplY3QgPSB7ICcwJzogeCwgJ2xlbmd0aCc6IHggfSxcbiAgICAgICAgICAgIHByb3BzID0gW107XG5cbiAgICAgICAgQ3Rvci5wcm90b3R5cGUgPSB7ICd2YWx1ZU9mJzogeCwgJ3knOiB4IH07XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBuZXcgQ3RvcikgeyBwcm9wcy5wdXNoKGtleSk7IH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZWN0IGlmIGBuYW1lYCBvciBgbWVzc2FnZWAgcHJvcGVydGllcyBvZiBgRXJyb3IucHJvdG90eXBlYCBhcmVcbiAgICAgICAgICogZW51bWVyYWJsZSBieSBkZWZhdWx0IChJRSA8IDksIFNhZmFyaSA8IDUuMSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgc3VwcG9ydC5lbnVtRXJyb3JQcm9wcyA9IHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZXJyb3JQcm90bywgJ21lc3NhZ2UnKSB8fFxuICAgICAgICAgICAgcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlcnJvclByb3RvLCAnbmFtZScpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlY3QgaWYgYHByb3RvdHlwZWAgcHJvcGVydGllcyBhcmUgZW51bWVyYWJsZSBieSBkZWZhdWx0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBGaXJlZm94IDwgMy42LCBPcGVyYSA+IDkuNTAgLSBPcGVyYSA8IDExLjYwLCBhbmQgU2FmYXJpIDwgNS4xXG4gICAgICAgICAqIChpZiB0aGUgcHJvdG90eXBlIG9yIGEgcHJvcGVydHkgb24gdGhlIHByb3RvdHlwZSBoYXMgYmVlbiBzZXQpXG4gICAgICAgICAqIGluY29ycmVjdGx5IHNldCB0aGUgYFtbRW51bWVyYWJsZV1dYCB2YWx1ZSBvZiBhIGZ1bmN0aW9uJ3MgYHByb3RvdHlwZWBcbiAgICAgICAgICogcHJvcGVydHkgdG8gYHRydWVgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIHN1cHBvcnQuZW51bVByb3RvdHlwZXMgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKEN0b3IsICdwcm90b3R5cGUnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZWN0IGlmIHByb3BlcnRpZXMgc2hhZG93aW5nIHRob3NlIG9uIGBPYmplY3QucHJvdG90eXBlYCBhcmUgbm9uLWVudW1lcmFibGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEluIElFIDwgOSBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcywgc2hhZG93aW5nIG5vbi1lbnVtZXJhYmxlIG9uZXMsXG4gICAgICAgICAqIGFyZSBtYWRlIG5vbi1lbnVtZXJhYmxlIGFzIHdlbGwgKGEuay5hIHRoZSBKU2NyaXB0IGBbW0RvbnRFbnVtXV1gIGJ1ZykuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgc3VwcG9ydC5ub25FbnVtU2hhZG93cyA9ICEvdmFsdWVPZi8udGVzdChwcm9wcyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVjdCBpZiBvd24gcHJvcGVydGllcyBhcmUgaXRlcmF0ZWQgYWZ0ZXIgaW5oZXJpdGVkIHByb3BlcnRpZXMgKElFIDwgOSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgc3VwcG9ydC5vd25MYXN0ID0gcHJvcHNbMF0gIT0gJ3gnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlY3QgaWYgYEFycmF5I3NoaWZ0YCBhbmQgYEFycmF5I3NwbGljZWAgYXVnbWVudCBhcnJheS1saWtlIG9iamVjdHNcbiAgICAgICAgICogY29ycmVjdGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBGaXJlZm94IDwgMTAsIGNvbXBhdGliaWxpdHkgbW9kZXMgb2YgSUUgOCwgYW5kIElFIDwgOSBoYXZlIGJ1Z2d5IEFycmF5XG4gICAgICAgICAqIGBzaGlmdCgpYCBhbmQgYHNwbGljZSgpYCBmdW5jdGlvbnMgdGhhdCBmYWlsIHRvIHJlbW92ZSB0aGUgbGFzdCBlbGVtZW50LFxuICAgICAgICAgKiBgdmFsdWVbMF1gLCBvZiBhcnJheS1saWtlIG9iamVjdHMgZXZlbiB0aG91Z2ggdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgaXNcbiAgICAgICAgICogc2V0IHRvIGAwYC4gVGhlIGBzaGlmdCgpYCBtZXRob2QgaXMgYnVnZ3kgaW4gY29tcGF0aWJpbGl0eSBtb2RlcyBvZiBJRSA4LFxuICAgICAgICAgKiB3aGlsZSBgc3BsaWNlKClgIGlzIGJ1Z2d5IHJlZ2FyZGxlc3Mgb2YgbW9kZSBpbiBJRSA8IDkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgc3VwcG9ydC5zcGxpY2VPYmplY3RzID0gKHNwbGljZS5jYWxsKG9iamVjdCwgMCwgMSksICFvYmplY3RbMF0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlY3QgbGFjayBvZiBzdXBwb3J0IGZvciBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgYnkgaW5kZXguXG4gICAgICAgICAqXG4gICAgICAgICAqIElFIDwgOCBjYW4ndCBhY2Nlc3MgY2hhcmFjdGVycyBieSBpbmRleC4gSUUgOCBjYW4gb25seSBhY2Nlc3MgY2hhcmFjdGVyc1xuICAgICAgICAgKiBieSBpbmRleCBvbiBzdHJpbmcgbGl0ZXJhbHMsIG5vdCBzdHJpbmcgb2JqZWN0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBzdXBwb3J0LnVuaW5kZXhlZENoYXJzID0gKCd4J1swXSArIE9iamVjdCgneCcpWzBdKSAhPSAneHgnO1xuICAgIH0oMSwgMCkpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0O1xuXG59LHt9XSw1OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgcHJvdmlkZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiBfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG5cbn0se31dLDYwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgICAoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBBbGdvbGlhU2VhcmNoO1xuXG4vLyBkZWZhdWx0IGRlYnVnIGFjdGl2YXRlZCBpbiBkZXYgZW52aXJvbm1lbnRzXG4vLyB0aGlzIGlzIHRyaWdnZXJlZCBpbiBwYWNrYWdlLmpzb24sIHVzaW5nIHRoZSBlbnZpZnkgdHJhbnNmb3JtXG4gICAgICAgIGlmIChcInByb2R1Y3Rpb25cIiA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgcmVxdWlyZSg2KS5lbmFibGUoJ2FsZ29saWFzZWFyY2gqJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXJyb3JzID0gcmVxdWlyZSg2Nik7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogQWxnb2xpYSBTZWFyY2ggbGlicmFyeSBpbml0aWFsaXphdGlvblxuICAgICAgICAgKiBodHRwczovL3d3dy5hbGdvbGlhLmNvbS9cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFwcGxpY2F0aW9uSUQgLSBZb3VyIGFwcGxpY2F0aW9uSUQsIGZvdW5kIGluIHlvdXIgZGFzaGJvYXJkXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcGlLZXkgLSBZb3VyIEFQSSBrZXksIGZvdW5kIGluIHlvdXIgZGFzaGJvYXJkXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRpbWVvdXQ9MjAwMF0gLSBUaGUgcmVxdWVzdCB0aW1lb3V0IHNldCBpbiBtaWxsaXNlY29uZHMsXG4gICAgICAgICAqIGFub3RoZXIgcmVxdWVzdCB3aWxsIGJlIGlzc3VlZCBhZnRlciB0aGlzIHRpbWVvdXRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnByb3RvY29sPSdodHRwOiddIC0gVGhlIHByb3RvY29sIHVzZWQgdG8gcXVlcnkgQWxnb2xpYSBTZWFyY2ggQVBJLlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXQgdG8gJ2h0dHBzOicgdG8gZm9yY2UgdXNpbmcgaHR0cHMuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdG8gZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2wgaW4gYnJvd3NlcnNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IFtvcHRzLmhvc3RzPXtcbiAgICAgICAgICogICAgICAgICAgIHJlYWQ6IFt0aGlzLmFwcGxpY2F0aW9uSUQgKyAnLWRzbi5hbGdvbGlhLm5ldCddLmNvbmNhdChbXG4gICAgICAgICAqICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25JRCArICctMS5hbGdvbGlhbmV0LmNvbScsXG4gICAgICAgICAqICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25JRCArICctMi5hbGdvbGlhbmV0LmNvbScsXG4gICAgICAgICAqICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25JRCArICctMy5hbGdvbGlhbmV0LmNvbSddXG4gICAgICAgICAqICAgICAgICAgICBdKSxcbiAgICAgICAgICogICAgICAgICAgIHdyaXRlOiBbdGhpcy5hcHBsaWNhdGlvbklEICsgJy5hbGdvbGlhLm5ldCddLmNvbmNhdChbXG4gICAgICAgICAqICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25JRCArICctMS5hbGdvbGlhbmV0LmNvbScsXG4gICAgICAgICAqICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25JRCArICctMi5hbGdvbGlhbmV0LmNvbScsXG4gICAgICAgICAqICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25JRCArICctMy5hbGdvbGlhbmV0LmNvbSddXG4gICAgICAgICAqICAgICAgICAgICBdKSAtIFRoZSBob3N0cyB0byB1c2UgZm9yIEFsZ29saWEgU2VhcmNoIEFQSS5cbiAgICAgICAgICogICAgICAgICAgIElmIHlvdSBwcm92aWRlIHRoZW0sIHlvdSB3aWxsIGxlc3MgYmVuZWZpdCBmcm9tIG91ciBIQSBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQWxnb2xpYVNlYXJjaChhcHBsaWNhdGlvbklELCBhcGlLZXksIG9wdHMpIHtcbiAgICAgICAgICAgIHZhciBkZWJ1ZyA9IHJlcXVpcmUoNikoJ2FsZ29saWFzZWFyY2gnKTtcblxuICAgICAgICAgICAgdmFyIGNsb25lID0gcmVxdWlyZSg0NCk7XG4gICAgICAgICAgICB2YXIgaXNBcnJheSA9IHJlcXVpcmUoNDcpO1xuXG4gICAgICAgICAgICB2YXIgdXNhZ2UgPSAnVXNhZ2U6IGFsZ29saWFzZWFyY2goYXBwbGljYXRpb25JRCwgYXBpS2V5LCBvcHRzKSc7XG5cbiAgICAgICAgICAgIGlmICghYXBwbGljYXRpb25JRCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuQWxnb2xpYVNlYXJjaEVycm9yKCdQbGVhc2UgcHJvdmlkZSBhbiBhcHBsaWNhdGlvbiBJRC4gJyArIHVzYWdlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFhcGlLZXkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkFsZ29saWFTZWFyY2hFcnJvcignUGxlYXNlIHByb3ZpZGUgYW4gQVBJIGtleS4gJyArIHVzYWdlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbklEID0gYXBwbGljYXRpb25JRDtcbiAgICAgICAgICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xuXG4gICAgICAgICAgICB2YXIgZGVmYXVsdEhvc3RzID0gW1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25JRCArICctMS5hbGdvbGlhbmV0LmNvbScsXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbklEICsgJy0yLmFsZ29saWFuZXQuY29tJyxcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uSUQgKyAnLTMuYWxnb2xpYW5ldC5jb20nXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdGhpcy5ob3N0cyA9IHtcbiAgICAgICAgICAgICAgICByZWFkOiBbXSxcbiAgICAgICAgICAgICAgICB3cml0ZTogW11cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuaG9zdEluZGV4ID0ge1xuICAgICAgICAgICAgICAgIHJlYWQ6IDAsXG4gICAgICAgICAgICAgICAgd3JpdGU6IDBcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgICAgICAgICB2YXIgcHJvdG9jb2wgPSBvcHRzLnByb3RvY29sIHx8ICdodHRwczonO1xuICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSBvcHRzLnRpbWVvdXQgPT09IHVuZGVmaW5lZCA/IDIwMDAgOiBvcHRzLnRpbWVvdXQ7XG5cbiAgICAgICAgICAgIC8vIHdoaWxlIHdlIGFkdm9jYXRlIGZvciBjb2xvbi1hdC10aGUtZW5kIHZhbHVlczogJ2h0dHA6JyBmb3IgYG9wdHMucHJvdG9jb2xgXG4gICAgICAgICAgICAvLyB3ZSBhbHNvIGFjY2VwdCBgaHR0cGAgYW5kIGBodHRwc2AuIEl0J3MgYSBjb21tb24gZXJyb3IuXG4gICAgICAgICAgICBpZiAoIS86JC8udGVzdChwcm90b2NvbCkpIHtcbiAgICAgICAgICAgICAgICBwcm90b2NvbCA9IHByb3RvY29sICsgJzonO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0cy5wcm90b2NvbCAhPT0gJ2h0dHA6JyAmJiBvcHRzLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuQWxnb2xpYVNlYXJjaEVycm9yKCdwcm90b2NvbCBtdXN0IGJlIGBodHRwOmAgb3IgYGh0dHBzOmAgKHdhcyBgJyArIG9wdHMucHJvdG9jb2wgKyAnYCknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm8gaG9zdHMgZ2l2ZW4sIGFkZCBkZWZhdWx0c1xuICAgICAgICAgICAgaWYgKCFvcHRzLmhvc3RzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0cy5yZWFkID0gW3RoaXMuYXBwbGljYXRpb25JRCArICctZHNuLmFsZ29saWEubmV0J10uY29uY2F0KGRlZmF1bHRIb3N0cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0cy53cml0ZSA9IFt0aGlzLmFwcGxpY2F0aW9uSUQgKyAnLmFsZ29saWEubmV0J10uY29uY2F0KGRlZmF1bHRIb3N0cyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkob3B0cy5ob3N0cykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhvc3RzLnJlYWQgPSBjbG9uZShvcHRzLmhvc3RzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhvc3RzLndyaXRlID0gY2xvbmUob3B0cy5ob3N0cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaG9zdHMucmVhZCA9IGNsb25lKG9wdHMuaG9zdHMucmVhZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0cy53cml0ZSA9IGNsb25lKG9wdHMuaG9zdHMud3JpdGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhZGQgcHJvdG9jb2wgYW5kIGxvd2VyY2FzZSBob3N0c1xuICAgICAgICAgICAgdGhpcy5ob3N0cy5yZWFkID0gbWFwKHRoaXMuaG9zdHMucmVhZCwgcHJlcGFyZUhvc3QocHJvdG9jb2wpKTtcbiAgICAgICAgICAgIHRoaXMuaG9zdHMud3JpdGUgPSBtYXAodGhpcy5ob3N0cy53cml0ZSwgcHJlcGFyZUhvc3QocHJvdG9jb2wpKTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSB0aW1lb3V0O1xuXG4gICAgICAgICAgICB0aGlzLmV4dHJhSGVhZGVycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuXG4gICAgICAgICAgICB0aGlzLl91YSA9IG9wdHMuX3VhO1xuICAgICAgICAgICAgdGhpcy5fdXNlQ2FjaGUgPSBvcHRzLl91c2VDYWNoZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdHMuX3VzZUNhY2hlO1xuXG4gICAgICAgICAgICB0aGlzLl9zZXRUaW1lb3V0ID0gb3B0cy5fc2V0VGltZW91dDtcblxuICAgICAgICAgICAgZGVidWcoJ2luaXQgZG9uZSwgJWonLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEFsZ29saWFTZWFyY2gucHJvdG90eXBlID0ge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIERlbGV0ZSBhbiBpbmRleFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBpbmRleE5hbWUgdGhlIG5hbWUgb2YgaW5kZXggdG8gZGVsZXRlXG4gICAgICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4gICAgICAgICAgICAgKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICAgICAgICAgICAgICogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgY29udGFpbnMgdGhlIHRhc2sgSURcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZGVsZXRlSW5kZXg6IGZ1bmN0aW9uKGluZGV4TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fanNvblJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgICAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhOYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTW92ZSBhbiBleGlzdGluZyBpbmRleC5cbiAgICAgICAgICAgICAqIEBwYXJhbSBzcmNJbmRleE5hbWUgdGhlIG5hbWUgb2YgaW5kZXggdG8gY29weS5cbiAgICAgICAgICAgICAqIEBwYXJhbSBkc3RJbmRleE5hbWUgdGhlIG5ldyBpbmRleCBuYW1lIHRoYXQgd2lsbCBjb250YWlucyBhIGNvcHkgb2ZcbiAgICAgICAgICAgICAqIHNyY0luZGV4TmFtZSAoZGVzdGluYXRpb24gd2lsbCBiZSBvdmVycml0ZW4gaWYgaXQgYWxyZWFkeSBleGlzdCkuXG4gICAgICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4gICAgICAgICAgICAgKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICAgICAgICAgICAgICogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgY29udGFpbnMgdGhlIHRhc2sgSURcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbW92ZUluZGV4OiBmdW5jdGlvbihzcmNJbmRleE5hbWUsIGRzdEluZGV4TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zdE9iaiA9IHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiAnbW92ZScsIGRlc3RpbmF0aW9uOiBkc3RJbmRleE5hbWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9qc29uUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoc3JjSW5kZXhOYW1lKSArICcvb3BlcmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogcG9zdE9iaixcbiAgICAgICAgICAgICAgICAgICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29weSBhbiBleGlzdGluZyBpbmRleC5cbiAgICAgICAgICAgICAqIEBwYXJhbSBzcmNJbmRleE5hbWUgdGhlIG5hbWUgb2YgaW5kZXggdG8gY29weS5cbiAgICAgICAgICAgICAqIEBwYXJhbSBkc3RJbmRleE5hbWUgdGhlIG5ldyBpbmRleCBuYW1lIHRoYXQgd2lsbCBjb250YWlucyBhIGNvcHlcbiAgICAgICAgICAgICAqIG9mIHNyY0luZGV4TmFtZSAoZGVzdGluYXRpb24gd2lsbCBiZSBvdmVycml0ZW4gaWYgaXQgYWxyZWFkeSBleGlzdCkuXG4gICAgICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4gICAgICAgICAgICAgKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICAgICAgICAgICAgICogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgY29udGFpbnMgdGhlIHRhc2sgSURcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29weUluZGV4OiBmdW5jdGlvbihzcmNJbmRleE5hbWUsIGRzdEluZGV4TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zdE9iaiA9IHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiAnY29weScsIGRlc3RpbmF0aW9uOiBkc3RJbmRleE5hbWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9qc29uUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoc3JjSW5kZXhOYW1lKSArICcvb3BlcmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogcG9zdE9iaixcbiAgICAgICAgICAgICAgICAgICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJuIGxhc3QgbG9nIGVudHJpZXMuXG4gICAgICAgICAgICAgKiBAcGFyYW0gb2Zmc2V0IFNwZWNpZnkgdGhlIGZpcnN0IGVudHJ5IHRvIHJldHJpZXZlICgwLWJhc2VkLCAwIGlzIHRoZSBtb3N0IHJlY2VudCBsb2cgZW50cnkpLlxuICAgICAgICAgICAgICogQHBhcmFtIGxlbmd0aCBTcGVjaWZ5IHRoZSBtYXhpbXVtIG51bWJlciBvZiBlbnRyaWVzIHRvIHJldHJpZXZlIHN0YXJ0aW5nXG4gICAgICAgICAgICAgKiBhdCBvZmZzZXQuIE1heGltdW0gYWxsb3dlZCB2YWx1ZTogMTAwMC5cbiAgICAgICAgICAgICAqIEBwYXJhbSBjYWxsYmFjayB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiAgICAgICAgICAgICAqICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4gICAgICAgICAgICAgKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCBjb250YWlucyB0aGUgdGFzayBJRFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRMb2dzOiBmdW5jdGlvbihvZmZzZXQsIGxlbmd0aCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldExvZ3MoW2NiXSlcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IDEwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCB0eXBlb2YgbGVuZ3RoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldExvZ3MoMSwgW2NiKV1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBsZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IDEwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9qc29uUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgIHVybDogJy8xL2xvZ3M/b2Zmc2V0PScgKyBvZmZzZXQgKyAnJmxlbmd0aD0nICsgbGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogTGlzdCBhbGwgZXhpc3RpbmcgaW5kZXhlcyAocGFnaW5hdGVkKVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBwYWdlIFRoZSBwYWdlIHRvIHJldHJpZXZlLCBzdGFydGluZyBhdCAwLlxuICAgICAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuICAgICAgICAgICAgICogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiAgICAgICAgICAgICAqICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB3aXRoIGluZGV4IGxpc3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGlzdEluZGV4ZXM6IGZ1bmN0aW9uKHBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9ICcnO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhZ2UgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgcGFnZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHBhZ2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gJz9wYWdlPScgKyBwYWdlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9qc29uUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgIHVybDogJy8xL2luZGV4ZXMnICsgcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBHZXQgdGhlIGluZGV4IG9iamVjdCBpbml0aWFsaXplZFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBpbmRleE5hbWUgdGhlIG5hbWUgb2YgaW5kZXhcbiAgICAgICAgICAgICAqIEBwYXJhbSBjYWxsYmFjayB0aGUgcmVzdWx0IGNhbGxiYWNrIHdpdGggb25lIGFyZ3VtZW50ICh0aGUgSW5kZXggaW5zdGFuY2UpXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGluaXRJbmRleDogZnVuY3Rpb24oaW5kZXhOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkluZGV4KHRoaXMsIGluZGV4TmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIExpc3QgYWxsIGV4aXN0aW5nIHVzZXIga2V5cyB3aXRoIHRoZWlyIGFzc29jaWF0ZWQgQUNMc1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBjYWxsYmFjayB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiAgICAgICAgICAgICAqICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4gICAgICAgICAgICAgKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgd2l0aCB1c2VyIGtleXMgbGlzdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsaXN0VXNlcktleXM6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pzb25SZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAnLzEva2V5cycsXG4gICAgICAgICAgICAgICAgICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBHZXQgQUNMIG9mIGEgdXNlciBrZXlcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ga2V5XG4gICAgICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4gICAgICAgICAgICAgKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICAgICAgICAgICAgICogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHdpdGggdXNlciBrZXlzIGxpc3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0VXNlcktleUFDTDogZnVuY3Rpb24oa2V5LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9qc29uUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgIHVybDogJy8xL2tleXMvJyArIGtleSxcbiAgICAgICAgICAgICAgICAgICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIERlbGV0ZSBhbiBleGlzdGluZyB1c2VyIGtleVxuICAgICAgICAgICAgICogQHBhcmFtIGtleVxuICAgICAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuICAgICAgICAgICAgICogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiAgICAgICAgICAgICAqICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB3aXRoIHVzZXIga2V5cyBsaXN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRlbGV0ZVVzZXJLZXk6IGZ1bmN0aW9uKGtleSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fanNvblJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgICAgICB1cmw6ICcvMS9rZXlzLycgKyBrZXksXG4gICAgICAgICAgICAgICAgICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogQWRkIGEgbmV3IGdsb2JhbCBBUEkga2V5XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmdbXX0gYWNscyAtIFRoZSBsaXN0IG9mIEFDTCBmb3IgdGhpcyBrZXkuIERlZmluZWQgYnkgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0XG4gICAgICAgICAgICAgKiAgIGNhbiBjb250YWlucyB0aGUgZm9sbG93aW5nIHZhbHVlczpcbiAgICAgICAgICAgICAqICAgICAtIHNlYXJjaDogYWxsb3cgdG8gc2VhcmNoIChodHRwcyBhbmQgaHR0cClcbiAgICAgICAgICAgICAqICAgICAtIGFkZE9iamVjdDogYWxsb3dzIHRvIGFkZC91cGRhdGUgYW4gb2JqZWN0IGluIHRoZSBpbmRleCAoaHR0cHMgb25seSlcbiAgICAgICAgICAgICAqICAgICAtIGRlbGV0ZU9iamVjdCA6IGFsbG93cyB0byBkZWxldGUgYW4gZXhpc3Rpbmcgb2JqZWN0IChodHRwcyBvbmx5KVxuICAgICAgICAgICAgICogICAgIC0gZGVsZXRlSW5kZXggOiBhbGxvd3MgdG8gZGVsZXRlIGluZGV4IGNvbnRlbnQgKGh0dHBzIG9ubHkpXG4gICAgICAgICAgICAgKiAgICAgLSBzZXR0aW5ncyA6IGFsbG93cyB0byBnZXQgaW5kZXggc2V0dGluZ3MgKGh0dHBzIG9ubHkpXG4gICAgICAgICAgICAgKiAgICAgLSBlZGl0U2V0dGluZ3MgOiBhbGxvd3MgdG8gY2hhbmdlIGluZGV4IHNldHRpbmdzIChodHRwcyBvbmx5KVxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gT3B0aW9ubmFsIHBhcmFtZXRlcnMgdG8gc2V0IGZvciB0aGUga2V5XG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnZhbGlkaXR5IC0gTnVtYmVyIG9mIHNlY29uZHMgYWZ0ZXIgd2hpY2ggdGhlIGtleSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCAoMCBtZWFucyBubyB0aW1lIGxpbWl0IGZvciB0aGlzIGtleSlcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubWF4UXVlcmllc1BlcklQUGVySG91ciAtIE51bWJlciBvZiBBUEkgY2FsbHMgYWxsb3dlZCBmcm9tIGFuIElQIGFkZHJlc3MgcGVyIGhvdXJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubWF4SGl0c1BlclF1ZXJ5IC0gTnVtYmVyIG9mIGhpdHMgdGhpcyBBUEkga2V5IGNhbiByZXRyaWV2ZSBpbiBvbmUgY2FsbFxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zLmluZGV4ZXMgLSBBbGxvd2VkIHRhcmdldGVkIGluZGV4ZXMgZm9yIHRoaXMga2V5XG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmRlc2NyaXB0aW9uIC0gQSBkZXNjcmlwdGlvbiBmb3IgeW91ciBrZXlcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcy5yZWZlcmVycyAtIEEgbGlzdCBvZiBhdXRob3JpemVkIHJlZmVyZXJzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zLnF1ZXJ5UGFyYW1ldGVycyAtIEZvcmNlIHRoZSBrZXkgdG8gdXNlIHNwZWNpZmljIHF1ZXJ5IHBhcmFtZXRlcnNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4gICAgICAgICAgICAgKiAgIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiAgICAgICAgICAgICAqICAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgd2l0aCB1c2VyIGtleXMgbGlzdFxuICAgICAgICAgICAgICogQHJldHVybiB7UHJvbWlzZXx1bmRlZmluZWR9IFJldHVybnMgYSBwcm9taXNlIGlmIG5vIGNhbGxiYWNrIGdpdmVuXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogY2xpZW50LmFkZFVzZXJLZXkoWydzZWFyY2gnXSwge1xuICAgICAgICAgICAgICogICB2YWxpZGl0eTogMzAwLFxuICAgICAgICAgICAgICogICBtYXhRdWVyaWVzUGVySVBQZXJIb3VyOiAyMDAwLFxuICAgICAgICAgICAgICogICBtYXhIaXRzUGVyUXVlcnk6IDMsXG4gICAgICAgICAgICAgKiAgIGluZGV4ZXM6IFsnZnJ1aXRzJ10sXG4gICAgICAgICAgICAgKiAgIGRlc2NyaXB0aW9uOiAnRWF0IHRocmVlIGZydWl0cycsXG4gICAgICAgICAgICAgKiAgIHJlZmVyZXJzOiBbJyouYWxnb2xpYS5jb20nXSxcbiAgICAgICAgICAgICAqICAgcXVlcnlQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgKiAgICAgdGFnRmlsdGVyczogWydwdWJsaWMnXSxcbiAgICAgICAgICAgICAqICAgfVxuICAgICAgICAgICAgICogfSlcbiAgICAgICAgICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFsZ29saWEuY29tL2RvYy9yZXN0X2FwaSNBZGRLZXl8QWxnb2xpYSBSRVNUIEFQSSBEb2N1bWVudGF0aW9ufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhZGRVc2VyS2V5OiBmdW5jdGlvbihhY2xzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgdHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcG9zdE9iaiA9IHtcbiAgICAgICAgICAgICAgICAgICAgYWNsOiBhY2xzXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zdE9iai52YWxpZGl0eSA9IHBhcmFtcy52YWxpZGl0eTtcbiAgICAgICAgICAgICAgICAgICAgcG9zdE9iai5tYXhRdWVyaWVzUGVySVBQZXJIb3VyID0gcGFyYW1zLm1heFF1ZXJpZXNQZXJJUFBlckhvdXI7XG4gICAgICAgICAgICAgICAgICAgIHBvc3RPYmoubWF4SGl0c1BlclF1ZXJ5ID0gcGFyYW1zLm1heEhpdHNQZXJRdWVyeTtcbiAgICAgICAgICAgICAgICAgICAgcG9zdE9iai5pbmRleGVzID0gcGFyYW1zLmluZGV4ZXM7XG4gICAgICAgICAgICAgICAgICAgIHBvc3RPYmouZGVzY3JpcHRpb24gPSBwYXJhbXMuZGVzY3JpcHRpb247XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5xdWVyeVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RPYmoucXVlcnlQYXJhbWV0ZXJzID0gdGhpcy5fZ2V0U2VhcmNoUGFyYW1zKHBhcmFtcy5xdWVyeVBhcmFtZXRlcnMsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBvc3RPYmoucmVmZXJlcnMgPSBwYXJhbXMucmVmZXJlcnM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pzb25SZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgIHVybDogJy8xL2tleXMnLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBwb3N0T2JqLFxuICAgICAgICAgICAgICAgICAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBZGQgYSBuZXcgZ2xvYmFsIEFQSSBrZXlcbiAgICAgICAgICAgICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgY2xpZW50LmFkZFVzZXJLZXkoKVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhZGRVc2VyS2V5V2l0aFZhbGlkaXR5OiBkZXByZWNhdGUoZnVuY3Rpb24oYWNscywgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZFVzZXJLZXkoYWNscywgcGFyYW1zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LCBkZXByZWNhdGVkTWVzc2FnZSgnY2xpZW50LmFkZFVzZXJLZXlXaXRoVmFsaWRpdHkoKScsICdjbGllbnQuYWRkVXNlcktleSgpJykpLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVwZGF0ZSBhbiBleGlzdGluZyBBUEkga2V5XG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSB0byB1cGRhdGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGFjbHMgLSBUaGUgbGlzdCBvZiBBQ0wgZm9yIHRoaXMga2V5LiBEZWZpbmVkIGJ5IGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdFxuICAgICAgICAgICAgICogICBjYW4gY29udGFpbnMgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4gICAgICAgICAgICAgKiAgICAgLSBzZWFyY2g6IGFsbG93IHRvIHNlYXJjaCAoaHR0cHMgYW5kIGh0dHApXG4gICAgICAgICAgICAgKiAgICAgLSBhZGRPYmplY3Q6IGFsbG93cyB0byBhZGQvdXBkYXRlIGFuIG9iamVjdCBpbiB0aGUgaW5kZXggKGh0dHBzIG9ubHkpXG4gICAgICAgICAgICAgKiAgICAgLSBkZWxldGVPYmplY3QgOiBhbGxvd3MgdG8gZGVsZXRlIGFuIGV4aXN0aW5nIG9iamVjdCAoaHR0cHMgb25seSlcbiAgICAgICAgICAgICAqICAgICAtIGRlbGV0ZUluZGV4IDogYWxsb3dzIHRvIGRlbGV0ZSBpbmRleCBjb250ZW50IChodHRwcyBvbmx5KVxuICAgICAgICAgICAgICogICAgIC0gc2V0dGluZ3MgOiBhbGxvd3MgdG8gZ2V0IGluZGV4IHNldHRpbmdzIChodHRwcyBvbmx5KVxuICAgICAgICAgICAgICogICAgIC0gZWRpdFNldHRpbmdzIDogYWxsb3dzIHRvIGNoYW5nZSBpbmRleCBzZXR0aW5ncyAoaHR0cHMgb25seSlcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIE9wdGlvbm5hbCBwYXJhbWV0ZXJzIHRvIHNldCBmb3IgdGhlIGtleVxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy52YWxpZGl0eSAtIE51bWJlciBvZiBzZWNvbmRzIGFmdGVyIHdoaWNoIHRoZSBrZXkgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgKDAgbWVhbnMgbm8gdGltZSBsaW1pdCBmb3IgdGhpcyBrZXkpXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1heFF1ZXJpZXNQZXJJUFBlckhvdXIgLSBOdW1iZXIgb2YgQVBJIGNhbGxzIGFsbG93ZWQgZnJvbSBhbiBJUCBhZGRyZXNzIHBlciBob3VyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1heEhpdHNQZXJRdWVyeSAtIE51bWJlciBvZiBoaXRzIHRoaXMgQVBJIGtleSBjYW4gcmV0cmlldmUgaW4gb25lIGNhbGxcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcy5pbmRleGVzIC0gQWxsb3dlZCB0YXJnZXRlZCBpbmRleGVzIGZvciB0aGlzIGtleVxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5kZXNjcmlwdGlvbiAtIEEgZGVzY3JpcHRpb24gZm9yIHlvdXIga2V5XG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMucmVmZXJlcnMgLSBBIGxpc3Qgb2YgYXV0aG9yaXplZCByZWZlcmVyc1xuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcy5xdWVyeVBhcmFtZXRlcnMgLSBGb3JjZSB0aGUga2V5IHRvIHVzZSBzcGVjaWZpYyBxdWVyeSBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuICAgICAgICAgICAgICogICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4gICAgICAgICAgICAgKiAgIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHdpdGggdXNlciBrZXlzIGxpc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V8dW5kZWZpbmVkfSBSZXR1cm5zIGEgcHJvbWlzZSBpZiBubyBjYWxsYmFjayBnaXZlblxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqIGNsaWVudC51cGRhdGVVc2VyS2V5KCdBUElLRVknLCBbJ3NlYXJjaCddLCB7XG4gICAqICAgdmFsaWRpdHk6IDMwMCxcbiAgICogICBtYXhRdWVyaWVzUGVySVBQZXJIb3VyOiAyMDAwLFxuICAgKiAgIG1heEhpdHNQZXJRdWVyeTogMyxcbiAgICogICBpbmRleGVzOiBbJ2ZydWl0cyddLFxuICAgKiAgIGRlc2NyaXB0aW9uOiAnRWF0IHRocmVlIGZydWl0cycsXG4gICAqICAgcmVmZXJlcnM6IFsnKi5hbGdvbGlhLmNvbSddLFxuICAgKiAgIHF1ZXJ5UGFyYW1ldGVyczoge1xuICAgKiAgICAgdGFnRmlsdGVyczogWydwdWJsaWMnXSxcbiAgICogICB9XG4gICAqIH0pXG4gICAgICAgICAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbGdvbGlhLmNvbS9kb2MvcmVzdF9hcGkjVXBkYXRlSW5kZXhLZXl8QWxnb2xpYSBSRVNUIEFQSSBEb2N1bWVudGF0aW9ufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB1cGRhdGVVc2VyS2V5OiBmdW5jdGlvbihrZXksIGFjbHMsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiB8fCB0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwdXRPYmogPSB7XG4gICAgICAgICAgICAgICAgICAgIGFjbDogYWNsc1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1dE9iai52YWxpZGl0eSA9IHBhcmFtcy52YWxpZGl0eTtcbiAgICAgICAgICAgICAgICAgICAgcHV0T2JqLm1heFF1ZXJpZXNQZXJJUFBlckhvdXIgPSBwYXJhbXMubWF4UXVlcmllc1BlcklQUGVySG91cjtcbiAgICAgICAgICAgICAgICAgICAgcHV0T2JqLm1heEhpdHNQZXJRdWVyeSA9IHBhcmFtcy5tYXhIaXRzUGVyUXVlcnk7XG4gICAgICAgICAgICAgICAgICAgIHB1dE9iai5pbmRleGVzID0gcGFyYW1zLmluZGV4ZXM7XG4gICAgICAgICAgICAgICAgICAgIHB1dE9iai5kZXNjcmlwdGlvbiA9IHBhcmFtcy5kZXNjcmlwdGlvbjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLnF1ZXJ5UGFyYW1ldGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHV0T2JqLnF1ZXJ5UGFyYW1ldGVycyA9IHRoaXMuX2dldFNlYXJjaFBhcmFtcyhwYXJhbXMucXVlcnlQYXJhbWV0ZXJzLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwdXRPYmoucmVmZXJlcnMgPSBwYXJhbXMucmVmZXJlcnM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pzb25SZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAnLzEva2V5cy8nICsga2V5LFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBwdXRPYmosXG4gICAgICAgICAgICAgICAgICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IHRoZSBleHRyYSBzZWN1cml0eSB0YWdGaWx0ZXJzIGhlYWRlclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IHRhZ3MgVGhlIGxpc3Qgb2YgdGFncyBkZWZpbmluZyB0aGUgY3VycmVudCBzZWN1cml0eSBmaWx0ZXJzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNldFNlY3VyaXR5VGFnczogZnVuY3Rpb24odGFncykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGFncykgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0clRhZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRhZ3NbaV0pID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yZWRUYWdzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0YWdzW2ldLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZWRUYWdzLnB1c2godGFnc1tpXVtqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clRhZ3MucHVzaCgnKCcgKyBvcmVkVGFncy5qb2luKCcsJykgKyAnKScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJUYWdzLnB1c2godGFnc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFncyA9IHN0clRhZ3Muam9pbignLCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuc2VjdXJpdHlUYWdzID0gdGFncztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IHRoZSBleHRyYSB1c2VyIHRva2VuIGhlYWRlclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJUb2tlbiBUaGUgdG9rZW4gaWRlbnRpZnlpbmcgYSB1bmlxIHVzZXIgKHVzZWQgdG8gYXBwbHkgcmF0ZSBsaW1pdHMpXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNldFVzZXJUb2tlbjogZnVuY3Rpb24odXNlclRva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51c2VyVG9rZW4gPSB1c2VyVG9rZW47XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluaXRpYWxpemUgYSBuZXcgYmF0Y2ggb2Ygc2VhcmNoIHF1ZXJpZXNcbiAgICAgICAgICAgICAqIEBkZXByZWNhdGVkIHVzZSBjbGllbnQuc2VhcmNoKClcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc3RhcnRRdWVyaWVzQmF0Y2g6IGRlcHJlY2F0ZShmdW5jdGlvbiBzdGFydFF1ZXJpZXNCYXRjaERlcHJlY2F0ZWQoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmF0Y2ggPSBbXTtcbiAgICAgICAgICAgIH0sIGRlcHJlY2F0ZWRNZXNzYWdlKCdjbGllbnQuc3RhcnRRdWVyaWVzQmF0Y2goKScsICdjbGllbnQuc2VhcmNoKCknKSksXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQWRkIGEgc2VhcmNoIHF1ZXJ5IGluIHRoZSBiYXRjaFxuICAgICAgICAgICAgICogQGRlcHJlY2F0ZWQgdXNlIGNsaWVudC5zZWFyY2goKVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhZGRRdWVyeUluQmF0Y2g6IGRlcHJlY2F0ZShmdW5jdGlvbiBhZGRRdWVyeUluQmF0Y2hEZXByZWNhdGVkKGluZGV4TmFtZSwgcXVlcnksIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iYXRjaC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhOYW1lOiBpbmRleE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBhcmdzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBkZXByZWNhdGVkTWVzc2FnZSgnY2xpZW50LmFkZFF1ZXJ5SW5CYXRjaCgpJywgJ2NsaWVudC5zZWFyY2goKScpKSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDbGVhciBhbGwgcXVlcmllcyBpbiBjbGllbnQncyBjYWNoZVxuICAgICAgICAgICAgICogQHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY2xlYXJDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMYXVuY2ggdGhlIGJhdGNoIG9mIHF1ZXJpZXMgdXNpbmcgWE1MSHR0cFJlcXVlc3QuXG4gICAgICAgICAgICAgKiBAZGVwcmVjYXRlZCB1c2UgY2xpZW50LnNlYXJjaCgpXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNlbmRRdWVyaWVzQmF0Y2g6IGRlcHJlY2F0ZShmdW5jdGlvbiBzZW5kUXVlcmllc0JhdGNoRGVwcmVjYXRlZChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlYXJjaCh0aGlzLl9iYXRjaCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSwgZGVwcmVjYXRlZE1lc3NhZ2UoJ2NsaWVudC5zZW5kUXVlcmllc0JhdGNoKCknLCAnY2xpZW50LnNlYXJjaCgpJykpLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBhIHJlcXVlc3QgY2FuIHRha2UgYmVmb3JlIGF1dG9tYXRpY2FsbHkgYmVpbmcgdGVybWluYXRlZC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNldFJlcXVlc3RUaW1lb3V0OiBmdW5jdGlvbihtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBwYXJzZUludChtaWxsaXNlY29uZHMsIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNlYXJjaCB0aHJvdWdoIG11bHRpcGxlIGluZGljZXMgYXQgdGhlIHNhbWUgdGltZVxuICAgICAgICAgICAgICogQHBhcmFtICB7T2JqZWN0W119ICAgcXVlcmllcyAgQW4gYXJyYXkgb2YgcXVlcmllcyB5b3Ugd2FudCB0byBydW4uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcXVlcmllc1tdLmluZGV4TmFtZSBUaGUgaW5kZXggbmFtZSB5b3Ugd2FudCB0byB0YXJnZXRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcXVlcmllc1tdLnF1ZXJ5XSBUaGUgcXVlcnkgdG8gaXNzdWUgb24gdGhpcyBpbmRleC4gQ2FuIGFsc28gYmUgcGFzc2VkIGludG8gYHBhcmFtc2BcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBxdWVyaWVzW10ucGFyYW1zIEFueSBzZWFyY2ggcGFyYW0gbGlrZSBoaXRzUGVyUGFnZSwgLi5cbiAgICAgICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBiZSBjYWxsZWRcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V8dW5kZWZpbmVkfSBSZXR1cm5zIGEgcHJvbWlzZSBpZiBubyBjYWxsYmFjayBnaXZlblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uKHF1ZXJpZXMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsaWVudCA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgcG9zdE9iaiA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdHM6IG1hcChxdWVyaWVzLCBmdW5jdGlvbiBwcmVwYXJlUmVxdWVzdChxdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9ICcnO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGxvdyBxdWVyeS5xdWVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgYXJlIG1pbWljaW5nIHRoZSBpbmRleC5zZWFyY2gocXVlcnksIHBhcmFtcykgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB7aW5kZXhOYW1lOiwgcXVlcnk6LCBwYXJhbXM6fVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXJ5LnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgKz0gJ3F1ZXJ5PScgKyBlbmNvZGVVUklDb21wb25lbnQocXVlcnkucXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4TmFtZTogcXVlcnkuaW5kZXhOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogY2xpZW50Ll9nZXRTZWFyY2hQYXJhbXMocXVlcnkucGFyYW1zLCBwYXJhbXMpXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fanNvblJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICBjYWNoZTogdGhpcy5jYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgIHVybDogJy8xL2luZGV4ZXMvKi9xdWVyaWVzJyxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogcG9zdE9iaixcbiAgICAgICAgICAgICAgICAgICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBlcmZvcm0gd3JpdGUgb3BlcmF0aW9ucyBhY2Nyb3NzIG11bHRpcGxlIGluZGV4ZXMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVG8gcmVkdWNlIHRoZSBhbW91bnQgb2YgdGltZSBzcGVudCBvbiBuZXR3b3JrIHJvdW5kIHRyaXBzLFxuICAgICAgICAgICAgICogeW91IGNhbiBjcmVhdGUsIHVwZGF0ZSwgb3IgZGVsZXRlIHNldmVyYWwgb2JqZWN0cyBpbiBvbmUgY2FsbCxcbiAgICAgICAgICAgICAqIHVzaW5nIHRoZSBiYXRjaCBlbmRwb2ludCAoYWxsIG9wZXJhdGlvbnMgYXJlIGRvbmUgaW4gdGhlIGdpdmVuIG9yZGVyKS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBBdmFpbGFibGUgYWN0aW9uczpcbiAgICAgICAgICAgICAqICAgLSBhZGRPYmplY3RcbiAgICAgICAgICAgICAqICAgLSB1cGRhdGVPYmplY3RcbiAgICAgICAgICAgICAqICAgLSBwYXJ0aWFsVXBkYXRlT2JqZWN0XG4gICAgICAgICAgICAgKiAgIC0gcGFydGlhbFVwZGF0ZU9iamVjdE5vQ3JlYXRlXG4gICAgICAgICAgICAgKiAgIC0gZGVsZXRlT2JqZWN0XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL3Jlc3RfYXBpI0luZGV4ZXNcbiAgICAgICAgICAgICAqIEBwYXJhbSAge09iamVjdFtdfSBvcGVyYXRpb25zIEFuIGFycmF5IG9mIG9wZXJhdGlvbnMgdG8gcGVyZm9ybVxuICAgICAgICAgICAgICogQHJldHVybiB7UHJvbWlzZXx1bmRlZmluZWR9IFJldHVybnMgYSBwcm9taXNlIGlmIG5vIGNhbGxiYWNrIGdpdmVuXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogY2xpZW50LmJhdGNoKFt7XG4gICAqICAgYWN0aW9uOiAnYWRkT2JqZWN0JyxcbiAgICogICBpbmRleE5hbWU6ICdjbGllbnRzJyxcbiAgICogICBib2R5OiB7XG4gICAqICAgICBuYW1lOiAnQmlsbCdcbiAgICogICB9XG4gICAqIH0sIHtcbiAgICogICBhY3Rpb246ICd1ZHBhdGVPYmplY3QnLFxuICAgKiAgIGluZGV4TmFtZTogJ2ZydWl0cycsXG4gICAqICAgYm9keToge1xuICAgKiAgICAgb2JqZWN0SUQ6ICcyOTEzOCcsXG4gICAqICAgICBuYW1lOiAnYmFuYW5hJ1xuICAgKiAgIH1cbiAgICogfV0sIGNiKVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBiYXRjaDogZnVuY3Rpb24ob3BlcmF0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fanNvblJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAnLzEvaW5kZXhlcy8qL2JhdGNoJyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdHM6IG9wZXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgc3BlY2lmaWMgbWV0aG9kc1xuICAgICAgICAgICAgZGVzdHJveTogbm90SW1wbGVtZW50ZWQsXG4gICAgICAgICAgICBlbmFibGVSYXRlTGltaXRGb3J3YXJkOiBub3RJbXBsZW1lbnRlZCxcbiAgICAgICAgICAgIGRpc2FibGVSYXRlTGltaXRGb3J3YXJkOiBub3RJbXBsZW1lbnRlZCxcbiAgICAgICAgICAgIHVzZVNlY3VyZWRBUElLZXk6IG5vdEltcGxlbWVudGVkLFxuICAgICAgICAgICAgZGlzYWJsZVNlY3VyZWRBUElLZXk6IG5vdEltcGxlbWVudGVkLFxuICAgICAgICAgICAgZ2VuZXJhdGVTZWN1cmVkQXBpS2V5OiBub3RJbXBsZW1lbnRlZCxcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBJbmRleCBjbGFzcyBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgICAqIFlvdSBzaG91bGQgbm90IHVzZSB0aGlzIG1ldGhvZCBkaXJlY3RseSBidXQgdXNlIGluaXRJbmRleCgpIGZ1bmN0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEluZGV4OiBmdW5jdGlvbihhbGdvbGlhc2VhcmNoLCBpbmRleE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4TmFtZSA9IGluZGV4TmFtZTtcbiAgICAgICAgICAgICAgICB0aGlzLmFzID0gYWxnb2xpYXNlYXJjaDtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGVBaGVhZEFyZ3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZUFoZWFkVmFsdWVPcHRpb24gPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGV2ZXJ5IGluZGV4IGluc3RhbmNlIGhhcyBpdCdzIG93biBjYWNoZVxuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFkZCBhbiBleHRyYSBmaWVsZCB0byB0aGUgSFRUUCByZXF1ZXN0XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIG5hbWUgdGhlIGhlYWRlciBmaWVsZCBuYW1lXG4gICAgICAgICAgICAgKiBAcGFyYW0gdmFsdWUgdGhlIGhlYWRlciBmaWVsZCB2YWx1ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZXRFeHRyYUhlYWRlcjogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4dHJhSGVhZGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZS50b0xvd2VyQ2FzZSgpLCB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIF9zZW5kUXVlcmllc0JhdGNoOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcHJlcGFyZVBhcmFtcygpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcVBhcmFtcyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5yZXF1ZXN0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSAnLzEvaW5kZXhlcy8nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnJlcXVlc3RzW2ldLmluZGV4TmFtZSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc/JyArIHBhcmFtcy5yZXF1ZXN0c1tpXS5wYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXFQYXJhbXMgKz0gaSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChxKSArICcmJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxUGFyYW1zO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9qc29uUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlOiB0aGlzLmNhY2hlLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAnLzEvaW5kZXhlcy8qL3F1ZXJpZXMnLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAnLzEvaW5kZXhlcy8qJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHByZXBhcmVQYXJhbXMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogV3JhcHBlciB0aGF0IHRyeSBhbGwgaG9zdHMgdG8gbWF4aW1pemUgdGhlIHF1YWxpdHkgb2Ygc2VydmljZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfanNvblJlcXVlc3Q6IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdERlYnVnID0gcmVxdWlyZSg2KSgnYWxnb2xpYXNlYXJjaDonICsgb3B0cy51cmwpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGJvZHk7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlID0gb3B0cy5jYWNoZTtcbiAgICAgICAgICAgICAgICB2YXIgY2xpZW50ID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgdHJpZXMgPSAwO1xuICAgICAgICAgICAgICAgIHZhciB1c2luZ0ZhbGxiYWNrID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0cy5ib2R5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IHNhZmVKU09OU3RyaW5naWZ5KG9wdHMuYm9keSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVxdWVzdERlYnVnKCdyZXF1ZXN0IHN0YXJ0Jyk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb1JlcXVlc3QocmVxdWVzdGVyLCByZXFPcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWNoZUlEO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGllbnQuX3VzZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUlEID0gb3B0cy51cmw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBhcyB3ZSBzb21ldGltZSB1c2UgUE9TVCByZXF1ZXN0cyB0byBwYXNzIHBhcmFtZXRlcnMgKGxpa2UgcXVlcnk9J2FhJyksXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjYWNoZUlEIG11c3QgYWxzbyBpbmNsdWRlIHRoZSBib2R5IHRvIGJlIGRpZmZlcmVudCBiZXR3ZWVuIGNhbGxzXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGllbnQuX3VzZUNhY2hlICYmIGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlSUQgKz0gJ19ib2R5XycgKyByZXFPcHRzLmJvZHk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgY2FjaGUgZXhpc3RlbmNlXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGllbnQuX3VzZUNhY2hlICYmIGNhY2hlICYmIGNhY2hlW2NhY2hlSURdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3REZWJ1Zygnc2VydmluZyByZXNwb25zZSBmcm9tIGNhY2hlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50Ll9wcm9taXNlLnJlc29sdmUoSlNPTi5wYXJzZShzYWZlSlNPTlN0cmluZ2lmeShjYWNoZVtjYWNoZUlEXSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIHJlYWNoZWQgbWF4IHRyaWVzXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmllcyA+PSBjbGllbnQuaG9zdHNbb3B0cy5ob3N0VHlwZV0ubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3Igd2UgbmVlZCB0byBzd2l0Y2ggdG8gZmFsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudC51c2VGYWxsYmFjayAmJiAhdXNpbmdGYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoZXJlJ3Mgbm8gZmFsbGJhY2sgb3Igd2UgYXJlIGFscmVhZHkgdXNpbmcgYSBmYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRzLmZhbGxiYWNrIHx8ICFjbGllbnQuX3JlcXVlc3QuZmFsbGJhY2sgfHwgdXNpbmdGYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3REZWJ1ZygnY291bGQgbm90IGdldCBhbnkgcmVzcG9uc2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIHN0b3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50Ll9wcm9taXNlLnJlamVjdChuZXcgZXJyb3JzLkFsZ29saWFTZWFyY2hFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Nhbm5vdCBjb25uZWN0IHRvIHRoZSBBbGdvbGlhU2VhcmNoIEFQSS4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBTZW5kIGFuIGVtYWlsIHRvIHN1cHBvcnRAYWxnb2xpYS5jb20gdG8gcmVwb3J0IGFuZCByZXNvbHZlIHRoZSBpc3N1ZS4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBBcHBsaWNhdGlvbiBpZCB3YXM6ICcgKyBjbGllbnQuYXBwbGljYXRpb25JRFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RGVidWcoJ3N3aXRjaGluZyB0byBmYWxsYmFjaycpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyB0cnkgdGhlIGZhbGxiYWNrIHN0YXJ0aW5nIGZyb20gaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJpZXMgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtZXRob2QsIHVybCBhbmQgYm9keSBhcmUgZmFsbGJhY2sgZGVwZW5kZW50XG4gICAgICAgICAgICAgICAgICAgICAgICByZXFPcHRzLm1ldGhvZCA9IG9wdHMuZmFsbGJhY2subWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxT3B0cy51cmwgPSBvcHRzLmZhbGxiYWNrLnVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcU9wdHMuanNvbkJvZHkgPSBvcHRzLmZhbGxiYWNrLmJvZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxT3B0cy5qc29uQm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcU9wdHMuYm9keSA9IHNhZmVKU09OU3RyaW5naWZ5KHJlcU9wdHMuanNvbkJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXFPcHRzLnRpbWVvdXQgPSBjbGllbnQucmVxdWVzdFRpbWVvdXQgKiAodHJpZXMgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudC5ob3N0SW5kZXhbb3B0cy5ob3N0VHlwZV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNpbmdGYWxsYmFjayA9IHRydWU7IC8vIHRoZSBjdXJyZW50IHJlcXVlc3QgaXMgbm93IHVzaW5nIGZhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9SZXF1ZXN0KGNsaWVudC5fcmVxdWVzdC5mYWxsYmFjaywgcmVxT3B0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gY2xpZW50Lmhvc3RzW29wdHMuaG9zdFR5cGVdW2NsaWVudC5ob3N0SW5kZXhbb3B0cy5ob3N0VHlwZV1dICsgcmVxT3B0cy51cmw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25Cb2R5OiBvcHRzLmJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHJlcU9wdHMubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogY2xpZW50Ll9jb21wdXRlUmVxdWVzdEhlYWRlcnMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHJlcU9wdHMudGltZW91dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnOiByZXF1ZXN0RGVidWdcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RGVidWcoJ21ldGhvZDogJXMsIHVybDogJXMsIGhlYWRlcnM6ICVqLCB0aW1lb3V0OiAlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm1ldGhvZCwgdXJsLCBvcHRpb25zLmhlYWRlcnMsIG9wdGlvbnMudGltZW91dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RlciA9PT0gY2xpZW50Ll9yZXF1ZXN0LmZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RGVidWcoJ3VzaW5nIGZhbGxiYWNrJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBgcmVxdWVzdGVyYCBpcyBhbnkgb2YgdGhpcy5fcmVxdWVzdCBvciB0aGlzLl9yZXF1ZXN0LmZhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIC8vIHRodXMgaXQgbmVlZHMgdG8gYmUgY2FsbGVkIHVzaW5nIHRoZSBjbGllbnQgYXMgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdGVyLmNhbGwoY2xpZW50LCB1cmwsIG9wdGlvbnMpLnRoZW4oc3VjY2VzcywgdHJ5RmFsbGJhY2spO1xuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHN1Y2Nlc3MoaHR0cFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wdXRlIHRoZSBzdGF0dXMgb2YgdGhlIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gaW4gYnJvd3NlciBtb2RlLCB1c2luZyBYRFIgb3IgSlNPTlAsIHdlIGhhdmUgbm8gc3RhdHVzQ29kZSBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvIHdlIHJlbHkgb24gb3VyIEFQSSByZXNwb25zZSBgc3RhdHVzYCBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBgd2FpdFRhc2tgIGNhbiBzZXQgYSBgc3RhdHVzYCBwcm9wZXJ0eSB3aGljaCBpcyBub3QgdGhlIHN0YXR1c0NvZGUgKGl0J3MgdGhlIHRhc2sgc3RhdHVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU28gd2UgY2hlY2sgaWYgdGhlcmUncyBhIGBtZXNzYWdlYCBhbG9uZyBgc3RhdHVzYCBhbmQgaXQgbWVhbnMgaXQncyBhbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoYXQncyB0aGUgb25seSBjYXNlIHdoZXJlIHdlIGhhdmUgYSByZXNwb25zZS5zdGF0dXMgdGhhdCdzIG5vdCB0aGUgaHR0cCBzdGF0dXNDb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdHVzID0gaHR0cFJlc3BvbnNlICYmIGh0dHBSZXNwb25zZS5ib2R5ICYmIGh0dHBSZXNwb25zZS5ib2R5Lm1lc3NhZ2UgJiYgaHR0cFJlc3BvbnNlLmJvZHkuc3RhdHVzIHx8XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBpbXBvcnRhbnQgdG8gY2hlY2sgdGhlIHJlcXVlc3Qgc3RhdHVzQ29kZSBBRlRFUiB0aGUgYm9keSBldmVudHVhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGF0dXNDb2RlIGJlY2F1c2Ugc29tZSBpbXBsZW1lbnRhdGlvbnMgKGpRdWVyeSBYRG9tYWluUmVxdWVzdCB0cmFuc3BvcnQpIG1heVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZW5kIHN0YXR1c0NvZGUgMjAwIHdoaWxlIHdlIGhhZCBhbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBSZXNwb25zZS5zdGF0dXNDb2RlIHx8XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBpbiBicm93c2VyIG1vZGUsIHVzaW5nIFhEUiBvciBKU09OUFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkZWZhdWx0IHRvIHN1Y2Nlc3Mgd2hlbiBubyBlcnJvciAobm8gcmVzcG9uc2Uuc3RhdHVzICYmIHJlc3BvbnNlLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIEpTT04ucGFyc2UoKSBlcnJvciB0aGVuIGJvZHkgaXMgbnVsbCBhbmQgaXQgZmFpbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwUmVzcG9uc2UgJiYgaHR0cFJlc3BvbnNlLmJvZHkgJiYgMjAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RGVidWcoJ3JlY2VpdmVkIHJlc3BvbnNlOiBzdGF0dXNDb2RlOiAlcywgY29tcHV0ZWQgc3RhdHVzQ29kZTogJWQsIGhlYWRlcnM6ICVqJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSwgc3RhdHVzLCBodHRwUmVzcG9uc2UuaGVhZGVycyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5ERUJVRyAmJiBwcm9jZXNzLmVudi5ERUJVRy5pbmRleE9mKCdkZWJ1Z0JvZHknKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RGVidWcoJ2JvZHk6ICVqJywgaHR0cFJlc3BvbnNlLmJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2sgPSBzdGF0dXMgPT09IDIwMCB8fCBzdGF0dXMgPT09IDIwMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXRyeSA9ICFvayAmJiBNYXRoLmZsb29yKHN0YXR1cyAvIDEwMCkgIT09IDQgJiYgTWF0aC5mbG9vcihzdGF0dXMgLyAxMDApICE9PSAxO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xpZW50Ll91c2VDYWNoZSAmJiBvayAmJiBjYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlSURdID0gaHR0cFJlc3BvbnNlLmJvZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZXMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0cnlSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bnJlY292ZXJhYmxlRXJyb3IgPSBuZXcgZXJyb3JzLkFsZ29saWFTZWFyY2hFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwUmVzcG9uc2UuYm9keSAmJiBodHRwUmVzcG9uc2UuYm9keS5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50Ll9wcm9taXNlLnJlamVjdCh1bnJlY292ZXJhYmxlRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdHJ5RmFsbGJhY2soZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlcnJvciBjYXNlczpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBXaGlsZSBub3QgaW4gZmFsbGJhY2sgbW9kZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIC0gQ09SUyBub3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAtIG5ldHdvcmsgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBXaGlsZSBpbiBmYWxsYmFjayBtb2RlOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgLSB0aW1lb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAtIG5ldHdvcmsgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIC0gYmFkbHkgZm9ybWF0dGVkIEpTT05QIChzY3JpcHQgbG9hZGVkLCBkaWQgbm90IGNhbGwgb3VyIGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIEluIGJvdGggY2FzZXM6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAtIHVuY2F1Z2h0IGV4Y2VwdGlvbiBvY2N1cnMgKFR5cGVFcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3REZWJ1ZygnZXJyb3I6ICVzLCBzdGFjazogJXMnLCBlcnIubWVzc2FnZSwgZXJyLnN0YWNrKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgZXJyb3JzLkFsZ29saWFTZWFyY2hFcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBuZXcgZXJyb3JzLlVua25vd24oZXJyICYmIGVyci5tZXNzYWdlLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmllcyArPSAxO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9wIHRoZSByZXF1ZXN0IGltcGxlbWVudGF0aW9uIHdoZW46XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSB0aGlzIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgY29tZXMgZnJvbSBhIHRocm93IGluIHNvbWUgb3RoZXIgcGllY2Ugb2YgY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyIGluc3RhbmNlb2YgZXJyb3JzLlVua25vd24gfHxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlcnZlciBzZW50IHVucGFyc2FibGUgSlNPTlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyIGluc3RhbmNlb2YgZXJyb3JzLlVucGFyc2FibGVKU09OIHx8XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBmYWxsYmFjayBhbmQgYSBuZXR3b3JrIGVycm9yIG9jY3VyZWQgKE5vIENPUlMsIGJhZCBBUFBJRClcbiAgICAgICAgICAgICAgICAgICAgICAgICFyZXF1ZXN0ZXIuZmFsbGJhY2sgJiYgZXJyIGluc3RhbmNlb2YgZXJyb3JzLk5ldHdvcmsgfHxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1heCB0cmllcyBhbmQgYWxyZWFkeSB1c2luZyBmYWxsYmFjayBvciBubyBmYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJpZXMgPj0gY2xpZW50Lmhvc3RzW29wdHMuaG9zdFR5cGVdLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHVzaW5nRmFsbGJhY2sgfHwgIW9wdHMuZmFsbGJhY2sgfHwgIWNsaWVudC5fcmVxdWVzdC5mYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9wIHJlcXVlc3QgaW1wbGVtZW50YXRpb24gZm9yIHRoaXMgY29tbWFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGllbnQuX3Byb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudC5ob3N0SW5kZXhbb3B0cy5ob3N0VHlwZV0gPSArK2NsaWVudC5ob3N0SW5kZXhbb3B0cy5ob3N0VHlwZV0gJSBjbGllbnQuaG9zdHNbb3B0cy5ob3N0VHlwZV0ubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgZXJyb3JzLlJlcXVlc3RUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHJ5UmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjbGllbnQuX3JlcXVlc3QuZmFsbGJhY2sgJiYgIWNsaWVudC51c2VGYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGFueSBlcnJvciBvY2N1cmVkIGJ1dCB0aW1lb3V0LCB1c2UgZmFsbGJhY2sgZm9yIHRoZSByZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhlIHNlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnQudXNlRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9SZXF1ZXN0KHJlcXVlc3RlciwgcmVxT3B0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiByZXRyeVJlcXVlc3QoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnQuaG9zdEluZGV4W29wdHMuaG9zdFR5cGVdID0gKytjbGllbnQuaG9zdEluZGV4W29wdHMuaG9zdFR5cGVdICUgY2xpZW50Lmhvc3RzW29wdHMuaG9zdFR5cGVdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcU9wdHMudGltZW91dCA9IGNsaWVudC5yZXF1ZXN0VGltZW91dCAqICh0cmllcyArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvUmVxdWVzdChyZXF1ZXN0ZXIsIHJlcU9wdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuIHVzZSBhIGZhbGxiYWNrIGlmIGZvcmNlZCBBTkQgZmFsbGJhY2sgcGFyYW1ldGVycyBhcmUgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgdmFyIHVzZUZhbGxiYWNrID0gY2xpZW50LnVzZUZhbGxiYWNrICYmIG9wdHMuZmFsbGJhY2s7XG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RPcHRpb25zID0gdXNlRmFsbGJhY2sgPyBvcHRzLmZhbGxiYWNrIDogb3B0cztcblxuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gZG9SZXF1ZXN0KFxuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIHJlcXVlc3RlclxuICAgICAgICAgICAgICAgICAgICB1c2VGYWxsYmFjayA/IGNsaWVudC5fcmVxdWVzdC5mYWxsYmFjayA6IGNsaWVudC5fcmVxdWVzdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiByZXF1ZXN0T3B0aW9ucy51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHJlcXVlc3RPcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uQm9keTogb3B0cy5ib2R5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dDogY2xpZW50LnJlcXVlc3RUaW1lb3V0ICogKHRyaWVzICsgMSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBlaXRoZXIgd2UgaGF2ZSBhIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gZWl0aGVyIHdlIGFyZSB1c2luZyBwcm9taXNlc1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiBva0NiKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXRQcm9taXNlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuY2FsbGJhY2sobnVsbCwgY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjbGllbnQuX3NldFRpbWVvdXQgfHwgc2V0VGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIG5vb2tDYihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXRQcm9taXNlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNsaWVudC5fc2V0VGltZW91dCB8fCBzZXRUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFRyYW5zZm9ybSBzZWFyY2ggcGFyYW0gb2JqZWN0IGluIHF1ZXJ5IHN0cmluZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfZ2V0U2VhcmNoUGFyYW1zOiBmdW5jdGlvbihhcmdzLCBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNVbmRlZmluZWQoYXJncykgfHwgYXJncyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXJncykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSBudWxsICYmIGFyZ3Nba2V5XSAhPT0gdW5kZWZpbmVkICYmIGFyZ3MuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zICs9IHBhcmFtcyA9PT0gJycgPyAnJyA6ICcmJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyArPSBrZXkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3Nba2V5XSkgPT09ICdbb2JqZWN0IEFycmF5XScgPyBzYWZlSlNPTlN0cmluZ2lmeShhcmdzW2tleV0pIDogYXJnc1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgX2lzVW5kZWZpbmVkOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfY29tcHV0ZVJlcXVlc3RIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm9yRWFjaCA9IHJlcXVpcmUoMTEpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RIZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICAneC1hbGdvbGlhLWFwaS1rZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAgICAgJ3gtYWxnb2xpYS1hcHBsaWNhdGlvbi1pZCc6IHRoaXMuYXBwbGljYXRpb25JRCxcbiAgICAgICAgICAgICAgICAgICAgJ3gtYWxnb2xpYS1hZ2VudCc6IHRoaXMuX3VhXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZXJUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVyc1sneC1hbGdvbGlhLXVzZXJ0b2tlbiddID0gdGhpcy51c2VyVG9rZW47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VjdXJpdHlUYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzWyd4LWFsZ29saWEtdGFnZmlsdGVycyddID0gdGhpcy5zZWN1cml0eVRhZ3M7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvckVhY2godGhpcy5leHRyYUhlYWRlcnMsIGZ1bmN0aW9uIGFkZFRvUmVxdWVzdEhlYWRlcnMoaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVyc1toZWFkZXIubmFtZV0gPSBoZWFkZXIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0SGVhZGVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBDb250YWlucyBhbGwgdGhlIGZ1bmN0aW9ucyByZWxhdGVkIHRvIG9uZSBpbmRleFxuICAgICAgICAgKiBZb3Ugc2hvdWxkIHVzZSBBbGdvbGlhU2VhcmNoLmluaXRJbmRleChpbmRleE5hbWUpIHRvIHJldHJpZXZlIHRoaXMgb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBBbGdvbGlhU2VhcmNoLnByb3RvdHlwZS5JbmRleC5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogQ2xlYXIgYWxsIHF1ZXJpZXMgaW4gY2FjaGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY2xlYXJDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBBZGQgYW4gb2JqZWN0IGluIHRoaXMgaW5kZXhcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gY29udGVudCBjb250YWlucyB0aGUgamF2YXNjcmlwdCBvYmplY3QgdG8gYWRkIGluc2lkZSB0aGUgaW5kZXhcbiAgICAgICAgICAgICAqIEBwYXJhbSBvYmplY3RJRCAob3B0aW9uYWwpIGFuIG9iamVjdElEIHlvdSB3YW50IHRvIGF0dHJpYnV0ZSB0byB0aGlzIG9iamVjdFxuICAgICAgICAgICAgICogKGlmIHRoZSBhdHRyaWJ1dGUgYWxyZWFkeSBleGlzdCB0aGUgb2xkIG9iamVjdCB3aWxsIGJlIG92ZXJ3cml0ZSlcbiAgICAgICAgICAgICAqIEBwYXJhbSBjYWxsYmFjayAob3B0aW9uYWwpIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50czpcbiAgICAgICAgICAgICAqICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4gICAgICAgICAgICAgKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCBjb250YWlucyAzIGVsZW1lbnRzOiBjcmVhdGVBdCwgdGFza0lkIGFuZCBvYmplY3RJRFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhZGRPYmplY3Q6IGZ1bmN0aW9uKGNvbnRlbnQsIG9iamVjdElELCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleE9iaiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCB0eXBlb2Ygb2JqZWN0SUQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBvYmplY3RJRDtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0SUQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBvYmplY3RJRCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgICAgICdQVVQnIDogLy8gdXBkYXRlIG9yIGNyZWF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BPU1QnLCAvLyBjcmVhdGUgKEFQSSBnZW5lcmF0ZXMgYW4gb2JqZWN0SUQpXG4gICAgICAgICAgICAgICAgICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgLy8gY3JlYXRlXG4gICAgICAgICAgICAgICAgICAgIChvYmplY3RJRCAhPT0gdW5kZWZpbmVkID8gJy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9iamVjdElEKSA6ICcnKSwgLy8gdXBkYXRlIG9yIGNyZWF0ZVxuICAgICAgICAgICAgICAgICAgICBib2R5OiBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEFkZCBzZXZlcmFsIG9iamVjdHNcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gb2JqZWN0cyBjb250YWlucyBhbiBhcnJheSBvZiBvYmplY3RzIHRvIGFkZFxuICAgICAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzOlxuICAgICAgICAgICAgICogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiAgICAgICAgICAgICAqICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB0aGF0IHVwZGF0ZUF0IGFuZCB0YXNrSURcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYWRkT2JqZWN0czogZnVuY3Rpb24ob2JqZWN0cywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBwb3N0T2JqID0ge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0czogW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ2FkZE9iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBvYmplY3RzW2ldXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHBvc3RPYmoucmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy9iYXRjaCcsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHBvc3RPYmosXG4gICAgICAgICAgICAgICAgICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogR2V0IGFuIG9iamVjdCBmcm9tIHRoaXMgaW5kZXhcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gb2JqZWN0SUQgdGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBvYmplY3QgdG8gcmV0cmlldmVcbiAgICAgICAgICAgICAqIEBwYXJhbSBhdHRycyAob3B0aW9uYWwpIGlmIHNldCwgY29udGFpbnMgdGhlIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byByZXRyaWV2ZVxuICAgICAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4gICAgICAgICAgICAgKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICAgICAgICAgICAgICogIGNvbnRlbnQ6IHRoZSBvYmplY3QgdG8gcmV0cmlldmUgb3IgdGhlIGVycm9yIG1lc3NhZ2UgaWYgYSBmYWlsdXJlIG9jY3VyZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0T2JqZWN0OiBmdW5jdGlvbihvYmplY3RJRCwgYXR0cnMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4T2JqID0gdGhpcztcblxuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IHR5cGVvZiBhdHRycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGF0dHJzO1xuICAgICAgICAgICAgICAgICAgICBhdHRycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gJz9hdHRyaWJ1dGVzPSc7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zICs9ICcsJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyArPSBhdHRyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9iamVjdElEKSArIHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogR2V0IHNldmVyYWwgb2JqZWN0cyBmcm9tIHRoaXMgaW5kZXhcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gb2JqZWN0SURzIHRoZSBhcnJheSBvZiB1bmlxdWUgaWRlbnRpZmllciBvZiBvYmplY3RzIHRvIHJldHJpZXZlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldE9iamVjdHM6IGZ1bmN0aW9uKG9iamVjdElEcywgYXR0cmlidXRlc1RvUmV0cmlldmUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4T2JqID0gdGhpcztcblxuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IHR5cGVvZiBhdHRyaWJ1dGVzVG9SZXRyaWV2ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGF0dHJpYnV0ZXNUb1JldHJpZXZlO1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzVG9SZXRyaWV2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgYm9keSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdHM6IG1hcChvYmplY3RJRHMsIGZ1bmN0aW9uIHByZXBhcmVSZXF1ZXN0KG9iamVjdElEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5kZXhOYW1lJzogaW5kZXhPYmouaW5kZXhOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvYmplY3RJRCc6IG9iamVjdElEXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlc1RvUmV0cmlldmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmF0dHJpYnV0ZXNUb1JldHJpZXZlID0gYXR0cmlidXRlc1RvUmV0cmlldmUuam9pbignLCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgIHVybDogJy8xL2luZGV4ZXMvKi9vYmplY3RzJyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogVXBkYXRlIHBhcnRpYWxseSBhbiBvYmplY3QgKG9ubHkgdXBkYXRlIGF0dHJpYnV0ZXMgcGFzc2VkIGluIGFyZ3VtZW50KVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBwYXJ0aWFsT2JqZWN0IGNvbnRhaW5zIHRoZSBqYXZhc2NyaXB0IGF0dHJpYnV0ZXMgdG8gb3ZlcnJpZGUsIHRoZVxuICAgICAgICAgICAgICogIG9iamVjdCBtdXN0IGNvbnRhaW5zIGFuIG9iamVjdElEIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzOlxuICAgICAgICAgICAgICogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiAgICAgICAgICAgICAqICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB0aGF0IGNvbnRhaW5zIDMgZWxlbWVudHM6IGNyZWF0ZUF0LCB0YXNrSWQgYW5kIG9iamVjdElEXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHBhcnRpYWxVcGRhdGVPYmplY3Q6IGZ1bmN0aW9uKHBhcnRpYWxPYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnLycgKyBlbmNvZGVVUklDb21wb25lbnQocGFydGlhbE9iamVjdC5vYmplY3RJRCkgKyAnL3BhcnRpYWwnLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBwYXJ0aWFsT2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFBhcnRpYWxseSBPdmVycmlkZSB0aGUgY29udGVudCBvZiBzZXZlcmFsIG9iamVjdHNcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gb2JqZWN0cyBjb250YWlucyBhbiBhcnJheSBvZiBvYmplY3RzIHRvIHVwZGF0ZSAoZWFjaCBvYmplY3QgbXVzdCBjb250YWlucyBhIG9iamVjdElEIGF0dHJpYnV0ZSlcbiAgICAgICAgICAgICAqIEBwYXJhbSBjYWxsYmFjayAob3B0aW9uYWwpIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50czpcbiAgICAgICAgICAgICAqICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4gICAgICAgICAgICAgKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgdGhhdCB1cGRhdGVBdCBhbmQgdGFza0lEXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHBhcnRpYWxVcGRhdGVPYmplY3RzOiBmdW5jdGlvbihvYmplY3RzLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleE9iaiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIHBvc3RPYmogPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RzOiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAncGFydGlhbFVwZGF0ZU9iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RJRDogb2JqZWN0c1tpXS5vYmplY3RJRCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IG9iamVjdHNbaV1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcG9zdE9iai5yZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnL2JhdGNoJyxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogcG9zdE9iaixcbiAgICAgICAgICAgICAgICAgICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBPdmVycmlkZSB0aGUgY29udGVudCBvZiBvYmplY3RcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gb2JqZWN0IGNvbnRhaW5zIHRoZSBqYXZhc2NyaXB0IG9iamVjdCB0byBzYXZlLCB0aGUgb2JqZWN0IG11c3QgY29udGFpbnMgYW4gb2JqZWN0SUQgYXR0cmlidXRlXG4gICAgICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgKG9wdGlvbmFsKSB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHM6XG4gICAgICAgICAgICAgKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICAgICAgICAgICAgICogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgdXBkYXRlQXQgYW5kIHRhc2tJRFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzYXZlT2JqZWN0OiBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgICAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcvJyArIGVuY29kZVVSSUNvbXBvbmVudChvYmplY3Qub2JqZWN0SUQpLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBvYmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogT3ZlcnJpZGUgdGhlIGNvbnRlbnQgb2Ygc2V2ZXJhbCBvYmplY3RzXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIG9iamVjdHMgY29udGFpbnMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB0byB1cGRhdGUgKGVhY2ggb2JqZWN0IG11c3QgY29udGFpbnMgYSBvYmplY3RJRCBhdHRyaWJ1dGUpXG4gICAgICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgKG9wdGlvbmFsKSB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHM6XG4gICAgICAgICAgICAgKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICAgICAgICAgICAgICogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgdXBkYXRlQXQgYW5kIHRhc2tJRFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzYXZlT2JqZWN0czogZnVuY3Rpb24ob2JqZWN0cywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBwb3N0T2JqID0ge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0czogW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ3VwZGF0ZU9iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RJRDogb2JqZWN0c1tpXS5vYmplY3RJRCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IG9iamVjdHNbaV1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcG9zdE9iai5yZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnL2JhdGNoJyxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogcG9zdE9iaixcbiAgICAgICAgICAgICAgICAgICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBEZWxldGUgYW4gb2JqZWN0IGZyb20gdGhlIGluZGV4XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIG9iamVjdElEIHRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiBvYmplY3QgdG8gZGVsZXRlXG4gICAgICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgKG9wdGlvbmFsKSB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHM6XG4gICAgICAgICAgICAgKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICAgICAgICAgICAgICogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgY29udGFpbnMgMyBlbGVtZW50czogY3JlYXRlQXQsIHRhc2tJZCBhbmQgb2JqZWN0SURcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZGVsZXRlT2JqZWN0OiBmdW5jdGlvbihvYmplY3RJRCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdElEID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvYmplY3RJRCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIG9iamVjdElEICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IGVycm9ycy5BbGdvbGlhU2VhcmNoRXJyb3IoJ0Nhbm5vdCBkZWxldGUgYW4gb2JqZWN0IHdpdGhvdXQgYW4gb2JqZWN0SUQnKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBvYmplY3RJRDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcy5fcHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9iamVjdElEKSxcbiAgICAgICAgICAgICAgICAgICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBEZWxldGUgc2V2ZXJhbCBvYmplY3RzIGZyb20gYW4gaW5kZXhcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gb2JqZWN0SURzIGNvbnRhaW5zIGFuIGFycmF5IG9mIG9iamVjdElEIHRvIGRlbGV0ZVxuICAgICAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzOlxuICAgICAgICAgICAgICogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiAgICAgICAgICAgICAqICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB0aGF0IGNvbnRhaW5zIDMgZWxlbWVudHM6IGNyZWF0ZUF0LCB0YXNrSWQgYW5kIG9iamVjdElEXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRlbGV0ZU9iamVjdHM6IGZ1bmN0aW9uKG9iamVjdElEcywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBwb3N0T2JqID0ge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0czogbWFwKG9iamVjdElEcywgZnVuY3Rpb24gcHJlcGFyZVJlcXVlc3Qob2JqZWN0SUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnZGVsZXRlT2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RJRDogb2JqZWN0SUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RJRDogb2JqZWN0SURcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnL2JhdGNoJyxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogcG9zdE9iaixcbiAgICAgICAgICAgICAgICAgICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBEZWxldGUgYWxsIG9iamVjdHMgbWF0Y2hpbmcgYSBxdWVyeVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBxdWVyeSB0aGUgcXVlcnkgc3RyaW5nXG4gICAgICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIHRoZSBvcHRpb25hbCBxdWVyeSBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgKG9wdGlvbmFsKSB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudFxuICAgICAgICAgICAgICogIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZGVsZXRlQnlRdWVyeTogZnVuY3Rpb24ocXVlcnksIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBjbGllbnQgPSBpbmRleE9iai5hcztcblxuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcmFtcy5hdHRyaWJ1dGVzVG9SZXRyaWV2ZSA9ICdvYmplY3RJRCc7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmhpdHNQZXJQYWdlID0gMTAwMDtcblxuICAgICAgICAgICAgICAgIC8vIHdoZW4gZGVsZXRpbmcsIHdlIHNob3VsZCBuZXZlciB1c2UgY2FjaGUgdG8gZ2V0IHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlYXJjaCByZXN1bHRzXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckNhY2hlKCk7XG5cbiAgICAgICAgICAgICAgICAvLyB0aGVyZSdzIGEgcHJvYmxlbSBpbiBob3cgd2UgdXNlIHRoZSBwcm9taXNlIGNoYWluLFxuICAgICAgICAgICAgICAgIC8vIHNlZSBob3cgd2FpdFRhc2sgaXMgZG9uZVxuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gdGhpc1xuICAgICAgICAgICAgICAgICAgICAuc2VhcmNoKHF1ZXJ5LCBwYXJhbXMpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHN0b3BPckRlbGV0ZSk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzdG9wT3JEZWxldGUoc2VhcmNoQ29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9wIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaENvbnRlbnQubmJIaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gaW5kZXhPYmouYXMuX3JlcXVlc3QucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlYXJjaENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZSBhbmQgZG8gYSByZWN1cnNpdmUgY2FsbFxuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqZWN0SURzID0gbWFwKHNlYXJjaENvbnRlbnQuaGl0cywgZnVuY3Rpb24gZ2V0T2JqZWN0SUQob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0Lm9iamVjdElEO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhPYmpcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kZWxldGVPYmplY3RzKG9iamVjdElEcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHdhaXRUYXNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZG9EZWxldGVCeVF1ZXJ5KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB3YWl0VGFzayhkZWxldGVPYmplY3RzQ29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhPYmoud2FpdFRhc2soZGVsZXRlT2JqZWN0c0NvbnRlbnQudGFza0lEKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb0RlbGV0ZUJ5UXVlcnkoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleE9iai5kZWxldGVCeVF1ZXJ5KHF1ZXJ5LCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3MsIGZhaWx1cmUpO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc3VjY2VzcygpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpdFByb21pc2UoZnVuY3Rpb24gZXhpdCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9LCBjbGllbnQuX3NldFRpbWVvdXQgfHwgc2V0VGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZmFpbHVyZShlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpdFByb21pc2UoZnVuY3Rpb24gZXhpdCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0sIGNsaWVudC5fc2V0VGltZW91dCB8fCBzZXRUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFNlYXJjaCBpbnNpZGUgdGhlIGluZGV4IHVzaW5nIFhNTEh0dHBSZXF1ZXN0IHJlcXVlc3QgKFVzaW5nIGEgUE9TVCBxdWVyeSB0b1xuICAgICAgICAgICAgICogbWluaW1pemUgbnVtYmVyIG9mIE9QVElPTlMgcXVlcmllczogQ3Jvc3MtT3JpZ2luIFJlc291cmNlIFNoYXJpbmcpLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBxdWVyeSB0aGUgZnVsbCB0ZXh0IHF1ZXJ5XG4gICAgICAgICAgICAgKiBAcGFyYW0gYXJncyAob3B0aW9uYWwpIGlmIHNldCwgY29udGFpbnMgYW4gb2JqZWN0IHdpdGggcXVlcnkgcGFyYW1ldGVyczpcbiAgICAgICAgICAgICAqIC0gcGFnZTogKGludGVnZXIpIFBhZ2luYXRpb24gcGFyYW1ldGVyIHVzZWQgdG8gc2VsZWN0IHRoZSBwYWdlIHRvIHJldHJpZXZlLlxuICAgICAgICAgICAgICogICAgICAgICAgICAgICAgICAgUGFnZSBpcyB6ZXJvLWJhc2VkIGFuZCBkZWZhdWx0cyB0byAwLiBUaHVzLFxuICAgICAgICAgICAgICogICAgICAgICAgICAgICAgICAgdG8gcmV0cmlldmUgdGhlIDEwdGggcGFnZSB5b3UgbmVlZCB0byBzZXQgcGFnZT05XG4gICAgICAgICAgICAgKiAtIGhpdHNQZXJQYWdlOiAoaW50ZWdlcikgUGFnaW5hdGlvbiBwYXJhbWV0ZXIgdXNlZCB0byBzZWxlY3QgdGhlIG51bWJlciBvZiBoaXRzIHBlciBwYWdlLiBEZWZhdWx0cyB0byAyMC5cbiAgICAgICAgICAgICAqIC0gYXR0cmlidXRlc1RvUmV0cmlldmU6IGEgc3RyaW5nIHRoYXQgY29udGFpbnMgdGhlIGxpc3Qgb2Ygb2JqZWN0IGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAqIHlvdSB3YW50IHRvIHJldHJpZXZlIChsZXQgeW91IG1pbmltaXplIHRoZSBhbnN3ZXIgc2l6ZSkuXG4gICAgICAgICAgICAgKiAgIEF0dHJpYnV0ZXMgYXJlIHNlcGFyYXRlZCB3aXRoIGEgY29tbWEgKGZvciBleGFtcGxlIFwibmFtZSxhZGRyZXNzXCIpLlxuICAgICAgICAgICAgICogICBZb3UgY2FuIGFsc28gdXNlIGFuIGFycmF5IChmb3IgZXhhbXBsZSBbXCJuYW1lXCIsXCJhZGRyZXNzXCJdKS5cbiAgICAgICAgICAgICAqICAgQnkgZGVmYXVsdCwgYWxsIGF0dHJpYnV0ZXMgYXJlIHJldHJpZXZlZC4gWW91IGNhbiBhbHNvIHVzZSAnKicgdG8gcmV0cmlldmUgYWxsXG4gICAgICAgICAgICAgKiAgIHZhbHVlcyB3aGVuIGFuIGF0dHJpYnV0ZXNUb1JldHJpZXZlIHNldHRpbmcgaXMgc3BlY2lmaWVkIGZvciB5b3VyIGluZGV4LlxuICAgICAgICAgICAgICogLSBhdHRyaWJ1dGVzVG9IaWdobGlnaHQ6IGEgc3RyaW5nIHRoYXQgY29udGFpbnMgdGhlIGxpc3Qgb2YgYXR0cmlidXRlcyB5b3VcbiAgICAgICAgICAgICAqICAgd2FudCB0byBoaWdobGlnaHQgYWNjb3JkaW5nIHRvIHRoZSBxdWVyeS5cbiAgICAgICAgICAgICAqICAgQXR0cmlidXRlcyBhcmUgc2VwYXJhdGVkIGJ5IGEgY29tbWEuIFlvdSBjYW4gYWxzbyB1c2UgYW4gYXJyYXkgKGZvciBleGFtcGxlIFtcIm5hbWVcIixcImFkZHJlc3NcIl0pLlxuICAgICAgICAgICAgICogICBJZiBhbiBhdHRyaWJ1dGUgaGFzIG5vIG1hdGNoIGZvciB0aGUgcXVlcnksIHRoZSByYXcgdmFsdWUgaXMgcmV0dXJuZWQuXG4gICAgICAgICAgICAgKiAgIEJ5IGRlZmF1bHQgYWxsIGluZGV4ZWQgdGV4dCBhdHRyaWJ1dGVzIGFyZSBoaWdobGlnaHRlZC5cbiAgICAgICAgICAgICAqICAgWW91IGNhbiB1c2UgYCpgIGlmIHlvdSB3YW50IHRvIGhpZ2hsaWdodCBhbGwgdGV4dHVhbCBhdHRyaWJ1dGVzLlxuICAgICAgICAgICAgICogICBOdW1lcmljYWwgYXR0cmlidXRlcyBhcmUgbm90IGhpZ2hsaWdodGVkLlxuICAgICAgICAgICAgICogICBBIG1hdGNoTGV2ZWwgaXMgcmV0dXJuZWQgZm9yIGVhY2ggaGlnaGxpZ2h0ZWQgYXR0cmlidXRlIGFuZCBjYW4gY29udGFpbjpcbiAgICAgICAgICAgICAqICAgICAgLSBmdWxsOiBpZiBhbGwgdGhlIHF1ZXJ5IHRlcm1zIHdlcmUgZm91bmQgaW4gdGhlIGF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAqICAgICAgLSBwYXJ0aWFsOiBpZiBvbmx5IHNvbWUgb2YgdGhlIHF1ZXJ5IHRlcm1zIHdlcmUgZm91bmQsXG4gICAgICAgICAgICAgKiAgICAgIC0gbm9uZTogaWYgbm9uZSBvZiB0aGUgcXVlcnkgdGVybXMgd2VyZSBmb3VuZC5cbiAgICAgICAgICAgICAqIC0gYXR0cmlidXRlc1RvU25pcHBldDogYSBzdHJpbmcgdGhhdCBjb250YWlucyB0aGUgbGlzdCBvZiBhdHRyaWJ1dGVzIHRvIHNuaXBwZXQgYWxvbmdzaWRlXG4gICAgICAgICAgICAgKiB0aGUgbnVtYmVyIG9mIHdvcmRzIHRvIHJldHVybiAoc3ludGF4IGlzIGBhdHRyaWJ1dGVOYW1lOm5iV29yZHNgKS5cbiAgICAgICAgICAgICAqICAgIEF0dHJpYnV0ZXMgYXJlIHNlcGFyYXRlZCBieSBhIGNvbW1hIChFeGFtcGxlOiBhdHRyaWJ1dGVzVG9TbmlwcGV0PW5hbWU6MTAsY29udGVudDoxMCkuXG4gICAgICAgICAgICAgKiAgICBZb3UgY2FuIGFsc28gdXNlIGFuIGFycmF5IChFeGFtcGxlOiBhdHRyaWJ1dGVzVG9TbmlwcGV0OiBbJ25hbWU6MTAnLCdjb250ZW50OjEwJ10pLlxuICAgICAgICAgICAgICogICAgQnkgZGVmYXVsdCBubyBzbmlwcGV0IGlzIGNvbXB1dGVkLlxuICAgICAgICAgICAgICogLSBtaW5Xb3JkU2l6ZWZvcjFUeXBvOiB0aGUgbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBpbiBhIHF1ZXJ5IHdvcmQgdG8gYWNjZXB0IG9uZSB0eXBvIGluIHRoaXMgd29yZC5cbiAgICAgICAgICAgICAqRCBlZmF1bHRzIHRvIDMuXG4gICAgICAgICAgICAgKiAtIG1pbldvcmRTaXplZm9yMlR5cG9zOiB0aGUgbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBpbiBhIHF1ZXJ5IHdvcmRcbiAgICAgICAgICAgICAqIHRvIGFjY2VwdCB0d28gdHlwb3MgaW4gdGhpcyB3b3JkLiBEZWZhdWx0cyB0byA3LlxuICAgICAgICAgICAgICogLSBnZXRSYW5raW5nSW5mbzogaWYgc2V0IHRvIDEsIHRoZSByZXN1bHQgaGl0cyB3aWxsIGNvbnRhaW4gcmFua2luZ1xuICAgICAgICAgICAgICogaW5mb3JtYXRpb24gaW4gX3JhbmtpbmdJbmZvIGF0dHJpYnV0ZS5cbiAgICAgICAgICAgICAqIC0gYXJvdW5kTGF0TG5nOiBzZWFyY2ggZm9yIGVudHJpZXMgYXJvdW5kIGEgZ2l2ZW5cbiAgICAgICAgICAgICAqIGxhdGl0dWRlL2xvbmdpdHVkZSAoc3BlY2lmaWVkIGFzIHR3byBmbG9hdHMgc2VwYXJhdGVkIGJ5IGEgY29tbWEpLlxuICAgICAgICAgICAgICogICBGb3IgZXhhbXBsZSBhcm91bmRMYXRMbmc9NDcuMzE2NjY5LDUuMDE2NjcwKS5cbiAgICAgICAgICAgICAqICAgWW91IGNhbiBzcGVjaWZ5IHRoZSBtYXhpbXVtIGRpc3RhbmNlIGluIG1ldGVycyB3aXRoIHRoZSBhcm91bmRSYWRpdXMgcGFyYW1ldGVyIChpbiBtZXRlcnMpXG4gICAgICAgICAgICAgKiAgIGFuZCB0aGUgcHJlY2lzaW9uIGZvciByYW5raW5nIHdpdGggYXJvdW5kUHJlY2lzaW9uXG4gICAgICAgICAgICAgKiAgIChmb3IgZXhhbXBsZSBpZiB5b3Ugc2V0IGFyb3VuZFByZWNpc2lvbj0xMDAsIHR3byBvYmplY3RzIHRoYXQgYXJlIGRpc3RhbnQgb2ZcbiAgICAgICAgICAgICAqICAgbGVzcyB0aGFuIDEwMG0gd2lsbCBiZSBjb25zaWRlcmVkIGFzIGlkZW50aWNhbCBmb3IgXCJnZW9cIiByYW5raW5nIHBhcmFtZXRlcikuXG4gICAgICAgICAgICAgKiAgIEF0IGluZGV4aW5nLCB5b3Ugc2hvdWxkIHNwZWNpZnkgZ2VvbG9jIG9mIGFuIG9iamVjdCB3aXRoIHRoZSBfZ2VvbG9jIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICogICAoaW4gdGhlIGZvcm0ge1wiX2dlb2xvY1wiOntcImxhdFwiOjQ4Ljg1MzQwOSwgXCJsbmdcIjoyLjM0ODgwMH19KVxuICAgICAgICAgICAgICogLSBpbnNpZGVCb3VuZGluZ0JveDogc2VhcmNoIGVudHJpZXMgaW5zaWRlIGEgZ2l2ZW4gYXJlYSBkZWZpbmVkIGJ5IHRoZSB0d28gZXh0cmVtZSBwb2ludHNcbiAgICAgICAgICAgICAqIG9mIGEgcmVjdGFuZ2xlIChkZWZpbmVkIGJ5IDQgZmxvYXRzOiBwMUxhdCxwMUxuZyxwMkxhdCxwMkxuZykuXG4gICAgICAgICAgICAgKiAgIEZvciBleGFtcGxlIGluc2lkZUJvdW5kaW5nQm94PTQ3LjMxNjUsNC45NjY1LDQ3LjM0MjQsNS4wMjAxKS5cbiAgICAgICAgICAgICAqICAgQXQgaW5kZXhpbmcsIHlvdSBzaG91bGQgc3BlY2lmeSBnZW9sb2Mgb2YgYW4gb2JqZWN0IHdpdGggdGhlIF9nZW9sb2MgYXR0cmlidXRlXG4gICAgICAgICAgICAgKiAgIChpbiB0aGUgZm9ybSB7XCJfZ2VvbG9jXCI6e1wibGF0XCI6NDguODUzNDA5LCBcImxuZ1wiOjIuMzQ4ODAwfX0pXG4gICAgICAgICAgICAgKiAtIG51bWVyaWNGaWx0ZXJzOiBhIHN0cmluZyB0aGF0IGNvbnRhaW5zIHRoZSBsaXN0IG9mIG51bWVyaWMgZmlsdGVycyB5b3Ugd2FudCB0b1xuICAgICAgICAgICAgICogYXBwbHkgc2VwYXJhdGVkIGJ5IGEgY29tbWEuXG4gICAgICAgICAgICAgKiAgIFRoZSBzeW50YXggb2Ygb25lIGZpbHRlciBpcyBgYXR0cmlidXRlTmFtZWAgZm9sbG93ZWQgYnkgYG9wZXJhbmRgIGZvbGxvd2VkIGJ5IGB2YWx1ZWAuXG4gICAgICAgICAgICAgKiAgIFN1cHBvcnRlZCBvcGVyYW5kcyBhcmUgYDxgLCBgPD1gLCBgPWAsIGA+YCBhbmQgYD49YC5cbiAgICAgICAgICAgICAqICAgWW91IGNhbiBoYXZlIG11bHRpcGxlIGNvbmRpdGlvbnMgb24gb25lIGF0dHJpYnV0ZSBsaWtlIGZvciBleGFtcGxlIG51bWVyaWNGaWx0ZXJzPXByaWNlPjEwMCxwcmljZTwxMDAwLlxuICAgICAgICAgICAgICogICBZb3UgY2FuIGFsc28gdXNlIGFuIGFycmF5IChmb3IgZXhhbXBsZSBudW1lcmljRmlsdGVyczogW1wicHJpY2U+MTAwXCIsXCJwcmljZTwxMDAwXCJdKS5cbiAgICAgICAgICAgICAqIC0gdGFnRmlsdGVyczogZmlsdGVyIHRoZSBxdWVyeSBieSBhIHNldCBvZiB0YWdzLiBZb3UgY2FuIEFORCB0YWdzIGJ5IHNlcGFyYXRpbmcgdGhlbSBieSBjb21tYXMuXG4gICAgICAgICAgICAgKiAgIFRvIE9SIHRhZ3MsIHlvdSBtdXN0IGFkZCBwYXJlbnRoZXNlcy4gRm9yIGV4YW1wbGUsIHRhZ3M9dGFnMSwodGFnMix0YWczKSBtZWFucyB0YWcxIEFORCAodGFnMiBPUiB0YWczKS5cbiAgICAgICAgICAgICAqICAgWW91IGNhbiBhbHNvIHVzZSBhbiBhcnJheSwgZm9yIGV4YW1wbGUgdGFnRmlsdGVyczogW1widGFnMVwiLFtcInRhZzJcIixcInRhZzNcIl1dXG4gICAgICAgICAgICAgKiAgIG1lYW5zIHRhZzEgQU5EICh0YWcyIE9SIHRhZzMpLlxuICAgICAgICAgICAgICogICBBdCBpbmRleGluZywgdGFncyBzaG91bGQgYmUgYWRkZWQgaW4gdGhlIF90YWdzKiogYXR0cmlidXRlXG4gICAgICAgICAgICAgKiAgIG9mIG9iamVjdHMgKGZvciBleGFtcGxlIHtcIl90YWdzXCI6W1widGFnMVwiLFwidGFnMlwiXX0pLlxuICAgICAgICAgICAgICogLSBmYWNldEZpbHRlcnM6IGZpbHRlciB0aGUgcXVlcnkgYnkgYSBsaXN0IG9mIGZhY2V0cy5cbiAgICAgICAgICAgICAqICAgRmFjZXRzIGFyZSBzZXBhcmF0ZWQgYnkgY29tbWFzIGFuZCBlYWNoIGZhY2V0IGlzIGVuY29kZWQgYXMgYGF0dHJpYnV0ZU5hbWU6dmFsdWVgLlxuICAgICAgICAgICAgICogICBGb3IgZXhhbXBsZTogYGZhY2V0RmlsdGVycz1jYXRlZ29yeTpCb29rLGF1dGhvcjpKb2huJTIwRG9lYC5cbiAgICAgICAgICAgICAqICAgWW91IGNhbiBhbHNvIHVzZSBhbiBhcnJheSAoZm9yIGV4YW1wbGUgYFtcImNhdGVnb3J5OkJvb2tcIixcImF1dGhvcjpKb2huJTIwRG9lXCJdYCkuXG4gICAgICAgICAgICAgKiAtIGZhY2V0czogTGlzdCBvZiBvYmplY3QgYXR0cmlidXRlcyB0aGF0IHlvdSB3YW50IHRvIHVzZSBmb3IgZmFjZXRpbmcuXG4gICAgICAgICAgICAgKiAgIENvbW1hIHNlcGFyYXRlZCBsaXN0OiBgXCJjYXRlZ29yeSxhdXRob3JcImAgb3IgYXJyYXkgYFsnY2F0ZWdvcnknLCdhdXRob3InXWBcbiAgICAgICAgICAgICAqICAgT25seSBhdHRyaWJ1dGVzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIGluICoqYXR0cmlidXRlc0ZvckZhY2V0aW5nKiogaW5kZXggc2V0dGluZ1xuICAgICAgICAgICAgICogICBjYW4gYmUgdXNlZCBpbiB0aGlzIHBhcmFtZXRlci5cbiAgICAgICAgICAgICAqICAgWW91IGNhbiBhbHNvIHVzZSBgKmAgdG8gcGVyZm9ybSBmYWNldGluZyBvbiBhbGwgYXR0cmlidXRlcyBzcGVjaWZpZWQgaW4gKiphdHRyaWJ1dGVzRm9yRmFjZXRpbmcqKi5cbiAgICAgICAgICAgICAqIC0gcXVlcnlUeXBlOiBzZWxlY3QgaG93IHRoZSBxdWVyeSB3b3JkcyBhcmUgaW50ZXJwcmV0ZWQsIGl0IGNhbiBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZTpcbiAgICAgICAgICAgICAqICAgIC0gcHJlZml4QWxsOiBhbGwgcXVlcnkgd29yZHMgYXJlIGludGVycHJldGVkIGFzIHByZWZpeGVzLFxuICAgICAgICAgICAgICogICAgLSBwcmVmaXhMYXN0OiBvbmx5IHRoZSBsYXN0IHdvcmQgaXMgaW50ZXJwcmV0ZWQgYXMgYSBwcmVmaXggKGRlZmF1bHQgYmVoYXZpb3IpLFxuICAgICAgICAgICAgICogICAgLSBwcmVmaXhOb25lOiBubyBxdWVyeSB3b3JkIGlzIGludGVycHJldGVkIGFzIGEgcHJlZml4LiBUaGlzIG9wdGlvbiBpcyBub3QgcmVjb21tZW5kZWQuXG4gICAgICAgICAgICAgKiAtIG9wdGlvbmFsV29yZHM6IGEgc3RyaW5nIHRoYXQgY29udGFpbnMgdGhlIGxpc3Qgb2Ygd29yZHMgdGhhdCBzaG91bGRcbiAgICAgICAgICAgICAqIGJlIGNvbnNpZGVyZWQgYXMgb3B0aW9uYWwgd2hlbiBmb3VuZCBpbiB0aGUgcXVlcnkuXG4gICAgICAgICAgICAgKiAgIENvbW1hIHNlcGFyYXRlZCBhbmQgYXJyYXkgYXJlIGFjY2VwdGVkLlxuICAgICAgICAgICAgICogLSBkaXN0aW5jdDogSWYgc2V0IHRvIDEsIGVuYWJsZSB0aGUgZGlzdGluY3QgZmVhdHVyZSAoZGlzYWJsZWQgYnkgZGVmYXVsdClcbiAgICAgICAgICAgICAqIGlmIHRoZSBhdHRyaWJ1dGVGb3JEaXN0aW5jdCBpbmRleCBzZXR0aW5nIGlzIHNldC5cbiAgICAgICAgICAgICAqICAgVGhpcyBmZWF0dXJlIGlzIHNpbWlsYXIgdG8gdGhlIFNRTCBcImRpc3RpbmN0XCIga2V5d29yZDogd2hlbiBlbmFibGVkXG4gICAgICAgICAgICAgKiAgIGluIGEgcXVlcnkgd2l0aCB0aGUgZGlzdGluY3Q9MSBwYXJhbWV0ZXIsXG4gICAgICAgICAgICAgKiAgIGFsbCBoaXRzIGNvbnRhaW5pbmcgYSBkdXBsaWNhdGUgdmFsdWUgZm9yIHRoZSBhdHRyaWJ1dGVGb3JEaXN0aW5jdCBhdHRyaWJ1dGUgYXJlIHJlbW92ZWQgZnJvbSByZXN1bHRzLlxuICAgICAgICAgICAgICogICBGb3IgZXhhbXBsZSwgaWYgdGhlIGNob3NlbiBhdHRyaWJ1dGUgaXMgc2hvd19uYW1lIGFuZCBzZXZlcmFsIGhpdHMgaGF2ZVxuICAgICAgICAgICAgICogICB0aGUgc2FtZSB2YWx1ZSBmb3Igc2hvd19uYW1lLCB0aGVuIG9ubHkgdGhlIGJlc3RcbiAgICAgICAgICAgICAqICAgb25lIGlzIGtlcHQgYW5kIG90aGVycyBhcmUgcmVtb3ZlZC5cbiAgICAgICAgICAgICAqIC0gcmVzdHJpY3RTZWFyY2hhYmxlQXR0cmlidXRlczogTGlzdCBvZiBhdHRyaWJ1dGVzIHlvdSB3YW50IHRvIHVzZSBmb3JcbiAgICAgICAgICAgICAqIHRleHR1YWwgc2VhcmNoIChtdXN0IGJlIGEgc3Vic2V0IG9mIHRoZSBhdHRyaWJ1dGVzVG9JbmRleCBpbmRleCBzZXR0aW5nKVxuICAgICAgICAgICAgICogZWl0aGVyIGNvbW1hIHNlcGFyYXRlZCBvciBhcyBhbiBhcnJheVxuICAgICAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrIHRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50czpcbiAgICAgICAgICAgICAqICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpLiBJZiBmYWxzZSwgdGhlIGNvbnRlbnQgY29udGFpbnMgdGhlIGVycm9yLlxuICAgICAgICAgICAgICogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgY29udGFpbnMgdGhlIGxpc3Qgb2YgcmVzdWx0cy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2VhcmNoOiBmdW5jdGlvbihxdWVyeSwgYXJncywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyB3YXJuIFYyIHVzZXJzIG9uIGhvdyB0byBzZWFyY2hcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBhcmdzID09PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY2FsbGJhY2sgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC5zZWFyY2gocXVlcnksIHBhcmFtcywgY2IpXG4gICAgICAgICAgICAgICAgICAgIC8vIC5zZWFyY2goY2IsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5BbGdvbGlhU2VhcmNoRXJyb3IoJ2luZGV4LnNlYXJjaCB1c2FnZSBpcyBpbmRleC5zZWFyY2gocXVlcnksIHBhcmFtcywgY2IpJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgdHlwZW9mIHF1ZXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC5zZWFyY2goKSwgLnNlYXJjaChjYilcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBxdWVyeTtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSAnJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgdHlwZW9mIGFyZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gLnNlYXJjaChxdWVyeS9hcmdzKSwgLnNlYXJjaChxdWVyeSwgY2IpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyAuc2VhcmNoKGFyZ3MpLCBjYXJlZnVsOiB0eXBlb2YgbnVsbCA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0JyAmJiBxdWVyeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gcXVlcnk7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocXVlcnkgPT09IHVuZGVmaW5lZCB8fCBxdWVyeSA9PT0gbnVsbCkgeyAvLyAuc2VhcmNoKHVuZGVmaW5lZC9udWxsKVxuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9ICcnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSAnJztcblxuICAgICAgICAgICAgICAgIGlmIChxdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyArPSAncXVlcnk9JyArIGVuY29kZVVSSUNvbXBvbmVudChxdWVyeSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBgX2dldFNlYXJjaFBhcmFtc2Agd2lsbCBhdWdtZW50IHBhcmFtcywgZG8gbm90IGJlIGZvb2xlZCBieSB0aGUgPSB2ZXJzdXMgKz0gZnJvbSBwcmV2aW91cyBpZlxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB0aGlzLmFzLl9nZXRTZWFyY2hQYXJhbXMoYXJncywgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VhcmNoKHBhcmFtcywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEJyb3dzZSBpbmRleCBjb250ZW50LiBUaGUgcmVzcG9uc2UgY29udGVudCB3aWxsIGhhdmUgYSBgY3Vyc29yYCBwcm9wZXJ0eSB0aGF0IHlvdSBjYW4gdXNlXG4gICAgICAgICAgICAgKiB0byBicm93c2Ugc3Vic2VxdWVudCBwYWdlcyBmb3IgdGhpcyBxdWVyeS4gVXNlIGBpbmRleC5icm93c2VOZXh0KGN1cnNvcilgIHdoZW4geW91IHdhbnQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IC0gVGhlIGZ1bGwgdGV4dCBxdWVyeVxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtxdWVyeVBhcmFtZXRlcnNdIC0gQW55IHNlYXJjaCBxdWVyeSBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBUaGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiAgICAgICAgICAgICAqICAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICAgICAgICAgICAgICogICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB3aXRoIHRoZSBicm93c2UgcmVzdWx0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfHVuZGVmaW5lZH0gUmV0dXJucyBhIHByb21pc2UgaWYgbm8gY2FsbGJhY2sgZ2l2ZW5cbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiBpbmRleC5icm93c2UoJ2Nvb2wgc29uZ3MnLCB7XG4gICAgICAgICAgICAgKiAgIHRhZ0ZpbHRlcnM6ICdwdWJsaWMsY29tbWVudHMnLFxuICAgICAgICAgICAgICogICBoaXRzUGVyUGFnZTogNTAwXG4gICAgICAgICAgICAgKiB9LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbGdvbGlhLmNvbS9kb2MvcmVzdF9hcGkjQnJvd3NlfEFsZ29saWEgUkVTVCBBUEkgRG9jdW1lbnRhdGlvbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gcHJlIDMuNS4wIHVzYWdlLCBiYWNrd2FyZCBjb21wYXRpYmxlXG4gICAgICAgICAgICAvLyBicm93c2U6IGZ1bmN0aW9uKHBhZ2UsIGhpdHNQZXJQYWdlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgYnJvd3NlOiBmdW5jdGlvbihxdWVyeSwgcXVlcnlQYXJhbWV0ZXJzLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBtZXJnZSA9IHJlcXVpcmUoNTcpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4T2JqID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciBwYWdlO1xuICAgICAgICAgICAgICAgIHZhciBoaXRzUGVyUGFnZTtcblxuICAgICAgICAgICAgICAgIC8vIHdlIGNoZWNrIHZhcmlhZGljIGNhbGxzIHRoYXQgYXJlIG5vdCB0aGUgb25lIGRlZmluZWRcbiAgICAgICAgICAgICAgICAvLyAuYnJvd3NlKCkvLmJyb3dzZShmbilcbiAgICAgICAgICAgICAgICAvLyA9PiBwYWdlID0gMFxuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBwYWdlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gLmJyb3dzZSgyKS8uYnJvd3NlKDIsIDEwKS8uYnJvd3NlKDIsIGZuKS8uYnJvd3NlKDIsIDEwLCBmbilcbiAgICAgICAgICAgICAgICAgICAgcGFnZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXRzUGVyUGFnZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdHNQZXJQYWdlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyAuYnJvd3NlKHF1ZXJ5UGFyYW1ldGVycykvLmJyb3dzZShxdWVyeVBhcmFtZXRlcnMsIGNiKVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdzdHJpbmcnICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gLmJyb3dzZShxdWVyeSwgY2IpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGl0J3MgYSAuYnJvd3NlKHF1ZXJ5KS8uYnJvd3NlKHF1ZXJ5LCBxdWVyeVBhcmFtZXRlcnMpLy5icm93c2UocXVlcnksIHF1ZXJ5UGFyYW1ldGVycywgY2IpXG5cbiAgICAgICAgICAgICAgICAvLyBnZXQgc2VhcmNoIHF1ZXJ5IHBhcmFtZXRlcnMgY29tYmluaW5nIHZhcmlvdXMgcG9zc2libGUgY2FsbHNcbiAgICAgICAgICAgICAgICAvLyB0byAuYnJvd3NlKCk7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzID0gbWVyZ2Uoe30sIHF1ZXJ5UGFyYW1ldGVycyB8fCB7fSwge1xuICAgICAgICAgICAgICAgICAgICBwYWdlOiBwYWdlLFxuICAgICAgICAgICAgICAgICAgICBoaXRzUGVyUGFnZTogaGl0c1BlclBhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuYXMuX2dldFNlYXJjaFBhcmFtcyhxdWVyeVBhcmFtZXRlcnMsICcnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy9icm93c2U/JyArIHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdFR5cGU6ICdyZWFkJyxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogQ29udGludWUgYnJvd3NpbmcgZnJvbSBhIHByZXZpb3VzIHBvc2l0aW9uIChjdXJzb3IpLCBvYnRhaW5lZCB2aWEgYSBjYWxsIHRvIGAuYnJvd3NlKClgLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSAtIFRoZSBmdWxsIHRleHQgcXVlcnlcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcXVlcnlQYXJhbWV0ZXJzXSAtIEFueSBzZWFyY2ggcXVlcnkgcGFyYW1ldGVyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gVGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4gICAgICAgICAgICAgKiAgIGVycm9yOiBudWxsIG9yIEVycm9yKCdtZXNzYWdlJylcbiAgICAgICAgICAgICAqICAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgd2l0aCB0aGUgYnJvd3NlIHJlc3VsdFxuICAgICAgICAgICAgICogQHJldHVybiB7UHJvbWlzZXx1bmRlZmluZWR9IFJldHVybnMgYSBwcm9taXNlIGlmIG5vIGNhbGxiYWNrIGdpdmVuXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogaW5kZXguYnJvd3NlRnJvbSgnMTRsa2ZzYWtsMzInLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbGdvbGlhLmNvbS9kb2MvcmVzdF9hcGkjQnJvd3NlfEFsZ29saWEgUkVTVCBBUEkgRG9jdW1lbnRhdGlvbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYnJvd3NlRnJvbTogZnVuY3Rpb24oY3Vyc29yLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL2Jyb3dzZT9jdXJzb3I9JyArIGVuY29kZVVSSUNvbXBvbmVudChjdXJzb3IpLFxuICAgICAgICAgICAgICAgICAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBCcm93c2UgYWxsIGNvbnRlbnQgZnJvbSBhbiBpbmRleCB1c2luZyBldmVudHMuIEJhc2ljYWxseSB0aGlzIHdpbGwgZG9cbiAgICAgICAgICAgICAqIC5icm93c2UoKSAtPiAuYnJvd3NlRnJvbSAtPiAuYnJvd3NlRnJvbSAtPiAuLiB1bnRpbCBhbGwgdGhlIHJlc3VsdHMgYXJlIHJldHVybmVkXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IC0gVGhlIGZ1bGwgdGV4dCBxdWVyeVxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtxdWVyeVBhcmFtZXRlcnNdIC0gQW55IHNlYXJjaCBxdWVyeSBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge0V2ZW50RW1pdHRlcn1cbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiB2YXIgYnJvd3NlciA9IGluZGV4LmJyb3dzZUFsbCgnY29vbCBzb25ncycsIHtcbiAgICAgICAgICAgICAqICAgdGFnRmlsdGVyczogJ3B1YmxpYyxjb21tZW50cycsXG4gICAgICAgICAgICAgKiAgIGhpdHNQZXJQYWdlOiA1MDBcbiAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIGJyb3dzZXIub24oJ3Jlc3VsdCcsIGZ1bmN0aW9uIHJlc3VsdENhbGxiYWNrKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAqICAgY29uc29sZS5sb2coY29udGVudC5oaXRzKTtcbiAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIC8vIGlmIGFueSBlcnJvciBvY2N1cnMsIHlvdSBnZXQgaXRcbiAgICAgICAgICAgICAqIGJyb3dzZXIub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgKiAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIC8vIHdoZW4geW91IGhhdmUgYnJvd3NlZCB0aGUgd2hvbGUgaW5kZXgsIHlvdSBnZXQgdGhpcyBldmVudFxuICAgICAgICAgICAgICogYnJvd3Nlci5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCcpO1xuICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogLy8gYXQgYW55IHBvaW50IGlmIHlvdSB3YW50IHRvIHN0b3AgdGhlIGJyb3dzaW5nIHByb2Nlc3MsIHlvdSBjYW4gc3RvcCBpdCBtYW51YWxseVxuICAgICAgICAgICAgICogLy8gb3RoZXJ3aXNlIGl0IHdpbGwgZ28gb24gYW5kIG9uXG4gICAgICAgICAgICAgKiBicm93c2VyLnN0b3AoKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbGdvbGlhLmNvbS9kb2MvcmVzdF9hcGkjQnJvd3NlfEFsZ29saWEgUkVTVCBBUEkgRG9jdW1lbnRhdGlvbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYnJvd3NlQWxsOiBmdW5jdGlvbihxdWVyeSwgcXVlcnlQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzID0gcXVlcnk7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBtZXJnZSA9IHJlcXVpcmUoNTcpO1xuXG4gICAgICAgICAgICAgICAgdmFyIEluZGV4QnJvd3NlciA9IHJlcXVpcmUoNjEpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGJyb3dzZXIgPSBuZXcgSW5kZXhCcm93c2VyKCk7XG4gICAgICAgICAgICAgICAgdmFyIGNsaWVudCA9IHRoaXMuYXM7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gY2xpZW50Ll9nZXRTZWFyY2hQYXJhbXMoXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlKHt9LCBxdWVyeVBhcmFtZXRlcnMgfHwge30sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVxuICAgICAgICAgICAgICAgICAgICB9KSwgJydcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgYnJvd3NpbmdcbiAgICAgICAgICAgICAgICBicm93c2VMb29wKCk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBicm93c2VMb29wKGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnJvd3Nlci5fc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXJ5U3RyaW5nO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSAnY3Vyc29yPScgKyBlbmNvZGVVUklDb21wb25lbnQoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gcGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2xpZW50Ll9qc29uUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4LmluZGV4TmFtZSkgKyAnL2Jyb3dzZT8nICsgcXVlcnlTdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGJyb3dzZUNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJyb3dzZUNhbGxiYWNrKGVyciwgY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnJvd3Nlci5fc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJvd3Nlci5fZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyb3dzZXIuX3Jlc3VsdChjb250ZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBubyBjdXJzb3IgbWVhbnMgd2UgYXJlIGZpbmlzaGVkIGJyb3dzaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50LmN1cnNvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicm93c2VyLl9lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyb3dzZUxvb3AoY29udGVudC5jdXJzb3IpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBicm93c2VyO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEdldCBhIFR5cGVhaGVhZC5qcyBhZGFwdGVyXG4gICAgICAgICAgICAgKiBAcGFyYW0gc2VhcmNoUGFyYW1zIGNvbnRhaW5zIGFuIG9iamVjdCB3aXRoIHF1ZXJ5IHBhcmFtZXRlcnMgKHNlZSBzZWFyY2ggZm9yIGRldGFpbHMpXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHR0QWRhcHRlcjogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiB0dEFkYXB0ZXIocXVlcnksIHN5bmNDYiwgYXN5bmNDYikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2I7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhc3luY0NiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0eXBlYWhlYWQgMC4xMVxuICAgICAgICAgICAgICAgICAgICAgICAgY2IgPSBhc3luY0NiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJlIHR5cGVhaGVhZCAwLjExXG4gICAgICAgICAgICAgICAgICAgICAgICBjYiA9IHN5bmNDYjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VhcmNoKHF1ZXJ5LCBwYXJhbXMsIGZ1bmN0aW9uIHNlYXJjaERvbmUoZXJyLCBjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKGNvbnRlbnQuaGl0cyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogV2FpdCB0aGUgcHVibGljYXRpb24gb2YgYSB0YXNrIG9uIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAgICAgKiBBbGwgc2VydmVyIHRhc2sgYXJlIGFzeW5jaHJvbm91cyBhbmQgeW91IGNhbiBjaGVjayB3aXRoIHRoaXMgbWV0aG9kIHRoYXQgdGhlIHRhc2sgaXMgcHVibGlzaGVkLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB0YXNrSUQgdGhlIGlkIG9mIHRoZSB0YXNrIHJldHVybmVkIGJ5IHNlcnZlclxuICAgICAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrIHRoZSByZXN1bHQgY2FsbGJhY2sgd2l0aCB3aXRoIHR3byBhcmd1bWVudHM6XG4gICAgICAgICAgICAgKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICAgICAgICAgICAgICogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHRoYXQgY29udGFpbnMgdGhlIGxpc3Qgb2YgcmVzdWx0c1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB3YWl0VGFzazogZnVuY3Rpb24odGFza0lELCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vIHdhaXQgbWluaW11bSAxMDBtcyBiZWZvcmUgcmV0cnlpbmdcbiAgICAgICAgICAgICAgICB2YXIgYmFzZURlbGF5ID0gMTAwO1xuICAgICAgICAgICAgICAgIC8vIHdhaXQgbWF4aW11bSA1cyBiZWZvcmUgcmV0cnlpbmdcbiAgICAgICAgICAgICAgICB2YXIgbWF4RGVsYXkgPSA1MDAwO1xuICAgICAgICAgICAgICAgIHZhciBsb29wID0gMDtcblxuICAgICAgICAgICAgICAgIC8vIHdhaXRUYXNrKCkgbXVzdCBiZSBoYW5kbGVkIGRpZmZlcmVudGx5IGZyb20gb3RoZXIgbWV0aG9kcyxcbiAgICAgICAgICAgICAgICAvLyBpdCdzIGEgcmVjdXJzaXZlIG1ldGhvZCB1c2luZyBhIHRpbWVvdXRcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBjbGllbnQgPSBpbmRleE9iai5hcztcblxuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gcmV0cnlMb29wKCk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByZXRyeUxvb3AoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGllbnQuX2pzb25SZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnL3Rhc2svJyArIHRhc2tJRFxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIHN1Y2Nlc3MoY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9vcCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGF5ID0gYmFzZURlbGF5ICogbG9vcCAqIGxvb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsYXkgPiBtYXhEZWxheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gbWF4RGVsYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50LnN0YXR1cyAhPT0gJ3B1Ymxpc2hlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50Ll9wcm9taXNlLmRlbGF5KGRlbGF5KS50aGVuKHJldHJ5TG9vcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2IsIGZhaWx1cmVDYik7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzdWNjZXNzQ2IoY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICBleGl0UHJvbWlzZShmdW5jdGlvbiBleGl0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGNsaWVudC5fc2V0VGltZW91dCB8fCBzZXRUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBmYWlsdXJlQ2IoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXRQcm9taXNlKGZ1bmN0aW9uIGV4aXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9LCBjbGllbnQuX3NldFRpbWVvdXQgfHwgc2V0VGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFRoaXMgZnVuY3Rpb24gZGVsZXRlcyB0aGUgaW5kZXggY29udGVudC4gU2V0dGluZ3MgYW5kIGluZGV4IHNwZWNpZmljIEFQSSBrZXlzIGFyZSBrZXB0IHVudG91Y2hlZC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgKG9wdGlvbmFsKSB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiAgICAgICAgICAgICAqICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4gICAgICAgICAgICAgKiAgY29udGVudDogdGhlIHNldHRpbmdzIG9iamVjdCBvciB0aGUgZXJyb3IgbWVzc2FnZSBpZiBhIGZhaWx1cmUgb2NjdXJlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjbGVhckluZGV4OiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleE9iaiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy9jbGVhcicsXG4gICAgICAgICAgICAgICAgICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogR2V0IHNldHRpbmdzIG9mIHRoaXMgaW5kZXhcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgKG9wdGlvbmFsKSB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiAgICAgICAgICAgICAqICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4gICAgICAgICAgICAgKiAgY29udGVudDogdGhlIHNldHRpbmdzIG9iamVjdCBvciB0aGUgZXJyb3IgbWVzc2FnZSBpZiBhIGZhaWx1cmUgb2NjdXJlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRTZXR0aW5nczogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy9zZXR0aW5ncycsXG4gICAgICAgICAgICAgICAgICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFNldCBzZXR0aW5ncyBmb3IgdGhpcyBpbmRleFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBzZXR0aWducyB0aGUgc2V0dGluZ3Mgb2JqZWN0IHRoYXQgY2FuIGNvbnRhaW5zIDpcbiAgICAgICAgICAgICAqIC0gbWluV29yZFNpemVmb3IxVHlwbzogKGludGVnZXIpIHRoZSBtaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIGFjY2VwdCBvbmUgdHlwbyAoZGVmYXVsdCA9IDMpLlxuICAgICAgICAgICAgICogLSBtaW5Xb3JkU2l6ZWZvcjJUeXBvczogKGludGVnZXIpIHRoZSBtaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIGFjY2VwdCB0d28gdHlwb3MgKGRlZmF1bHQgPSA3KS5cbiAgICAgICAgICAgICAqIC0gaGl0c1BlclBhZ2U6IChpbnRlZ2VyKSB0aGUgbnVtYmVyIG9mIGhpdHMgcGVyIHBhZ2UgKGRlZmF1bHQgPSAxMCkuXG4gICAgICAgICAgICAgKiAtIGF0dHJpYnV0ZXNUb1JldHJpZXZlOiAoYXJyYXkgb2Ygc3RyaW5ncykgZGVmYXVsdCBsaXN0IG9mIGF0dHJpYnV0ZXMgdG8gcmV0cmlldmUgaW4gb2JqZWN0cy5cbiAgICAgICAgICAgICAqICAgSWYgc2V0IHRvIG51bGwsIGFsbCBhdHRyaWJ1dGVzIGFyZSByZXRyaWV2ZWQuXG4gICAgICAgICAgICAgKiAtIGF0dHJpYnV0ZXNUb0hpZ2hsaWdodDogKGFycmF5IG9mIHN0cmluZ3MpIGRlZmF1bHQgbGlzdCBvZiBhdHRyaWJ1dGVzIHRvIGhpZ2hsaWdodC5cbiAgICAgICAgICAgICAqICAgSWYgc2V0IHRvIG51bGwsIGFsbCBpbmRleGVkIGF0dHJpYnV0ZXMgYXJlIGhpZ2hsaWdodGVkLlxuICAgICAgICAgICAgICogLSBhdHRyaWJ1dGVzVG9TbmlwcGV0Kio6IChhcnJheSBvZiBzdHJpbmdzKSBkZWZhdWx0IGxpc3Qgb2YgYXR0cmlidXRlcyB0byBzbmlwcGV0IGFsb25nc2lkZSB0aGUgbnVtYmVyXG4gICAgICAgICAgICAgKiBvZiB3b3JkcyB0byByZXR1cm4gKHN5bnRheCBpcyBhdHRyaWJ1dGVOYW1lOm5iV29yZHMpLlxuICAgICAgICAgICAgICogICBCeSBkZWZhdWx0IG5vIHNuaXBwZXQgaXMgY29tcHV0ZWQuIElmIHNldCB0byBudWxsLCBubyBzbmlwcGV0IGlzIGNvbXB1dGVkLlxuICAgICAgICAgICAgICogLSBhdHRyaWJ1dGVzVG9JbmRleDogKGFycmF5IG9mIHN0cmluZ3MpIHRoZSBsaXN0IG9mIGZpZWxkcyB5b3Ugd2FudCB0byBpbmRleC5cbiAgICAgICAgICAgICAqICAgSWYgc2V0IHRvIG51bGwsIGFsbCB0ZXh0dWFsIGFuZCBudW1lcmljYWwgYXR0cmlidXRlcyBvZiB5b3VyIG9iamVjdHMgYXJlIGluZGV4ZWQsXG4gICAgICAgICAgICAgKiAgIGJ1dCB5b3Ugc2hvdWxkIHVwZGF0ZSBpdCB0byBnZXQgb3B0aW1hbCByZXN1bHRzLlxuICAgICAgICAgICAgICogICBUaGlzIHBhcmFtZXRlciBoYXMgdHdvIGltcG9ydGFudCB1c2VzOlxuICAgICAgICAgICAgICogICAgIC0gTGltaXQgdGhlIGF0dHJpYnV0ZXMgdG8gaW5kZXg6IEZvciBleGFtcGxlIGlmIHlvdSBzdG9yZSBhIGJpbmFyeSBpbWFnZSBpbiBiYXNlNjQsXG4gICAgICAgICAgICAgKiAgICAgeW91IHdhbnQgdG8gc3RvcmUgaXQgYW5kIGJlIGFibGUgdG9cbiAgICAgICAgICAgICAqICAgICAgIHJldHJpZXZlIGl0IGJ1dCB5b3UgZG9uJ3Qgd2FudCB0byBzZWFyY2ggaW4gdGhlIGJhc2U2NCBzdHJpbmcuXG4gICAgICAgICAgICAgKiAgICAgLSBDb250cm9sIHBhcnQgb2YgdGhlIHJhbmtpbmcqOiAoc2VlIHRoZSByYW5raW5nIHBhcmFtZXRlciBmb3IgZnVsbCBleHBsYW5hdGlvbilcbiAgICAgICAgICAgICAqICAgICBNYXRjaGVzIGluIGF0dHJpYnV0ZXMgYXQgdGhlIGJlZ2lubmluZyBvZlxuICAgICAgICAgICAgICogICAgICAgdGhlIGxpc3Qgd2lsbCBiZSBjb25zaWRlcmVkIG1vcmUgaW1wb3J0YW50IHRoYW4gbWF0Y2hlcyBpbiBhdHRyaWJ1dGVzIGZ1cnRoZXIgZG93biB0aGUgbGlzdC5cbiAgICAgICAgICAgICAqICAgICAgIEluIG9uZSBhdHRyaWJ1dGUsIG1hdGNoaW5nIHRleHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXR0cmlidXRlIHdpbGwgYmVcbiAgICAgICAgICAgICAqICAgICAgIGNvbnNpZGVyZWQgbW9yZSBpbXBvcnRhbnQgdGhhbiB0ZXh0IGFmdGVyLCB5b3UgY2FuIGRpc2FibGVcbiAgICAgICAgICAgICAqICAgICAgIHRoaXMgYmVoYXZpb3IgaWYgeW91IGFkZCB5b3VyIGF0dHJpYnV0ZSBpbnNpZGUgYHVub3JkZXJlZChBdHRyaWJ1dGVOYW1lKWAsXG4gICAgICAgICAgICAgKiAgICAgICBmb3IgZXhhbXBsZSBhdHRyaWJ1dGVzVG9JbmRleDogW1widGl0bGVcIiwgXCJ1bm9yZGVyZWQodGV4dClcIl0uXG4gICAgICAgICAgICAgKiAtIGF0dHJpYnV0ZXNGb3JGYWNldGluZzogKGFycmF5IG9mIHN0cmluZ3MpIFRoZSBsaXN0IG9mIGZpZWxkcyB5b3Ugd2FudCB0byB1c2UgZm9yIGZhY2V0aW5nLlxuICAgICAgICAgICAgICogICBBbGwgc3RyaW5ncyBpbiB0aGUgYXR0cmlidXRlIHNlbGVjdGVkIGZvciBmYWNldGluZyBhcmUgZXh0cmFjdGVkIGFuZCBhZGRlZCBhcyBhIGZhY2V0LlxuICAgICAgICAgICAgICogICBJZiBzZXQgdG8gbnVsbCwgbm8gYXR0cmlidXRlIGlzIHVzZWQgZm9yIGZhY2V0aW5nLlxuICAgICAgICAgICAgICogLSBhdHRyaWJ1dGVGb3JEaXN0aW5jdDogKHN0cmluZykgVGhlIGF0dHJpYnV0ZSBuYW1lIHVzZWQgZm9yIHRoZSBEaXN0aW5jdCBmZWF0dXJlLlxuICAgICAgICAgICAgICogVGhpcyBmZWF0dXJlIGlzIHNpbWlsYXIgdG8gdGhlIFNRTCBcImRpc3RpbmN0XCIga2V5d29yZDogd2hlbiBlbmFibGVkXG4gICAgICAgICAgICAgKiAgIGluIHF1ZXJ5IHdpdGggdGhlIGRpc3RpbmN0PTEgcGFyYW1ldGVyLCBhbGwgaGl0cyBjb250YWluaW5nIGEgZHVwbGljYXRlXG4gICAgICAgICAgICAgKiAgIHZhbHVlIGZvciB0aGlzIGF0dHJpYnV0ZSBhcmUgcmVtb3ZlZCBmcm9tIHJlc3VsdHMuXG4gICAgICAgICAgICAgKiAgIEZvciBleGFtcGxlLCBpZiB0aGUgY2hvc2VuIGF0dHJpYnV0ZSBpcyBzaG93X25hbWUgYW5kIHNldmVyYWwgaGl0cyBoYXZlXG4gICAgICAgICAgICAgKiAgIHRoZSBzYW1lIHZhbHVlIGZvciBzaG93X25hbWUsIHRoZW4gb25seSB0aGUgYmVzdCBvbmUgaXMga2VwdCBhbmQgb3RoZXJzIGFyZSByZW1vdmVkLlxuICAgICAgICAgICAgICogLSByYW5raW5nOiAoYXJyYXkgb2Ygc3RyaW5ncykgY29udHJvbHMgdGhlIHdheSByZXN1bHRzIGFyZSBzb3J0ZWQuXG4gICAgICAgICAgICAgKiAgIFdlIGhhdmUgc2l4IGF2YWlsYWJsZSBjcml0ZXJpYTpcbiAgICAgICAgICAgICAqICAgIC0gdHlwbzogc29ydCBhY2NvcmRpbmcgdG8gbnVtYmVyIG9mIHR5cG9zLFxuICAgICAgICAgICAgICogICAgLSBnZW86IHNvcnQgYWNjb3JkaW5nIHRvIGRlY3JlYXNzaW5nIGRpc3RhbmNlIHdoZW4gcGVyZm9ybWluZyBhIGdlby1sb2NhdGlvbiBiYXNlZCBzZWFyY2gsXG4gICAgICAgICAgICAgKiAgICAtIHByb3hpbWl0eTogc29ydCBhY2NvcmRpbmcgdG8gdGhlIHByb3hpbWl0eSBvZiBxdWVyeSB3b3JkcyBpbiBoaXRzLFxuICAgICAgICAgICAgICogICAgLSBhdHRyaWJ1dGU6IHNvcnQgYWNjb3JkaW5nIHRvIHRoZSBvcmRlciBvZiBhdHRyaWJ1dGVzIGRlZmluZWQgYnkgYXR0cmlidXRlc1RvSW5kZXgsXG4gICAgICAgICAgICAgKiAgICAtIGV4YWN0OlxuICAgICAgICAgICAgICogICAgICAgIC0gaWYgdGhlIHVzZXIgcXVlcnkgY29udGFpbnMgb25lIHdvcmQ6IHNvcnQgb2JqZWN0cyBoYXZpbmcgYW4gYXR0cmlidXRlXG4gICAgICAgICAgICAgKiAgICAgICAgdGhhdCBpcyBleGFjdGx5IHRoZSBxdWVyeSB3b3JkIGJlZm9yZSBvdGhlcnMuXG4gICAgICAgICAgICAgKiAgICAgICAgICBGb3IgZXhhbXBsZSBpZiB5b3Ugc2VhcmNoIGZvciB0aGUgXCJWXCIgVFYgc2hvdywgeW91IHdhbnQgdG8gZmluZCBpdFxuICAgICAgICAgICAgICogICAgICAgICAgd2l0aCB0aGUgXCJWXCIgcXVlcnkgYW5kIGF2b2lkIHRvIGhhdmUgYWxsIHBvcHVsYXIgVFZcbiAgICAgICAgICAgICAqICAgICAgICAgIHNob3cgc3RhcnRpbmcgYnkgdGhlIHYgbGV0dGVyIGJlZm9yZSBpdC5cbiAgICAgICAgICAgICAqICAgICAgICAtIGlmIHRoZSB1c2VyIHF1ZXJ5IGNvbnRhaW5zIG11bHRpcGxlIHdvcmRzOiBzb3J0IGFjY29yZGluZyB0byB0aGVcbiAgICAgICAgICAgICAqICAgICAgICBudW1iZXIgb2Ygd29yZHMgdGhhdCBtYXRjaGVkIGV4YWN0bHkgKGFuZCBub3QgYXMgYSBwcmVmaXgpLlxuICAgICAgICAgICAgICogICAgLSBjdXN0b206IHNvcnQgYWNjb3JkaW5nIHRvIGEgdXNlciBkZWZpbmVkIGZvcm11bGEgc2V0IGluICoqY3VzdG9tUmFua2luZyoqIGF0dHJpYnV0ZS5cbiAgICAgICAgICAgICAqICAgVGhlIHN0YW5kYXJkIG9yZGVyIGlzIFtcInR5cG9cIiwgXCJnZW9cIiwgXCJwcm94aW1pdHlcIiwgXCJhdHRyaWJ1dGVcIiwgXCJleGFjdFwiLCBcImN1c3RvbVwiXVxuICAgICAgICAgICAgICogLSBjdXN0b21SYW5raW5nOiAoYXJyYXkgb2Ygc3RyaW5ncykgbGV0cyB5b3Ugc3BlY2lmeSBwYXJ0IG9mIHRoZSByYW5raW5nLlxuICAgICAgICAgICAgICogICBUaGUgc3ludGF4IG9mIHRoaXMgY29uZGl0aW9uIGlzIGFuIGFycmF5IG9mIHN0cmluZ3MgY29udGFpbmluZyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgKiAgIHByZWZpeGVkIGJ5IGFzYyAoYXNjZW5kaW5nIG9yZGVyKSBvciBkZXNjIChkZXNjZW5kaW5nIG9yZGVyKSBvcGVyYXRvci5cbiAgICAgICAgICAgICAqICAgRm9yIGV4YW1wbGUgYFwiY3VzdG9tUmFua2luZ1wiID0+IFtcImRlc2MocG9wdWxhdGlvbilcIiwgXCJhc2MobmFtZSlcIl1gXG4gICAgICAgICAgICAgKiAtIHF1ZXJ5VHlwZTogU2VsZWN0IGhvdyB0aGUgcXVlcnkgd29yZHMgYXJlIGludGVycHJldGVkLCBpdCBjYW4gYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWU6XG4gICAgICAgICAgICAgKiAgIC0gcHJlZml4QWxsOiBhbGwgcXVlcnkgd29yZHMgYXJlIGludGVycHJldGVkIGFzIHByZWZpeGVzLFxuICAgICAgICAgICAgICogICAtIHByZWZpeExhc3Q6IG9ubHkgdGhlIGxhc3Qgd29yZCBpcyBpbnRlcnByZXRlZCBhcyBhIHByZWZpeCAoZGVmYXVsdCBiZWhhdmlvciksXG4gICAgICAgICAgICAgKiAgIC0gcHJlZml4Tm9uZTogbm8gcXVlcnkgd29yZCBpcyBpbnRlcnByZXRlZCBhcyBhIHByZWZpeC4gVGhpcyBvcHRpb24gaXMgbm90IHJlY29tbWVuZGVkLlxuICAgICAgICAgICAgICogLSBoaWdobGlnaHRQcmVUYWc6IChzdHJpbmcpIFNwZWNpZnkgdGhlIHN0cmluZyB0aGF0IGlzIGluc2VydGVkIGJlZm9yZVxuICAgICAgICAgICAgICogdGhlIGhpZ2hsaWdodGVkIHBhcnRzIGluIHRoZSBxdWVyeSByZXN1bHQgKGRlZmF1bHQgdG8gXCI8ZW0+XCIpLlxuICAgICAgICAgICAgICogLSBoaWdobGlnaHRQb3N0VGFnOiAoc3RyaW5nKSBTcGVjaWZ5IHRoZSBzdHJpbmcgdGhhdCBpcyBpbnNlcnRlZCBhZnRlclxuICAgICAgICAgICAgICogdGhlIGhpZ2hsaWdodGVkIHBhcnRzIGluIHRoZSBxdWVyeSByZXN1bHQgKGRlZmF1bHQgdG8gXCI8L2VtPlwiKS5cbiAgICAgICAgICAgICAqIC0gb3B0aW9uYWxXb3JkczogKGFycmF5IG9mIHN0cmluZ3MpIFNwZWNpZnkgYSBsaXN0IG9mIHdvcmRzIHRoYXQgc2hvdWxkXG4gICAgICAgICAgICAgKiBiZSBjb25zaWRlcmVkIGFzIG9wdGlvbmFsIHdoZW4gZm91bmQgaW4gdGhlIHF1ZXJ5LlxuICAgICAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrIChvcHRpb25hbCkgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4gICAgICAgICAgICAgKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICAgICAgICAgICAgICogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIG9yIHRoZSBlcnJvciBtZXNzYWdlIGlmIGEgZmFpbHVyZSBvY2N1cmVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNldFNldHRpbmdzOiBmdW5jdGlvbihzZXR0aW5ncywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhPYmogPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICAgICAgICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudChpbmRleE9iai5pbmRleE5hbWUpICsgJy9zZXR0aW5ncycsXG4gICAgICAgICAgICAgICAgICAgIGhvc3RUeXBlOiAnd3JpdGUnLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBzZXR0aW5ncyxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIExpc3QgYWxsIGV4aXN0aW5nIHVzZXIga2V5cyBhc3NvY2lhdGVkIHRvIHRoaXMgaW5kZXhcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgdGhlIHJlc3VsdCBjYWxsYmFjayBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzXG4gICAgICAgICAgICAgKiAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICAgICAgICAgICAgICogIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHdpdGggdXNlciBrZXlzIGxpc3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGlzdFVzZXJLZXlzOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleE9iaiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGluZGV4T2JqLmluZGV4TmFtZSkgKyAnL2tleXMnLFxuICAgICAgICAgICAgICAgICAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogR2V0IEFDTCBvZiBhIHVzZXIga2V5IGFzc29jaWF0ZWQgdG8gdGhpcyBpbmRleFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBrZXlcbiAgICAgICAgICAgICAqIEBwYXJhbSBjYWxsYmFjayB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiAgICAgICAgICAgICAqICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4gICAgICAgICAgICAgKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgd2l0aCB1c2VyIGtleXMgbGlzdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRVc2VyS2V5QUNMOiBmdW5jdGlvbihrZXksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgICAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcva2V5cy8nICsga2V5LFxuICAgICAgICAgICAgICAgICAgICBob3N0VHlwZTogJ3JlYWQnLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogRGVsZXRlIGFuIGV4aXN0aW5nIHVzZXIga2V5IGFzc29jaWF0ZWQgdG8gdGhpcyBpbmRleFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBrZXlcbiAgICAgICAgICAgICAqIEBwYXJhbSBjYWxsYmFjayB0aGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiAgICAgICAgICAgICAqICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4gICAgICAgICAgICAgKiAgY29udGVudDogdGhlIHNlcnZlciBhbnN3ZXIgd2l0aCB1c2VyIGtleXMgbGlzdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBkZWxldGVVc2VyS2V5OiBmdW5jdGlvbihrZXksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4T2JqID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcy5fanNvblJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgICAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQoaW5kZXhPYmouaW5kZXhOYW1lKSArICcva2V5cy8nICsga2V5LFxuICAgICAgICAgICAgICAgICAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEFkZCBhIG5ldyBBUEkga2V5IHRvIHRoaXMgaW5kZXhcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBhY2xzIC0gVGhlIGxpc3Qgb2YgQUNMIGZvciB0aGlzIGtleS4gRGVmaW5lZCBieSBhbiBhcnJheSBvZiBzdHJpbmdzIHRoYXRcbiAgICAgICAgICAgICAqICAgY2FuIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuICAgICAgICAgICAgICogICAgIC0gc2VhcmNoOiBhbGxvdyB0byBzZWFyY2ggKGh0dHBzIGFuZCBodHRwKVxuICAgICAgICAgICAgICogICAgIC0gYWRkT2JqZWN0OiBhbGxvd3MgdG8gYWRkL3VwZGF0ZSBhbiBvYmplY3QgaW4gdGhlIGluZGV4IChodHRwcyBvbmx5KVxuICAgICAgICAgICAgICogICAgIC0gZGVsZXRlT2JqZWN0IDogYWxsb3dzIHRvIGRlbGV0ZSBhbiBleGlzdGluZyBvYmplY3QgKGh0dHBzIG9ubHkpXG4gICAgICAgICAgICAgKiAgICAgLSBkZWxldGVJbmRleCA6IGFsbG93cyB0byBkZWxldGUgaW5kZXggY29udGVudCAoaHR0cHMgb25seSlcbiAgICAgICAgICAgICAqICAgICAtIHNldHRpbmdzIDogYWxsb3dzIHRvIGdldCBpbmRleCBzZXR0aW5ncyAoaHR0cHMgb25seSlcbiAgICAgICAgICAgICAqICAgICAtIGVkaXRTZXR0aW5ncyA6IGFsbG93cyB0byBjaGFuZ2UgaW5kZXggc2V0dGluZ3MgKGh0dHBzIG9ubHkpXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBPcHRpb25uYWwgcGFyYW1ldGVycyB0byBzZXQgZm9yIHRoZSBrZXlcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudmFsaWRpdHkgLSBOdW1iZXIgb2Ygc2Vjb25kcyBhZnRlciB3aGljaCB0aGUga2V5IHdpbGxcbiAgICAgICAgICAgICAqIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCAoMCBtZWFucyBubyB0aW1lIGxpbWl0IGZvciB0aGlzIGtleSlcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubWF4UXVlcmllc1BlcklQUGVySG91ciAtIE51bWJlciBvZiBBUEkgY2FsbHMgYWxsb3dlZCBmcm9tIGFuIElQIGFkZHJlc3MgcGVyIGhvdXJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubWF4SGl0c1BlclF1ZXJ5IC0gTnVtYmVyIG9mIGhpdHMgdGhpcyBBUEkga2V5IGNhbiByZXRyaWV2ZSBpbiBvbmUgY2FsbFxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5kZXNjcmlwdGlvbiAtIEEgZGVzY3JpcHRpb24gZm9yIHlvdXIga2V5XG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMucmVmZXJlcnMgLSBBIGxpc3Qgb2YgYXV0aG9yaXplZCByZWZlcmVyc1xuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcy5xdWVyeVBhcmFtZXRlcnMgLSBGb3JjZSB0aGUga2V5IHRvIHVzZSBzcGVjaWZpYyBxdWVyeSBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSByZXN1bHQgY2FsbGJhY2sgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50c1xuICAgICAgICAgICAgICogICBlcnJvcjogbnVsbCBvciBFcnJvcignbWVzc2FnZScpXG4gICAgICAgICAgICAgKiAgIGNvbnRlbnQ6IHRoZSBzZXJ2ZXIgYW5zd2VyIHdpdGggdXNlciBrZXlzIGxpc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V8dW5kZWZpbmVkfSBSZXR1cm5zIGEgcHJvbWlzZSBpZiBubyBjYWxsYmFjayBnaXZlblxuICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAqIGluZGV4LmFkZFVzZXJLZXkoWydzZWFyY2gnXSwge1xuICAgICAgICAgICAgICogICB2YWxpZGl0eTogMzAwLFxuICAgICAgICAgICAgICogICBtYXhRdWVyaWVzUGVySVBQZXJIb3VyOiAyMDAwLFxuICAgICAgICAgICAgICogICBtYXhIaXRzUGVyUXVlcnk6IDMsXG4gICAgICAgICAgICAgKiAgIGRlc2NyaXB0aW9uOiAnRWF0IHRocmVlIGZydWl0cycsXG4gICAgICAgICAgICAgKiAgIHJlZmVyZXJzOiBbJyouYWxnb2xpYS5jb20nXSxcbiAgICAgICAgICAgICAqICAgcXVlcnlQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgKiAgICAgdGFnRmlsdGVyczogWydwdWJsaWMnXSxcbiAgICAgICAgICAgICAqICAgfVxuICAgICAgICAgICAgICogfSlcbiAgICAgICAgICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFsZ29saWEuY29tL2RvYy9yZXN0X2FwaSNBZGRJbmRleEtleXxBbGdvbGlhIFJFU1QgQVBJIERvY3VtZW50YXRpb259XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFkZFVzZXJLZXk6IGZ1bmN0aW9uKGFjbHMsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCB0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwb3N0T2JqID0ge1xuICAgICAgICAgICAgICAgICAgICBhY2w6IGFjbHNcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBwb3N0T2JqLnZhbGlkaXR5ID0gcGFyYW1zLnZhbGlkaXR5O1xuICAgICAgICAgICAgICAgICAgICBwb3N0T2JqLm1heFF1ZXJpZXNQZXJJUFBlckhvdXIgPSBwYXJhbXMubWF4UXVlcmllc1BlcklQUGVySG91cjtcbiAgICAgICAgICAgICAgICAgICAgcG9zdE9iai5tYXhIaXRzUGVyUXVlcnkgPSBwYXJhbXMubWF4SGl0c1BlclF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICBwb3N0T2JqLmRlc2NyaXB0aW9uID0gcGFyYW1zLmRlc2NyaXB0aW9uO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMucXVlcnlQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0T2JqLnF1ZXJ5UGFyYW1ldGVycyA9IHRoaXMuYXMuX2dldFNlYXJjaFBhcmFtcyhwYXJhbXMucXVlcnlQYXJhbWV0ZXJzLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwb3N0T2JqLnJlZmVyZXJzID0gcGFyYW1zLnJlZmVyZXJzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9rZXlzJyxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogcG9zdE9iaixcbiAgICAgICAgICAgICAgICAgICAgaG9zdFR5cGU6ICd3cml0ZScsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBZGQgYW4gZXhpc3RpbmcgdXNlciBrZXkgYXNzb2NpYXRlZCB0byB0aGlzIGluZGV4XG4gICAgICAgICAgICAgKiBAZGVwcmVjYXRlZCB1c2UgaW5kZXguYWRkVXNlcktleSgpXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFkZFVzZXJLZXlXaXRoVmFsaWRpdHk6IGRlcHJlY2F0ZShmdW5jdGlvbiBkZXByZWNhdGVkQWRkVXNlcktleVdpdGhWYWxpZGl0eShhY2xzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkVXNlcktleShhY2xzLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sIGRlcHJlY2F0ZWRNZXNzYWdlKCdpbmRleC5hZGRVc2VyS2V5V2l0aFZhbGlkaXR5KCknLCAnaW5kZXguYWRkVXNlcktleSgpJykpLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVwZGF0ZSBhbiBleGlzdGluZyBBUEkga2V5IG9mIHRoaXMgaW5kZXhcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IHRvIHVwZGF0ZVxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmdbXX0gYWNscyAtIFRoZSBsaXN0IG9mIEFDTCBmb3IgdGhpcyBrZXkuIERlZmluZWQgYnkgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0XG4gICAgICAgICAgICAgKiAgIGNhbiBjb250YWlucyB0aGUgZm9sbG93aW5nIHZhbHVlczpcbiAgICAgICAgICAgICAqICAgICAtIHNlYXJjaDogYWxsb3cgdG8gc2VhcmNoIChodHRwcyBhbmQgaHR0cClcbiAgICAgICAgICAgICAqICAgICAtIGFkZE9iamVjdDogYWxsb3dzIHRvIGFkZC91cGRhdGUgYW4gb2JqZWN0IGluIHRoZSBpbmRleCAoaHR0cHMgb25seSlcbiAgICAgICAgICAgICAqICAgICAtIGRlbGV0ZU9iamVjdCA6IGFsbG93cyB0byBkZWxldGUgYW4gZXhpc3Rpbmcgb2JqZWN0IChodHRwcyBvbmx5KVxuICAgICAgICAgICAgICogICAgIC0gZGVsZXRlSW5kZXggOiBhbGxvd3MgdG8gZGVsZXRlIGluZGV4IGNvbnRlbnQgKGh0dHBzIG9ubHkpXG4gICAgICAgICAgICAgKiAgICAgLSBzZXR0aW5ncyA6IGFsbG93cyB0byBnZXQgaW5kZXggc2V0dGluZ3MgKGh0dHBzIG9ubHkpXG4gICAgICAgICAgICAgKiAgICAgLSBlZGl0U2V0dGluZ3MgOiBhbGxvd3MgdG8gY2hhbmdlIGluZGV4IHNldHRpbmdzIChodHRwcyBvbmx5KVxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gT3B0aW9ubmFsIHBhcmFtZXRlcnMgdG8gc2V0IGZvciB0aGUga2V5XG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnZhbGlkaXR5IC0gTnVtYmVyIG9mIHNlY29uZHMgYWZ0ZXIgd2hpY2ggdGhlIGtleSB3aWxsXG4gICAgICAgICAgICAgKiBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgKDAgbWVhbnMgbm8gdGltZSBsaW1pdCBmb3IgdGhpcyBrZXkpXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1heFF1ZXJpZXNQZXJJUFBlckhvdXIgLSBOdW1iZXIgb2YgQVBJIGNhbGxzIGFsbG93ZWQgZnJvbSBhbiBJUCBhZGRyZXNzIHBlciBob3VyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1heEhpdHNQZXJRdWVyeSAtIE51bWJlciBvZiBoaXRzIHRoaXMgQVBJIGtleSBjYW4gcmV0cmlldmUgaW4gb25lIGNhbGxcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZGVzY3JpcHRpb24gLSBBIGRlc2NyaXB0aW9uIGZvciB5b3VyIGtleVxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zLnJlZmVyZXJzIC0gQSBsaXN0IG9mIGF1dGhvcml6ZWQgcmVmZXJlcnNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMucXVlcnlQYXJhbWV0ZXJzIC0gRm9yY2UgdGhlIGtleSB0byB1c2Ugc3BlY2lmaWMgcXVlcnkgcGFyYW1ldGVyc1xuICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgcmVzdWx0IGNhbGxiYWNrIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHNcbiAgICAgICAgICAgICAqICAgZXJyb3I6IG51bGwgb3IgRXJyb3IoJ21lc3NhZ2UnKVxuICAgICAgICAgICAgICogICBjb250ZW50OiB0aGUgc2VydmVyIGFuc3dlciB3aXRoIHVzZXIga2V5cyBsaXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfHVuZGVmaW5lZH0gUmV0dXJucyBhIHByb21pc2UgaWYgbm8gY2FsbGJhY2sgZ2l2ZW5cbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiBpbmRleC51cGRhdGVVc2VyS2V5KCdBUElLRVknLCBbJ3NlYXJjaCddLCB7XG4gICAqICAgdmFsaWRpdHk6IDMwMCxcbiAgICogICBtYXhRdWVyaWVzUGVySVBQZXJIb3VyOiAyMDAwLFxuICAgKiAgIG1heEhpdHNQZXJRdWVyeTogMyxcbiAgICogICBkZXNjcmlwdGlvbjogJ0VhdCB0aHJlZSBmcnVpdHMnLFxuICAgKiAgIHJlZmVyZXJzOiBbJyouYWxnb2xpYS5jb20nXSxcbiAgICogICBxdWVyeVBhcmFtZXRlcnM6IHtcbiAgICogICAgIHRhZ0ZpbHRlcnM6IFsncHVibGljJ10sXG4gICAqICAgfVxuICAgKiB9KVxuICAgICAgICAgICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYWxnb2xpYS5jb20vZG9jL3Jlc3RfYXBpI1VwZGF0ZUluZGV4S2V5fEFsZ29saWEgUkVTVCBBUEkgRG9jdW1lbnRhdGlvbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdXBkYXRlVXNlcktleTogZnVuY3Rpb24oa2V5LCBhY2xzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgfHwgdHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcHV0T2JqID0ge1xuICAgICAgICAgICAgICAgICAgICBhY2w6IGFjbHNcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBwdXRPYmoudmFsaWRpdHkgPSBwYXJhbXMudmFsaWRpdHk7XG4gICAgICAgICAgICAgICAgICAgIHB1dE9iai5tYXhRdWVyaWVzUGVySVBQZXJIb3VyID0gcGFyYW1zLm1heFF1ZXJpZXNQZXJJUFBlckhvdXI7XG4gICAgICAgICAgICAgICAgICAgIHB1dE9iai5tYXhIaXRzUGVyUXVlcnkgPSBwYXJhbXMubWF4SGl0c1BlclF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICBwdXRPYmouZGVzY3JpcHRpb24gPSBwYXJhbXMuZGVzY3JpcHRpb247XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5xdWVyeVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1dE9iai5xdWVyeVBhcmFtZXRlcnMgPSB0aGlzLmFzLl9nZXRTZWFyY2hQYXJhbXMocGFyYW1zLnF1ZXJ5UGFyYW1ldGVycywgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcHV0T2JqLnJlZmVyZXJzID0gcGFyYW1zLnJlZmVyZXJzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFzLl9qc29uUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICAgICAgICAgIHVybDogJy8xL2luZGV4ZXMvJyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmluZGV4TmFtZSkgKyAnL2tleXMvJyArIGtleSxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogcHV0T2JqLFxuICAgICAgICAgICAgICAgICAgICBob3N0VHlwZTogJ3dyaXRlJyxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfc2VhcmNoOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMuX2pzb25SZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHRoaXMuY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICB1cmw6ICcvMS9pbmRleGVzLycgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5pbmRleE5hbWUpICsgJy9xdWVyeScsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtwYXJhbXM6IHBhcmFtc30sXG4gICAgICAgICAgICAgICAgICAgIGhvc3RUeXBlOiAncmVhZCcsXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAnLzEvaW5kZXhlcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW5kZXhOYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHtwYXJhbXM6IHBhcmFtc31cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBhczogbnVsbCxcbiAgICAgICAgICAgIGluZGV4TmFtZTogbnVsbCxcbiAgICAgICAgICAgIHR5cGVBaGVhZEFyZ3M6IG51bGwsXG4gICAgICAgICAgICB0eXBlQWhlYWRWYWx1ZU9wdGlvbjogbnVsbFxuICAgICAgICB9O1xuXG4vLyBleHRyYWN0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vY29tcG9uZW50L21hcC9ibG9iL21hc3Rlci9pbmRleC5qc1xuLy8gd2l0aG91dCB0aGUgY3JhenkgdG9GdW5jdGlvbiB0aGluZ1xuICAgICAgICBmdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwcmVwYXJlSG9zdChwcm90b2NvbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHByZXBhcmUoaG9zdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm90b2NvbCArICcvLycgKyBob3N0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbm90SW1wbGVtZW50ZWQoKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9ICdOb3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBlbnZpcm9ubWVudC5cXG4nICtcbiAgICAgICAgICAgICAgICAnSWYgeW91IGZlZWwgdGhpcyBpcyBhIG1pc3Rha2UsIHdyaXRlIHRvIHN1cHBvcnRAYWxnb2xpYS5jb20nO1xuXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkFsZ29saWFTZWFyY2hFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZWRNZXNzYWdlKHByZXZpb3VzVXNhZ2UsIG5ld1VzYWdlKSB7XG4gICAgICAgICAgICB2YXIgZ2l0aHViQW5jaG9yTGluayA9IHByZXZpb3VzVXNhZ2UudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCcuJywgJycpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJygpJywgJycpO1xuXG4gICAgICAgICAgICByZXR1cm4gJ2FsZ29saWFzZWFyY2g6IGAnICsgcHJldmlvdXNVc2FnZSArICdgIHdhcyByZXBsYWNlZCBieSBgJyArIG5ld1VzYWdlICtcbiAgICAgICAgICAgICAgICAnYC4gUGxlYXNlIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYWxnb2xpYS9hbGdvbGlhc2VhcmNoLWNsaWVudC1qcy93aWtpL0RlcHJlY2F0ZWQjJyArIGdpdGh1YkFuY2hvckxpbms7XG4gICAgICAgIH1cblxuLy8gUGFyc2UgY2xvdWQgZG9lcyBub3Qgc3VwcG9ydHMgc2V0VGltZW91dFxuLy8gV2UgZG8gbm90IHN0b3JlIGEgc2V0VGltZW91dCByZWZlcmVuY2UgaW4gdGhlIGNsaWVudCBldmVyeXRpbWVcbi8vIFdlIG9ubHkgZmFsbGJhY2sgdG8gYSBmYWtlIHNldFRpbWVvdXQgd2hlbiBub3QgYXZhaWxhYmxlXG4vLyBzZXRUaW1lb3V0IGNhbm5vdCBiZSBvdmVycmlkZSBnbG9iYWxseSBzYWRseVxuICAgICAgICBmdW5jdGlvbiBleGl0UHJvbWlzZShmbiwgX3NldFRpbWVvdXQpIHtcbiAgICAgICAgICAgIF9zZXRUaW1lb3V0KGZuLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZShmbiwgbWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgICAgICAgICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkZXByZWNhdGVkO1xuICAgICAgICB9XG5cbi8vIFByb3RvdHlwZS5qcyA8IDEuNywgYSB3aWRlbHkgdXNlZCBsaWJyYXJ5LCBkZWZpbmVzIGEgd2VpcmRcbi8vIEFycmF5LnByb3RvdHlwZS50b0pTT04gZnVuY3Rpb24gdGhhdCB3aWxsIGZhaWwgdG8gc3RyaW5naWZ5IG91ciBjb250ZW50XG4vLyBhcHByb3ByaWF0ZWx5XG4vLyByZWZzOlxuLy8gICAtIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vZm9ydW0vIyF0b3BpYy9wcm90b3R5cGUtY29yZS9FLVNBVnZWX1Y5UVxuLy8gICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9zc3RlcGhlbnNvbi9wcm90b3R5cGUvY29tbWl0LzAzOGEyOTg1YTcwNTkzYzFhODZjMjMwZmFkYmRmZTJlNDg5OGE0OGNcbi8vICAgLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMTQ4NDQxLzE0NzA3OVxuICAgICAgICBmdW5jdGlvbiBzYWZlSlNPTlN0cmluZ2lmeShvYmopIHtcbiAgICAgICAgICAgIC8qIGVzbGludCBuby1leHRlbmQtbmF0aXZlOjAgKi9cblxuICAgICAgICAgICAgaWYgKEFycmF5LnByb3RvdHlwZS50b0pTT04gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG9KU09OID0gQXJyYXkucHJvdG90eXBlLnRvSlNPTjtcbiAgICAgICAgICAgIGRlbGV0ZSBBcnJheS5wcm90b3R5cGUudG9KU09OO1xuICAgICAgICAgICAgdmFyIG91dCA9IEpTT04uc3RyaW5naWZ5KG9iaik7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUudG9KU09OID0gdG9KU09OO1xuXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICB9KS5jYWxsKHRoaXMscmVxdWlyZSgyKSlcbn0se1wiMTFcIjoxMSxcIjJcIjoyLFwiNDRcIjo0NCxcIjQ3XCI6NDcsXCI1N1wiOjU3LFwiNlwiOjYsXCI2MVwiOjYxLFwiNjZcIjo2Nn1dLDYxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgICAndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgaXMgdGhlIG9iamVjdCByZXR1cm5lZCBieSB0aGUgYGluZGV4LmJyb3dzZUFsbCgpYCBtZXRob2RcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSW5kZXhCcm93c2VyO1xuXG4gICAgdmFyIGluaGVyaXRzID0gcmVxdWlyZSgxMCk7XG4gICAgdmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoMSkuRXZlbnRFbWl0dGVyO1xuXG4gICAgZnVuY3Rpb24gSW5kZXhCcm93c2VyKCkge1xuICAgIH1cblxuICAgIGluaGVyaXRzKEluZGV4QnJvd3NlciwgRXZlbnRFbWl0dGVyKTtcblxuICAgIEluZGV4QnJvd3Nlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY2xlYW4oKTtcbiAgICB9O1xuXG4gICAgSW5kZXhCcm93c2VyLnByb3RvdHlwZS5fZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZW5kJyk7XG4gICAgICAgIHRoaXMuX2NsZWFuKCk7XG4gICAgfTtcblxuICAgIEluZGV4QnJvd3Nlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICB0aGlzLl9jbGVhbigpO1xuICAgIH07XG5cbiAgICBJbmRleEJyb3dzZXIucHJvdG90eXBlLl9yZXN1bHQgPSBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgIHRoaXMuZW1pdCgncmVzdWx0JywgY29udGVudCk7XG4gICAgfTtcblxuICAgIEluZGV4QnJvd3Nlci5wcm90b3R5cGUuX2NsZWFuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdzdG9wJyk7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdlbmQnKTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Vycm9yJyk7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZXN1bHQnKTtcbiAgICB9O1xuXG59LHtcIjFcIjoxLFwiMTBcIjoxMH1dLDYyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgICAndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgaXMgdGhlIHN0YW5kYWxvbmUgYnJvd3NlciBidWlsZCBlbnRyeSBwb2ludFxuLy8gQnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQWxnb2xpYSBTZWFyY2ggSmF2YVNjcmlwdCBjbGllbnQsXG4vLyB1c2luZyBYTUxIdHRwUmVxdWVzdCwgWERvbWFpblJlcXVlc3QgYW5kIEpTT05QIGFzIGZhbGxiYWNrXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBhbGdvbGlhc2VhcmNoO1xuXG4gICAgdmFyIGluaGVyaXRzID0gcmVxdWlyZSgxMCk7XG4gICAgdmFyIFByb21pc2UgPSB3aW5kb3cuUHJvbWlzZSB8fCByZXF1aXJlKDkpLlByb21pc2U7XG5cbiAgICB2YXIgQWxnb2xpYVNlYXJjaCA9IHJlcXVpcmUoNjApO1xuICAgIHZhciBlcnJvcnMgPSByZXF1aXJlKDY2KTtcbiAgICB2YXIgaW5saW5lSGVhZGVycyA9IHJlcXVpcmUoNjQpO1xuICAgIHZhciBqc29ucFJlcXVlc3QgPSByZXF1aXJlKDY1KTtcblxuICAgIGZ1bmN0aW9uIGFsZ29saWFzZWFyY2goYXBwbGljYXRpb25JRCwgYXBpS2V5LCBvcHRzKSB7XG4gICAgICAgIHZhciBjbG9uZURlZXAgPSByZXF1aXJlKDQ1KTtcblxuICAgICAgICB2YXIgZ2V0RG9jdW1lbnRQcm90b2NvbCA9IHJlcXVpcmUoNjMpO1xuXG4gICAgICAgIG9wdHMgPSBjbG9uZURlZXAob3B0cyB8fCB7fSk7XG5cbiAgICAgICAgaWYgKG9wdHMucHJvdG9jb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0cy5wcm90b2NvbCA9IGdldERvY3VtZW50UHJvdG9jb2woKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdHMuX3VhID0gb3B0cy5fdWEgfHwgYWxnb2xpYXNlYXJjaC51YTtcblxuICAgICAgICByZXR1cm4gbmV3IEFsZ29saWFTZWFyY2hCcm93c2VyKGFwcGxpY2F0aW9uSUQsIGFwaUtleSwgb3B0cyk7XG4gICAgfVxuXG4gICAgYWxnb2xpYXNlYXJjaC52ZXJzaW9uID0gcmVxdWlyZSg2Nyk7XG4gICAgYWxnb2xpYXNlYXJjaC51YSA9ICdBbGdvbGlhIGZvciB2YW5pbGxhIEphdmFTY3JpcHQgJyArIGFsZ29saWFzZWFyY2gudmVyc2lvbjtcblxuLy8gd2UgZXhwb3NlIGludG8gd2luZG93IG5vIG1hdHRlciBob3cgd2UgYXJlIHVzZWQsIHRoaXMgd2lsbCBhbGxvd1xuLy8gdXMgdG8gZWFzaWx5IGRlYnVnIGFueSB3ZWJzaXRlIHJ1bm5pbmcgYWxnb2xpYVxuICAgIHdpbmRvdy5fX2FsZ29saWEgPSB7XG4gICAgICAgIGRlYnVnOiByZXF1aXJlKDYpLFxuICAgICAgICBhbGdvbGlhc2VhcmNoOiBhbGdvbGlhc2VhcmNoXG4gICAgfTtcblxuICAgIHZhciBzdXBwb3J0ID0ge1xuICAgICAgICBoYXNYTUxIdHRwUmVxdWVzdDogJ1hNTEh0dHBSZXF1ZXN0JyBpbiB3aW5kb3csXG4gICAgICAgIGhhc1hEb21haW5SZXF1ZXN0OiAnWERvbWFpblJlcXVlc3QnIGluIHdpbmRvdyxcbiAgICAgICAgY29yczogJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCksXG4gICAgICAgIHRpbWVvdXQ6ICd0aW1lb3V0JyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBBbGdvbGlhU2VhcmNoQnJvd3NlcigpIHtcbiAgICAgICAgLy8gY2FsbCBBbGdvbGlhU2VhcmNoIGNvbnN0cnVjdG9yXG4gICAgICAgIEFsZ29saWFTZWFyY2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBpbmhlcml0cyhBbGdvbGlhU2VhcmNoQnJvd3NlciwgQWxnb2xpYVNlYXJjaCk7XG5cbiAgICBBbGdvbGlhU2VhcmNoQnJvd3Nlci5wcm90b3R5cGUuX3JlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KHVybCwgb3B0cykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gd3JhcFJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAvLyBubyBjb3JzIG9yIFhEb21haW5SZXF1ZXN0LCBubyByZXF1ZXN0XG4gICAgICAgICAgICBpZiAoIXN1cHBvcnQuY29ycyAmJiAhc3VwcG9ydC5oYXNYRG9tYWluUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIC8vIHZlcnkgb2xkIGJyb3dzZXIsIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IGVycm9ycy5OZXR3b3JrKCdDT1JTIG5vdCBzdXBwb3J0ZWQnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cmwgPSBpbmxpbmVIZWFkZXJzKHVybCwgb3B0cy5oZWFkZXJzKTtcblxuICAgICAgICAgICAgdmFyIGJvZHkgPSBvcHRzLmJvZHk7XG4gICAgICAgICAgICB2YXIgcmVxID0gc3VwcG9ydC5jb3JzID8gbmV3IFhNTEh0dHBSZXF1ZXN0KCkgOiBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICAgICAgICAgIHZhciBvbnRpbWVvdXQ7XG4gICAgICAgICAgICB2YXIgdGltZWRPdXQ7XG5cbiAgICAgICAgICAgIC8vIGRvIG5vdCByZWx5IG9uIGRlZmF1bHQgWEhSIGFzeW5jIGZsYWcsIGFzIHNvbWUgYW5hbHl0aWNzIGNvZGUgbGlrZSBob3RqYXJcbiAgICAgICAgICAgIC8vIGJyZWFrcyBpdCBhbmQgc2V0IGl0IHRvIGZhbHNlIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIGlmIChyZXEgaW5zdGFuY2VvZiBYTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIHJlcS5vcGVuKG9wdHMubWV0aG9kLCB1cmwsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXEub3BlbihvcHRzLm1ldGhvZCwgdXJsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN1cHBvcnQuY29ycykge1xuICAgICAgICAgICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLm1ldGhvZCA9PT0gJ1BPU1QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0FjY2Vzc19jb250cm9sX0NPUlMjU2ltcGxlX3JlcXVlc3RzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcignY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoJ2FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHdlIHNldCBhbiBlbXB0eSBvbnByb2dyZXNzIGxpc3RlbmVyXG4gICAgICAgICAgICAvLyBzbyB0aGF0IFhEb21haW5SZXF1ZXN0IG9uIElFOSBpcyBub3QgYWJvcnRlZFxuICAgICAgICAgICAgLy8gcmVmczpcbiAgICAgICAgICAgIC8vICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGdvbGlhL2FsZ29saWFzZWFyY2gtY2xpZW50LWpzL2lzc3Vlcy83NlxuICAgICAgICAgICAgLy8gIC0gaHR0cHM6Ly9zb2NpYWwubXNkbi5taWNyb3NvZnQuY29tL0ZvcnVtcy9pZS9lbi1VUy8zMGVmM2FkZC03NjdjLTQ0MzYtYjhhOS1mMWNhMTliNDgxMmUvaWU5LXJ0bS14ZG9tYWlucmVxdWVzdC1pc3N1ZWQtcmVxdWVzdHMtbWF5LWFib3J0LWlmLWFsbC1ldmVudC1oYW5kbGVycy1ub3Qtc3BlY2lmaWVkP2ZvcnVtPWlld2ViZGV2ZWxvcG1lbnRcbiAgICAgICAgICAgIHJlcS5vbnByb2dyZXNzID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG4gICAgICAgICAgICByZXEub25sb2FkID0gbG9hZDtcbiAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXJyb3I7XG5cbiAgICAgICAgICAgIGlmIChzdXBwb3J0LnRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAvLyAudGltZW91dCBzdXBwb3J0ZWQgYnkgYm90aCBYSFIgYW5kIFhEUixcbiAgICAgICAgICAgICAgICAvLyB3ZSBkbyByZWNlaXZlIHRpbWVvdXQgZXZlbnQsIHRlc3RlZFxuICAgICAgICAgICAgICAgIHJlcS50aW1lb3V0ID0gb3B0cy50aW1lb3V0O1xuXG4gICAgICAgICAgICAgICAgcmVxLm9udGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9udGltZW91dCA9IHNldFRpbWVvdXQodGltZW91dCwgb3B0cy50aW1lb3V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVxLnNlbmQoYm9keSk7XG5cbiAgICAgICAgICAgIC8vIGV2ZW50IG9iamVjdCBub3QgcmVjZWl2ZWQgaW4gSUU4LCBhdCBsZWFzdFxuICAgICAgICAgICAgLy8gYnV0IHdlIGRvIG5vdCB1c2UgaXQsIHN0aWxsIGltcG9ydGFudCB0byBub3RlXG4gICAgICAgICAgICBmdW5jdGlvbiBsb2FkKC8qZXZlbnQqLykge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0cyByZXEudGltZW91dCwgd2UgY2FuXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBib3RoIGEgbG9hZCBhbmQgdGltZW91dCBldmVudCwgc2luY2UgaGFuZGxlZCBieSBhIGR1bWIgc2V0VGltZW91dFxuICAgICAgICAgICAgICAgIGlmICh0aW1lZE91dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0LnRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG9udGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG91dDtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04ucGFyc2UocmVxLnJlc3BvbnNlVGV4dCksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiByZXEuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gWERvbWFpblJlcXVlc3QgZG9lcyBub3QgaGF2ZSBhbnkgcmVzcG9uc2UgaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmVxLmdldEFsbFJlc3BvbnNlSGVhZGVycyAmJiByZXEuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwge31cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCA9IG5ldyBlcnJvcnMuVW5wYXJzYWJsZUpTT04oe1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9yZTogcmVxLnJlc3BvbnNlVGV4dFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3V0IGluc3RhbmNlb2YgZXJyb3JzLlVucGFyc2FibGVKU09OKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChvdXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGVycm9yKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVkT3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXN1cHBvcnQudGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQob250aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBlcnJvciBldmVudCBpcyB0cmlnZXJyZWQgYm90aCB3aXRoIFhEUi9YSFIgb246XG4gICAgICAgICAgICAgICAgLy8gICAtIEROUyBlcnJvclxuICAgICAgICAgICAgICAgIC8vICAgLSB1bmFsbG93ZWQgY3Jvc3MgZG9tYWluIHJlcXVlc3RcbiAgICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBlcnJvcnMuTmV0d29yayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JlOiBldmVudFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHRpbWVvdXQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0LnRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZWRPdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXEuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZWplY3QobmV3IGVycm9ycy5SZXF1ZXN0VGltZW91dCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIEFsZ29saWFTZWFyY2hCcm93c2VyLnByb3RvdHlwZS5fcmVxdWVzdC5mYWxsYmFjayA9IGZ1bmN0aW9uIHJlcXVlc3RGYWxsYmFjayh1cmwsIG9wdHMpIHtcbiAgICAgICAgdXJsID0gaW5saW5lSGVhZGVycyh1cmwsIG9wdHMuaGVhZGVycyk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIHdyYXBKc29ucFJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBqc29ucFJlcXVlc3QodXJsLCBvcHRzLCBmdW5jdGlvbiBqc29ucFJlcXVlc3REb25lKGVyciwgY29udGVudCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXNvbHZlKGNvbnRlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBBbGdvbGlhU2VhcmNoQnJvd3Nlci5wcm90b3R5cGUuX3Byb21pc2UgPSB7XG4gICAgICAgIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0UHJvbWlzZSh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh2YWwpO1xuICAgICAgICB9LFxuICAgICAgICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlUHJvbWlzZSh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVsYXk6IGZ1bmN0aW9uIGRlbGF5UHJvbWlzZShtcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIHJlc29sdmVPblRpbWVvdXQocmVzb2x2ZS8qLCByZWplY3QqLykge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG59LHtcIjEwXCI6MTAsXCI0NVwiOjQ1LFwiNlwiOjYsXCI2MFwiOjYwLFwiNjNcIjo2MyxcIjY0XCI6NjQsXCI2NVwiOjY1LFwiNjZcIjo2NixcIjY3XCI6NjcsXCI5XCI6OX1dLDYzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdldERvY3VtZW50UHJvdG9jb2w7XG5cbiAgICBmdW5jdGlvbiBnZXREb2N1bWVudFByb3RvY29sKCkge1xuICAgICAgICB2YXIgcHJvdG9jb2wgPSB3aW5kb3cuZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2w7XG5cbiAgICAgICAgLy8gd2hlbiBpbiBgZmlsZTpgIG1vZGUgKGxvY2FsIGh0bWwgZmlsZSksIGRlZmF1bHQgdG8gYGh0dHA6YFxuICAgICAgICBpZiAocHJvdG9jb2wgIT09ICdodHRwOicgJiYgcHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgICAgICAgICBwcm90b2NvbCA9ICdodHRwOic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvdG9jb2w7XG4gICAgfVxuXG59LHt9XSw2NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpbmxpbmVIZWFkZXJzO1xuXG4gICAgdmFyIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSg1KTtcblxuICAgIGZ1bmN0aW9uIGlubGluZUhlYWRlcnModXJsLCBoZWFkZXJzKSB7XG4gICAgICAgIGlmICgvXFw/Ly50ZXN0KHVybCkpIHtcbiAgICAgICAgICAgIHVybCArPSAnJic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cmwgKz0gJz8nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVybCArIHF1ZXJ5c3RyaW5nLmVuY29kZShoZWFkZXJzKTtcbiAgICB9XG5cbn0se1wiNVwiOjV9XSw2NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBqc29ucFJlcXVlc3Q7XG5cbiAgICB2YXIgZXJyb3JzID0gcmVxdWlyZSg2Nik7XG5cbiAgICB2YXIgSlNPTlBDb3VudGVyID0gMDtcblxuICAgIGZ1bmN0aW9uIGpzb25wUmVxdWVzdCh1cmwsIG9wdHMsIGNiKSB7XG4gICAgICAgIGlmIChvcHRzLm1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICAgICAgICAgIGNiKG5ldyBFcnJvcignTWV0aG9kICcgKyBvcHRzLm1ldGhvZCArICcgJyArIHVybCArICcgaXMgbm90IHN1cHBvcnRlZCBieSBKU09OUC4nKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBvcHRzLmRlYnVnKCdKU09OUDogc3RhcnQnKTtcblxuICAgICAgICB2YXIgY2JDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHRpbWVkT3V0ID0gZmFsc2U7XG5cbiAgICAgICAgSlNPTlBDb3VudGVyICs9IDE7XG4gICAgICAgIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICAgICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICB2YXIgY2JOYW1lID0gJ2FsZ29saWFKU09OUF8nICsgSlNPTlBDb3VudGVyO1xuICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuXG4gICAgICAgIHdpbmRvd1tjYk5hbWVdID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkZWxldGUgd2luZG93W2NiTmFtZV07XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgd2luZG93W2NiTmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aW1lZE91dCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2JDYWxsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICBjbGVhbigpO1xuXG4gICAgICAgICAgICBjYihudWxsLCB7XG4gICAgICAgICAgICAgICAgYm9keTogZGF0YS8qLFxuICAgICAgICAgICAgICAgICAvLyBXZSBkbyBub3Qgc2VuZCB0aGUgc3RhdHVzQ29kZSwgdGhlcmUncyBubyBzdGF0dXNDb2RlIGluIEpTT05QLCBpdCB3aWxsIGJlXG4gICAgICAgICAgICAgICAgIC8vIGNvbXB1dGVkIHVzaW5nIGRhdGEuc3RhdHVzICYmIGRhdGEubWVzc2FnZSBsaWtlIHdpdGggWERSXG4gICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUqL1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gYWRkIGNhbGxiYWNrIGJ5IGhhbmRcbiAgICAgICAgdXJsICs9ICcmY2FsbGJhY2s9JyArIGNiTmFtZTtcblxuICAgICAgICAvLyBhZGQgYm9keSBwYXJhbXMgbWFudWFsbHlcbiAgICAgICAgaWYgKG9wdHMuanNvbkJvZHkgJiYgb3B0cy5qc29uQm9keS5wYXJhbXMpIHtcbiAgICAgICAgICAgIHVybCArPSAnJicgKyBvcHRzLmpzb25Cb2R5LnBhcmFtcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvbnRpbWVvdXQgPSBzZXRUaW1lb3V0KHRpbWVvdXQsIG9wdHMudGltZW91dCk7XG5cbiAgICAgICAgLy8gc2NyaXB0IG9ucmVhZHlzdGF0ZWNoYW5nZSBuZWVkZWQgb25seSBmb3JcbiAgICAgICAgLy8gPD0gSUU4XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIuanMvaXNzdWVzLzQ1MjNcbiAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHJlYWR5c3RhdGVjaGFuZ2U7XG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSBzdWNjZXNzO1xuICAgICAgICBzY3JpcHQub25lcnJvciA9IGVycm9yO1xuXG4gICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIHNjcmlwdC5kZWZlciA9IHRydWU7XG4gICAgICAgIHNjcmlwdC5zcmMgPSB1cmw7XG4gICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblxuICAgICAgICBmdW5jdGlvbiBzdWNjZXNzKCkge1xuICAgICAgICAgICAgb3B0cy5kZWJ1ZygnSlNPTlA6IHN1Y2Nlc3MnKTtcblxuICAgICAgICAgICAgaWYgKGRvbmUgfHwgdGltZWRPdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBzY3JpcHQgbG9hZGVkIGJ1dCBkaWQgbm90IGNhbGwgdGhlIGZuID0+IHNjcmlwdCBsb2FkaW5nIGVycm9yXG4gICAgICAgICAgICBpZiAoIWNiQ2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5kZWJ1ZygnSlNPTlA6IEZhaWwuIFNjcmlwdCBsb2FkZWQgYnV0IGRpZCBub3QgY2FsbCB0aGUgY2FsbGJhY2snKTtcbiAgICAgICAgICAgICAgICBjbGVhbigpO1xuICAgICAgICAgICAgICAgIGNiKG5ldyBlcnJvcnMuSlNPTlBTY3JpcHRGYWlsKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09ICdsb2FkZWQnIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNsZWFuKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG9udGltZW91dCk7XG4gICAgICAgICAgICBzY3JpcHQub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgaGVhZC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3dbY2JOYW1lXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgd2luZG93W2NiTmFtZSArICdfbG9hZGVkJ107XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgd2luZG93W2NiTmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIHdpbmRvd1tjYk5hbWUgKyAnX2xvYWRlZCddID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHRpbWVvdXQoKSB7XG4gICAgICAgICAgICBvcHRzLmRlYnVnKCdKU09OUDogU2NyaXB0IHRpbWVvdXQnKTtcblxuICAgICAgICAgICAgdGltZWRPdXQgPSB0cnVlO1xuICAgICAgICAgICAgY2xlYW4oKTtcbiAgICAgICAgICAgIGNiKG5ldyBlcnJvcnMuUmVxdWVzdFRpbWVvdXQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBlcnJvcigpIHtcbiAgICAgICAgICAgIG9wdHMuZGVidWcoJ0pTT05QOiBTY3JpcHQgZXJyb3InKTtcblxuICAgICAgICAgICAgaWYgKGRvbmUgfHwgdGltZWRPdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsZWFuKCk7XG4gICAgICAgICAgICBjYihuZXcgZXJyb3JzLkpTT05QU2NyaXB0RXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0se1wiNjZcIjo2Nn1dLDY2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbiAgICAndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgZmlsZSBob3N0cyBvdXIgZXJyb3IgZGVmaW5pdGlvbnNcbi8vIFdlIHVzZSBjdXN0b20gZXJyb3IgXCJ0eXBlc1wiIHNvIHRoYXQgd2UgY2FuIGFjdCBvbiB0aGVtIHdoZW4gd2UgbmVlZCBpdFxuLy8gZS5nLjogaWYgZXJyb3IgaW5zdGFuY2VvZiBlcnJvcnMuVW5wYXJzYWJsZUpTT04gdGhlbi4uXG5cbiAgICB2YXIgaW5oZXJpdHMgPSByZXF1aXJlKDEwKTtcblxuICAgIGZ1bmN0aW9uIEFsZ29saWFTZWFyY2hFcnJvcihtZXNzYWdlLCBleHRyYVByb3BlcnRpZXMpIHtcbiAgICAgICAgdmFyIGZvckVhY2ggPSByZXF1aXJlKDExKTtcblxuICAgICAgICB2YXIgZXJyb3IgPSB0aGlzO1xuXG4gICAgICAgIC8vIHRyeSB0byBnZXQgYSBzdGFja3RyYWNlXG4gICAgICAgIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3Iuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrIHx8ICdDYW5ub3QgZ2V0IGEgc3RhY2t0cmFjZSwgYnJvd3NlciBpcyB0b28gb2xkJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcic7XG5cbiAgICAgICAgaWYgKGV4dHJhUHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yRWFjaChleHRyYVByb3BlcnRpZXMsIGZ1bmN0aW9uIGFkZFRvRXJyb3JPYmplY3QodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgIGVycm9yW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5oZXJpdHMoQWxnb2xpYVNlYXJjaEVycm9yLCBFcnJvcik7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDdXN0b21FcnJvcihuYW1lLCBtZXNzYWdlKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFsZ29saWFTZWFyY2hDdXN0b21FcnJvcigpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICAgICAgLy8gY3VzdG9tIG1lc3NhZ2Ugbm90IHNldCwgdXNlIGRlZmF1bHRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEFsZ29saWFTZWFyY2hFcnJvci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdBbGdvbGlhU2VhcmNoJyArIG5hbWUgKyAnRXJyb3InO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5oZXJpdHMoQWxnb2xpYVNlYXJjaEN1c3RvbUVycm9yLCBBbGdvbGlhU2VhcmNoRXJyb3IpO1xuXG4gICAgICAgIHJldHVybiBBbGdvbGlhU2VhcmNoQ3VzdG9tRXJyb3I7XG4gICAgfVxuXG4vLyBsYXRlIGV4cG9ydHMgdG8gbGV0IHZhcmlvdXMgZm4gZGVmcyBhbmQgaW5oZXJpdHMgdGFrZSBwbGFjZVxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBBbGdvbGlhU2VhcmNoRXJyb3I6IEFsZ29saWFTZWFyY2hFcnJvcixcbiAgICAgICAgVW5wYXJzYWJsZUpTT046IGNyZWF0ZUN1c3RvbUVycm9yKFxuICAgICAgICAgICAgJ1VucGFyc2FibGVKU09OJyxcbiAgICAgICAgICAgICdDb3VsZCBub3QgcGFyc2UgdGhlIGluY29taW5nIHJlc3BvbnNlIGFzIEpTT04sIHNlZSBlcnIubW9yZSBmb3IgZGV0YWlscydcbiAgICAgICAgKSxcbiAgICAgICAgUmVxdWVzdFRpbWVvdXQ6IGNyZWF0ZUN1c3RvbUVycm9yKFxuICAgICAgICAgICAgJ1JlcXVlc3RUaW1lb3V0JyxcbiAgICAgICAgICAgICdSZXF1ZXN0IHRpbWVkb3V0IGJlZm9yZSBnZXR0aW5nIGEgcmVzcG9uc2UnXG4gICAgICAgICksXG4gICAgICAgIE5ldHdvcms6IGNyZWF0ZUN1c3RvbUVycm9yKFxuICAgICAgICAgICAgJ05ldHdvcmsnLFxuICAgICAgICAgICAgJ05ldHdvcmsgaXNzdWUsIHNlZSBlcnIubW9yZSBmb3IgZGV0YWlscydcbiAgICAgICAgKSxcbiAgICAgICAgSlNPTlBTY3JpcHRGYWlsOiBjcmVhdGVDdXN0b21FcnJvcihcbiAgICAgICAgICAgICdKU09OUFNjcmlwdEZhaWwnLFxuICAgICAgICAgICAgJzxzY3JpcHQ+IHdhcyBsb2FkZWQgYnV0IGRpZCBub3QgY2FsbCBvdXIgcHJvdmlkZWQgY2FsbGJhY2snXG4gICAgICAgICksXG4gICAgICAgIEpTT05QU2NyaXB0RXJyb3I6IGNyZWF0ZUN1c3RvbUVycm9yKFxuICAgICAgICAgICAgJ0pTT05QU2NyaXB0RXJyb3InLFxuICAgICAgICAgICAgJzxzY3JpcHQ+IHVuYWJsZSB0byBsb2FkIGR1ZSB0byBhbiBgZXJyb3JgIGV2ZW50IG9uIGl0J1xuICAgICAgICApLFxuICAgICAgICBVbmtub3duOiBjcmVhdGVDdXN0b21FcnJvcihcbiAgICAgICAgICAgICdVbmtub3duJyxcbiAgICAgICAgICAgICdVbmtub3duIGVycm9yIG9jY3VyZWQnXG4gICAgICAgIClcbiAgICB9O1xuXG59LHtcIjEwXCI6MTAsXCIxMVwiOjExfV0sNjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuICAgIG1vZHVsZS5leHBvcnRzPVwiMy43LjdcIlxufSx7fV19LHt9LFs2Ml0pKDYyKVxufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHJlc291cmNlcy9hc3NldHMvanMvdmVuZG9yL2FsZ29saWFzZWFyY2guanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBOzs7OztBQUtBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBOzs7O0FBSUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0dBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 3 */
/***/ function(module, exports) {

eval("(function(){var $c=function(a){this.w=a||[]};$c.prototype.set=function(a){this.w[a]=!0};$c.prototype.encode=function(){\nvar this$1 = this;\nfor(var a=[],b=0;b<this.w.length;b++)this$1.w[b]&&(a[Math.floor(b/6)]^=1<<b%6);for(b=0;b<a.length;b++)a[b]=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\".charAt(a[b]||0);return a.join(\"\")+\"~\"};var vd=new $c;function J(a){vd.set(a)}var Nd=function(a,b){var c=new $c(Dd(a));c.set(b);a.set(Gd,c.w)},Td=function(a){a=Dd(a);a=new $c(a);for(var b=vd.w.slice(),c=0;c<a.w.length;c++)b[c]=b[c]||a.w[c];return(new $c(b)).encode()},Dd=function(a){a=a.get(Gd);ka(a)||(a=[]);return a};var ea=function(a){return\"function\"==typeof a},ka=function(a){return\"[object Array]\"==Object.prototype.toString.call(Object(a))},qa=function(a){return void 0!=a&&-1<(a.constructor+\"\").indexOf(\"String\")},D=function(a,b){return 0==a.indexOf(b)},sa=function(a){return a?a.replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g,\"\"):\"\"},ta=function(a){var b=M.createElement(\"img\");b.width=1;b.height=1;b.src=a;return b},ua=function(){},K=function(a){if(encodeURIComponent instanceof Function)return encodeURIComponent(a);J(28);return a},\nL=function(a,b,c,d){try{a.addEventListener?a.addEventListener(b,c,!!d):a.attachEvent&&a.attachEvent(\"on\"+b,c)}catch(e){J(27)}},f=/^[\\w\\-:/.?=&%!]+$/,wa=function(a,b,c){a&&(c?(c=\"\",b&&f.test(b)&&(c=' id=\"'+b+'\"'),f.test(a)&&M.write(\"<script\"+c+' src=\"'+a+'\">\\x3c/script>')):(c=M.createElement(\"script\"),c.type=\"text/javascript\",c.async=!0,c.src=a,b&&(c.id=b),a=M.getElementsByTagName(\"script\")[0],a.parentNode.insertBefore(c,a)))},Ud=function(){return\"https:\"==M.location.protocol},E=function(a,b){var c=\na.match(\"(?:&|#|\\\\?)\"+K(b).replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g,\"\\\\$1\")+\"=([^&#]*)\");return c&&2==c.length?c[1]:\"\"},xa=function(){var a=\"\"+M.location.hostname;return 0==a.indexOf(\"www.\")?a.substring(4):a},ya=function(a){var b=M.referrer;if(/^https?:\\/\\//i.test(b)){if(a)return b;a=\"//\"+M.location.hostname;var c=b.indexOf(a);if(5==c||6==c)if(a=b.charAt(c+a.length),\"/\"==a||\"?\"==a||\"\"==a||\":\"==a)return;return b}},za=function(a,b){if(1==b.length&&null!=b[0]&&\"object\"===typeof b[0])return b[0];for(var c=\n{},d=Math.min(a.length+1,b.length),e=0;e<d;e++)if(\"object\"===typeof b[e]){for(var g in b[e])b[e].hasOwnProperty(g)&&(c[g]=b[e][g]);break}else e<a.length&&(c[a[e]]=b[e]);return c};var ee=function(){this.keys=[];this.values={};this.m={}};ee.prototype.set=function(a,b,c){this.keys.push(a);c?this.m[\":\"+a]=b:this.values[\":\"+a]=b};ee.prototype.get=function(a){return this.m.hasOwnProperty(\":\"+a)?this.m[\":\"+a]:this.values[\":\"+a]};ee.prototype.map=function(a){\nvar this$1 = this;\nfor(var b=0;b<this.keys.length;b++){var c=this$1.keys[b],d=this$1.get(c);d&&a(c,d)}};var O=window,M=document;var F=window,G=function(a){var b=F._gaUserPrefs;if(b&&b.ioo&&b.ioo()||a&&!0===F[\"ga-disable-\"+a])return!0;try{var c=F.external;if(c&&c._gaUserPrefs&&\"oo\"==c._gaUserPrefs)return!0}catch(d){}return!1};var Ca=function(a){var b=[],c=M.cookie.split(\";\");a=new RegExp(\"^\\\\s*\"+a+\"=\\\\s*(.*?)\\\\s*$\");for(var d=0;d<c.length;d++){var e=c[d].match(a);e&&b.push(e[1])}return b},zc=function(a,b,c,d,e,g){e=G(e)?!1:eb.test(M.location.hostname)||\"/\"==c&&vc.test(d)?!1:!0;if(!e)return!1;b&&1200<b.length&&(b=b.substring(0,1200),J(24));c=a+\"=\"+b+\"; path=\"+c+\"; \";g&&(c+=\"expires=\"+(new Date((new Date).getTime()+g)).toGMTString()+\"; \");d&&\"none\"!=d&&(c+=\"domain=\"+d+\";\");d=M.cookie;M.cookie=c;if(!(d=d!=M.cookie))a:{a=\nCa(a);for(d=0;d<a.length;d++)if(b==a[d]){d=!0;break a}d=!1}return d},Cc=function(a){return K(a).replace(/\\(/g,\"%28\").replace(/\\)/g,\"%29\")},vc=/^(www\\.)?google(\\.com?)?(\\.[a-z]{2})?$/,eb=/(^|\\.)doubleclick\\.net$/i;var oc=function(){return(Ba||Ud()?\"https:\":\"http:\")+\"//www.google-analytics.com\"},Da=function(a){this.name=\"len\";this.message=a+\"-8192\"},ba=function(a,b,c){c=c||ua;if(2036>=b.length)wc(a,b,c);else if(8192>=b.length)x(a,b,c)||wd(a,b,c)||wc(a,b,c);else throw ge(\"len\",b.length),new Da(b.length);},wc=function(a,b,c){var d=ta(a+\"?\"+b);d.onload=d.onerror=function(){d.onload=null;d.onerror=null;c()}},wd=function(a,b,c){var d=O.XMLHttpRequest;if(!d)return!1;var e=new d;if(!(\"withCredentials\"in e))return!1;\ne.open(\"POST\",a,!0);e.withCredentials=!0;e.setRequestHeader(\"Content-Type\",\"text/plain\");e.onreadystatechange=function(){4==e.readyState&&(c(),e=null)};e.send(b);return!0},x=function(a,b,c){return O.navigator.sendBeacon?O.navigator.sendBeacon(a,b)?(c(),!0):!1:!1},ge=function(a,b,c){1<=100*Math.random()||G(\"?\")||(a=[\"t=error\",\"_e=\"+a,\"_v=j47\",\"sr=1\"],b&&a.push(\"_f=\"+b),c&&a.push(\"_m=\"+K(c.substring(0,100))),a.push(\"aip=1\"),a.push(\"z=\"+hd()),wc(oc()+\"/collect\",a.join(\"&\"),ua))};var h=function(a){var b=O.gaData=O.gaData||{};return b[a]=b[a]||{}};var Ha=function(){this.M=[]};Ha.prototype.add=function(a){this.M.push(a)};Ha.prototype.D=function(a){\nvar this$1 = this;\ntry{for(var b=0;b<this.M.length;b++){var c=a.get(this$1.M[b]);c&&ea(c)&&c.call(O,a)}}catch(d){}b=a.get(Ia);b!=ua&&ea(b)&&(a.set(Ia,ua,!0),setTimeout(b,10))};function Ja(a){if(100!=a.get(Ka)&&La(P(a,Q))%1E4>=100*R(a,Ka))throw\"abort\";}function Ma(a){if(G(P(a,Na)))throw\"abort\";}function Oa(){var a=M.location.protocol;if(\"http:\"!=a&&\"https:\"!=a)throw\"abort\";}\nfunction Pa(a){try{O.navigator.sendBeacon?J(42):O.XMLHttpRequest&&\"withCredentials\"in new O.XMLHttpRequest&&J(40)}catch(c){}a.set(ld,Td(a),!0);a.set(Ac,R(a,Ac)+1);var b=[];Qa.map(function(c,d){if(d.F){var e=a.get(c);void 0!=e&&e!=d.defaultValue&&(\"boolean\"==typeof e&&(e*=1),b.push(d.F+\"=\"+K(\"\"+e)))}});b.push(\"z=\"+Bd());a.set(Ra,b.join(\"&\"),!0)}\nfunction Sa(a){var b=P(a,gd)||oc()+\"/collect\",c=P(a,fa);!c&&a.get(Vd)&&(c=\"beacon\");if(c){var d=P(a,Ra),e=a.get(Ia),e=e||ua;\"image\"==c?wc(b,d,e):\"xhr\"==c&&wd(b,d,e)||\"beacon\"==c&&x(b,d,e)||ba(b,d,e)}else ba(b,P(a,Ra),a.get(Ia));b=a.get(Na);b=h(b);c=b.hitcount;b.hitcount=c?c+1:1;b=a.get(Na);delete h(b).pending_experiments;a.set(Ia,ua,!0)}\nfunction Hc(a){(O.gaData=O.gaData||{}).expId&&a.set(Nc,(O.gaData=O.gaData||{}).expId);(O.gaData=O.gaData||{}).expVar&&a.set(Oc,(O.gaData=O.gaData||{}).expVar);var b;var c=a.get(Na);if(c=h(c).pending_experiments){var d=[];for(b in c)c.hasOwnProperty(b)&&c[b]&&d.push(encodeURIComponent(b)+\".\"+encodeURIComponent(c[b]));b=d.join(\"!\")}else b=void 0;b&&a.set(m,b,!0)}function cd(){if(O.navigator&&\"preview\"==O.navigator.loadPurpose)throw\"abort\";}\nfunction yd(a){var b=O.gaDevIds;ka(b)&&0!=b.length&&a.set(\"&did\",b.join(\",\"),!0)}function vb(a){if(!a.get(Na))throw\"abort\";};var hd=function(){return Math.round(2147483647*Math.random())},Bd=function(){try{var a=new Uint32Array(1);O.crypto.getRandomValues(a);return a[0]&2147483647}catch(b){return hd()}};function Ta(a){var b=R(a,Ua);500<=b&&J(15);var c=P(a,Va);if(\"transaction\"!=c&&\"item\"!=c){var c=R(a,Wa),d=(new Date).getTime(),e=R(a,Xa);0==e&&a.set(Xa,d);e=Math.round(2*(d-e)/1E3);0<e&&(c=Math.min(c+e,20),a.set(Xa,d));if(0>=c)throw\"abort\";a.set(Wa,--c)}a.set(Ua,++b)};var Ya=function(){this.data=new ee},Qa=new ee,Za=[];Ya.prototype.get=function(a){var b=$a(a),c=this.data.get(a);b&&void 0==c&&(c=ea(b.defaultValue)?b.defaultValue():b.defaultValue);return b&&b.Z?b.Z(this,a,c):c};var P=function(a,b){var c=a.get(b);return void 0==c?\"\":\"\"+c},R=function(a,b){var c=a.get(b);return void 0==c||\"\"===c?0:1*c};Ya.prototype.set=function(a,b,c){\nvar this$1 = this;\nif(a)if(\"object\"==typeof a)for(var d in a)a.hasOwnProperty(d)&&ab(this$1,d,a[d],c);else ab(this,a,b,c)};\nvar ab=function(a,b,c,d){if(void 0!=c)switch(b){case Na:wb.test(c)}var e=$a(b);e&&e.o?e.o(a,b,c,d):a.data.set(b,c,d)},bb=function(a,b,c,d,e){this.name=a;this.F=b;this.Z=d;this.o=e;this.defaultValue=c},$a=function(a){var b=Qa.get(a);if(!b)for(var c=0;c<Za.length;c++){var d=Za[c],e=d[0].exec(a);if(e){b=d[1](e);Qa.set(b.name,b);break}}return b},yc=function(a){var b;Qa.map(function(c,d){d.F==a&&(b=d)});return b&&b.name},S=function(a,b,c,d,e){a=new bb(a,b,c,d,e);Qa.set(a.name,a);return a.name},cb=function(a,\nb){Za.push([new RegExp(\"^\"+a+\"$\"),b])},T=function(a,b,c){return S(a,b,c,void 0,db)},db=function(){};var gb=qa(window.GoogleAnalyticsObject)&&sa(window.GoogleAnalyticsObject)||\"ga\",Ba=!1,hb=T(\"apiVersion\",\"v\"),ib=T(\"clientVersion\",\"_v\");S(\"anonymizeIp\",\"aip\");var jb=S(\"adSenseId\",\"a\"),Va=S(\"hitType\",\"t\"),Ia=S(\"hitCallback\"),Ra=S(\"hitPayload\");S(\"nonInteraction\",\"ni\");S(\"currencyCode\",\"cu\");S(\"dataSource\",\"ds\");var Vd=S(\"useBeacon\",void 0,!1),fa=S(\"transport\");S(\"sessionControl\",\"sc\",\"\");S(\"sessionGroup\",\"sg\");S(\"queueTime\",\"qt\");var Ac=S(\"_s\",\"_s\");S(\"screenName\",\"cd\");\nvar kb=S(\"location\",\"dl\",\"\"),lb=S(\"referrer\",\"dr\"),mb=S(\"page\",\"dp\",\"\");S(\"hostname\",\"dh\");var nb=S(\"language\",\"ul\"),ob=S(\"encoding\",\"de\");S(\"title\",\"dt\",function(){return M.title||void 0});cb(\"contentGroup([0-9]+)\",function(a){return new bb(a[0],\"cg\"+a[1])});var pb=S(\"screenColors\",\"sd\"),qb=S(\"screenResolution\",\"sr\"),rb=S(\"viewportSize\",\"vp\"),sb=S(\"javaEnabled\",\"je\"),tb=S(\"flashVersion\",\"fl\");S(\"campaignId\",\"ci\");S(\"campaignName\",\"cn\");S(\"campaignSource\",\"cs\");S(\"campaignMedium\",\"cm\");\nS(\"campaignKeyword\",\"ck\");S(\"campaignContent\",\"cc\");var ub=S(\"eventCategory\",\"ec\"),xb=S(\"eventAction\",\"ea\"),yb=S(\"eventLabel\",\"el\"),zb=S(\"eventValue\",\"ev\"),Bb=S(\"socialNetwork\",\"sn\"),Cb=S(\"socialAction\",\"sa\"),Db=S(\"socialTarget\",\"st\"),Eb=S(\"l1\",\"plt\"),Fb=S(\"l2\",\"pdt\"),Gb=S(\"l3\",\"dns\"),Hb=S(\"l4\",\"rrt\"),Ib=S(\"l5\",\"srt\"),Jb=S(\"l6\",\"tcp\"),Kb=S(\"l7\",\"dit\"),Lb=S(\"l8\",\"clt\"),Mb=S(\"timingCategory\",\"utc\"),Nb=S(\"timingVar\",\"utv\"),Ob=S(\"timingLabel\",\"utl\"),Pb=S(\"timingValue\",\"utt\");S(\"appName\",\"an\");\nS(\"appVersion\",\"av\",\"\");S(\"appId\",\"aid\",\"\");S(\"appInstallerId\",\"aiid\",\"\");S(\"exDescription\",\"exd\");S(\"exFatal\",\"exf\");var Nc=S(\"expId\",\"xid\"),Oc=S(\"expVar\",\"xvar\"),m=S(\"exp\",\"exp\"),Rc=S(\"_utma\",\"_utma\"),Sc=S(\"_utmz\",\"_utmz\"),Tc=S(\"_utmht\",\"_utmht\"),Ua=S(\"_hc\",void 0,0),Xa=S(\"_ti\",void 0,0),Wa=S(\"_to\",void 0,20);cb(\"dimension([0-9]+)\",function(a){return new bb(a[0],\"cd\"+a[1])});cb(\"metric([0-9]+)\",function(a){return new bb(a[0],\"cm\"+a[1])});S(\"linkerParam\",void 0,void 0,Bc,db);\nvar ld=S(\"usage\",\"_u\"),Gd=S(\"_um\");S(\"forceSSL\",void 0,void 0,function(){return Ba},function(a,b,c){J(34);Ba=!!c});var ed=S(\"_j1\",\"jid\");cb(\"\\\\&(.*)\",function(a){var b=new bb(a[0],a[1]),c=yc(a[0].substring(1));c&&(b.Z=function(a){return a.get(c)},b.o=function(a,b,g,ca){a.set(c,g,ca)},b.F=void 0);return b});\nvar Qb=T(\"_oot\"),dd=S(\"previewTask\"),Rb=S(\"checkProtocolTask\"),md=S(\"validationTask\"),Sb=S(\"checkStorageTask\"),Uc=S(\"historyImportTask\"),Tb=S(\"samplerTask\"),Vb=S(\"_rlt\"),Wb=S(\"buildHitTask\"),Xb=S(\"sendHitTask\"),Vc=S(\"ceTask\"),zd=S(\"devIdTask\"),Cd=S(\"timingTask\"),Ld=S(\"displayFeaturesTask\"),V=T(\"name\"),Q=T(\"clientId\",\"cid\"),n=T(\"clientIdTime\"),Ad=S(\"userId\",\"uid\"),Na=T(\"trackingId\",\"tid\"),U=T(\"cookieName\",void 0,\"_ga\"),W=T(\"cookieDomain\"),Yb=T(\"cookiePath\",void 0,\"/\"),Zb=T(\"cookieExpires\",void 0,63072E3),\n$b=T(\"legacyCookieDomain\"),Wc=T(\"legacyHistoryImport\",void 0,!0),ac=T(\"storage\",void 0,\"cookie\"),bc=T(\"allowLinker\",void 0,!1),cc=T(\"allowAnchor\",void 0,!0),Ka=T(\"sampleRate\",\"sf\",100),dc=T(\"siteSpeedSampleRate\",void 0,1),ec=T(\"alwaysSendReferrer\",void 0,!1),gd=S(\"transportUrl\"),Md=S(\"_r\",\"_r\");function X(a,b,c,d){b[a]=function(){try{return d&&J(d),c.apply(this,arguments)}catch(e){throw ge(\"exc\",a,e&&e.name),e;}}};var Od=function(a){this.V=a;this.fa=void 0;this.$=!1;this.oa=void 0;this.ea=1},Ed=function(a,b){var c;if(a.fa&&a.$)return 0;a.$=!0;if(b){if(a.oa&&R(b,a.oa))return R(b,a.oa);if(0==b.get(dc))return 0}if(0==a.V)return 0;void 0===c&&(c=Bd());return 0==c%a.V?Math.floor(c/a.V)%a.ea+1:0};function fc(){var a,b,c;if((c=(c=O.navigator)?c.plugins:null)&&c.length)for(var d=0;d<c.length&&!b;d++){var e=c[d];-1<e.name.indexOf(\"Shockwave Flash\")&&(b=e.description)}if(!b)try{a=new ActiveXObject(\"ShockwaveFlash.ShockwaveFlash.7\"),b=a.GetVariable(\"$version\")}catch(g){}if(!b)try{a=new ActiveXObject(\"ShockwaveFlash.ShockwaveFlash.6\"),b=\"WIN 6,0,21,0\",a.AllowScriptAccess=\"always\",b=a.GetVariable(\"$version\")}catch(g){}if(!b)try{a=new ActiveXObject(\"ShockwaveFlash.ShockwaveFlash\"),b=a.GetVariable(\"$version\")}catch(g){}b&&\n(a=b.match(/[\\d]+/g))&&3<=a.length&&(b=a[0]+\".\"+a[1]+\" r\"+a[2]);return b||void 0};var aa=function(a){var b=Math.min(R(a,dc),100);return La(P(a,Q))%100>=b?!1:!0},gc=function(a){var b={};if(Ec(b)||Fc(b)){var c=b[Eb];void 0==c||Infinity==c||isNaN(c)||(0<c?(Y(b,Gb),Y(b,Jb),Y(b,Ib),Y(b,Fb),Y(b,Hb),Y(b,Kb),Y(b,Lb),a(b)):L(O,\"load\",function(){gc(a)},!1))}},Ec=function(a){var b=O.performance||O.webkitPerformance,b=b&&b.timing;if(!b)return!1;var c=b.navigationStart;if(0==c)return!1;a[Eb]=b.loadEventStart-c;a[Gb]=b.domainLookupEnd-b.domainLookupStart;a[Jb]=b.connectEnd-b.connectStart;a[Ib]=\nb.responseStart-b.requestStart;a[Fb]=b.responseEnd-b.responseStart;a[Hb]=b.fetchStart-c;a[Kb]=b.domInteractive-c;a[Lb]=b.domContentLoadedEventStart-c;return!0},Fc=function(a){if(O.top!=O)return!1;var b=O.external,c=b&&b.onloadT;b&&!b.isValidLoadTime&&(c=void 0);2147483648<c&&(c=void 0);0<c&&b.setPageReadyTime();if(void 0==c)return!1;a[Eb]=c;return!0},Y=function(a,b){var c=a[b];if(isNaN(c)||Infinity==c||0>c)a[b]=void 0},Fd=function(a){return function(b){if(\"pageview\"==b.get(Va)&&!a.I){a.I=!0;var c=\naa(b);b=0<E(b.get(kb),\"gclid\").length;(c||b)&&gc(function(b){a.send(c?\"timing\":\"adtiming\",b)})}}};var hc=!1,mc=function(a){if(\"cookie\"==P(a,ac)){var b=P(a,U),c=nd(a),d=kc(P(a,Yb)),e=lc(P(a,W)),g=1E3*R(a,Zb),ca=P(a,Na);if(\"auto\"!=e)zc(b,c,d,e,ca,g)&&(hc=!0);else{J(32);var l;a:{c=[];e=xa().split(\".\");if(4==e.length&&(l=e[e.length-1],parseInt(l,10)==l)){l=[\"none\"];break a}for(l=e.length-2;0<=l;l--)c.push(e.slice(l).join(\".\"));c.push(\"none\");l=c}for(var k=0;k<l.length;k++)if(e=l[k],a.data.set(W,e),c=nd(a),zc(b,c,d,e,ca,g)){hc=!0;return}a.data.set(W,\"auto\")}}},nc=function(a){if(\"cookie\"==P(a,ac)&&\n!hc&&(mc(a),!hc))throw\"abort\";},Yc=function(a){if(a.get(Wc)){var b=P(a,W),c=P(a,$b)||xa(),d=Xc(\"__utma\",c,b);d&&(J(19),a.set(Tc,(new Date).getTime(),!0),a.set(Rc,d.R),(b=Xc(\"__utmz\",c,b))&&d.hash==b.hash&&a.set(Sc,b.R))}},nd=function(a){var b=Cc(P(a,Q)),c=lc(P(a,W)).split(\".\").length;a=jc(P(a,Yb));1<a&&(c+=\"-\"+a);return[\"GA1\",c,b].join(\".\")},Gc=function(a,b,c){for(var d=[],e=[],g,ca=0;ca<a.length;ca++){var l=a[ca];l.H[c]==b?d.push(l):void 0==g||l.H[c]<g?(e=[l],g=l.H[c]):l.H[c]==g&&e.push(l)}return 0<\nd.length?d:e},lc=function(a){return 0==a.indexOf(\".\")?a.substr(1):a},kc=function(a){if(!a)return\"/\";1<a.length&&a.lastIndexOf(\"/\")==a.length-1&&(a=a.substr(0,a.length-1));0!=a.indexOf(\"/\")&&(a=\"/\"+a);return a},jc=function(a){a=kc(a);return\"/\"==a?1:a.split(\"/\").length};function Xc(a,b,c){\"none\"==b&&(b=\"\");var d=[],e=Ca(a);a=\"__utma\"==a?6:2;for(var g=0;g<e.length;g++){var ca=(\"\"+e[g]).split(\".\");ca.length>=a&&d.push({hash:ca[0],R:e[g],O:ca})}if(0!=d.length)return 1==d.length?d[0]:Zc(b,d)||Zc(c,d)||Zc(null,d)||d[0]}function Zc(a,b){var c,d;null==a?c=d=1:(c=La(a),d=La(D(a,\".\")?a.substring(1):\".\"+a));for(var e=0;e<b.length;e++)if(b[e].hash==c||b[e].hash==d)return b[e]};var od=new RegExp(/^https?:\\/\\/([^\\/:]+)/),pd=/(.*)([?&#])(?:_ga=[^&#]*)(?:&?)(.*)/;function Bc(a){a=a.get(Q);var b=Ic(a,0);return\"_ga=1.\"+K(b+\".\"+a)}function Ic(a,b){for(var c=new Date,d=O.navigator,e=d.plugins||[],c=[a,d.userAgent,c.getTimezoneOffset(),c.getYear(),c.getDate(),c.getHours(),c.getMinutes()+b],d=0;d<e.length;++d)c.push(e[d].description);return La(c.join(\".\"))}var Dc=function(a){J(48);this.target=a;this.T=!1};\nDc.prototype.ca=function(a,b){if(a.tagName){if(\"a\"==a.tagName.toLowerCase()){a.href&&(a.href=qd(this,a.href,b));return}if(\"form\"==a.tagName.toLowerCase())return rd(this,a)}if(\"string\"==typeof a)return qd(this,a,b)};\nvar qd=function(a,b,c){var d=pd.exec(b);d&&3<=d.length&&(b=d[1]+(d[3]?d[2]+d[3]:\"\"));a=a.target.get(\"linkerParam\");var e=b.indexOf(\"?\"),d=b.indexOf(\"#\");c?b+=(-1==d?\"#\":\"&\")+a:(c=-1==e?\"?\":\"&\",b=-1==d?b+(c+a):b.substring(0,d)+c+a+b.substring(d));return b=b.replace(/&+_ga=/,\"&_ga=\")},rd=function(a,b){if(b&&b.action){var c=a.target.get(\"linkerParam\").split(\"=\")[1];if(\"get\"==b.method.toLowerCase()){for(var d=b.childNodes||[],e=0;e<d.length;e++)if(\"_ga\"==d[e].name){d[e].setAttribute(\"value\",c);return}d=\nM.createElement(\"input\");d.setAttribute(\"type\",\"hidden\");d.setAttribute(\"name\",\"_ga\");d.setAttribute(\"value\",c);b.appendChild(d)}else\"post\"==b.method.toLowerCase()&&(b.action=qd(a,b.action))}};\nDc.prototype.S=function(a,b,c){function d(c){try{c=c||O.event;var d;a:{var g=c.target||c.srcElement;for(c=100;g&&0<c;){if(g.href&&g.nodeName.match(/^a(?:rea)?$/i)){d=g;break a}g=g.parentNode;c--}d={}}(\"http:\"==d.protocol||\"https:\"==d.protocol)&&sd(a,d.hostname||\"\")&&d.href&&(d.href=qd(e,d.href,b))}catch(k){J(26)}}var e=this;this.T||(this.T=!0,L(M,\"mousedown\",d,!1),L(M,\"keyup\",d,!1));c&&L(M,\"submit\",function(b){b=b||O.event;if((b=b.target||b.srcElement)&&b.action){var c=b.action.match(od);c&&sd(a,\nc[1])&&rd(e,b)}})};function sd(a,b){if(b==M.location.hostname)return!1;for(var c=0;c<a.length;c++)if(a[c]instanceof RegExp){if(a[c].test(b))return!0}else if(0<=b.indexOf(a[c]))return!0;return!1};var p=/^(GTM|OPT)-[A-Z0-9]+$/,q=/;_gaexp=[^;]*/g,r=/;((__utma=)|([^;=]+=GAX?\\d+\\.))[^;]*/g,t=function(a){function b(a,b){b&&(c+=\"&\"+a+\"=\"+K(b))}var c=\"https://www.google-analytics.com/gtm/js?id=\"+K(a.id);\"dataLayer\"!=a.B&&b(\"l\",a.B);b(\"t\",a.target);b(\"cid\",a.ja);b(\"cidt\",a.ka);b(\"gac\",a.la);b(\"aip\",a.ia);a.na&&b(\"m\",\"sync\");b(\"cycle\",a.G);return c};var Jd=function(a,b,c){this.U=ed;this.aa=b;(b=c)||(b=(b=P(a,V))&&\"t0\"!=b?Wd.test(b)?\"_gat_\"+Cc(P(a,Na)):\"_gat_\"+Cc(b):\"_gat\");this.Y=b;Ed(new Od(100),a)&&(J(30),this.pa=!0)},Rd=function(a,b){var c=b.get(Wb);b.set(Wb,function(b){Pd(a,b);var d=c(b);Qd(a,b);return d});var d=b.get(Xb);b.set(Xb,function(b){var c=d(b);Id(a,b);return c})},Pd=function(a,b){b.get(a.U)||(\"1\"==Ca(a.Y)[0]?b.set(a.U,\"\",!0):b.set(a.U,\"\"+hd(),!0))},Qd=function(a,b){if(b.get(a.U)){var c=6E5;a.pa&&(c/=10);zc(a.Y,\"1\",b.get(Yb),b.get(W),\nb.get(Na),c)}},Id=function(a,b){if(b.get(a.U)){var c=new ee,d=function(a){$a(a).F&&c.set($a(a).F,b.get(a))};d(hb);d(ib);d(Na);d(Q);d(Ad);d(a.U);c.set($a(ld).F,Td(b));var e=a.aa;c.map(function(a,b){e+=K(a)+\"=\";e+=K(\"\"+b)+\"&\"});e+=\"z=\"+hd();ta(e);b.set(a.U,\"\",!0)}},Wd=/^gtm\\d+$/;var fd=function(a,b){var c=a.b;if(!c.get(\"dcLoaded\")){Nd(c,29);b=b||{};var d;b[U]&&(d=Cc(b[U]));d=new Jd(c,\"https://stats.g.doubleclick.net/r/collect?t=dc&aip=1&_r=3&\",d);Rd(d,c);c.set(\"dcLoaded\",!0)}};var Sd=function(a){if(!a.get(\"dcLoaded\")&&\"cookie\"==a.get(ac)){Nd(a,51);var b=new Jd(a);Pd(b,a);Qd(b,a);a.get(b.U)&&(a.set(Md,1,!0),a.set(gd,oc()+\"/r/collect\",!0))}};var Lc=function(){var a=O.gaGlobal=O.gaGlobal||{};return a.hid=a.hid||hd()};var ad,bd=function(a,b,c){if(!ad){var d;d=M.location.hash;var e=O.name,g=/^#?gaso=([^&]*)/;if(e=(d=(d=d&&d.match(g)||e&&e.match(g))?d[1]:Ca(\"GASO\")[0]||\"\")&&d.match(/^(?:!([-0-9a-z.]{1,40})!)?([-.\\w]{10,1200})$/i))zc(\"GASO\",\"\"+d,c,b,a,0),window._udo||(window._udo=b),window._utcp||(window._utcp=c),a=e[1],wa(\"https://www.google.com/analytics/web/inpage/pub/inpage.js?\"+(a?\"prefix=\"+a+\"&\":\"\")+hd(),\"_gasojs\");ad=!0}};var wb=/^(UA|YT|MO|GP)-(\\d+)-(\\d+)$/,pc=function(a){function b(a,b){d.b.data.set(a,b)}function c(a,c){b(a,c);d.filters.add(a)}var d=this;this.b=new Ya;this.filters=new Ha;b(V,a[V]);b(Na,sa(a[Na]));b(U,a[U]);b(W,a[W]||xa());b(Yb,a[Yb]);b(Zb,a[Zb]);b($b,a[$b]);b(Wc,a[Wc]);b(bc,a[bc]);b(cc,a[cc]);b(Ka,a[Ka]);b(dc,a[dc]);b(ec,a[ec]);b(ac,a[ac]);b(Ad,a[Ad]);b(n,a[n]);b(hb,1);b(ib,\"j47\");c(Qb,Ma);c(dd,cd);c(Rb,Oa);c(md,vb);c(Sb,nc);c(Uc,Yc);c(Tb,Ja);c(Vb,Ta);c(Vc,Hc);c(zd,yd);c(Ld,Sd);c(Wb,Pa);c(Xb,Sa);\nc(Cd,Fd(this));Jc(this.b,a[Q]);Kc(this.b);this.b.set(jb,Lc());bd(this.b.get(Na),this.b.get(W),this.b.get(Yb))},Jc=function(a,b){if(\"cookie\"==P(a,ac)){hc=!1;var c;b:{var d=Ca(P(a,U));if(d&&!(1>d.length)){c=[];for(var e=0;e<d.length;e++){var g;g=d[e].split(\".\");var ca=g.shift();(\"GA1\"==ca||\"1\"==ca)&&1<g.length?(ca=g.shift().split(\"-\"),1==ca.length&&(ca[1]=\"1\"),ca[0]*=1,ca[1]*=1,g={H:ca,s:g.join(\".\")}):g=void 0;g&&c.push(g)}if(1==c.length){J(13);c=c[0].s;break b}if(0==c.length)J(12);else{J(14);d=lc(P(a,\nW)).split(\".\").length;c=Gc(c,d,0);if(1==c.length){c=c[0].s;break b}d=jc(P(a,Yb));c=Gc(c,d,1);c=c[0]&&c[0].s;break b}}c=void 0}c||(c=P(a,W),d=P(a,$b)||xa(),c=Xc(\"__utma\",d,c),void 0!=c?(J(10),c=c.O[1]+\".\"+c.O[2]):c=void 0);c&&(a.data.set(Q,c),hc=!0)}c=a.get(cc);if(e=E(M.location[c?\"href\":\"search\"],\"_ga\"))a.get(bc)?(c=e.indexOf(\".\"),-1==c?J(22):(d=e.substring(c+1),\"1\"!=e.substring(0,c)?J(22):(c=d.indexOf(\".\"),-1==c?J(22):(e=d.substring(0,c),c=d.substring(c+1),e!=Ic(c,0)&&e!=Ic(c,-1)&&e!=Ic(c,-2)?J(23):\n(J(11),a.data.set(Q,c)))))):J(21);b&&(J(9),a.data.set(Q,K(b)));if(!a.get(Q))if(c=(c=O.gaGlobal&&O.gaGlobal.vid)&&-1!=c.search(/^(?:utma\\.)?\\d+\\.\\d+$/)?c:void 0)J(17),a.data.set(Q,c);else{J(8);c=O.navigator.userAgent+(M.cookie?M.cookie:\"\")+(M.referrer?M.referrer:\"\");d=c.length;for(e=O.history.length;0<e;)c+=e--^d++;a.data.set(Q,[hd()^La(c)&2147483647,Math.round((new Date).getTime()/1E3)].join(\".\"))}mc(a)},Kc=function(a){var b=O.navigator,c=O.screen,d=M.location;a.set(lb,ya(a.get(ec)));if(d){var e=\nd.pathname||\"\";\"/\"!=e.charAt(0)&&(J(31),e=\"/\"+e);a.set(kb,d.protocol+\"//\"+d.hostname+e+d.search)}c&&a.set(qb,c.width+\"x\"+c.height);c&&a.set(pb,c.colorDepth+\"-bit\");var c=M.documentElement,g=(e=M.body)&&e.clientWidth&&e.clientHeight,ca=[];c&&c.clientWidth&&c.clientHeight&&(\"CSS1Compat\"===M.compatMode||!g)?ca=[c.clientWidth,c.clientHeight]:g&&(ca=[e.clientWidth,e.clientHeight]);c=0>=ca[0]||0>=ca[1]?\"\":ca.join(\"x\");a.set(rb,c);a.set(tb,fc());a.set(ob,M.characterSet||M.charset);a.set(sb,b&&\"function\"===\ntypeof b.javaEnabled&&b.javaEnabled()||!1);a.set(nb,(b&&(b.language||b.browserLanguage)||\"\").toLowerCase());if(d&&a.get(cc)&&(b=M.location.hash)){b=b.split(/[?&#]+/);d=[];for(c=0;c<b.length;++c)(D(b[c],\"utm_id\")||D(b[c],\"utm_campaign\")||D(b[c],\"utm_source\")||D(b[c],\"utm_medium\")||D(b[c],\"utm_term\")||D(b[c],\"utm_content\")||D(b[c],\"gclid\")||D(b[c],\"dclid\")||D(b[c],\"gclsrc\"))&&d.push(b[c]);0<d.length&&(b=\"#\"+d.join(\"&\"),a.set(kb,a.get(kb)+b))}};pc.prototype.get=function(a){return this.b.get(a)};\npc.prototype.set=function(a,b){this.b.set(a,b)};var qc={pageview:[mb],event:[ub,xb,yb,zb],social:[Bb,Cb,Db],timing:[Mb,Nb,Pb,Ob]};pc.prototype.send=function(a){if(!(1>arguments.length)){var b,c;\"string\"===typeof arguments[0]?(b=arguments[0],c=[].slice.call(arguments,1)):(b=arguments[0]&&arguments[0][Va],c=arguments);b&&(c=za(qc[b]||[],c),c[Va]=b,this.b.set(c,void 0,!0),this.filters.D(this.b),this.b.data.m={})}};\npc.prototype.ma=function(a,b){var c=this;u(a,c,b)||(v(a,function(){u(a,c,b)}),y(String(c.get(V)),a,void 0,b,!0))};var rc=function(a){if(\"prerender\"==M.visibilityState)return!1;a();return!0},z=function(a){if(!rc(a)){J(16);var b=!1,c=function(){if(!b&&rc(a)){b=!0;var d=c,e=M;e.removeEventListener?e.removeEventListener(\"visibilitychange\",d,!1):e.detachEvent&&e.detachEvent(\"onvisibilitychange\",d)}};L(M,\"visibilitychange\",c)}};var td=/^(?:(\\w+)\\.)?(?:(\\w+):)?(\\w+)$/,sc=function(a){if(ea(a[0]))this.u=a[0];else{var b=td.exec(a[0]);null!=b&&4==b.length&&(this.c=b[1]||\"t0\",this.K=b[2]||\"\",this.C=b[3],this.a=[].slice.call(a,1),this.K||(this.A=\"create\"==this.C,this.i=\"require\"==this.C,this.g=\"provide\"==this.C,this.ba=\"remove\"==this.C),this.i&&(3<=this.a.length?(this.X=this.a[1],this.W=this.a[2]):this.a[1]&&(qa(this.a[1])?this.X=this.a[1]:this.W=this.a[1])));b=a[1];a=a[2];if(!this.C)throw\"abort\";if(this.i&&(!qa(b)||\"\"==b))throw\"abort\";\nif(this.g&&(!qa(b)||\"\"==b||!ea(a)))throw\"abort\";if(ud(this.c)||ud(this.K))throw\"abort\";if(this.g&&\"t0\"!=this.c)throw\"abort\";}};function ud(a){return 0<=a.indexOf(\".\")||0<=a.indexOf(\":\")};var Yd,Zd,$d,A;Yd=new ee;$d=new ee;A=new ee;Zd={ec:45,ecommerce:46,linkid:47};\nvar u=function(a,b,c){b==N||b.get(V);var d=Yd.get(a);if(!ea(d))return!1;b.plugins_=b.plugins_||new ee;if(b.plugins_.get(a))return!0;b.plugins_.set(a,new d(b,c||{}));return!0},y=function(a,b,c,d,e){if(!ea(Yd.get(b))&&!$d.get(b)){Zd.hasOwnProperty(b)&&J(Zd[b]);if(p.test(b)){J(52);a=N.j(a);if(!a)return!0;c=d||{};d={id:b,B:c.dataLayer||\"dataLayer\",ia:!!a.get(\"anonymizeIp\"),na:e,G:!1};a.get(\"&gtm\")==b&&(d.G=!0);var g=String(a.get(\"name\"));\"t0\"!=g&&(d.target=g);G(String(a.get(\"trackingId\")))||(d.ja=String(a.get(Q)),\nd.ka=Number(a.get(n)),a=c.palindrome?r:q,a=(a=M.cookie.replace(/^|(; +)/g,\";\").match(a))?a.sort().join(\"\").substring(1):void 0,d.la=a);a=d.B;c=(new Date).getTime();O[a]=O[a]||[];c={\"gtm.start\":c};e||(c.event=\"gtm.js\");O[a].push(c);c=t(d)}!c&&Zd.hasOwnProperty(b)?(J(39),c=b+\".js\"):J(43);c&&(c&&0<=c.indexOf(\"/\")||(c=(Ba||Ud()?\"https:\":\"http:\")+\"//www.google-analytics.com/plugins/ua/\"+c),d=ae(c),a=d.protocol,c=M.location.protocol,(\"https:\"==a||a==c||(\"http:\"!=a?0:\"http:\"==c))&&B(d)&&(wa(d.url,void 0,\ne),$d.set(b,!0)))}},v=function(a,b){var c=A.get(a)||[];c.push(b);A.set(a,c)},C=function(a,b){Yd.set(a,b);for(var c=A.get(a)||[],d=0;d<c.length;d++)c[d]();A.set(a,[])},B=function(a){var b=ae(M.location.href);if(D(a.url,\"https://www.google-analytics.com/gtm/js?id=\"))return!0;if(a.query||0<=a.url.indexOf(\"?\")||0<=a.path.indexOf(\"://\"))return!1;if(a.host==b.host&&a.port==b.port)return!0;b=\"http:\"==a.protocol?80:443;return\"www.google-analytics.com\"==a.host&&(a.port||b)==b&&D(a.path,\"/plugins/\")?!0:!1},\nae=function(a){function b(a){var b=(a.hostname||\"\").split(\":\")[0].toLowerCase(),c=(a.protocol||\"\").toLowerCase(),c=1*a.port||(\"http:\"==c?80:\"https:\"==c?443:\"\");a=a.pathname||\"\";D(a,\"/\")||(a=\"/\"+a);return[b,\"\"+c,a]}var c=M.createElement(\"a\");c.href=M.location.href;var d=(c.protocol||\"\").toLowerCase(),e=b(c),g=c.search||\"\",ca=d+\"//\"+e[0]+(e[1]?\":\"+e[1]:\"\");D(a,\"//\")?a=d+a:D(a,\"/\")?a=ca+a:!a||D(a,\"?\")?a=ca+e[2]+(a||g):0>a.split(\"/\")[0].indexOf(\":\")&&(a=ca+e[2].substring(0,e[2].lastIndexOf(\"/\"))+\"/\"+\na);c.href=a;d=b(c);return{protocol:(c.protocol||\"\").toLowerCase(),host:d[0],port:d[1],path:d[2],query:c.search||\"\",url:a||\"\"}};var Z={ga:function(){Z.f=[]}};Z.ga();Z.D=function(a){var b=Z.J.apply(Z,arguments),b=Z.f.concat(b);for(Z.f=[];0<b.length&&!Z.v(b[0])&&!(b.shift(),0<Z.f.length););Z.f=Z.f.concat(b)};Z.J=function(a){\nvar arguments$1 = arguments;\nfor(var b=[],c=0;c<arguments.length;c++)try{var d=new sc(arguments$1[c]);d.g?C(d.a[0],d.a[1]):(d.i&&(d.ha=y(d.c,d.a[0],d.X,d.W)),b.push(d))}catch(e){}return b};\nZ.v=function(a){try{if(a.u)a.u.call(O,N.j(\"t0\"));else{var b=a.c==gb?N:N.j(a.c);if(a.A)\"t0\"!=a.c||N.create.apply(N,a.a);else if(a.ba)N.remove(a.c);else if(b)if(a.i){if(a.ha&&(a.ha=y(a.c,a.a[0],a.X,a.W)),!u(a.a[0],b,a.W))return!0}else if(a.K){var c=a.C,d=a.a,e=b.plugins_.get(a.K);e[c].apply(e,d)}else b[a.C].apply(b,a.a)}}catch(g){}};var N=function(a){J(1);Z.D.apply(Z,[arguments])};N.h={};N.P=[];N.L=0;N.answer=42;var uc=[Na,W,V];N.create=function(a){var b=za(uc,[].slice.call(arguments));b[V]||(b[V]=\"t0\");var c=\"\"+b[V];if(N.h[c])return N.h[c];b=new pc(b);N.h[c]=b;N.P.push(b);return b};N.remove=function(a){for(var b=0;b<N.P.length;b++)if(N.P[b].get(V)==a){N.P.splice(b,1);N.h[a]=null;break}};N.j=function(a){return N.h[a]};N.getAll=function(){return N.P.slice(0)};\nN.N=function(){\"ga\"!=gb&&J(49);var a=O[gb];if(!a||42!=a.answer){N.L=a&&a.l;N.loaded=!0;var b=O[gb]=N;X(\"create\",b,b.create);X(\"remove\",b,b.remove);X(\"getByName\",b,b.j,5);X(\"getAll\",b,b.getAll,6);b=pc.prototype;X(\"get\",b,b.get,7);X(\"set\",b,b.set,4);X(\"send\",b,b.send);X(\"requireSync\",b,b.ma);b=Ya.prototype;X(\"get\",b,b.get);X(\"set\",b,b.set);if(!Ud()&&!Ba){a:{for(var b=M.getElementsByTagName(\"script\"),c=0;c<b.length&&100>c;c++){var d=b[c].src;if(d&&0==d.indexOf(\"https://www.google-analytics.com/analytics\")){J(33);\nb=!0;break a}}b=!1}b&&(Ba=!0)}Ud()||Ba||!Ed(new Od(1E4))||(J(36),Ba=!0);(O.gaplugins=O.gaplugins||{}).Linker=Dc;b=Dc.prototype;C(\"linker\",Dc);X(\"decorate\",b,b.ca,20);X(\"autoLink\",b,b.S,25);C(\"displayfeatures\",fd);C(\"adfeatures\",fd);a=a&&a.q;ka(a)?Z.D.apply(N,a):J(50)}};N.da=function(){for(var a=N.getAll(),b=0;b<a.length;b++)a[b].get(V)};var H=N.N,I=O[gb];I&&I.r?H():z(H);z(function(){Z.D([\"provide\",\"render\",ua])});function La(a){var b=1,c,d;if(a)for(b=0,d=a.length-1;0<=d;d--)c=a.charCodeAt(d),b=(b<<6&268435455)+c+(c<<14),c=b&266338304,b=0!=c?b^c>>21:b;return b};})(window);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9yZXNvdXJjZXMvYXNzZXRzL2pzL3ZlbmRvci9hbmFseXRpY3MuanM/OWM3OCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXt2YXIgJGM9ZnVuY3Rpb24oYSl7dGhpcy53PWF8fFtdfTskYy5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGEpe3RoaXMud1thXT0hMH07JGMucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbigpe2Zvcih2YXIgYT1bXSxiPTA7Yjx0aGlzLncubGVuZ3RoO2IrKyl0aGlzLndbYl0mJihhW01hdGguZmxvb3IoYi82KV1ePTE8PGIlNik7Zm9yKGI9MDtiPGEubGVuZ3RoO2IrKylhW2JdPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktX1wiLmNoYXJBdChhW2JdfHwwKTtyZXR1cm4gYS5qb2luKFwiXCIpK1wiflwifTt2YXIgdmQ9bmV3ICRjO2Z1bmN0aW9uIEooYSl7dmQuc2V0KGEpfXZhciBOZD1mdW5jdGlvbihhLGIpe3ZhciBjPW5ldyAkYyhEZChhKSk7Yy5zZXQoYik7YS5zZXQoR2QsYy53KX0sVGQ9ZnVuY3Rpb24oYSl7YT1EZChhKTthPW5ldyAkYyhhKTtmb3IodmFyIGI9dmQudy5zbGljZSgpLGM9MDtjPGEudy5sZW5ndGg7YysrKWJbY109YltjXXx8YS53W2NdO3JldHVybihuZXcgJGMoYikpLmVuY29kZSgpfSxEZD1mdW5jdGlvbihhKXthPWEuZ2V0KEdkKTtrYShhKXx8KGE9W10pO3JldHVybiBhfTt2YXIgZWE9ZnVuY3Rpb24oYSl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgYX0sa2E9ZnVuY3Rpb24oYSl7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiPT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoT2JqZWN0KGEpKX0scWE9ZnVuY3Rpb24oYSl7cmV0dXJuIHZvaWQgMCE9YSYmLTE8KGEuY29uc3RydWN0b3IrXCJcIikuaW5kZXhPZihcIlN0cmluZ1wiKX0sRD1mdW5jdGlvbihhLGIpe3JldHVybiAwPT1hLmluZGV4T2YoYil9LHNhPWZ1bmN0aW9uKGEpe3JldHVybiBhP2EucmVwbGFjZSgvXltcXHNcXHhhMF0rfFtcXHNcXHhhMF0rJC9nLFwiXCIpOlwiXCJ9LHRhPWZ1bmN0aW9uKGEpe3ZhciBiPU0uY3JlYXRlRWxlbWVudChcImltZ1wiKTtiLndpZHRoPTE7Yi5oZWlnaHQ9MTtiLnNyYz1hO3JldHVybiBifSx1YT1mdW5jdGlvbigpe30sSz1mdW5jdGlvbihhKXtpZihlbmNvZGVVUklDb21wb25lbnQgaW5zdGFuY2VvZiBGdW5jdGlvbilyZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGEpO0ooMjgpO3JldHVybiBhfSxcbkw9ZnVuY3Rpb24oYSxiLGMsZCl7dHJ5e2EuYWRkRXZlbnRMaXN0ZW5lcj9hLmFkZEV2ZW50TGlzdGVuZXIoYixjLCEhZCk6YS5hdHRhY2hFdmVudCYmYS5hdHRhY2hFdmVudChcIm9uXCIrYixjKX1jYXRjaChlKXtKKDI3KX19LGY9L15bXFx3XFwtOi8uPz0mJSFdKyQvLHdhPWZ1bmN0aW9uKGEsYixjKXthJiYoYz8oYz1cIlwiLGImJmYudGVzdChiKSYmKGM9JyBpZD1cIicrYisnXCInKSxmLnRlc3QoYSkmJk0ud3JpdGUoXCI8c2NyaXB0XCIrYysnIHNyYz1cIicrYSsnXCI+XFx4M2Mvc2NyaXB0PicpKTooYz1NLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiksYy50eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIsYy5hc3luYz0hMCxjLnNyYz1hLGImJihjLmlkPWIpLGE9TS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKVswXSxhLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGMsYSkpKX0sVWQ9ZnVuY3Rpb24oKXtyZXR1cm5cImh0dHBzOlwiPT1NLmxvY2F0aW9uLnByb3RvY29sfSxFPWZ1bmN0aW9uKGEsYil7dmFyIGM9XG5hLm1hdGNoKFwiKD86JnwjfFxcXFw/KVwiK0soYikucmVwbGFjZSgvKFsuKis/Xj0hOiR7fSgpfFxcW1xcXVxcL1xcXFxdKS9nLFwiXFxcXCQxXCIpK1wiPShbXiYjXSopXCIpO3JldHVybiBjJiYyPT1jLmxlbmd0aD9jWzFdOlwiXCJ9LHhhPWZ1bmN0aW9uKCl7dmFyIGE9XCJcIitNLmxvY2F0aW9uLmhvc3RuYW1lO3JldHVybiAwPT1hLmluZGV4T2YoXCJ3d3cuXCIpP2Euc3Vic3RyaW5nKDQpOmF9LHlhPWZ1bmN0aW9uKGEpe3ZhciBiPU0ucmVmZXJyZXI7aWYoL15odHRwcz86XFwvXFwvL2kudGVzdChiKSl7aWYoYSlyZXR1cm4gYjthPVwiLy9cIitNLmxvY2F0aW9uLmhvc3RuYW1lO3ZhciBjPWIuaW5kZXhPZihhKTtpZig1PT1jfHw2PT1jKWlmKGE9Yi5jaGFyQXQoYythLmxlbmd0aCksXCIvXCI9PWF8fFwiP1wiPT1hfHxcIlwiPT1hfHxcIjpcIj09YSlyZXR1cm47cmV0dXJuIGJ9fSx6YT1mdW5jdGlvbihhLGIpe2lmKDE9PWIubGVuZ3RoJiZudWxsIT1iWzBdJiZcIm9iamVjdFwiPT09dHlwZW9mIGJbMF0pcmV0dXJuIGJbMF07Zm9yKHZhciBjPVxue30sZD1NYXRoLm1pbihhLmxlbmd0aCsxLGIubGVuZ3RoKSxlPTA7ZTxkO2UrKylpZihcIm9iamVjdFwiPT09dHlwZW9mIGJbZV0pe2Zvcih2YXIgZyBpbiBiW2VdKWJbZV0uaGFzT3duUHJvcGVydHkoZykmJihjW2ddPWJbZV1bZ10pO2JyZWFrfWVsc2UgZTxhLmxlbmd0aCYmKGNbYVtlXV09YltlXSk7cmV0dXJuIGN9O3ZhciBlZT1mdW5jdGlvbigpe3RoaXMua2V5cz1bXTt0aGlzLnZhbHVlcz17fTt0aGlzLm09e319O2VlLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSxiLGMpe3RoaXMua2V5cy5wdXNoKGEpO2M/dGhpcy5tW1wiOlwiK2FdPWI6dGhpcy52YWx1ZXNbXCI6XCIrYV09Yn07ZWUucHJvdG90eXBlLmdldD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5tLmhhc093blByb3BlcnR5KFwiOlwiK2EpP3RoaXMubVtcIjpcIithXTp0aGlzLnZhbHVlc1tcIjpcIithXX07ZWUucHJvdG90eXBlLm1hcD1mdW5jdGlvbihhKXtmb3IodmFyIGI9MDtiPHRoaXMua2V5cy5sZW5ndGg7YisrKXt2YXIgYz10aGlzLmtleXNbYl0sZD10aGlzLmdldChjKTtkJiZhKGMsZCl9fTt2YXIgTz13aW5kb3csTT1kb2N1bWVudDt2YXIgRj13aW5kb3csRz1mdW5jdGlvbihhKXt2YXIgYj1GLl9nYVVzZXJQcmVmcztpZihiJiZiLmlvbyYmYi5pb28oKXx8YSYmITA9PT1GW1wiZ2EtZGlzYWJsZS1cIithXSlyZXR1cm4hMDt0cnl7dmFyIGM9Ri5leHRlcm5hbDtpZihjJiZjLl9nYVVzZXJQcmVmcyYmXCJvb1wiPT1jLl9nYVVzZXJQcmVmcylyZXR1cm4hMH1jYXRjaChkKXt9cmV0dXJuITF9O3ZhciBDYT1mdW5jdGlvbihhKXt2YXIgYj1bXSxjPU0uY29va2llLnNwbGl0KFwiO1wiKTthPW5ldyBSZWdFeHAoXCJeXFxcXHMqXCIrYStcIj1cXFxccyooLio/KVxcXFxzKiRcIik7Zm9yKHZhciBkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF0ubWF0Y2goYSk7ZSYmYi5wdXNoKGVbMV0pfXJldHVybiBifSx6Yz1mdW5jdGlvbihhLGIsYyxkLGUsZyl7ZT1HKGUpPyExOmViLnRlc3QoTS5sb2NhdGlvbi5ob3N0bmFtZSl8fFwiL1wiPT1jJiZ2Yy50ZXN0KGQpPyExOiEwO2lmKCFlKXJldHVybiExO2ImJjEyMDA8Yi5sZW5ndGgmJihiPWIuc3Vic3RyaW5nKDAsMTIwMCksSigyNCkpO2M9YStcIj1cIitiK1wiOyBwYXRoPVwiK2MrXCI7IFwiO2cmJihjKz1cImV4cGlyZXM9XCIrKG5ldyBEYXRlKChuZXcgRGF0ZSkuZ2V0VGltZSgpK2cpKS50b0dNVFN0cmluZygpK1wiOyBcIik7ZCYmXCJub25lXCIhPWQmJihjKz1cImRvbWFpbj1cIitkK1wiO1wiKTtkPU0uY29va2llO00uY29va2llPWM7aWYoIShkPWQhPU0uY29va2llKSlhOnthPVxuQ2EoYSk7Zm9yKGQ9MDtkPGEubGVuZ3RoO2QrKylpZihiPT1hW2RdKXtkPSEwO2JyZWFrIGF9ZD0hMX1yZXR1cm4gZH0sQ2M9ZnVuY3Rpb24oYSl7cmV0dXJuIEsoYSkucmVwbGFjZSgvXFwoL2csXCIlMjhcIikucmVwbGFjZSgvXFwpL2csXCIlMjlcIil9LHZjPS9eKHd3d1xcLik/Z29vZ2xlKFxcLmNvbT8pPyhcXC5bYS16XXsyfSk/JC8sZWI9LyhefFxcLilkb3VibGVjbGlja1xcLm5ldCQvaTt2YXIgb2M9ZnVuY3Rpb24oKXtyZXR1cm4oQmF8fFVkKCk/XCJodHRwczpcIjpcImh0dHA6XCIpK1wiLy93d3cuZ29vZ2xlLWFuYWx5dGljcy5jb21cIn0sRGE9ZnVuY3Rpb24oYSl7dGhpcy5uYW1lPVwibGVuXCI7dGhpcy5tZXNzYWdlPWErXCItODE5MlwifSxiYT1mdW5jdGlvbihhLGIsYyl7Yz1jfHx1YTtpZigyMDM2Pj1iLmxlbmd0aCl3YyhhLGIsYyk7ZWxzZSBpZig4MTkyPj1iLmxlbmd0aCl4KGEsYixjKXx8d2QoYSxiLGMpfHx3YyhhLGIsYyk7ZWxzZSB0aHJvdyBnZShcImxlblwiLGIubGVuZ3RoKSxuZXcgRGEoYi5sZW5ndGgpO30sd2M9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRhKGErXCI/XCIrYik7ZC5vbmxvYWQ9ZC5vbmVycm9yPWZ1bmN0aW9uKCl7ZC5vbmxvYWQ9bnVsbDtkLm9uZXJyb3I9bnVsbDtjKCl9fSx3ZD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9Ty5YTUxIdHRwUmVxdWVzdDtpZighZClyZXR1cm4hMTt2YXIgZT1uZXcgZDtpZighKFwid2l0aENyZWRlbnRpYWxzXCJpbiBlKSlyZXR1cm4hMTtcbmUub3BlbihcIlBPU1RcIixhLCEwKTtlLndpdGhDcmVkZW50aWFscz0hMDtlLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIixcInRleHQvcGxhaW5cIik7ZS5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXs0PT1lLnJlYWR5U3RhdGUmJihjKCksZT1udWxsKX07ZS5zZW5kKGIpO3JldHVybiEwfSx4PWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gTy5uYXZpZ2F0b3Iuc2VuZEJlYWNvbj9PLm5hdmlnYXRvci5zZW5kQmVhY29uKGEsYik/KGMoKSwhMCk6ITE6ITF9LGdlPWZ1bmN0aW9uKGEsYixjKXsxPD0xMDAqTWF0aC5yYW5kb20oKXx8RyhcIj9cIil8fChhPVtcInQ9ZXJyb3JcIixcIl9lPVwiK2EsXCJfdj1qNDdcIixcInNyPTFcIl0sYiYmYS5wdXNoKFwiX2Y9XCIrYiksYyYmYS5wdXNoKFwiX209XCIrSyhjLnN1YnN0cmluZygwLDEwMCkpKSxhLnB1c2goXCJhaXA9MVwiKSxhLnB1c2goXCJ6PVwiK2hkKCkpLHdjKG9jKCkrXCIvY29sbGVjdFwiLGEuam9pbihcIiZcIiksdWEpKX07dmFyIGg9ZnVuY3Rpb24oYSl7dmFyIGI9Ty5nYURhdGE9Ty5nYURhdGF8fHt9O3JldHVybiBiW2FdPWJbYV18fHt9fTt2YXIgSGE9ZnVuY3Rpb24oKXt0aGlzLk09W119O0hhLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oYSl7dGhpcy5NLnB1c2goYSl9O0hhLnByb3RvdHlwZS5EPWZ1bmN0aW9uKGEpe3RyeXtmb3IodmFyIGI9MDtiPHRoaXMuTS5sZW5ndGg7YisrKXt2YXIgYz1hLmdldCh0aGlzLk1bYl0pO2MmJmVhKGMpJiZjLmNhbGwoTyxhKX19Y2F0Y2goZCl7fWI9YS5nZXQoSWEpO2IhPXVhJiZlYShiKSYmKGEuc2V0KElhLHVhLCEwKSxzZXRUaW1lb3V0KGIsMTApKX07ZnVuY3Rpb24gSmEoYSl7aWYoMTAwIT1hLmdldChLYSkmJkxhKFAoYSxRKSklMUU0Pj0xMDAqUihhLEthKSl0aHJvd1wiYWJvcnRcIjt9ZnVuY3Rpb24gTWEoYSl7aWYoRyhQKGEsTmEpKSl0aHJvd1wiYWJvcnRcIjt9ZnVuY3Rpb24gT2EoKXt2YXIgYT1NLmxvY2F0aW9uLnByb3RvY29sO2lmKFwiaHR0cDpcIiE9YSYmXCJodHRwczpcIiE9YSl0aHJvd1wiYWJvcnRcIjt9XG5mdW5jdGlvbiBQYShhKXt0cnl7Ty5uYXZpZ2F0b3Iuc2VuZEJlYWNvbj9KKDQyKTpPLlhNTEh0dHBSZXF1ZXN0JiZcIndpdGhDcmVkZW50aWFsc1wiaW4gbmV3IE8uWE1MSHR0cFJlcXVlc3QmJkooNDApfWNhdGNoKGMpe31hLnNldChsZCxUZChhKSwhMCk7YS5zZXQoQWMsUihhLEFjKSsxKTt2YXIgYj1bXTtRYS5tYXAoZnVuY3Rpb24oYyxkKXtpZihkLkYpe3ZhciBlPWEuZ2V0KGMpO3ZvaWQgMCE9ZSYmZSE9ZC5kZWZhdWx0VmFsdWUmJihcImJvb2xlYW5cIj09dHlwZW9mIGUmJihlKj0xKSxiLnB1c2goZC5GK1wiPVwiK0soXCJcIitlKSkpfX0pO2IucHVzaChcIno9XCIrQmQoKSk7YS5zZXQoUmEsYi5qb2luKFwiJlwiKSwhMCl9XG5mdW5jdGlvbiBTYShhKXt2YXIgYj1QKGEsZ2QpfHxvYygpK1wiL2NvbGxlY3RcIixjPVAoYSxmYSk7IWMmJmEuZ2V0KFZkKSYmKGM9XCJiZWFjb25cIik7aWYoYyl7dmFyIGQ9UChhLFJhKSxlPWEuZ2V0KElhKSxlPWV8fHVhO1wiaW1hZ2VcIj09Yz93YyhiLGQsZSk6XCJ4aHJcIj09YyYmd2QoYixkLGUpfHxcImJlYWNvblwiPT1jJiZ4KGIsZCxlKXx8YmEoYixkLGUpfWVsc2UgYmEoYixQKGEsUmEpLGEuZ2V0KElhKSk7Yj1hLmdldChOYSk7Yj1oKGIpO2M9Yi5oaXRjb3VudDtiLmhpdGNvdW50PWM/YysxOjE7Yj1hLmdldChOYSk7ZGVsZXRlIGgoYikucGVuZGluZ19leHBlcmltZW50czthLnNldChJYSx1YSwhMCl9XG5mdW5jdGlvbiBIYyhhKXsoTy5nYURhdGE9Ty5nYURhdGF8fHt9KS5leHBJZCYmYS5zZXQoTmMsKE8uZ2FEYXRhPU8uZ2FEYXRhfHx7fSkuZXhwSWQpOyhPLmdhRGF0YT1PLmdhRGF0YXx8e30pLmV4cFZhciYmYS5zZXQoT2MsKE8uZ2FEYXRhPU8uZ2FEYXRhfHx7fSkuZXhwVmFyKTt2YXIgYjt2YXIgYz1hLmdldChOYSk7aWYoYz1oKGMpLnBlbmRpbmdfZXhwZXJpbWVudHMpe3ZhciBkPVtdO2ZvcihiIGluIGMpYy5oYXNPd25Qcm9wZXJ0eShiKSYmY1tiXSYmZC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChiKStcIi5cIitlbmNvZGVVUklDb21wb25lbnQoY1tiXSkpO2I9ZC5qb2luKFwiIVwiKX1lbHNlIGI9dm9pZCAwO2ImJmEuc2V0KG0sYiwhMCl9ZnVuY3Rpb24gY2QoKXtpZihPLm5hdmlnYXRvciYmXCJwcmV2aWV3XCI9PU8ubmF2aWdhdG9yLmxvYWRQdXJwb3NlKXRocm93XCJhYm9ydFwiO31cbmZ1bmN0aW9uIHlkKGEpe3ZhciBiPU8uZ2FEZXZJZHM7a2EoYikmJjAhPWIubGVuZ3RoJiZhLnNldChcIiZkaWRcIixiLmpvaW4oXCIsXCIpLCEwKX1mdW5jdGlvbiB2YihhKXtpZighYS5nZXQoTmEpKXRocm93XCJhYm9ydFwiO307dmFyIGhkPWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGgucm91bmQoMjE0NzQ4MzY0NypNYXRoLnJhbmRvbSgpKX0sQmQ9ZnVuY3Rpb24oKXt0cnl7dmFyIGE9bmV3IFVpbnQzMkFycmF5KDEpO08uY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhKTtyZXR1cm4gYVswXSYyMTQ3NDgzNjQ3fWNhdGNoKGIpe3JldHVybiBoZCgpfX07ZnVuY3Rpb24gVGEoYSl7dmFyIGI9UihhLFVhKTs1MDA8PWImJkooMTUpO3ZhciBjPVAoYSxWYSk7aWYoXCJ0cmFuc2FjdGlvblwiIT1jJiZcIml0ZW1cIiE9Yyl7dmFyIGM9UihhLFdhKSxkPShuZXcgRGF0ZSkuZ2V0VGltZSgpLGU9UihhLFhhKTswPT1lJiZhLnNldChYYSxkKTtlPU1hdGgucm91bmQoMiooZC1lKS8xRTMpOzA8ZSYmKGM9TWF0aC5taW4oYytlLDIwKSxhLnNldChYYSxkKSk7aWYoMD49Yyl0aHJvd1wiYWJvcnRcIjthLnNldChXYSwtLWMpfWEuc2V0KFVhLCsrYil9O3ZhciBZYT1mdW5jdGlvbigpe3RoaXMuZGF0YT1uZXcgZWV9LFFhPW5ldyBlZSxaYT1bXTtZYS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGEpe3ZhciBiPSRhKGEpLGM9dGhpcy5kYXRhLmdldChhKTtiJiZ2b2lkIDA9PWMmJihjPWVhKGIuZGVmYXVsdFZhbHVlKT9iLmRlZmF1bHRWYWx1ZSgpOmIuZGVmYXVsdFZhbHVlKTtyZXR1cm4gYiYmYi5aP2IuWih0aGlzLGEsYyk6Y307dmFyIFA9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmdldChiKTtyZXR1cm4gdm9pZCAwPT1jP1wiXCI6XCJcIitjfSxSPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5nZXQoYik7cmV0dXJuIHZvaWQgMD09Y3x8XCJcIj09PWM/MDoxKmN9O1lhLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSxiLGMpe2lmKGEpaWYoXCJvYmplY3RcIj09dHlwZW9mIGEpZm9yKHZhciBkIGluIGEpYS5oYXNPd25Qcm9wZXJ0eShkKSYmYWIodGhpcyxkLGFbZF0sYyk7ZWxzZSBhYih0aGlzLGEsYixjKX07XG52YXIgYWI9ZnVuY3Rpb24oYSxiLGMsZCl7aWYodm9pZCAwIT1jKXN3aXRjaChiKXtjYXNlIE5hOndiLnRlc3QoYyl9dmFyIGU9JGEoYik7ZSYmZS5vP2UubyhhLGIsYyxkKTphLmRhdGEuc2V0KGIsYyxkKX0sYmI9ZnVuY3Rpb24oYSxiLGMsZCxlKXt0aGlzLm5hbWU9YTt0aGlzLkY9Yjt0aGlzLlo9ZDt0aGlzLm89ZTt0aGlzLmRlZmF1bHRWYWx1ZT1jfSwkYT1mdW5jdGlvbihhKXt2YXIgYj1RYS5nZXQoYSk7aWYoIWIpZm9yKHZhciBjPTA7YzxaYS5sZW5ndGg7YysrKXt2YXIgZD1aYVtjXSxlPWRbMF0uZXhlYyhhKTtpZihlKXtiPWRbMV0oZSk7UWEuc2V0KGIubmFtZSxiKTticmVha319cmV0dXJuIGJ9LHljPWZ1bmN0aW9uKGEpe3ZhciBiO1FhLm1hcChmdW5jdGlvbihjLGQpe2QuRj09YSYmKGI9ZCl9KTtyZXR1cm4gYiYmYi5uYW1lfSxTPWZ1bmN0aW9uKGEsYixjLGQsZSl7YT1uZXcgYmIoYSxiLGMsZCxlKTtRYS5zZXQoYS5uYW1lLGEpO3JldHVybiBhLm5hbWV9LGNiPWZ1bmN0aW9uKGEsXG5iKXtaYS5wdXNoKFtuZXcgUmVnRXhwKFwiXlwiK2ErXCIkXCIpLGJdKX0sVD1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIFMoYSxiLGMsdm9pZCAwLGRiKX0sZGI9ZnVuY3Rpb24oKXt9O3ZhciBnYj1xYSh3aW5kb3cuR29vZ2xlQW5hbHl0aWNzT2JqZWN0KSYmc2Eod2luZG93Lkdvb2dsZUFuYWx5dGljc09iamVjdCl8fFwiZ2FcIixCYT0hMSxoYj1UKFwiYXBpVmVyc2lvblwiLFwidlwiKSxpYj1UKFwiY2xpZW50VmVyc2lvblwiLFwiX3ZcIik7UyhcImFub255bWl6ZUlwXCIsXCJhaXBcIik7dmFyIGpiPVMoXCJhZFNlbnNlSWRcIixcImFcIiksVmE9UyhcImhpdFR5cGVcIixcInRcIiksSWE9UyhcImhpdENhbGxiYWNrXCIpLFJhPVMoXCJoaXRQYXlsb2FkXCIpO1MoXCJub25JbnRlcmFjdGlvblwiLFwibmlcIik7UyhcImN1cnJlbmN5Q29kZVwiLFwiY3VcIik7UyhcImRhdGFTb3VyY2VcIixcImRzXCIpO3ZhciBWZD1TKFwidXNlQmVhY29uXCIsdm9pZCAwLCExKSxmYT1TKFwidHJhbnNwb3J0XCIpO1MoXCJzZXNzaW9uQ29udHJvbFwiLFwic2NcIixcIlwiKTtTKFwic2Vzc2lvbkdyb3VwXCIsXCJzZ1wiKTtTKFwicXVldWVUaW1lXCIsXCJxdFwiKTt2YXIgQWM9UyhcIl9zXCIsXCJfc1wiKTtTKFwic2NyZWVuTmFtZVwiLFwiY2RcIik7XG52YXIga2I9UyhcImxvY2F0aW9uXCIsXCJkbFwiLFwiXCIpLGxiPVMoXCJyZWZlcnJlclwiLFwiZHJcIiksbWI9UyhcInBhZ2VcIixcImRwXCIsXCJcIik7UyhcImhvc3RuYW1lXCIsXCJkaFwiKTt2YXIgbmI9UyhcImxhbmd1YWdlXCIsXCJ1bFwiKSxvYj1TKFwiZW5jb2RpbmdcIixcImRlXCIpO1MoXCJ0aXRsZVwiLFwiZHRcIixmdW5jdGlvbigpe3JldHVybiBNLnRpdGxlfHx2b2lkIDB9KTtjYihcImNvbnRlbnRHcm91cChbMC05XSspXCIsZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBiYihhWzBdLFwiY2dcIithWzFdKX0pO3ZhciBwYj1TKFwic2NyZWVuQ29sb3JzXCIsXCJzZFwiKSxxYj1TKFwic2NyZWVuUmVzb2x1dGlvblwiLFwic3JcIikscmI9UyhcInZpZXdwb3J0U2l6ZVwiLFwidnBcIiksc2I9UyhcImphdmFFbmFibGVkXCIsXCJqZVwiKSx0Yj1TKFwiZmxhc2hWZXJzaW9uXCIsXCJmbFwiKTtTKFwiY2FtcGFpZ25JZFwiLFwiY2lcIik7UyhcImNhbXBhaWduTmFtZVwiLFwiY25cIik7UyhcImNhbXBhaWduU291cmNlXCIsXCJjc1wiKTtTKFwiY2FtcGFpZ25NZWRpdW1cIixcImNtXCIpO1xuUyhcImNhbXBhaWduS2V5d29yZFwiLFwiY2tcIik7UyhcImNhbXBhaWduQ29udGVudFwiLFwiY2NcIik7dmFyIHViPVMoXCJldmVudENhdGVnb3J5XCIsXCJlY1wiKSx4Yj1TKFwiZXZlbnRBY3Rpb25cIixcImVhXCIpLHliPVMoXCJldmVudExhYmVsXCIsXCJlbFwiKSx6Yj1TKFwiZXZlbnRWYWx1ZVwiLFwiZXZcIiksQmI9UyhcInNvY2lhbE5ldHdvcmtcIixcInNuXCIpLENiPVMoXCJzb2NpYWxBY3Rpb25cIixcInNhXCIpLERiPVMoXCJzb2NpYWxUYXJnZXRcIixcInN0XCIpLEViPVMoXCJsMVwiLFwicGx0XCIpLEZiPVMoXCJsMlwiLFwicGR0XCIpLEdiPVMoXCJsM1wiLFwiZG5zXCIpLEhiPVMoXCJsNFwiLFwicnJ0XCIpLEliPVMoXCJsNVwiLFwic3J0XCIpLEpiPVMoXCJsNlwiLFwidGNwXCIpLEtiPVMoXCJsN1wiLFwiZGl0XCIpLExiPVMoXCJsOFwiLFwiY2x0XCIpLE1iPVMoXCJ0aW1pbmdDYXRlZ29yeVwiLFwidXRjXCIpLE5iPVMoXCJ0aW1pbmdWYXJcIixcInV0dlwiKSxPYj1TKFwidGltaW5nTGFiZWxcIixcInV0bFwiKSxQYj1TKFwidGltaW5nVmFsdWVcIixcInV0dFwiKTtTKFwiYXBwTmFtZVwiLFwiYW5cIik7XG5TKFwiYXBwVmVyc2lvblwiLFwiYXZcIixcIlwiKTtTKFwiYXBwSWRcIixcImFpZFwiLFwiXCIpO1MoXCJhcHBJbnN0YWxsZXJJZFwiLFwiYWlpZFwiLFwiXCIpO1MoXCJleERlc2NyaXB0aW9uXCIsXCJleGRcIik7UyhcImV4RmF0YWxcIixcImV4ZlwiKTt2YXIgTmM9UyhcImV4cElkXCIsXCJ4aWRcIiksT2M9UyhcImV4cFZhclwiLFwieHZhclwiKSxtPVMoXCJleHBcIixcImV4cFwiKSxSYz1TKFwiX3V0bWFcIixcIl91dG1hXCIpLFNjPVMoXCJfdXRtelwiLFwiX3V0bXpcIiksVGM9UyhcIl91dG1odFwiLFwiX3V0bWh0XCIpLFVhPVMoXCJfaGNcIix2b2lkIDAsMCksWGE9UyhcIl90aVwiLHZvaWQgMCwwKSxXYT1TKFwiX3RvXCIsdm9pZCAwLDIwKTtjYihcImRpbWVuc2lvbihbMC05XSspXCIsZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBiYihhWzBdLFwiY2RcIithWzFdKX0pO2NiKFwibWV0cmljKFswLTldKylcIixmdW5jdGlvbihhKXtyZXR1cm4gbmV3IGJiKGFbMF0sXCJjbVwiK2FbMV0pfSk7UyhcImxpbmtlclBhcmFtXCIsdm9pZCAwLHZvaWQgMCxCYyxkYik7XG52YXIgbGQ9UyhcInVzYWdlXCIsXCJfdVwiKSxHZD1TKFwiX3VtXCIpO1MoXCJmb3JjZVNTTFwiLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gQmF9LGZ1bmN0aW9uKGEsYixjKXtKKDM0KTtCYT0hIWN9KTt2YXIgZWQ9UyhcIl9qMVwiLFwiamlkXCIpO2NiKFwiXFxcXCYoLiopXCIsZnVuY3Rpb24oYSl7dmFyIGI9bmV3IGJiKGFbMF0sYVsxXSksYz15YyhhWzBdLnN1YnN0cmluZygxKSk7YyYmKGIuWj1mdW5jdGlvbihhKXtyZXR1cm4gYS5nZXQoYyl9LGIubz1mdW5jdGlvbihhLGIsZyxjYSl7YS5zZXQoYyxnLGNhKX0sYi5GPXZvaWQgMCk7cmV0dXJuIGJ9KTtcbnZhciBRYj1UKFwiX29vdFwiKSxkZD1TKFwicHJldmlld1Rhc2tcIiksUmI9UyhcImNoZWNrUHJvdG9jb2xUYXNrXCIpLG1kPVMoXCJ2YWxpZGF0aW9uVGFza1wiKSxTYj1TKFwiY2hlY2tTdG9yYWdlVGFza1wiKSxVYz1TKFwiaGlzdG9yeUltcG9ydFRhc2tcIiksVGI9UyhcInNhbXBsZXJUYXNrXCIpLFZiPVMoXCJfcmx0XCIpLFdiPVMoXCJidWlsZEhpdFRhc2tcIiksWGI9UyhcInNlbmRIaXRUYXNrXCIpLFZjPVMoXCJjZVRhc2tcIiksemQ9UyhcImRldklkVGFza1wiKSxDZD1TKFwidGltaW5nVGFza1wiKSxMZD1TKFwiZGlzcGxheUZlYXR1cmVzVGFza1wiKSxWPVQoXCJuYW1lXCIpLFE9VChcImNsaWVudElkXCIsXCJjaWRcIiksbj1UKFwiY2xpZW50SWRUaW1lXCIpLEFkPVMoXCJ1c2VySWRcIixcInVpZFwiKSxOYT1UKFwidHJhY2tpbmdJZFwiLFwidGlkXCIpLFU9VChcImNvb2tpZU5hbWVcIix2b2lkIDAsXCJfZ2FcIiksVz1UKFwiY29va2llRG9tYWluXCIpLFliPVQoXCJjb29raWVQYXRoXCIsdm9pZCAwLFwiL1wiKSxaYj1UKFwiY29va2llRXhwaXJlc1wiLHZvaWQgMCw2MzA3MkUzKSxcbiRiPVQoXCJsZWdhY3lDb29raWVEb21haW5cIiksV2M9VChcImxlZ2FjeUhpc3RvcnlJbXBvcnRcIix2b2lkIDAsITApLGFjPVQoXCJzdG9yYWdlXCIsdm9pZCAwLFwiY29va2llXCIpLGJjPVQoXCJhbGxvd0xpbmtlclwiLHZvaWQgMCwhMSksY2M9VChcImFsbG93QW5jaG9yXCIsdm9pZCAwLCEwKSxLYT1UKFwic2FtcGxlUmF0ZVwiLFwic2ZcIiwxMDApLGRjPVQoXCJzaXRlU3BlZWRTYW1wbGVSYXRlXCIsdm9pZCAwLDEpLGVjPVQoXCJhbHdheXNTZW5kUmVmZXJyZXJcIix2b2lkIDAsITEpLGdkPVMoXCJ0cmFuc3BvcnRVcmxcIiksTWQ9UyhcIl9yXCIsXCJfclwiKTtmdW5jdGlvbiBYKGEsYixjLGQpe2JbYV09ZnVuY3Rpb24oKXt0cnl7cmV0dXJuIGQmJkooZCksYy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y2F0Y2goZSl7dGhyb3cgZ2UoXCJleGNcIixhLGUmJmUubmFtZSksZTt9fX07dmFyIE9kPWZ1bmN0aW9uKGEpe3RoaXMuVj1hO3RoaXMuZmE9dm9pZCAwO3RoaXMuJD0hMTt0aGlzLm9hPXZvaWQgMDt0aGlzLmVhPTF9LEVkPWZ1bmN0aW9uKGEsYil7dmFyIGM7aWYoYS5mYSYmYS4kKXJldHVybiAwO2EuJD0hMDtpZihiKXtpZihhLm9hJiZSKGIsYS5vYSkpcmV0dXJuIFIoYixhLm9hKTtpZigwPT1iLmdldChkYykpcmV0dXJuIDB9aWYoMD09YS5WKXJldHVybiAwO3ZvaWQgMD09PWMmJihjPUJkKCkpO3JldHVybiAwPT1jJWEuVj9NYXRoLmZsb29yKGMvYS5WKSVhLmVhKzE6MH07ZnVuY3Rpb24gZmMoKXt2YXIgYSxiLGM7aWYoKGM9KGM9Ty5uYXZpZ2F0b3IpP2MucGx1Z2luczpudWxsKSYmYy5sZW5ndGgpZm9yKHZhciBkPTA7ZDxjLmxlbmd0aCYmIWI7ZCsrKXt2YXIgZT1jW2RdOy0xPGUubmFtZS5pbmRleE9mKFwiU2hvY2t3YXZlIEZsYXNoXCIpJiYoYj1lLmRlc2NyaXB0aW9uKX1pZighYil0cnl7YT1uZXcgQWN0aXZlWE9iamVjdChcIlNob2Nrd2F2ZUZsYXNoLlNob2Nrd2F2ZUZsYXNoLjdcIiksYj1hLkdldFZhcmlhYmxlKFwiJHZlcnNpb25cIil9Y2F0Y2goZyl7fWlmKCFiKXRyeXthPW5ldyBBY3RpdmVYT2JqZWN0KFwiU2hvY2t3YXZlRmxhc2guU2hvY2t3YXZlRmxhc2guNlwiKSxiPVwiV0lOIDYsMCwyMSwwXCIsYS5BbGxvd1NjcmlwdEFjY2Vzcz1cImFsd2F5c1wiLGI9YS5HZXRWYXJpYWJsZShcIiR2ZXJzaW9uXCIpfWNhdGNoKGcpe31pZighYil0cnl7YT1uZXcgQWN0aXZlWE9iamVjdChcIlNob2Nrd2F2ZUZsYXNoLlNob2Nrd2F2ZUZsYXNoXCIpLGI9YS5HZXRWYXJpYWJsZShcIiR2ZXJzaW9uXCIpfWNhdGNoKGcpe31iJiZcbihhPWIubWF0Y2goL1tcXGRdKy9nKSkmJjM8PWEubGVuZ3RoJiYoYj1hWzBdK1wiLlwiK2FbMV0rXCIgclwiK2FbMl0pO3JldHVybiBifHx2b2lkIDB9O3ZhciBhYT1mdW5jdGlvbihhKXt2YXIgYj1NYXRoLm1pbihSKGEsZGMpLDEwMCk7cmV0dXJuIExhKFAoYSxRKSklMTAwPj1iPyExOiEwfSxnYz1mdW5jdGlvbihhKXt2YXIgYj17fTtpZihFYyhiKXx8RmMoYikpe3ZhciBjPWJbRWJdO3ZvaWQgMD09Y3x8SW5maW5pdHk9PWN8fGlzTmFOKGMpfHwoMDxjPyhZKGIsR2IpLFkoYixKYiksWShiLEliKSxZKGIsRmIpLFkoYixIYiksWShiLEtiKSxZKGIsTGIpLGEoYikpOkwoTyxcImxvYWRcIixmdW5jdGlvbigpe2djKGEpfSwhMSkpfX0sRWM9ZnVuY3Rpb24oYSl7dmFyIGI9Ty5wZXJmb3JtYW5jZXx8Ty53ZWJraXRQZXJmb3JtYW5jZSxiPWImJmIudGltaW5nO2lmKCFiKXJldHVybiExO3ZhciBjPWIubmF2aWdhdGlvblN0YXJ0O2lmKDA9PWMpcmV0dXJuITE7YVtFYl09Yi5sb2FkRXZlbnRTdGFydC1jO2FbR2JdPWIuZG9tYWluTG9va3VwRW5kLWIuZG9tYWluTG9va3VwU3RhcnQ7YVtKYl09Yi5jb25uZWN0RW5kLWIuY29ubmVjdFN0YXJ0O2FbSWJdPVxuYi5yZXNwb25zZVN0YXJ0LWIucmVxdWVzdFN0YXJ0O2FbRmJdPWIucmVzcG9uc2VFbmQtYi5yZXNwb25zZVN0YXJ0O2FbSGJdPWIuZmV0Y2hTdGFydC1jO2FbS2JdPWIuZG9tSW50ZXJhY3RpdmUtYzthW0xiXT1iLmRvbUNvbnRlbnRMb2FkZWRFdmVudFN0YXJ0LWM7cmV0dXJuITB9LEZjPWZ1bmN0aW9uKGEpe2lmKE8udG9wIT1PKXJldHVybiExO3ZhciBiPU8uZXh0ZXJuYWwsYz1iJiZiLm9ubG9hZFQ7YiYmIWIuaXNWYWxpZExvYWRUaW1lJiYoYz12b2lkIDApOzIxNDc0ODM2NDg8YyYmKGM9dm9pZCAwKTswPGMmJmIuc2V0UGFnZVJlYWR5VGltZSgpO2lmKHZvaWQgMD09YylyZXR1cm4hMTthW0ViXT1jO3JldHVybiEwfSxZPWZ1bmN0aW9uKGEsYil7dmFyIGM9YVtiXTtpZihpc05hTihjKXx8SW5maW5pdHk9PWN8fDA+YylhW2JdPXZvaWQgMH0sRmQ9ZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe2lmKFwicGFnZXZpZXdcIj09Yi5nZXQoVmEpJiYhYS5JKXthLkk9ITA7dmFyIGM9XG5hYShiKTtiPTA8RShiLmdldChrYiksXCJnY2xpZFwiKS5sZW5ndGg7KGN8fGIpJiZnYyhmdW5jdGlvbihiKXthLnNlbmQoYz9cInRpbWluZ1wiOlwiYWR0aW1pbmdcIixiKX0pfX19O3ZhciBoYz0hMSxtYz1mdW5jdGlvbihhKXtpZihcImNvb2tpZVwiPT1QKGEsYWMpKXt2YXIgYj1QKGEsVSksYz1uZChhKSxkPWtjKFAoYSxZYikpLGU9bGMoUChhLFcpKSxnPTFFMypSKGEsWmIpLGNhPVAoYSxOYSk7aWYoXCJhdXRvXCIhPWUpemMoYixjLGQsZSxjYSxnKSYmKGhjPSEwKTtlbHNle0ooMzIpO3ZhciBsO2E6e2M9W107ZT14YSgpLnNwbGl0KFwiLlwiKTtpZig0PT1lLmxlbmd0aCYmKGw9ZVtlLmxlbmd0aC0xXSxwYXJzZUludChsLDEwKT09bCkpe2w9W1wibm9uZVwiXTticmVhayBhfWZvcihsPWUubGVuZ3RoLTI7MDw9bDtsLS0pYy5wdXNoKGUuc2xpY2UobCkuam9pbihcIi5cIikpO2MucHVzaChcIm5vbmVcIik7bD1jfWZvcih2YXIgaz0wO2s8bC5sZW5ndGg7aysrKWlmKGU9bFtrXSxhLmRhdGEuc2V0KFcsZSksYz1uZChhKSx6YyhiLGMsZCxlLGNhLGcpKXtoYz0hMDtyZXR1cm59YS5kYXRhLnNldChXLFwiYXV0b1wiKX19fSxuYz1mdW5jdGlvbihhKXtpZihcImNvb2tpZVwiPT1QKGEsYWMpJiZcbiFoYyYmKG1jKGEpLCFoYykpdGhyb3dcImFib3J0XCI7fSxZYz1mdW5jdGlvbihhKXtpZihhLmdldChXYykpe3ZhciBiPVAoYSxXKSxjPVAoYSwkYil8fHhhKCksZD1YYyhcIl9fdXRtYVwiLGMsYik7ZCYmKEooMTkpLGEuc2V0KFRjLChuZXcgRGF0ZSkuZ2V0VGltZSgpLCEwKSxhLnNldChSYyxkLlIpLChiPVhjKFwiX191dG16XCIsYyxiKSkmJmQuaGFzaD09Yi5oYXNoJiZhLnNldChTYyxiLlIpKX19LG5kPWZ1bmN0aW9uKGEpe3ZhciBiPUNjKFAoYSxRKSksYz1sYyhQKGEsVykpLnNwbGl0KFwiLlwiKS5sZW5ndGg7YT1qYyhQKGEsWWIpKTsxPGEmJihjKz1cIi1cIithKTtyZXR1cm5bXCJHQTFcIixjLGJdLmpvaW4oXCIuXCIpfSxHYz1mdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPVtdLGU9W10sZyxjYT0wO2NhPGEubGVuZ3RoO2NhKyspe3ZhciBsPWFbY2FdO2wuSFtjXT09Yj9kLnB1c2gobCk6dm9pZCAwPT1nfHxsLkhbY108Zz8oZT1bbF0sZz1sLkhbY10pOmwuSFtjXT09ZyYmZS5wdXNoKGwpfXJldHVybiAwPFxuZC5sZW5ndGg/ZDplfSxsYz1mdW5jdGlvbihhKXtyZXR1cm4gMD09YS5pbmRleE9mKFwiLlwiKT9hLnN1YnN0cigxKTphfSxrYz1mdW5jdGlvbihhKXtpZighYSlyZXR1cm5cIi9cIjsxPGEubGVuZ3RoJiZhLmxhc3RJbmRleE9mKFwiL1wiKT09YS5sZW5ndGgtMSYmKGE9YS5zdWJzdHIoMCxhLmxlbmd0aC0xKSk7MCE9YS5pbmRleE9mKFwiL1wiKSYmKGE9XCIvXCIrYSk7cmV0dXJuIGF9LGpjPWZ1bmN0aW9uKGEpe2E9a2MoYSk7cmV0dXJuXCIvXCI9PWE/MTphLnNwbGl0KFwiL1wiKS5sZW5ndGh9O2Z1bmN0aW9uIFhjKGEsYixjKXtcIm5vbmVcIj09YiYmKGI9XCJcIik7dmFyIGQ9W10sZT1DYShhKTthPVwiX191dG1hXCI9PWE/NjoyO2Zvcih2YXIgZz0wO2c8ZS5sZW5ndGg7ZysrKXt2YXIgY2E9KFwiXCIrZVtnXSkuc3BsaXQoXCIuXCIpO2NhLmxlbmd0aD49YSYmZC5wdXNoKHtoYXNoOmNhWzBdLFI6ZVtnXSxPOmNhfSl9aWYoMCE9ZC5sZW5ndGgpcmV0dXJuIDE9PWQubGVuZ3RoP2RbMF06WmMoYixkKXx8WmMoYyxkKXx8WmMobnVsbCxkKXx8ZFswXX1mdW5jdGlvbiBaYyhhLGIpe3ZhciBjLGQ7bnVsbD09YT9jPWQ9MTooYz1MYShhKSxkPUxhKEQoYSxcIi5cIik/YS5zdWJzdHJpbmcoMSk6XCIuXCIrYSkpO2Zvcih2YXIgZT0wO2U8Yi5sZW5ndGg7ZSsrKWlmKGJbZV0uaGFzaD09Y3x8YltlXS5oYXNoPT1kKXJldHVybiBiW2VdfTt2YXIgb2Q9bmV3IFJlZ0V4cCgvXmh0dHBzPzpcXC9cXC8oW15cXC86XSspLykscGQ9LyguKikoWz8mI10pKD86X2dhPVteJiNdKikoPzomPykoLiopLztmdW5jdGlvbiBCYyhhKXthPWEuZ2V0KFEpO3ZhciBiPUljKGEsMCk7cmV0dXJuXCJfZ2E9MS5cIitLKGIrXCIuXCIrYSl9ZnVuY3Rpb24gSWMoYSxiKXtmb3IodmFyIGM9bmV3IERhdGUsZD1PLm5hdmlnYXRvcixlPWQucGx1Z2luc3x8W10sYz1bYSxkLnVzZXJBZ2VudCxjLmdldFRpbWV6b25lT2Zmc2V0KCksYy5nZXRZZWFyKCksYy5nZXREYXRlKCksYy5nZXRIb3VycygpLGMuZ2V0TWludXRlcygpK2JdLGQ9MDtkPGUubGVuZ3RoOysrZCljLnB1c2goZVtkXS5kZXNjcmlwdGlvbik7cmV0dXJuIExhKGMuam9pbihcIi5cIikpfXZhciBEYz1mdW5jdGlvbihhKXtKKDQ4KTt0aGlzLnRhcmdldD1hO3RoaXMuVD0hMX07XG5EYy5wcm90b3R5cGUuY2E9ZnVuY3Rpb24oYSxiKXtpZihhLnRhZ05hbWUpe2lmKFwiYVwiPT1hLnRhZ05hbWUudG9Mb3dlckNhc2UoKSl7YS5ocmVmJiYoYS5ocmVmPXFkKHRoaXMsYS5ocmVmLGIpKTtyZXR1cm59aWYoXCJmb3JtXCI9PWEudGFnTmFtZS50b0xvd2VyQ2FzZSgpKXJldHVybiByZCh0aGlzLGEpfWlmKFwic3RyaW5nXCI9PXR5cGVvZiBhKXJldHVybiBxZCh0aGlzLGEsYil9O1xudmFyIHFkPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1wZC5leGVjKGIpO2QmJjM8PWQubGVuZ3RoJiYoYj1kWzFdKyhkWzNdP2RbMl0rZFszXTpcIlwiKSk7YT1hLnRhcmdldC5nZXQoXCJsaW5rZXJQYXJhbVwiKTt2YXIgZT1iLmluZGV4T2YoXCI/XCIpLGQ9Yi5pbmRleE9mKFwiI1wiKTtjP2IrPSgtMT09ZD9cIiNcIjpcIiZcIikrYTooYz0tMT09ZT9cIj9cIjpcIiZcIixiPS0xPT1kP2IrKGMrYSk6Yi5zdWJzdHJpbmcoMCxkKStjK2ErYi5zdWJzdHJpbmcoZCkpO3JldHVybiBiPWIucmVwbGFjZSgvJitfZ2E9LyxcIiZfZ2E9XCIpfSxyZD1mdW5jdGlvbihhLGIpe2lmKGImJmIuYWN0aW9uKXt2YXIgYz1hLnRhcmdldC5nZXQoXCJsaW5rZXJQYXJhbVwiKS5zcGxpdChcIj1cIilbMV07aWYoXCJnZXRcIj09Yi5tZXRob2QudG9Mb3dlckNhc2UoKSl7Zm9yKHZhciBkPWIuY2hpbGROb2Rlc3x8W10sZT0wO2U8ZC5sZW5ndGg7ZSsrKWlmKFwiX2dhXCI9PWRbZV0ubmFtZSl7ZFtlXS5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLGMpO3JldHVybn1kPVxuTS5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7ZC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJoaWRkZW5cIik7ZC5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsXCJfZ2FcIik7ZC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLGMpO2IuYXBwZW5kQ2hpbGQoZCl9ZWxzZVwicG9zdFwiPT1iLm1ldGhvZC50b0xvd2VyQ2FzZSgpJiYoYi5hY3Rpb249cWQoYSxiLmFjdGlvbikpfX07XG5EYy5wcm90b3R5cGUuUz1mdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZChjKXt0cnl7Yz1jfHxPLmV2ZW50O3ZhciBkO2E6e3ZhciBnPWMudGFyZ2V0fHxjLnNyY0VsZW1lbnQ7Zm9yKGM9MTAwO2cmJjA8Yzspe2lmKGcuaHJlZiYmZy5ub2RlTmFtZS5tYXRjaCgvXmEoPzpyZWEpPyQvaSkpe2Q9ZzticmVhayBhfWc9Zy5wYXJlbnROb2RlO2MtLX1kPXt9fShcImh0dHA6XCI9PWQucHJvdG9jb2x8fFwiaHR0cHM6XCI9PWQucHJvdG9jb2wpJiZzZChhLGQuaG9zdG5hbWV8fFwiXCIpJiZkLmhyZWYmJihkLmhyZWY9cWQoZSxkLmhyZWYsYikpfWNhdGNoKGspe0ooMjYpfX12YXIgZT10aGlzO3RoaXMuVHx8KHRoaXMuVD0hMCxMKE0sXCJtb3VzZWRvd25cIixkLCExKSxMKE0sXCJrZXl1cFwiLGQsITEpKTtjJiZMKE0sXCJzdWJtaXRcIixmdW5jdGlvbihiKXtiPWJ8fE8uZXZlbnQ7aWYoKGI9Yi50YXJnZXR8fGIuc3JjRWxlbWVudCkmJmIuYWN0aW9uKXt2YXIgYz1iLmFjdGlvbi5tYXRjaChvZCk7YyYmc2QoYSxcbmNbMV0pJiZyZChlLGIpfX0pfTtmdW5jdGlvbiBzZChhLGIpe2lmKGI9PU0ubG9jYXRpb24uaG9zdG5hbWUpcmV0dXJuITE7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspaWYoYVtjXWluc3RhbmNlb2YgUmVnRXhwKXtpZihhW2NdLnRlc3QoYikpcmV0dXJuITB9ZWxzZSBpZigwPD1iLmluZGV4T2YoYVtjXSkpcmV0dXJuITA7cmV0dXJuITF9O3ZhciBwPS9eKEdUTXxPUFQpLVtBLVowLTldKyQvLHE9LztfZ2FleHA9W147XSovZyxyPS87KChfX3V0bWE9KXwoW147PV0rPUdBWD9cXGQrXFwuKSlbXjtdKi9nLHQ9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihhLGIpe2ImJihjKz1cIiZcIithK1wiPVwiK0soYikpfXZhciBjPVwiaHR0cHM6Ly93d3cuZ29vZ2xlLWFuYWx5dGljcy5jb20vZ3RtL2pzP2lkPVwiK0soYS5pZCk7XCJkYXRhTGF5ZXJcIiE9YS5CJiZiKFwibFwiLGEuQik7YihcInRcIixhLnRhcmdldCk7YihcImNpZFwiLGEuamEpO2IoXCJjaWR0XCIsYS5rYSk7YihcImdhY1wiLGEubGEpO2IoXCJhaXBcIixhLmlhKTthLm5hJiZiKFwibVwiLFwic3luY1wiKTtiKFwiY3ljbGVcIixhLkcpO3JldHVybiBjfTt2YXIgSmQ9ZnVuY3Rpb24oYSxiLGMpe3RoaXMuVT1lZDt0aGlzLmFhPWI7KGI9Yyl8fChiPShiPVAoYSxWKSkmJlwidDBcIiE9Yj9XZC50ZXN0KGIpP1wiX2dhdF9cIitDYyhQKGEsTmEpKTpcIl9nYXRfXCIrQ2MoYik6XCJfZ2F0XCIpO3RoaXMuWT1iO0VkKG5ldyBPZCgxMDApLGEpJiYoSigzMCksdGhpcy5wYT0hMCl9LFJkPWZ1bmN0aW9uKGEsYil7dmFyIGM9Yi5nZXQoV2IpO2Iuc2V0KFdiLGZ1bmN0aW9uKGIpe1BkKGEsYik7dmFyIGQ9YyhiKTtRZChhLGIpO3JldHVybiBkfSk7dmFyIGQ9Yi5nZXQoWGIpO2Iuc2V0KFhiLGZ1bmN0aW9uKGIpe3ZhciBjPWQoYik7SWQoYSxiKTtyZXR1cm4gY30pfSxQZD1mdW5jdGlvbihhLGIpe2IuZ2V0KGEuVSl8fChcIjFcIj09Q2EoYS5ZKVswXT9iLnNldChhLlUsXCJcIiwhMCk6Yi5zZXQoYS5VLFwiXCIraGQoKSwhMCkpfSxRZD1mdW5jdGlvbihhLGIpe2lmKGIuZ2V0KGEuVSkpe3ZhciBjPTZFNTthLnBhJiYoYy89MTApO3pjKGEuWSxcIjFcIixiLmdldChZYiksYi5nZXQoVyksXG5iLmdldChOYSksYyl9fSxJZD1mdW5jdGlvbihhLGIpe2lmKGIuZ2V0KGEuVSkpe3ZhciBjPW5ldyBlZSxkPWZ1bmN0aW9uKGEpeyRhKGEpLkYmJmMuc2V0KCRhKGEpLkYsYi5nZXQoYSkpfTtkKGhiKTtkKGliKTtkKE5hKTtkKFEpO2QoQWQpO2QoYS5VKTtjLnNldCgkYShsZCkuRixUZChiKSk7dmFyIGU9YS5hYTtjLm1hcChmdW5jdGlvbihhLGIpe2UrPUsoYSkrXCI9XCI7ZSs9SyhcIlwiK2IpK1wiJlwifSk7ZSs9XCJ6PVwiK2hkKCk7dGEoZSk7Yi5zZXQoYS5VLFwiXCIsITApfX0sV2Q9L15ndG1cXGQrJC87dmFyIGZkPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5iO2lmKCFjLmdldChcImRjTG9hZGVkXCIpKXtOZChjLDI5KTtiPWJ8fHt9O3ZhciBkO2JbVV0mJihkPUNjKGJbVV0pKTtkPW5ldyBKZChjLFwiaHR0cHM6Ly9zdGF0cy5nLmRvdWJsZWNsaWNrLm5ldC9yL2NvbGxlY3Q/dD1kYyZhaXA9MSZfcj0zJlwiLGQpO1JkKGQsYyk7Yy5zZXQoXCJkY0xvYWRlZFwiLCEwKX19O3ZhciBTZD1mdW5jdGlvbihhKXtpZighYS5nZXQoXCJkY0xvYWRlZFwiKSYmXCJjb29raWVcIj09YS5nZXQoYWMpKXtOZChhLDUxKTt2YXIgYj1uZXcgSmQoYSk7UGQoYixhKTtRZChiLGEpO2EuZ2V0KGIuVSkmJihhLnNldChNZCwxLCEwKSxhLnNldChnZCxvYygpK1wiL3IvY29sbGVjdFwiLCEwKSl9fTt2YXIgTGM9ZnVuY3Rpb24oKXt2YXIgYT1PLmdhR2xvYmFsPU8uZ2FHbG9iYWx8fHt9O3JldHVybiBhLmhpZD1hLmhpZHx8aGQoKX07dmFyIGFkLGJkPWZ1bmN0aW9uKGEsYixjKXtpZighYWQpe3ZhciBkO2Q9TS5sb2NhdGlvbi5oYXNoO3ZhciBlPU8ubmFtZSxnPS9eIz9nYXNvPShbXiZdKikvO2lmKGU9KGQ9KGQ9ZCYmZC5tYXRjaChnKXx8ZSYmZS5tYXRjaChnKSk/ZFsxXTpDYShcIkdBU09cIilbMF18fFwiXCIpJiZkLm1hdGNoKC9eKD86IShbLTAtOWEtei5dezEsNDB9KSEpPyhbLS5cXHddezEwLDEyMDB9KSQvaSkpemMoXCJHQVNPXCIsXCJcIitkLGMsYixhLDApLHdpbmRvdy5fdWRvfHwod2luZG93Ll91ZG89Yiksd2luZG93Ll91dGNwfHwod2luZG93Ll91dGNwPWMpLGE9ZVsxXSx3YShcImh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vYW5hbHl0aWNzL3dlYi9pbnBhZ2UvcHViL2lucGFnZS5qcz9cIisoYT9cInByZWZpeD1cIithK1wiJlwiOlwiXCIpK2hkKCksXCJfZ2Fzb2pzXCIpO2FkPSEwfX07dmFyIHdiPS9eKFVBfFlUfE1PfEdQKS0oXFxkKyktKFxcZCspJC8scGM9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihhLGIpe2QuYi5kYXRhLnNldChhLGIpfWZ1bmN0aW9uIGMoYSxjKXtiKGEsYyk7ZC5maWx0ZXJzLmFkZChhKX12YXIgZD10aGlzO3RoaXMuYj1uZXcgWWE7dGhpcy5maWx0ZXJzPW5ldyBIYTtiKFYsYVtWXSk7YihOYSxzYShhW05hXSkpO2IoVSxhW1VdKTtiKFcsYVtXXXx8eGEoKSk7YihZYixhW1liXSk7YihaYixhW1piXSk7YigkYixhWyRiXSk7YihXYyxhW1djXSk7YihiYyxhW2JjXSk7YihjYyxhW2NjXSk7YihLYSxhW0thXSk7YihkYyxhW2RjXSk7YihlYyxhW2VjXSk7YihhYyxhW2FjXSk7YihBZCxhW0FkXSk7YihuLGFbbl0pO2IoaGIsMSk7YihpYixcImo0N1wiKTtjKFFiLE1hKTtjKGRkLGNkKTtjKFJiLE9hKTtjKG1kLHZiKTtjKFNiLG5jKTtjKFVjLFljKTtjKFRiLEphKTtjKFZiLFRhKTtjKFZjLEhjKTtjKHpkLHlkKTtjKExkLFNkKTtjKFdiLFBhKTtjKFhiLFNhKTtcbmMoQ2QsRmQodGhpcykpO0pjKHRoaXMuYixhW1FdKTtLYyh0aGlzLmIpO3RoaXMuYi5zZXQoamIsTGMoKSk7YmQodGhpcy5iLmdldChOYSksdGhpcy5iLmdldChXKSx0aGlzLmIuZ2V0KFliKSl9LEpjPWZ1bmN0aW9uKGEsYil7aWYoXCJjb29raWVcIj09UChhLGFjKSl7aGM9ITE7dmFyIGM7Yjp7dmFyIGQ9Q2EoUChhLFUpKTtpZihkJiYhKDE+ZC5sZW5ndGgpKXtjPVtdO2Zvcih2YXIgZT0wO2U8ZC5sZW5ndGg7ZSsrKXt2YXIgZztnPWRbZV0uc3BsaXQoXCIuXCIpO3ZhciBjYT1nLnNoaWZ0KCk7KFwiR0ExXCI9PWNhfHxcIjFcIj09Y2EpJiYxPGcubGVuZ3RoPyhjYT1nLnNoaWZ0KCkuc3BsaXQoXCItXCIpLDE9PWNhLmxlbmd0aCYmKGNhWzFdPVwiMVwiKSxjYVswXSo9MSxjYVsxXSo9MSxnPXtIOmNhLHM6Zy5qb2luKFwiLlwiKX0pOmc9dm9pZCAwO2cmJmMucHVzaChnKX1pZigxPT1jLmxlbmd0aCl7SigxMyk7Yz1jWzBdLnM7YnJlYWsgYn1pZigwPT1jLmxlbmd0aClKKDEyKTtlbHNle0ooMTQpO2Q9bGMoUChhLFxuVykpLnNwbGl0KFwiLlwiKS5sZW5ndGg7Yz1HYyhjLGQsMCk7aWYoMT09Yy5sZW5ndGgpe2M9Y1swXS5zO2JyZWFrIGJ9ZD1qYyhQKGEsWWIpKTtjPUdjKGMsZCwxKTtjPWNbMF0mJmNbMF0uczticmVhayBifX1jPXZvaWQgMH1jfHwoYz1QKGEsVyksZD1QKGEsJGIpfHx4YSgpLGM9WGMoXCJfX3V0bWFcIixkLGMpLHZvaWQgMCE9Yz8oSigxMCksYz1jLk9bMV0rXCIuXCIrYy5PWzJdKTpjPXZvaWQgMCk7YyYmKGEuZGF0YS5zZXQoUSxjKSxoYz0hMCl9Yz1hLmdldChjYyk7aWYoZT1FKE0ubG9jYXRpb25bYz9cImhyZWZcIjpcInNlYXJjaFwiXSxcIl9nYVwiKSlhLmdldChiYyk/KGM9ZS5pbmRleE9mKFwiLlwiKSwtMT09Yz9KKDIyKTooZD1lLnN1YnN0cmluZyhjKzEpLFwiMVwiIT1lLnN1YnN0cmluZygwLGMpP0ooMjIpOihjPWQuaW5kZXhPZihcIi5cIiksLTE9PWM/SigyMik6KGU9ZC5zdWJzdHJpbmcoMCxjKSxjPWQuc3Vic3RyaW5nKGMrMSksZSE9SWMoYywwKSYmZSE9SWMoYywtMSkmJmUhPUljKGMsLTIpP0ooMjMpOlxuKEooMTEpLGEuZGF0YS5zZXQoUSxjKSkpKSkpOkooMjEpO2ImJihKKDkpLGEuZGF0YS5zZXQoUSxLKGIpKSk7aWYoIWEuZ2V0KFEpKWlmKGM9KGM9Ty5nYUdsb2JhbCYmTy5nYUdsb2JhbC52aWQpJiYtMSE9Yy5zZWFyY2goL14oPzp1dG1hXFwuKT9cXGQrXFwuXFxkKyQvKT9jOnZvaWQgMClKKDE3KSxhLmRhdGEuc2V0KFEsYyk7ZWxzZXtKKDgpO2M9Ty5uYXZpZ2F0b3IudXNlckFnZW50KyhNLmNvb2tpZT9NLmNvb2tpZTpcIlwiKSsoTS5yZWZlcnJlcj9NLnJlZmVycmVyOlwiXCIpO2Q9Yy5sZW5ndGg7Zm9yKGU9Ty5oaXN0b3J5Lmxlbmd0aDswPGU7KWMrPWUtLV5kKys7YS5kYXRhLnNldChRLFtoZCgpXkxhKGMpJjIxNDc0ODM2NDcsTWF0aC5yb3VuZCgobmV3IERhdGUpLmdldFRpbWUoKS8xRTMpXS5qb2luKFwiLlwiKSl9bWMoYSl9LEtjPWZ1bmN0aW9uKGEpe3ZhciBiPU8ubmF2aWdhdG9yLGM9Ty5zY3JlZW4sZD1NLmxvY2F0aW9uO2Euc2V0KGxiLHlhKGEuZ2V0KGVjKSkpO2lmKGQpe3ZhciBlPVxuZC5wYXRobmFtZXx8XCJcIjtcIi9cIiE9ZS5jaGFyQXQoMCkmJihKKDMxKSxlPVwiL1wiK2UpO2Euc2V0KGtiLGQucHJvdG9jb2wrXCIvL1wiK2QuaG9zdG5hbWUrZStkLnNlYXJjaCl9YyYmYS5zZXQocWIsYy53aWR0aCtcInhcIitjLmhlaWdodCk7YyYmYS5zZXQocGIsYy5jb2xvckRlcHRoK1wiLWJpdFwiKTt2YXIgYz1NLmRvY3VtZW50RWxlbWVudCxnPShlPU0uYm9keSkmJmUuY2xpZW50V2lkdGgmJmUuY2xpZW50SGVpZ2h0LGNhPVtdO2MmJmMuY2xpZW50V2lkdGgmJmMuY2xpZW50SGVpZ2h0JiYoXCJDU1MxQ29tcGF0XCI9PT1NLmNvbXBhdE1vZGV8fCFnKT9jYT1bYy5jbGllbnRXaWR0aCxjLmNsaWVudEhlaWdodF06ZyYmKGNhPVtlLmNsaWVudFdpZHRoLGUuY2xpZW50SGVpZ2h0XSk7Yz0wPj1jYVswXXx8MD49Y2FbMV0/XCJcIjpjYS5qb2luKFwieFwiKTthLnNldChyYixjKTthLnNldCh0YixmYygpKTthLnNldChvYixNLmNoYXJhY3RlclNldHx8TS5jaGFyc2V0KTthLnNldChzYixiJiZcImZ1bmN0aW9uXCI9PT1cbnR5cGVvZiBiLmphdmFFbmFibGVkJiZiLmphdmFFbmFibGVkKCl8fCExKTthLnNldChuYiwoYiYmKGIubGFuZ3VhZ2V8fGIuYnJvd3Nlckxhbmd1YWdlKXx8XCJcIikudG9Mb3dlckNhc2UoKSk7aWYoZCYmYS5nZXQoY2MpJiYoYj1NLmxvY2F0aW9uLmhhc2gpKXtiPWIuc3BsaXQoL1s/JiNdKy8pO2Q9W107Zm9yKGM9MDtjPGIubGVuZ3RoOysrYykoRChiW2NdLFwidXRtX2lkXCIpfHxEKGJbY10sXCJ1dG1fY2FtcGFpZ25cIil8fEQoYltjXSxcInV0bV9zb3VyY2VcIil8fEQoYltjXSxcInV0bV9tZWRpdW1cIil8fEQoYltjXSxcInV0bV90ZXJtXCIpfHxEKGJbY10sXCJ1dG1fY29udGVudFwiKXx8RChiW2NdLFwiZ2NsaWRcIil8fEQoYltjXSxcImRjbGlkXCIpfHxEKGJbY10sXCJnY2xzcmNcIikpJiZkLnB1c2goYltjXSk7MDxkLmxlbmd0aCYmKGI9XCIjXCIrZC5qb2luKFwiJlwiKSxhLnNldChrYixhLmdldChrYikrYikpfX07cGMucHJvdG90eXBlLmdldD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5iLmdldChhKX07XG5wYy5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGEsYil7dGhpcy5iLnNldChhLGIpfTt2YXIgcWM9e3BhZ2V2aWV3OlttYl0sZXZlbnQ6W3ViLHhiLHliLHpiXSxzb2NpYWw6W0JiLENiLERiXSx0aW1pbmc6W01iLE5iLFBiLE9iXX07cGMucHJvdG90eXBlLnNlbmQ9ZnVuY3Rpb24oYSl7aWYoISgxPmFyZ3VtZW50cy5sZW5ndGgpKXt2YXIgYixjO1wic3RyaW5nXCI9PT10eXBlb2YgYXJndW1lbnRzWzBdPyhiPWFyZ3VtZW50c1swXSxjPVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpKTooYj1hcmd1bWVudHNbMF0mJmFyZ3VtZW50c1swXVtWYV0sYz1hcmd1bWVudHMpO2ImJihjPXphKHFjW2JdfHxbXSxjKSxjW1ZhXT1iLHRoaXMuYi5zZXQoYyx2b2lkIDAsITApLHRoaXMuZmlsdGVycy5EKHRoaXMuYiksdGhpcy5iLmRhdGEubT17fSl9fTtcbnBjLnByb3RvdHlwZS5tYT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7dShhLGMsYil8fCh2KGEsZnVuY3Rpb24oKXt1KGEsYyxiKX0pLHkoU3RyaW5nKGMuZ2V0KFYpKSxhLHZvaWQgMCxiLCEwKSl9O3ZhciByYz1mdW5jdGlvbihhKXtpZihcInByZXJlbmRlclwiPT1NLnZpc2liaWxpdHlTdGF0ZSlyZXR1cm4hMTthKCk7cmV0dXJuITB9LHo9ZnVuY3Rpb24oYSl7aWYoIXJjKGEpKXtKKDE2KTt2YXIgYj0hMSxjPWZ1bmN0aW9uKCl7aWYoIWImJnJjKGEpKXtiPSEwO3ZhciBkPWMsZT1NO2UucmVtb3ZlRXZlbnRMaXN0ZW5lcj9lLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsZCwhMSk6ZS5kZXRhY2hFdmVudCYmZS5kZXRhY2hFdmVudChcIm9udmlzaWJpbGl0eWNoYW5nZVwiLGQpfX07TChNLFwidmlzaWJpbGl0eWNoYW5nZVwiLGMpfX07dmFyIHRkPS9eKD86KFxcdyspXFwuKT8oPzooXFx3Kyk6KT8oXFx3KykkLyxzYz1mdW5jdGlvbihhKXtpZihlYShhWzBdKSl0aGlzLnU9YVswXTtlbHNle3ZhciBiPXRkLmV4ZWMoYVswXSk7bnVsbCE9YiYmND09Yi5sZW5ndGgmJih0aGlzLmM9YlsxXXx8XCJ0MFwiLHRoaXMuSz1iWzJdfHxcIlwiLHRoaXMuQz1iWzNdLHRoaXMuYT1bXS5zbGljZS5jYWxsKGEsMSksdGhpcy5LfHwodGhpcy5BPVwiY3JlYXRlXCI9PXRoaXMuQyx0aGlzLmk9XCJyZXF1aXJlXCI9PXRoaXMuQyx0aGlzLmc9XCJwcm92aWRlXCI9PXRoaXMuQyx0aGlzLmJhPVwicmVtb3ZlXCI9PXRoaXMuQyksdGhpcy5pJiYoMzw9dGhpcy5hLmxlbmd0aD8odGhpcy5YPXRoaXMuYVsxXSx0aGlzLlc9dGhpcy5hWzJdKTp0aGlzLmFbMV0mJihxYSh0aGlzLmFbMV0pP3RoaXMuWD10aGlzLmFbMV06dGhpcy5XPXRoaXMuYVsxXSkpKTtiPWFbMV07YT1hWzJdO2lmKCF0aGlzLkMpdGhyb3dcImFib3J0XCI7aWYodGhpcy5pJiYoIXFhKGIpfHxcIlwiPT1iKSl0aHJvd1wiYWJvcnRcIjtcbmlmKHRoaXMuZyYmKCFxYShiKXx8XCJcIj09Ynx8IWVhKGEpKSl0aHJvd1wiYWJvcnRcIjtpZih1ZCh0aGlzLmMpfHx1ZCh0aGlzLkspKXRocm93XCJhYm9ydFwiO2lmKHRoaXMuZyYmXCJ0MFwiIT10aGlzLmMpdGhyb3dcImFib3J0XCI7fX07ZnVuY3Rpb24gdWQoYSl7cmV0dXJuIDA8PWEuaW5kZXhPZihcIi5cIil8fDA8PWEuaW5kZXhPZihcIjpcIil9O3ZhciBZZCxaZCwkZCxBO1lkPW5ldyBlZTskZD1uZXcgZWU7QT1uZXcgZWU7WmQ9e2VjOjQ1LGVjb21tZXJjZTo0NixsaW5raWQ6NDd9O1xudmFyIHU9ZnVuY3Rpb24oYSxiLGMpe2I9PU58fGIuZ2V0KFYpO3ZhciBkPVlkLmdldChhKTtpZighZWEoZCkpcmV0dXJuITE7Yi5wbHVnaW5zXz1iLnBsdWdpbnNffHxuZXcgZWU7aWYoYi5wbHVnaW5zXy5nZXQoYSkpcmV0dXJuITA7Yi5wbHVnaW5zXy5zZXQoYSxuZXcgZChiLGN8fHt9KSk7cmV0dXJuITB9LHk9ZnVuY3Rpb24oYSxiLGMsZCxlKXtpZighZWEoWWQuZ2V0KGIpKSYmISRkLmdldChiKSl7WmQuaGFzT3duUHJvcGVydHkoYikmJkooWmRbYl0pO2lmKHAudGVzdChiKSl7Sig1Mik7YT1OLmooYSk7aWYoIWEpcmV0dXJuITA7Yz1kfHx7fTtkPXtpZDpiLEI6Yy5kYXRhTGF5ZXJ8fFwiZGF0YUxheWVyXCIsaWE6ISFhLmdldChcImFub255bWl6ZUlwXCIpLG5hOmUsRzohMX07YS5nZXQoXCImZ3RtXCIpPT1iJiYoZC5HPSEwKTt2YXIgZz1TdHJpbmcoYS5nZXQoXCJuYW1lXCIpKTtcInQwXCIhPWcmJihkLnRhcmdldD1nKTtHKFN0cmluZyhhLmdldChcInRyYWNraW5nSWRcIikpKXx8KGQuamE9U3RyaW5nKGEuZ2V0KFEpKSxcbmQua2E9TnVtYmVyKGEuZ2V0KG4pKSxhPWMucGFsaW5kcm9tZT9yOnEsYT0oYT1NLmNvb2tpZS5yZXBsYWNlKC9efCg7ICspL2csXCI7XCIpLm1hdGNoKGEpKT9hLnNvcnQoKS5qb2luKFwiXCIpLnN1YnN0cmluZygxKTp2b2lkIDAsZC5sYT1hKTthPWQuQjtjPShuZXcgRGF0ZSkuZ2V0VGltZSgpO09bYV09T1thXXx8W107Yz17XCJndG0uc3RhcnRcIjpjfTtlfHwoYy5ldmVudD1cImd0bS5qc1wiKTtPW2FdLnB1c2goYyk7Yz10KGQpfSFjJiZaZC5oYXNPd25Qcm9wZXJ0eShiKT8oSigzOSksYz1iK1wiLmpzXCIpOkooNDMpO2MmJihjJiYwPD1jLmluZGV4T2YoXCIvXCIpfHwoYz0oQmF8fFVkKCk/XCJodHRwczpcIjpcImh0dHA6XCIpK1wiLy93d3cuZ29vZ2xlLWFuYWx5dGljcy5jb20vcGx1Z2lucy91YS9cIitjKSxkPWFlKGMpLGE9ZC5wcm90b2NvbCxjPU0ubG9jYXRpb24ucHJvdG9jb2wsKFwiaHR0cHM6XCI9PWF8fGE9PWN8fChcImh0dHA6XCIhPWE/MDpcImh0dHA6XCI9PWMpKSYmQihkKSYmKHdhKGQudXJsLHZvaWQgMCxcbmUpLCRkLnNldChiLCEwKSkpfX0sdj1mdW5jdGlvbihhLGIpe3ZhciBjPUEuZ2V0KGEpfHxbXTtjLnB1c2goYik7QS5zZXQoYSxjKX0sQz1mdW5jdGlvbihhLGIpe1lkLnNldChhLGIpO2Zvcih2YXIgYz1BLmdldChhKXx8W10sZD0wO2Q8Yy5sZW5ndGg7ZCsrKWNbZF0oKTtBLnNldChhLFtdKX0sQj1mdW5jdGlvbihhKXt2YXIgYj1hZShNLmxvY2F0aW9uLmhyZWYpO2lmKEQoYS51cmwsXCJodHRwczovL3d3dy5nb29nbGUtYW5hbHl0aWNzLmNvbS9ndG0vanM/aWQ9XCIpKXJldHVybiEwO2lmKGEucXVlcnl8fDA8PWEudXJsLmluZGV4T2YoXCI/XCIpfHwwPD1hLnBhdGguaW5kZXhPZihcIjovL1wiKSlyZXR1cm4hMTtpZihhLmhvc3Q9PWIuaG9zdCYmYS5wb3J0PT1iLnBvcnQpcmV0dXJuITA7Yj1cImh0dHA6XCI9PWEucHJvdG9jb2w/ODA6NDQzO3JldHVyblwid3d3Lmdvb2dsZS1hbmFseXRpY3MuY29tXCI9PWEuaG9zdCYmKGEucG9ydHx8Yik9PWImJkQoYS5wYXRoLFwiL3BsdWdpbnMvXCIpPyEwOiExfSxcbmFlPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYSl7dmFyIGI9KGEuaG9zdG5hbWV8fFwiXCIpLnNwbGl0KFwiOlwiKVswXS50b0xvd2VyQ2FzZSgpLGM9KGEucHJvdG9jb2x8fFwiXCIpLnRvTG93ZXJDYXNlKCksYz0xKmEucG9ydHx8KFwiaHR0cDpcIj09Yz84MDpcImh0dHBzOlwiPT1jPzQ0MzpcIlwiKTthPWEucGF0aG5hbWV8fFwiXCI7RChhLFwiL1wiKXx8KGE9XCIvXCIrYSk7cmV0dXJuW2IsXCJcIitjLGFdfXZhciBjPU0uY3JlYXRlRWxlbWVudChcImFcIik7Yy5ocmVmPU0ubG9jYXRpb24uaHJlZjt2YXIgZD0oYy5wcm90b2NvbHx8XCJcIikudG9Mb3dlckNhc2UoKSxlPWIoYyksZz1jLnNlYXJjaHx8XCJcIixjYT1kK1wiLy9cIitlWzBdKyhlWzFdP1wiOlwiK2VbMV06XCJcIik7RChhLFwiLy9cIik/YT1kK2E6RChhLFwiL1wiKT9hPWNhK2E6IWF8fEQoYSxcIj9cIik/YT1jYStlWzJdKyhhfHxnKTowPmEuc3BsaXQoXCIvXCIpWzBdLmluZGV4T2YoXCI6XCIpJiYoYT1jYStlWzJdLnN1YnN0cmluZygwLGVbMl0ubGFzdEluZGV4T2YoXCIvXCIpKStcIi9cIitcbmEpO2MuaHJlZj1hO2Q9YihjKTtyZXR1cm57cHJvdG9jb2w6KGMucHJvdG9jb2x8fFwiXCIpLnRvTG93ZXJDYXNlKCksaG9zdDpkWzBdLHBvcnQ6ZFsxXSxwYXRoOmRbMl0scXVlcnk6Yy5zZWFyY2h8fFwiXCIsdXJsOmF8fFwiXCJ9fTt2YXIgWj17Z2E6ZnVuY3Rpb24oKXtaLmY9W119fTtaLmdhKCk7Wi5EPWZ1bmN0aW9uKGEpe3ZhciBiPVouSi5hcHBseShaLGFyZ3VtZW50cyksYj1aLmYuY29uY2F0KGIpO2ZvcihaLmY9W107MDxiLmxlbmd0aCYmIVoudihiWzBdKSYmIShiLnNoaWZ0KCksMDxaLmYubGVuZ3RoKTspO1ouZj1aLmYuY29uY2F0KGIpfTtaLko9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVtdLGM9MDtjPGFyZ3VtZW50cy5sZW5ndGg7YysrKXRyeXt2YXIgZD1uZXcgc2MoYXJndW1lbnRzW2NdKTtkLmc/QyhkLmFbMF0sZC5hWzFdKTooZC5pJiYoZC5oYT15KGQuYyxkLmFbMF0sZC5YLGQuVykpLGIucHVzaChkKSl9Y2F0Y2goZSl7fXJldHVybiBifTtcbloudj1mdW5jdGlvbihhKXt0cnl7aWYoYS51KWEudS5jYWxsKE8sTi5qKFwidDBcIikpO2Vsc2V7dmFyIGI9YS5jPT1nYj9OOk4uaihhLmMpO2lmKGEuQSlcInQwXCIhPWEuY3x8Ti5jcmVhdGUuYXBwbHkoTixhLmEpO2Vsc2UgaWYoYS5iYSlOLnJlbW92ZShhLmMpO2Vsc2UgaWYoYilpZihhLmkpe2lmKGEuaGEmJihhLmhhPXkoYS5jLGEuYVswXSxhLlgsYS5XKSksIXUoYS5hWzBdLGIsYS5XKSlyZXR1cm4hMH1lbHNlIGlmKGEuSyl7dmFyIGM9YS5DLGQ9YS5hLGU9Yi5wbHVnaW5zXy5nZXQoYS5LKTtlW2NdLmFwcGx5KGUsZCl9ZWxzZSBiW2EuQ10uYXBwbHkoYixhLmEpfX1jYXRjaChnKXt9fTt2YXIgTj1mdW5jdGlvbihhKXtKKDEpO1ouRC5hcHBseShaLFthcmd1bWVudHNdKX07Ti5oPXt9O04uUD1bXTtOLkw9MDtOLmFuc3dlcj00Mjt2YXIgdWM9W05hLFcsVl07Ti5jcmVhdGU9ZnVuY3Rpb24oYSl7dmFyIGI9emEodWMsW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtiW1ZdfHwoYltWXT1cInQwXCIpO3ZhciBjPVwiXCIrYltWXTtpZihOLmhbY10pcmV0dXJuIE4uaFtjXTtiPW5ldyBwYyhiKTtOLmhbY109YjtOLlAucHVzaChiKTtyZXR1cm4gYn07Ti5yZW1vdmU9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7YjxOLlAubGVuZ3RoO2IrKylpZihOLlBbYl0uZ2V0KFYpPT1hKXtOLlAuc3BsaWNlKGIsMSk7Ti5oW2FdPW51bGw7YnJlYWt9fTtOLmo9ZnVuY3Rpb24oYSl7cmV0dXJuIE4uaFthXX07Ti5nZXRBbGw9ZnVuY3Rpb24oKXtyZXR1cm4gTi5QLnNsaWNlKDApfTtcbk4uTj1mdW5jdGlvbigpe1wiZ2FcIiE9Z2ImJkooNDkpO3ZhciBhPU9bZ2JdO2lmKCFhfHw0MiE9YS5hbnN3ZXIpe04uTD1hJiZhLmw7Ti5sb2FkZWQ9ITA7dmFyIGI9T1tnYl09TjtYKFwiY3JlYXRlXCIsYixiLmNyZWF0ZSk7WChcInJlbW92ZVwiLGIsYi5yZW1vdmUpO1goXCJnZXRCeU5hbWVcIixiLGIuaiw1KTtYKFwiZ2V0QWxsXCIsYixiLmdldEFsbCw2KTtiPXBjLnByb3RvdHlwZTtYKFwiZ2V0XCIsYixiLmdldCw3KTtYKFwic2V0XCIsYixiLnNldCw0KTtYKFwic2VuZFwiLGIsYi5zZW5kKTtYKFwicmVxdWlyZVN5bmNcIixiLGIubWEpO2I9WWEucHJvdG90eXBlO1goXCJnZXRcIixiLGIuZ2V0KTtYKFwic2V0XCIsYixiLnNldCk7aWYoIVVkKCkmJiFCYSl7YTp7Zm9yKHZhciBiPU0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIiksYz0wO2M8Yi5sZW5ndGgmJjEwMD5jO2MrKyl7dmFyIGQ9YltjXS5zcmM7aWYoZCYmMD09ZC5pbmRleE9mKFwiaHR0cHM6Ly93d3cuZ29vZ2xlLWFuYWx5dGljcy5jb20vYW5hbHl0aWNzXCIpKXtKKDMzKTtcbmI9ITA7YnJlYWsgYX19Yj0hMX1iJiYoQmE9ITApfVVkKCl8fEJhfHwhRWQobmV3IE9kKDFFNCkpfHwoSigzNiksQmE9ITApOyhPLmdhcGx1Z2lucz1PLmdhcGx1Z2luc3x8e30pLkxpbmtlcj1EYztiPURjLnByb3RvdHlwZTtDKFwibGlua2VyXCIsRGMpO1goXCJkZWNvcmF0ZVwiLGIsYi5jYSwyMCk7WChcImF1dG9MaW5rXCIsYixiLlMsMjUpO0MoXCJkaXNwbGF5ZmVhdHVyZXNcIixmZCk7QyhcImFkZmVhdHVyZXNcIixmZCk7YT1hJiZhLnE7a2EoYSk/Wi5ELmFwcGx5KE4sYSk6Sig1MCl9fTtOLmRhPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPU4uZ2V0QWxsKCksYj0wO2I8YS5sZW5ndGg7YisrKWFbYl0uZ2V0KFYpfTt2YXIgSD1OLk4sST1PW2diXTtJJiZJLnI/SCgpOnooSCk7eihmdW5jdGlvbigpe1ouRChbXCJwcm92aWRlXCIsXCJyZW5kZXJcIix1YV0pfSk7ZnVuY3Rpb24gTGEoYSl7dmFyIGI9MSxjLGQ7aWYoYSlmb3IoYj0wLGQ9YS5sZW5ndGgtMTswPD1kO2QtLSljPWEuY2hhckNvZGVBdChkKSxiPShiPDw2JjI2ODQzNTQ1NSkrYysoYzw8MTQpLGM9YiYyNjYzMzgzMDQsYj0wIT1jP2JeYz4+MjE6YjtyZXR1cm4gYn07fSkod2luZG93KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyByZXNvdXJjZXMvYXNzZXRzL2pzL3ZlbmRvci9hbmFseXRpY3MuanMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBQ0E7QUFDQTs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 4 */
/***/ function(module, exports) {

eval("/*\n    The MIT License (MIT)\n\n    Copyright (c) <2013> <Ren Aysha>\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in\n    all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n    THE SOFTWARE.\n*/\n\nif ( typeof Object.create !== 'function' ) {\n    Object.create = function( obj ) {\n        function F() {}\n        F.prototype = obj;\n        return new F();\n    };\n}\n\n(function( $, window, document, undefined ) {\n    \"use strict\";\n\n    var Anchorific = {\n\n        init: function( options, elem ) {\n            var self = this;\n\n            self.elem = elem;\n            self.$elem = $( elem );\n\n            self.opt = $.extend( {},  this.opt, options );\n\n            self.headers = self.$elem.find( 'h1, h2, h3, h4, h5, h6' );\n            self.previous = 0;\n\n            // Fix bug #1\n            if ( self.headers.length !== 0 ) {\n                self.first = parseInt( self.headers.prop( 'nodeName' ).substring( 1 ), null );\n            }\n\n            self.build();\n        },\n\n        opt: {\n            navigation: '.anchorific', // position of navigation\n            speed: 200, // speed of sliding back to top\n            anchorClass: 'anchor', // class of anchor links\n            anchorText: '#', // prepended or appended to anchor headings\n            top: '.top', // back to top button or link class\n            spy: true, // scroll spy\n            position: 'append', // position of anchor text\n            spyOffset: !0 // specify heading offset for spy scrolling\n        },\n\n        build: function() {\n            var self = this, obj, navigations = function() {};\n            // when navigation configuration is set\n            if ( self.opt.navigation ) {\n                $( self.opt.navigation ).append( '<ul />' );\n                self.previous = $( self.opt.navigation ).find( 'ul' ).last();\n                navigations = function( obj ) {\n                    return self.navigations( obj );\n                };\n            }\n\n            for( var i = 0; i < self.headers.length; i++ ) {\n                obj = self.headers.eq( i );\n                navigations( obj );\n                self.anchor( obj );\n            }\n\n            if ( self.opt.spy )\n                self.spy();\n\n            if ( self.opt.top )\n                self.back();\n        },\n\n        navigations: function( obj ) {\n            var self = this, link, list, which, name = self.name( obj );\n\n            if ( obj.attr( 'id' ) !== undefined )\n                name = obj.attr( 'id' );\n\n            link = $( '<a />' ).attr( 'href', '#' + name ).text( obj.text() );\n            list = $( '<li />' ).append( link );\n\n            which = parseInt( obj.prop( 'nodeName' ).substring( 1 ), null );\n            list.attr( 'data-tag', which );\n\n            self.subheadings( which, list );\n\n            self.first = which;\n        },\n\n        subheadings: function( which, a ) {\n            var self = this, ul = $( self.opt.navigation ).find( 'ul' ),\n                li = $( self.opt.navigation ).find( 'li' );\n\n            if ( which === self.first ) {\n                self.previous.append( a );\n            } else if ( which > self.first ) {\n                li.last().append( '<ul />' );\n                // can't use cache ul; need to find ul once more\n                $( self.opt.navigation ).find( 'ul' ).last().append( a );\n                self.previous = a.parent();\n            } else {\n                $( 'li[data-tag=' + which + ']' ).last().parent().append( a );\n                self.previous = a.parent();\n            }\n        },\n\n        name: function( obj ) {\n            var name = obj.text().replace( /\\s+/g, '-' );\n            var pattern = new RegExp(\"[`~!@#$^&*()=|{}':;',\\\\[\\\\].<>/?~ï¼@#ï¿¥â¦â¦&*ï¼ï¼&;|{}ããâï¼ï¼ââ'ãï¼ãï¼]\")\n            var rs = \"\";\n            for (var i = 0; i < name.length; i++) {\n                rs = rs+name.substr(i, 1).replace(pattern, '');\n            }\n            return rs;\n        },\n\n        anchor: function( obj ) {\n            var self = this, name = self.name( obj ), anchor, text = self.opt.anchorText,\n                klass = self.opt.anchorClass, id;\n\n            if ( obj.attr( 'id' ) === undefined )\n                obj.attr( 'id', name );\n\n            id = obj.attr( 'id' );\n\n            anchor = $( '<a />' ).attr( 'href', '#' + id ).html( text ).addClass( klass );\n\n            if ( self.opt.position === 'append' ) {\n                obj.append( anchor );\n            } else {\n                obj.prepend( anchor );\n            }\n        },\n\n        back: function() {\n            var self = this, body = $( 'body, html' ), top = $( self.opt.top );\n\n            top.on( 'click', function( e ) {\n                e.preventDefault();\n\n                body.animate({\n                    'scrollTop': 0\n                }, self.opt.speed );\n            });\n        },\n\n        top: function( that ) {\n            var self = this, top = self.opt.top, back;\n\n            if ( top !== false ) {\n                back = ( $( that ).scrollTop() > 200 ) ?\n                        $( top ).fadeIn() :\n                        $( top ).fadeOut();\n            }\n        },\n\n        spy: function() {\n            var self = this, previous, current, list, top, prev;\n\n            $( window ).scroll( function( e ) {\n                // show links back to top\n                self.top( this );\n                // get all the header on top of the viewport\n                current = self.headers.map( function( e ) {\n                    if ( ( $( this ).offset().top - $( window ).scrollTop() ) < self.opt.spyOffset ) {\n                        return this;\n                    }\n                });\n                // get only the latest header on the viewport\n                current = $( current ).eq( current.length - 1 );\n\n                if ( current && current.length ) {\n                    // get all li tag that contains href of # ( all the parents )\n                    list = $( 'li:has(a[href=\"#' + current.attr( 'id' ) + '\"])' );\n\n                    if ( prev !== undefined ) {\n                        prev.removeClass( 'active' );\n                    }\n\n                    list.addClass( 'active' );\n                    prev = list;\n                }\n            });\n        }\n    };\n\n    $.fn.anchorific = function( options ) {\n        return this.each(function() {\n            if ( ! $.data( this, 'anchorific' ) ) {\n                var anchor = Object.create( Anchorific );\n\n                anchor.init( options, this );\n\n                $.data( this, 'anchorific', anchor );\n            }\n        });\n    };\n\n})( jQuery, window, document );//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9yZXNvdXJjZXMvYXNzZXRzL2pzL3ZlbmRvci9hbmNob3JpZmljLmpzP2UzNDciXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICAgIENvcHlyaWdodCAoYykgPDIwMTM+IDxSZW4gQXlzaGE+XG5cbiAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAgICB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gICAgYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gICAgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gICAgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICAgIFRIRSBTT0ZUV0FSRS5cbiovXG5cbmlmICggdHlwZW9mIE9iamVjdC5jcmVhdGUgIT09ICdmdW5jdGlvbicgKSB7XG4gICAgT2JqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uKCBvYmogKSB7XG4gICAgICAgIGZ1bmN0aW9uIEYoKSB7fVxuICAgICAgICBGLnByb3RvdHlwZSA9IG9iajtcbiAgICAgICAgcmV0dXJuIG5ldyBGKCk7XG4gICAgfTtcbn1cblxuKGZ1bmN0aW9uKCAkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQgKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgQW5jaG9yaWZpYyA9IHtcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiggb3B0aW9ucywgZWxlbSApIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgc2VsZi5lbGVtID0gZWxlbTtcbiAgICAgICAgICAgIHNlbGYuJGVsZW0gPSAkKCBlbGVtICk7XG5cbiAgICAgICAgICAgIHNlbGYub3B0ID0gJC5leHRlbmQoIHt9LCAgdGhpcy5vcHQsIG9wdGlvbnMgKTtcblxuICAgICAgICAgICAgc2VsZi5oZWFkZXJzID0gc2VsZi4kZWxlbS5maW5kKCAnaDEsIGgyLCBoMywgaDQsIGg1LCBoNicgKTtcbiAgICAgICAgICAgIHNlbGYucHJldmlvdXMgPSAwO1xuXG4gICAgICAgICAgICAvLyBGaXggYnVnICMxXG4gICAgICAgICAgICBpZiAoIHNlbGYuaGVhZGVycy5sZW5ndGggIT09IDAgKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5maXJzdCA9IHBhcnNlSW50KCBzZWxmLmhlYWRlcnMucHJvcCggJ25vZGVOYW1lJyApLnN1YnN0cmluZyggMSApLCBudWxsICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuYnVpbGQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvcHQ6IHtcbiAgICAgICAgICAgIG5hdmlnYXRpb246ICcuYW5jaG9yaWZpYycsIC8vIHBvc2l0aW9uIG9mIG5hdmlnYXRpb25cbiAgICAgICAgICAgIHNwZWVkOiAyMDAsIC8vIHNwZWVkIG9mIHNsaWRpbmcgYmFjayB0byB0b3BcbiAgICAgICAgICAgIGFuY2hvckNsYXNzOiAnYW5jaG9yJywgLy8gY2xhc3Mgb2YgYW5jaG9yIGxpbmtzXG4gICAgICAgICAgICBhbmNob3JUZXh0OiAnIycsIC8vIHByZXBlbmRlZCBvciBhcHBlbmRlZCB0byBhbmNob3IgaGVhZGluZ3NcbiAgICAgICAgICAgIHRvcDogJy50b3AnLCAvLyBiYWNrIHRvIHRvcCBidXR0b24gb3IgbGluayBjbGFzc1xuICAgICAgICAgICAgc3B5OiB0cnVlLCAvLyBzY3JvbGwgc3B5XG4gICAgICAgICAgICBwb3NpdGlvbjogJ2FwcGVuZCcsIC8vIHBvc2l0aW9uIG9mIGFuY2hvciB0ZXh0XG4gICAgICAgICAgICBzcHlPZmZzZXQ6ICEwIC8vIHNwZWNpZnkgaGVhZGluZyBvZmZzZXQgZm9yIHNweSBzY3JvbGxpbmdcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIG9iaiwgbmF2aWdhdGlvbnMgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgICAgICAgLy8gd2hlbiBuYXZpZ2F0aW9uIGNvbmZpZ3VyYXRpb24gaXMgc2V0XG4gICAgICAgICAgICBpZiAoIHNlbGYub3B0Lm5hdmlnYXRpb24gKSB7XG4gICAgICAgICAgICAgICAgJCggc2VsZi5vcHQubmF2aWdhdGlvbiApLmFwcGVuZCggJzx1bCAvPicgKTtcbiAgICAgICAgICAgICAgICBzZWxmLnByZXZpb3VzID0gJCggc2VsZi5vcHQubmF2aWdhdGlvbiApLmZpbmQoICd1bCcgKS5sYXN0KCk7XG4gICAgICAgICAgICAgICAgbmF2aWdhdGlvbnMgPSBmdW5jdGlvbiggb2JqICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5uYXZpZ2F0aW9ucyggb2JqICk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzZWxmLmhlYWRlcnMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gc2VsZi5oZWFkZXJzLmVxKCBpICk7XG4gICAgICAgICAgICAgICAgbmF2aWdhdGlvbnMoIG9iaiApO1xuICAgICAgICAgICAgICAgIHNlbGYuYW5jaG9yKCBvYmogKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBzZWxmLm9wdC5zcHkgKVxuICAgICAgICAgICAgICAgIHNlbGYuc3B5KCk7XG5cbiAgICAgICAgICAgIGlmICggc2VsZi5vcHQudG9wIClcbiAgICAgICAgICAgICAgICBzZWxmLmJhY2soKTtcbiAgICAgICAgfSxcblxuICAgICAgICBuYXZpZ2F0aW9uczogZnVuY3Rpb24oIG9iaiApIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcywgbGluaywgbGlzdCwgd2hpY2gsIG5hbWUgPSBzZWxmLm5hbWUoIG9iaiApO1xuXG4gICAgICAgICAgICBpZiAoIG9iai5hdHRyKCAnaWQnICkgIT09IHVuZGVmaW5lZCApXG4gICAgICAgICAgICAgICAgbmFtZSA9IG9iai5hdHRyKCAnaWQnICk7XG5cbiAgICAgICAgICAgIGxpbmsgPSAkKCAnPGEgLz4nICkuYXR0ciggJ2hyZWYnLCAnIycgKyBuYW1lICkudGV4dCggb2JqLnRleHQoKSApO1xuICAgICAgICAgICAgbGlzdCA9ICQoICc8bGkgLz4nICkuYXBwZW5kKCBsaW5rICk7XG5cbiAgICAgICAgICAgIHdoaWNoID0gcGFyc2VJbnQoIG9iai5wcm9wKCAnbm9kZU5hbWUnICkuc3Vic3RyaW5nKCAxICksIG51bGwgKTtcbiAgICAgICAgICAgIGxpc3QuYXR0ciggJ2RhdGEtdGFnJywgd2hpY2ggKTtcblxuICAgICAgICAgICAgc2VsZi5zdWJoZWFkaW5ncyggd2hpY2gsIGxpc3QgKTtcblxuICAgICAgICAgICAgc2VsZi5maXJzdCA9IHdoaWNoO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN1YmhlYWRpbmdzOiBmdW5jdGlvbiggd2hpY2gsIGEgKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIHVsID0gJCggc2VsZi5vcHQubmF2aWdhdGlvbiApLmZpbmQoICd1bCcgKSxcbiAgICAgICAgICAgICAgICBsaSA9ICQoIHNlbGYub3B0Lm5hdmlnYXRpb24gKS5maW5kKCAnbGknICk7XG5cbiAgICAgICAgICAgIGlmICggd2hpY2ggPT09IHNlbGYuZmlyc3QgKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5wcmV2aW91cy5hcHBlbmQoIGEgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHdoaWNoID4gc2VsZi5maXJzdCApIHtcbiAgICAgICAgICAgICAgICBsaS5sYXN0KCkuYXBwZW5kKCAnPHVsIC8+JyApO1xuICAgICAgICAgICAgICAgIC8vIGNhbid0IHVzZSBjYWNoZSB1bDsgbmVlZCB0byBmaW5kIHVsIG9uY2UgbW9yZVxuICAgICAgICAgICAgICAgICQoIHNlbGYub3B0Lm5hdmlnYXRpb24gKS5maW5kKCAndWwnICkubGFzdCgpLmFwcGVuZCggYSApO1xuICAgICAgICAgICAgICAgIHNlbGYucHJldmlvdXMgPSBhLnBhcmVudCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKCAnbGlbZGF0YS10YWc9JyArIHdoaWNoICsgJ10nICkubGFzdCgpLnBhcmVudCgpLmFwcGVuZCggYSApO1xuICAgICAgICAgICAgICAgIHNlbGYucHJldmlvdXMgPSBhLnBhcmVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG5hbWU6IGZ1bmN0aW9uKCBvYmogKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG9iai50ZXh0KCkucmVwbGFjZSggL1xccysvZywgJy0nICk7XG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IG5ldyBSZWdFeHAoXCJbYH4hQCMkXiYqKCk9fHt9Jzo7JyxcXFxcW1xcXFxdLjw+Lz9+77yBQCPvv6XigKbigKYmKu+8iO+8iSY7fHt944CQ44CR4oCY77yb77ya4oCd4oCcJ+OAgu+8jOOAge+8n11cIilcbiAgICAgICAgICAgIHZhciBycyA9IFwiXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBycyA9IHJzK25hbWUuc3Vic3RyKGksIDEpLnJlcGxhY2UocGF0dGVybiwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFuY2hvcjogZnVuY3Rpb24oIG9iaiApIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcywgbmFtZSA9IHNlbGYubmFtZSggb2JqICksIGFuY2hvciwgdGV4dCA9IHNlbGYub3B0LmFuY2hvclRleHQsXG4gICAgICAgICAgICAgICAga2xhc3MgPSBzZWxmLm9wdC5hbmNob3JDbGFzcywgaWQ7XG5cbiAgICAgICAgICAgIGlmICggb2JqLmF0dHIoICdpZCcgKSA9PT0gdW5kZWZpbmVkIClcbiAgICAgICAgICAgICAgICBvYmouYXR0ciggJ2lkJywgbmFtZSApO1xuXG4gICAgICAgICAgICBpZCA9IG9iai5hdHRyKCAnaWQnICk7XG5cbiAgICAgICAgICAgIGFuY2hvciA9ICQoICc8YSAvPicgKS5hdHRyKCAnaHJlZicsICcjJyArIGlkICkuaHRtbCggdGV4dCApLmFkZENsYXNzKCBrbGFzcyApO1xuXG4gICAgICAgICAgICBpZiAoIHNlbGYub3B0LnBvc2l0aW9uID09PSAnYXBwZW5kJyApIHtcbiAgICAgICAgICAgICAgICBvYmouYXBwZW5kKCBhbmNob3IgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JqLnByZXBlbmQoIGFuY2hvciApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBib2R5ID0gJCggJ2JvZHksIGh0bWwnICksIHRvcCA9ICQoIHNlbGYub3B0LnRvcCApO1xuXG4gICAgICAgICAgICB0b3Aub24oICdjbGljaycsIGZ1bmN0aW9uKCBlICkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgIGJvZHkuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICdzY3JvbGxUb3AnOiAwXG4gICAgICAgICAgICAgICAgfSwgc2VsZi5vcHQuc3BlZWQgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvcDogZnVuY3Rpb24oIHRoYXQgKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIHRvcCA9IHNlbGYub3B0LnRvcCwgYmFjaztcblxuICAgICAgICAgICAgaWYgKCB0b3AgIT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgIGJhY2sgPSAoICQoIHRoYXQgKS5zY3JvbGxUb3AoKSA+IDIwMCApID9cbiAgICAgICAgICAgICAgICAgICAgICAgICQoIHRvcCApLmZhZGVJbigpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICQoIHRvcCApLmZhZGVPdXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzcHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBwcmV2aW91cywgY3VycmVudCwgbGlzdCwgdG9wLCBwcmV2O1xuXG4gICAgICAgICAgICAkKCB3aW5kb3cgKS5zY3JvbGwoIGZ1bmN0aW9uKCBlICkge1xuICAgICAgICAgICAgICAgIC8vIHNob3cgbGlua3MgYmFjayB0byB0b3BcbiAgICAgICAgICAgICAgICBzZWxmLnRvcCggdGhpcyApO1xuICAgICAgICAgICAgICAgIC8vIGdldCBhbGwgdGhlIGhlYWRlciBvbiB0b3Agb2YgdGhlIHZpZXdwb3J0XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHNlbGYuaGVhZGVycy5tYXAoIGZ1bmN0aW9uKCBlICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICggJCggdGhpcyApLm9mZnNldCgpLnRvcCAtICQoIHdpbmRvdyApLnNjcm9sbFRvcCgpICkgPCBzZWxmLm9wdC5zcHlPZmZzZXQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGdldCBvbmx5IHRoZSBsYXRlc3QgaGVhZGVyIG9uIHRoZSB2aWV3cG9ydFxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSAkKCBjdXJyZW50ICkuZXEoIGN1cnJlbnQubGVuZ3RoIC0gMSApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBjdXJyZW50ICYmIGN1cnJlbnQubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgYWxsIGxpIHRhZyB0aGF0IGNvbnRhaW5zIGhyZWYgb2YgIyAoIGFsbCB0aGUgcGFyZW50cyApXG4gICAgICAgICAgICAgICAgICAgIGxpc3QgPSAkKCAnbGk6aGFzKGFbaHJlZj1cIiMnICsgY3VycmVudC5hdHRyKCAnaWQnICkgKyAnXCJdKScgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHByZXYgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYucmVtb3ZlQ2xhc3MoICdhY3RpdmUnICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsaXN0LmFkZENsYXNzKCAnYWN0aXZlJyApO1xuICAgICAgICAgICAgICAgICAgICBwcmV2ID0gbGlzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkLmZuLmFuY2hvcmlmaWMgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICggISAkLmRhdGEoIHRoaXMsICdhbmNob3JpZmljJyApICkge1xuICAgICAgICAgICAgICAgIHZhciBhbmNob3IgPSBPYmplY3QuY3JlYXRlKCBBbmNob3JpZmljICk7XG5cbiAgICAgICAgICAgICAgICBhbmNob3IuaW5pdCggb3B0aW9ucywgdGhpcyApO1xuXG4gICAgICAgICAgICAgICAgJC5kYXRhKCB0aGlzLCAnYW5jaG9yaWZpYycsIGFuY2hvciApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG59KSggalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50ICk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHJlc291cmNlcy9hc3NldHMvanMvdmVuZG9yL2FuY2hvcmlmaWMuanMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 5 */
/***/ function(module, exports) {

eval("/*!\n * Bootstrap v3.3.2 (http://getbootstrap.com)\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n */\n\n/*!\n * Generated using the Bootstrap Customizer (http://getbootstrap.com/customize/?id=9980c2379b76bb6cbd79)\n * Config saved to config.json and https://gist.github.com/9980c2379b76bb6cbd79\n */\nif (typeof jQuery === 'undefined') {\n  throw new Error('Bootstrap\\'s JavaScript requires jQuery')\n}\n+function ($) {\n  'use strict';\n  var version = $.fn.jquery.split(' ')[0].split('.')\n  if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1)) {\n    throw new Error('Bootstrap\\'s JavaScript requires jQuery version 1.9.1 or higher')\n  }\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: dropdown.js v3.3.2\n * http://getbootstrap.com/javascript/#dropdowns\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // DROPDOWN CLASS DEFINITION\n  // =========================\n\n  var backdrop = '.dropdown-backdrop'\n  var toggle   = '[data-toggle=\"dropdown\"]'\n  var Dropdown = function (element) {\n    $(element).on('click.bs.dropdown', this.toggle)\n  }\n\n  Dropdown.VERSION = '3.3.2'\n\n  Dropdown.prototype.toggle = function (e) {\n    var $this = $(this)\n\n    if ($this.is('.disabled, :disabled')) return\n\n    var $parent  = getParent($this)\n    var isActive = $parent.hasClass('open')\n\n    clearMenus()\n\n    if (!isActive) {\n      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {\n        // if mobile we use a backdrop because click events don't delegate\n        $('<div class=\"dropdown-backdrop\"/>').insertAfter($(this)).on('click', clearMenus)\n      }\n\n      var relatedTarget = { relatedTarget: this }\n      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))\n\n      if (e.isDefaultPrevented()) return\n\n      $this\n        .trigger('focus')\n        .attr('aria-expanded', 'true')\n\n      $parent\n        .toggleClass('open')\n        .trigger('shown.bs.dropdown', relatedTarget)\n    }\n\n    return false\n  }\n\n  Dropdown.prototype.keydown = function (e) {\n    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return\n\n    var $this = $(this)\n\n    e.preventDefault()\n    e.stopPropagation()\n\n    if ($this.is('.disabled, :disabled')) return\n\n    var $parent  = getParent($this)\n    var isActive = $parent.hasClass('open')\n\n    if ((!isActive && e.which != 27) || (isActive && e.which == 27)) {\n      if (e.which == 27) $parent.find(toggle).trigger('focus')\n      return $this.trigger('click')\n    }\n\n    var desc = ' li:not(.divider):visible a'\n    var $items = $parent.find('[role=\"menu\"]' + desc + ', [role=\"listbox\"]' + desc)\n\n    if (!$items.length) return\n\n    var index = $items.index(e.target)\n\n    if (e.which == 38 && index > 0)                 index--                        // up\n    if (e.which == 40 && index < $items.length - 1) index++                        // down\n    if (!~index)                                      index = 0\n\n    $items.eq(index).trigger('focus')\n  }\n\n  function clearMenus(e) {\n    if (e && e.which === 3) return\n    $(backdrop).remove()\n    $(toggle).each(function () {\n      var $this         = $(this)\n      var $parent       = getParent($this)\n      var relatedTarget = { relatedTarget: this }\n\n      if (!$parent.hasClass('open')) return\n\n      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))\n\n      if (e.isDefaultPrevented()) return\n\n      $this.attr('aria-expanded', 'false')\n      $parent.removeClass('open').trigger('hidden.bs.dropdown', relatedTarget)\n    })\n  }\n\n  function getParent($this) {\n    var selector = $this.attr('data-target')\n\n    if (!selector) {\n      selector = $this.attr('href')\n      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\\s]*$)/, '') // strip for ie7\n    }\n\n    var $parent = selector && $(selector)\n\n    return $parent && $parent.length ? $parent : $this.parent()\n  }\n\n\n  // DROPDOWN PLUGIN DEFINITION\n  // ==========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this)\n      var data  = $this.data('bs.dropdown')\n\n      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))\n      if (typeof option == 'string') data[option].call($this)\n    })\n  }\n\n  var old = $.fn.dropdown\n\n  $.fn.dropdown             = Plugin\n  $.fn.dropdown.Constructor = Dropdown\n\n\n  // DROPDOWN NO CONFLICT\n  // ====================\n\n  $.fn.dropdown.noConflict = function () {\n    $.fn.dropdown = old\n    return this\n  }\n\n\n  // APPLY TO STANDARD DROPDOWN ELEMENTS\n  // ===================================\n\n  $(document)\n    .on('click.bs.dropdown.data-api', clearMenus)\n    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })\n    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)\n    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)\n    .on('keydown.bs.dropdown.data-api', '[role=\"menu\"]', Dropdown.prototype.keydown)\n    .on('keydown.bs.dropdown.data-api', '[role=\"listbox\"]', Dropdown.prototype.keydown)\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: transition.js v3.3.2\n * http://getbootstrap.com/javascript/#transitions\n * ========================================================================\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)\n  // ============================================================\n\n  function transitionEnd() {\n    var el = document.createElement('bootstrap')\n\n    var transEndEventNames = {\n      WebkitTransition : 'webkitTransitionEnd',\n      MozTransition    : 'transitionend',\n      OTransition      : 'oTransitionEnd otransitionend',\n      transition       : 'transitionend'\n    }\n\n    for (var name in transEndEventNames) {\n      if (el.style[name] !== undefined) {\n        return { end: transEndEventNames[name] }\n      }\n    }\n\n    return false // explicit for ie8 (  ._.)\n  }\n\n  // http://blog.alexmaccaw.com/css-transitions\n  $.fn.emulateTransitionEnd = function (duration) {\n    var called = false\n    var $el = this\n    $(this).one('bsTransitionEnd', function () { called = true })\n    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }\n    setTimeout(callback, duration)\n    return this\n  }\n\n  $(function () {\n    $.support.transition = transitionEnd()\n\n    if (!$.support.transition) return\n\n    $.event.special.bsTransitionEnd = {\n      bindType: $.support.transition.end,\n      delegateType: $.support.transition.end,\n      handle: function (e) {\n        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)\n      }\n    }\n  })\n\n}(jQuery);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9yZXNvdXJjZXMvYXNzZXRzL2pzL3ZlbmRvci9ib290c3RyYXAuanM/Y2ZiZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEJvb3RzdHJhcCB2My4zLjIgKGh0dHA6Ly9nZXRib290c3RyYXAuY29tKVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICovXG5cbi8qIVxuICogR2VuZXJhdGVkIHVzaW5nIHRoZSBCb290c3RyYXAgQ3VzdG9taXplciAoaHR0cDovL2dldGJvb3RzdHJhcC5jb20vY3VzdG9taXplLz9pZD05OTgwYzIzNzliNzZiYjZjYmQ3OSlcbiAqIENvbmZpZyBzYXZlZCB0byBjb25maWcuanNvbiBhbmQgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vOTk4MGMyMzc5Yjc2YmI2Y2JkNzlcbiAqL1xuaWYgKHR5cGVvZiBqUXVlcnkgPT09ICd1bmRlZmluZWQnKSB7XG4gIHRocm93IG5ldyBFcnJvcignQm9vdHN0cmFwXFwncyBKYXZhU2NyaXB0IHJlcXVpcmVzIGpRdWVyeScpXG59XG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICB2YXIgdmVyc2lvbiA9ICQuZm4uanF1ZXJ5LnNwbGl0KCcgJylbMF0uc3BsaXQoJy4nKVxuICBpZiAoKHZlcnNpb25bMF0gPCAyICYmIHZlcnNpb25bMV0gPCA5KSB8fCAodmVyc2lvblswXSA9PSAxICYmIHZlcnNpb25bMV0gPT0gOSAmJiB2ZXJzaW9uWzJdIDwgMSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jvb3RzdHJhcFxcJ3MgSmF2YVNjcmlwdCByZXF1aXJlcyBqUXVlcnkgdmVyc2lvbiAxLjkuMSBvciBoaWdoZXInKVxuICB9XG59KGpRdWVyeSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBkcm9wZG93bi5qcyB2My4zLjJcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2Ryb3Bkb3duc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIERST1BET1dOIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBiYWNrZHJvcCA9ICcuZHJvcGRvd24tYmFja2Ryb3AnXG4gIHZhciB0b2dnbGUgICA9ICdbZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXSdcbiAgdmFyIERyb3Bkb3duID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAkKGVsZW1lbnQpLm9uKCdjbGljay5icy5kcm9wZG93bicsIHRoaXMudG9nZ2xlKVxuICB9XG5cbiAgRHJvcGRvd24uVkVSU0lPTiA9ICczLjMuMidcblxuICBEcm9wZG93bi5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgJHRoaXMgPSAkKHRoaXMpXG5cbiAgICBpZiAoJHRoaXMuaXMoJy5kaXNhYmxlZCwgOmRpc2FibGVkJykpIHJldHVyblxuXG4gICAgdmFyICRwYXJlbnQgID0gZ2V0UGFyZW50KCR0aGlzKVxuICAgIHZhciBpc0FjdGl2ZSA9ICRwYXJlbnQuaGFzQ2xhc3MoJ29wZW4nKVxuXG4gICAgY2xlYXJNZW51cygpXG5cbiAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmICEkcGFyZW50LmNsb3Nlc3QoJy5uYXZiYXItbmF2JykubGVuZ3RoKSB7XG4gICAgICAgIC8vIGlmIG1vYmlsZSB3ZSB1c2UgYSBiYWNrZHJvcCBiZWNhdXNlIGNsaWNrIGV2ZW50cyBkb24ndCBkZWxlZ2F0ZVxuICAgICAgICAkKCc8ZGl2IGNsYXNzPVwiZHJvcGRvd24tYmFja2Ryb3BcIi8+JykuaW5zZXJ0QWZ0ZXIoJCh0aGlzKSkub24oJ2NsaWNrJywgY2xlYXJNZW51cylcbiAgICAgIH1cblxuICAgICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSB7IHJlbGF0ZWRUYXJnZXQ6IHRoaXMgfVxuICAgICAgJHBhcmVudC50cmlnZ2VyKGUgPSAkLkV2ZW50KCdzaG93LmJzLmRyb3Bkb3duJywgcmVsYXRlZFRhcmdldCkpXG5cbiAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgICAgJHRoaXNcbiAgICAgICAgLnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAndHJ1ZScpXG5cbiAgICAgICRwYXJlbnRcbiAgICAgICAgLnRvZ2dsZUNsYXNzKCdvcGVuJylcbiAgICAgICAgLnRyaWdnZXIoJ3Nob3duLmJzLmRyb3Bkb3duJywgcmVsYXRlZFRhcmdldClcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIERyb3Bkb3duLnByb3RvdHlwZS5rZXlkb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoIS8oMzh8NDB8Mjd8MzIpLy50ZXN0KGUud2hpY2gpIHx8IC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZS50YXJnZXQudGFnTmFtZSkpIHJldHVyblxuXG4gICAgdmFyICR0aGlzID0gJCh0aGlzKVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICAgaWYgKCR0aGlzLmlzKCcuZGlzYWJsZWQsIDpkaXNhYmxlZCcpKSByZXR1cm5cblxuICAgIHZhciAkcGFyZW50ICA9IGdldFBhcmVudCgkdGhpcylcbiAgICB2YXIgaXNBY3RpdmUgPSAkcGFyZW50Lmhhc0NsYXNzKCdvcGVuJylcblxuICAgIGlmICgoIWlzQWN0aXZlICYmIGUud2hpY2ggIT0gMjcpIHx8IChpc0FjdGl2ZSAmJiBlLndoaWNoID09IDI3KSkge1xuICAgICAgaWYgKGUud2hpY2ggPT0gMjcpICRwYXJlbnQuZmluZCh0b2dnbGUpLnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgIHJldHVybiAkdGhpcy50cmlnZ2VyKCdjbGljaycpXG4gICAgfVxuXG4gICAgdmFyIGRlc2MgPSAnIGxpOm5vdCguZGl2aWRlcik6dmlzaWJsZSBhJ1xuICAgIHZhciAkaXRlbXMgPSAkcGFyZW50LmZpbmQoJ1tyb2xlPVwibWVudVwiXScgKyBkZXNjICsgJywgW3JvbGU9XCJsaXN0Ym94XCJdJyArIGRlc2MpXG5cbiAgICBpZiAoISRpdGVtcy5sZW5ndGgpIHJldHVyblxuXG4gICAgdmFyIGluZGV4ID0gJGl0ZW1zLmluZGV4KGUudGFyZ2V0KVxuXG4gICAgaWYgKGUud2hpY2ggPT0gMzggJiYgaW5kZXggPiAwKSAgICAgICAgICAgICAgICAgaW5kZXgtLSAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwXG4gICAgaWYgKGUud2hpY2ggPT0gNDAgJiYgaW5kZXggPCAkaXRlbXMubGVuZ3RoIC0gMSkgaW5kZXgrKyAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvd25cbiAgICBpZiAoIX5pbmRleCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMFxuXG4gICAgJGl0ZW1zLmVxKGluZGV4KS50cmlnZ2VyKCdmb2N1cycpXG4gIH1cblxuICBmdW5jdGlvbiBjbGVhck1lbnVzKGUpIHtcbiAgICBpZiAoZSAmJiBlLndoaWNoID09PSAzKSByZXR1cm5cbiAgICAkKGJhY2tkcm9wKS5yZW1vdmUoKVxuICAgICQodG9nZ2xlKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgICAgICAgID0gJCh0aGlzKVxuICAgICAgdmFyICRwYXJlbnQgICAgICAgPSBnZXRQYXJlbnQoJHRoaXMpXG4gICAgICB2YXIgcmVsYXRlZFRhcmdldCA9IHsgcmVsYXRlZFRhcmdldDogdGhpcyB9XG5cbiAgICAgIGlmICghJHBhcmVudC5oYXNDbGFzcygnb3BlbicpKSByZXR1cm5cblxuICAgICAgJHBhcmVudC50cmlnZ2VyKGUgPSAkLkV2ZW50KCdoaWRlLmJzLmRyb3Bkb3duJywgcmVsYXRlZFRhcmdldCkpXG5cbiAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgICAgJHRoaXMuYXR0cignYXJpYS1leHBhbmRlZCcsICdmYWxzZScpXG4gICAgICAkcGFyZW50LnJlbW92ZUNsYXNzKCdvcGVuJykudHJpZ2dlcignaGlkZGVuLmJzLmRyb3Bkb3duJywgcmVsYXRlZFRhcmdldClcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGFyZW50KCR0aGlzKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gJHRoaXMuYXR0cignZGF0YS10YXJnZXQnKVxuXG4gICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdocmVmJylcbiAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IgJiYgLyNbQS1aYS16XS8udGVzdChzZWxlY3RvcikgJiYgc2VsZWN0b3IucmVwbGFjZSgvLiooPz0jW15cXHNdKiQpLywgJycpIC8vIHN0cmlwIGZvciBpZTdcbiAgICB9XG5cbiAgICB2YXIgJHBhcmVudCA9IHNlbGVjdG9yICYmICQoc2VsZWN0b3IpXG5cbiAgICByZXR1cm4gJHBhcmVudCAmJiAkcGFyZW50Lmxlbmd0aCA/ICRwYXJlbnQgOiAkdGhpcy5wYXJlbnQoKVxuICB9XG5cblxuICAvLyBEUk9QRE9XTiBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICA9ICR0aGlzLmRhdGEoJ2JzLmRyb3Bkb3duJylcblxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5kcm9wZG93bicsIChkYXRhID0gbmV3IERyb3Bkb3duKHRoaXMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0uY2FsbCgkdGhpcylcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4uZHJvcGRvd25cblxuICAkLmZuLmRyb3Bkb3duICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uZHJvcGRvd24uQ29uc3RydWN0b3IgPSBEcm9wZG93blxuXG5cbiAgLy8gRFJPUERPV04gTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PT1cblxuICAkLmZuLmRyb3Bkb3duLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5kcm9wZG93biA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIEFQUExZIFRPIFNUQU5EQVJEIERST1BET1dOIEVMRU1FTlRTXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgJChkb2N1bWVudClcbiAgICAub24oJ2NsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgY2xlYXJNZW51cylcbiAgICAub24oJ2NsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgJy5kcm9wZG93biBmb3JtJywgZnVuY3Rpb24gKGUpIHsgZS5zdG9wUHJvcGFnYXRpb24oKSB9KVxuICAgIC5vbignY2xpY2suYnMuZHJvcGRvd24uZGF0YS1hcGknLCB0b2dnbGUsIERyb3Bkb3duLnByb3RvdHlwZS50b2dnbGUpXG4gICAgLm9uKCdrZXlkb3duLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgdG9nZ2xlLCBEcm9wZG93bi5wcm90b3R5cGUua2V5ZG93bilcbiAgICAub24oJ2tleWRvd24uYnMuZHJvcGRvd24uZGF0YS1hcGknLCAnW3JvbGU9XCJtZW51XCJdJywgRHJvcGRvd24ucHJvdG90eXBlLmtleWRvd24pXG4gICAgLm9uKCdrZXlkb3duLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgJ1tyb2xlPVwibGlzdGJveFwiXScsIERyb3Bkb3duLnByb3RvdHlwZS5rZXlkb3duKVxuXG59KGpRdWVyeSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiB0cmFuc2l0aW9uLmpzIHYzLjMuMlxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jdHJhbnNpdGlvbnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBDU1MgVFJBTlNJVElPTiBTVVBQT1JUIChTaG91dG91dDogaHR0cDovL3d3dy5tb2Rlcm5penIuY29tLylcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkVuZCgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdib290c3RyYXAnKVxuXG4gICAgdmFyIHRyYW5zRW5kRXZlbnROYW1lcyA9IHtcbiAgICAgIFdlYmtpdFRyYW5zaXRpb24gOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgICBNb3pUcmFuc2l0aW9uICAgIDogJ3RyYW5zaXRpb25lbmQnLFxuICAgICAgT1RyYW5zaXRpb24gICAgICA6ICdvVHJhbnNpdGlvbkVuZCBvdHJhbnNpdGlvbmVuZCcsXG4gICAgICB0cmFuc2l0aW9uICAgICAgIDogJ3RyYW5zaXRpb25lbmQnXG4gICAgfVxuXG4gICAgZm9yICh2YXIgbmFtZSBpbiB0cmFuc0VuZEV2ZW50TmFtZXMpIHtcbiAgICAgIGlmIChlbC5zdHlsZVtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7IGVuZDogdHJhbnNFbmRFdmVudE5hbWVzW25hbWVdIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2UgLy8gZXhwbGljaXQgZm9yIGllOCAoICAuXy4pXG4gIH1cblxuICAvLyBodHRwOi8vYmxvZy5hbGV4bWFjY2F3LmNvbS9jc3MtdHJhbnNpdGlvbnNcbiAgJC5mbi5lbXVsYXRlVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xuICAgIHZhciBjYWxsZWQgPSBmYWxzZVxuICAgIHZhciAkZWwgPSB0aGlzXG4gICAgJCh0aGlzKS5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uICgpIHsgY2FsbGVkID0gdHJ1ZSB9KVxuICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHsgaWYgKCFjYWxsZWQpICQoJGVsKS50cmlnZ2VyKCQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCkgfVxuICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIGR1cmF0aW9uKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAkKGZ1bmN0aW9uICgpIHtcbiAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25FbmQoKVxuXG4gICAgaWYgKCEkLnN1cHBvcnQudHJhbnNpdGlvbikgcmV0dXJuXG5cbiAgICAkLmV2ZW50LnNwZWNpYWwuYnNUcmFuc2l0aW9uRW5kID0ge1xuICAgICAgYmluZFR5cGU6ICQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCxcbiAgICAgIGRlbGVnYXRlVHlwZTogJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kLFxuICAgICAgaGFuZGxlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoJChlLnRhcmdldCkuaXModGhpcykpIHJldHVybiBlLmhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbn0oalF1ZXJ5KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyByZXNvdXJjZXMvYXNzZXRzL2pzL3ZlbmRvci9ib290c3RyYXAuanMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

eval("/*!\n *  Copyright 2011 Twitter, Inc.\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n\nvar Hogan = {};\n\n(function (Hogan) {\n    Hogan.Template = function (codeObj, text, compiler, options) {\n        codeObj = codeObj || {};\n        this.r = codeObj.code || this.r;\n        this.c = compiler;\n        this.options = options || {};\n        this.text = text || '';\n        this.partials = codeObj.partials || {};\n        this.subs = codeObj.subs || {};\n        this.buf = '';\n    }\n\n    Hogan.Template.prototype = {\n        // render: replaced by generated code.\n        r: function (context, partials, indent) { return ''; },\n\n        // variable escaping\n        v: hoganEscape,\n\n        // triple stache\n        t: coerceToString,\n\n        render: function render(context, partials, indent) {\n            return this.ri([context], partials || {}, indent);\n        },\n\n        // render internal -- a hook for overrides that catches partials too\n        ri: function (context, partials, indent) {\n            return this.r(context, partials, indent);\n        },\n\n        // ensurePartial\n        ep: function(symbol, partials) {\n            var this$1 = this;\n\n            var partial = this.partials[symbol];\n\n            // check to see that if we've instantiated this partial before\n            var template = partials[partial.name];\n            if (partial.instance && partial.base == template) {\n                return partial.instance;\n            }\n\n            if (typeof template == 'string') {\n                if (!this.c) {\n                    throw new Error(\"No compiler available.\");\n                }\n                template = this.c.compile(template, this.options);\n            }\n\n            if (!template) {\n                return null;\n            }\n\n            // We use this to check whether the partials dictionary has changed\n            this.partials[symbol].base = template;\n\n            if (partial.subs) {\n                // Make sure we consider parent template now\n                if (!partials.stackText) partials.stackText = {};\n                for (key in partial.subs) {\n                    if (!partials.stackText[key]) {\n                        partials.stackText[key] = (this$1.activeSub !== undefined && partials.stackText[this$1.activeSub]) ? partials.stackText[this$1.activeSub] : this$1.text;\n                    }\n                }\n                template = createSpecializedPartial(template, partial.subs, partial.partials,\n                    this.stackSubs, this.stackPartials, partials.stackText);\n            }\n            this.partials[symbol].instance = template;\n\n            return template;\n        },\n\n        // tries to find a partial in the current scope and render it\n        rp: function(symbol, context, partials, indent) {\n            var partial = this.ep(symbol, partials);\n            if (!partial) {\n                return '';\n            }\n\n            return partial.ri(context, partials, indent);\n        },\n\n        // render a section\n        rs: function(context, partials, section) {\n            var this$1 = this;\n\n            var tail = context[context.length - 1];\n\n            if (!isArray(tail)) {\n                section(context, partials, this);\n                return;\n            }\n\n            for (var i = 0; i < tail.length; i++) {\n                context.push(tail[i]);\n                section(context, partials, this$1);\n                context.pop();\n            }\n        },\n\n        // maybe start a section\n        s: function(val, ctx, partials, inverted, start, end, tags) {\n            var pass;\n\n            if (isArray(val) && val.length === 0) {\n                return false;\n            }\n\n            if (typeof val == 'function') {\n                val = this.ms(val, ctx, partials, inverted, start, end, tags);\n            }\n\n            pass = !!val;\n\n            if (!inverted && pass && ctx) {\n                ctx.push((typeof val == 'object') ? val : ctx[ctx.length - 1]);\n            }\n\n            return pass;\n        },\n\n        // find values with dotted names\n        d: function(key, ctx, partials, returnFound) {\n            var found,\n                names = key.split('.'),\n                val = this.f(names[0], ctx, partials, returnFound),\n                doModelGet = this.options.modelGet,\n                cx = null;\n\n            if (key === '.' && isArray(ctx[ctx.length - 2])) {\n                val = ctx[ctx.length - 1];\n            } else {\n                for (var i = 1; i < names.length; i++) {\n                    found = findInScope(names[i], val, doModelGet);\n                    if (found !== undefined) {\n                        cx = val;\n                        val = found;\n                    } else {\n                        val = '';\n                    }\n                }\n            }\n\n            if (returnFound && !val) {\n                return false;\n            }\n\n            if (!returnFound && typeof val == 'function') {\n                ctx.push(cx);\n                val = this.mv(val, ctx, partials);\n                ctx.pop();\n            }\n\n            return val;\n        },\n\n        // find values with normal names\n        f: function(key, ctx, partials, returnFound) {\n            var val = false,\n                v = null,\n                found = false,\n                doModelGet = this.options.modelGet;\n\n            for (var i = ctx.length - 1; i >= 0; i--) {\n                v = ctx[i];\n                val = findInScope(key, v, doModelGet);\n                if (val !== undefined) {\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found) {\n                return (returnFound) ? false : \"\";\n            }\n\n            if (!returnFound && typeof val == 'function') {\n                val = this.mv(val, ctx, partials);\n            }\n\n            return val;\n        },\n\n        // higher order templates\n        ls: function(func, cx, partials, text, tags) {\n            var oldTags = this.options.delimiters;\n\n            this.options.delimiters = tags;\n            this.b(this.ct(coerceToString(func.call(cx, text)), cx, partials));\n            this.options.delimiters = oldTags;\n\n            return false;\n        },\n\n        // compile text\n        ct: function(text, cx, partials) {\n            if (this.options.disableLambda) {\n                throw new Error('Lambda features disabled.');\n            }\n            return this.c.compile(text, this.options).render(cx, partials);\n        },\n\n        // template result buffering\n        b: function(s) { this.buf += s; },\n\n        fl: function() { var r = this.buf; this.buf = ''; return r; },\n\n        // method replace section\n        ms: function(func, ctx, partials, inverted, start, end, tags) {\n            var textSource,\n                cx = ctx[ctx.length - 1],\n                result = func.call(cx);\n\n            if (typeof result == 'function') {\n                if (inverted) {\n                    return true;\n                } else {\n                    textSource = (this.activeSub && this.subsText && this.subsText[this.activeSub]) ? this.subsText[this.activeSub] : this.text;\n                    return this.ls(result, cx, partials, textSource.substring(start, end), tags);\n                }\n            }\n\n            return result;\n        },\n\n        // method replace variable\n        mv: function(func, ctx, partials) {\n            var cx = ctx[ctx.length - 1];\n            var result = func.call(cx);\n\n            if (typeof result == 'function') {\n                return this.ct(coerceToString(result.call(cx)), cx, partials);\n            }\n\n            return result;\n        },\n\n        sub: function(name, context, partials, indent) {\n            var f = this.subs[name];\n            if (f) {\n                this.activeSub = name;\n                f(context, partials, this, indent);\n                this.activeSub = false;\n            }\n        }\n\n    };\n\n    //Find a key in an object\n    function findInScope(key, scope, doModelGet) {\n        var val;\n\n        if (scope && typeof scope == 'object') {\n\n            if (scope[key] !== undefined) {\n                val = scope[key];\n\n                // try lookup with get for backbone or similar model data\n            } else if (doModelGet && scope.get && typeof scope.get == 'function') {\n                val = scope.get(key);\n            }\n        }\n\n        return val;\n    }\n\n    function createSpecializedPartial(instance, subs, partials, stackSubs, stackPartials, stackText) {\n        function PartialTemplate() {};\n        PartialTemplate.prototype = instance;\n        function Substitutions() {};\n        Substitutions.prototype = instance.subs;\n        var key;\n        var partial = new PartialTemplate();\n        partial.subs = new Substitutions();\n        partial.subsText = {};  //hehe. substext.\n        partial.buf = '';\n\n        stackSubs = stackSubs || {};\n        partial.stackSubs = stackSubs;\n        partial.subsText = stackText;\n        for (key in subs) {\n            if (!stackSubs[key]) stackSubs[key] = subs[key];\n        }\n        for (key in stackSubs) {\n            partial.subs[key] = stackSubs[key];\n        }\n\n        stackPartials = stackPartials || {};\n        partial.stackPartials = stackPartials;\n        for (key in partials) {\n            if (!stackPartials[key]) stackPartials[key] = partials[key];\n        }\n        for (key in stackPartials) {\n            partial.partials[key] = stackPartials[key];\n        }\n\n        return partial;\n    }\n\n    var rAmp = /&/g,\n        rLt = /</g,\n        rGt = />/g,\n        rApos = /\\'/g,\n        rQuot = /\\\"/g,\n        hChars = /[&<>\\\"\\']/;\n\n    function coerceToString(val) {\n        return String((val === null || val === undefined) ? '' : val);\n    }\n\n    function hoganEscape(str) {\n        str = coerceToString(str);\n        return hChars.test(str) ?\n            str\n                .replace(rAmp, '&amp;')\n                .replace(rLt, '&lt;')\n                .replace(rGt, '&gt;')\n                .replace(rApos, '&#39;')\n                .replace(rQuot, '&quot;') :\n            str;\n    }\n\n    var isArray = Array.isArray || function(a) {\n            return Object.prototype.toString.call(a) === '[object Array]';\n        };\n\n})( true ? exports : Hogan);\n\n\n\n(function (Hogan) {\n    // Setup regex  assignments\n    // remove whitespace according to Mustache spec\n    var rIsWhitespace = /\\S/,\n        rQuot = /\\\"/g,\n        rNewline =  /\\n/g,\n        rCr = /\\r/g,\n        rSlash = /\\\\/g,\n        rLineSep = /\\u2028/,\n        rParagraphSep = /\\u2029/;\n\n    Hogan.tags = {\n        '#': 1, '^': 2, '<': 3, '$': 4,\n        '/': 5, '!': 6, '>': 7, '=': 8, '_v': 9,\n        '{': 10, '&': 11, '_t': 12\n    };\n\n    Hogan.scan = function scan(text, delimiters) {\n        var len = text.length,\n            IN_TEXT = 0,\n            IN_TAG_TYPE = 1,\n            IN_TAG = 2,\n            state = IN_TEXT,\n            tagType = null,\n            tag = null,\n            buf = '',\n            tokens = [],\n            seenTag = false,\n            i = 0,\n            lineStart = 0,\n            otag = '{{',\n            ctag = '}}';\n\n        function addBuf() {\n            if (buf.length > 0) {\n                tokens.push({tag: '_t', text: new String(buf)});\n                buf = '';\n            }\n        }\n\n        function lineIsWhitespace() {\n            var isAllWhitespace = true;\n            for (var j = lineStart; j < tokens.length; j++) {\n                isAllWhitespace =\n                    (Hogan.tags[tokens[j].tag] < Hogan.tags['_v']) ||\n                    (tokens[j].tag == '_t' && tokens[j].text.match(rIsWhitespace) === null);\n                if (!isAllWhitespace) {\n                    return false;\n                }\n            }\n\n            return isAllWhitespace;\n        }\n\n        function filterLine(haveSeenTag, noNewLine) {\n            addBuf();\n\n            if (haveSeenTag && lineIsWhitespace()) {\n                for (var j = lineStart, next; j < tokens.length; j++) {\n                    if (tokens[j].text) {\n                        if ((next = tokens[j+1]) && next.tag == '>') {\n                            // set indent to token value\n                            next.indent = tokens[j].text.toString()\n                        }\n                        tokens.splice(j, 1);\n                    }\n                }\n            } else if (!noNewLine) {\n                tokens.push({tag:'\\n'});\n            }\n\n            seenTag = false;\n            lineStart = tokens.length;\n        }\n\n        function changeDelimiters(text, index) {\n            var close = '=' + ctag,\n                closeIndex = text.indexOf(close, index),\n                delimiters = trim(\n                    text.substring(text.indexOf('=', index) + 1, closeIndex)\n                ).split(' ');\n\n            otag = delimiters[0];\n            ctag = delimiters[delimiters.length - 1];\n\n            return closeIndex + close.length - 1;\n        }\n\n        if (delimiters) {\n            delimiters = delimiters.split(' ');\n            otag = delimiters[0];\n            ctag = delimiters[1];\n        }\n\n        for (i = 0; i < len; i++) {\n            if (state == IN_TEXT) {\n                if (tagChange(otag, text, i)) {\n                    --i;\n                    addBuf();\n                    state = IN_TAG_TYPE;\n                } else {\n                    if (text.charAt(i) == '\\n') {\n                        filterLine(seenTag);\n                    } else {\n                        buf += text.charAt(i);\n                    }\n                }\n            } else if (state == IN_TAG_TYPE) {\n                i += otag.length - 1;\n                tag = Hogan.tags[text.charAt(i + 1)];\n                tagType = tag ? text.charAt(i + 1) : '_v';\n                if (tagType == '=') {\n                    i = changeDelimiters(text, i);\n                    state = IN_TEXT;\n                } else {\n                    if (tag) {\n                        i++;\n                    }\n                    state = IN_TAG;\n                }\n                seenTag = i;\n            } else {\n                if (tagChange(ctag, text, i)) {\n                    tokens.push({tag: tagType, n: trim(buf), otag: otag, ctag: ctag,\n                        i: (tagType == '/') ? seenTag - otag.length : i + ctag.length});\n                    buf = '';\n                    i += ctag.length - 1;\n                    state = IN_TEXT;\n                    if (tagType == '{') {\n                        if (ctag == '}}') {\n                            i++;\n                        } else {\n                            cleanTripleStache(tokens[tokens.length - 1]);\n                        }\n                    }\n                } else {\n                    buf += text.charAt(i);\n                }\n            }\n        }\n\n        filterLine(seenTag, true);\n\n        return tokens;\n    }\n\n    function cleanTripleStache(token) {\n        if (token.n.substr(token.n.length - 1) === '}') {\n            token.n = token.n.substring(0, token.n.length - 1);\n        }\n    }\n\n    function trim(s) {\n        if (s.trim) {\n            return s.trim();\n        }\n\n        return s.replace(/^\\s*|\\s*$/g, '');\n    }\n\n    function tagChange(tag, text, index) {\n        if (text.charAt(index) != tag.charAt(0)) {\n            return false;\n        }\n\n        for (var i = 1, l = tag.length; i < l; i++) {\n            if (text.charAt(index + i) != tag.charAt(i)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // the tags allowed inside super templates\n    var allowedInSuper = {'_t': true, '\\n': true, '$': true, '/': true};\n\n    function buildTree(tokens, kind, stack, customTags) {\n        var instructions = [],\n            opener = null,\n            tail = null,\n            token = null;\n\n        tail = stack[stack.length - 1];\n\n        while (tokens.length > 0) {\n            token = tokens.shift();\n\n            if (tail && tail.tag == '<' && !(token.tag in allowedInSuper)) {\n                throw new Error('Illegal content in < super tag.');\n            }\n\n            if (Hogan.tags[token.tag] <= Hogan.tags['$'] || isOpener(token, customTags)) {\n                stack.push(token);\n                token.nodes = buildTree(tokens, token.tag, stack, customTags);\n            } else if (token.tag == '/') {\n                if (stack.length === 0) {\n                    throw new Error('Closing tag without opener: /' + token.n);\n                }\n                opener = stack.pop();\n                if (token.n != opener.n && !isCloser(token.n, opener.n, customTags)) {\n                    throw new Error('Nesting error: ' + opener.n + ' vs. ' + token.n);\n                }\n                opener.end = token.i;\n                return instructions;\n            } else if (token.tag == '\\n') {\n                token.last = (tokens.length == 0) || (tokens[0].tag == '\\n');\n            }\n\n            instructions.push(token);\n        }\n\n        if (stack.length > 0) {\n            throw new Error('missing closing tag: ' + stack.pop().n);\n        }\n\n        return instructions;\n    }\n\n    function isOpener(token, tags) {\n        for (var i = 0, l = tags.length; i < l; i++) {\n            if (tags[i].o == token.n) {\n                token.tag = '#';\n                return true;\n            }\n        }\n    }\n\n    function isCloser(close, open, tags) {\n        for (var i = 0, l = tags.length; i < l; i++) {\n            if (tags[i].c == close && tags[i].o == open) {\n                return true;\n            }\n        }\n    }\n\n    function stringifySubstitutions(obj) {\n        var items = [];\n        for (var key in obj) {\n            items.push('\"' + esc(key) + '\": function(c,p,t,i) {' + obj[key] + '}');\n        }\n        return \"{ \" + items.join(\",\") + \" }\";\n    }\n\n    function stringifyPartials(codeObj) {\n        var partials = [];\n        for (var key in codeObj.partials) {\n            partials.push('\"' + esc(key) + '\":{name:\"' + esc(codeObj.partials[key].name) + '\", ' + stringifyPartials(codeObj.partials[key]) + \"}\");\n        }\n        return \"partials: {\" + partials.join(\",\") + \"}, subs: \" + stringifySubstitutions(codeObj.subs);\n    }\n\n    Hogan.stringify = function(codeObj, text, options) {\n        return \"{code: function (c,p,i) { \" + Hogan.wrapMain(codeObj.code) + \" },\" + stringifyPartials(codeObj) +  \"}\";\n    }\n\n    var serialNo = 0;\n    Hogan.generate = function(tree, text, options) {\n        serialNo = 0;\n        var context = { code: '', subs: {}, partials: {} };\n        Hogan.walk(tree, context);\n\n        if (options.asString) {\n            return this.stringify(context, text, options);\n        }\n\n        return this.makeTemplate(context, text, options);\n    }\n\n    Hogan.wrapMain = function(code) {\n        return 'var t=this;t.b(i=i||\"\");' + code + 'return t.fl();';\n    }\n\n    Hogan.template = Hogan.Template;\n\n    Hogan.makeTemplate = function(codeObj, text, options) {\n        var template = this.makePartials(codeObj);\n        template.code = new Function('c', 'p', 'i', this.wrapMain(codeObj.code));\n        return new this.template(template, text, this, options);\n    }\n\n    Hogan.makePartials = function(codeObj) {\n        var this$1 = this;\n\n        var key, template = {subs: {}, partials: codeObj.partials, name: codeObj.name};\n        for (key in template.partials) {\n            template.partials[key] = this$1.makePartials(template.partials[key]);\n        }\n        for (key in codeObj.subs) {\n            template.subs[key] = new Function('c', 'p', 't', 'i', codeObj.subs[key]);\n        }\n        return template;\n    }\n\n    function esc(s) {\n        return s.replace(rSlash, '\\\\\\\\')\n            .replace(rQuot, '\\\\\\\"')\n            .replace(rNewline, '\\\\n')\n            .replace(rCr, '\\\\r')\n            .replace(rLineSep, '\\\\u2028')\n            .replace(rParagraphSep, '\\\\u2029');\n    }\n\n    function chooseMethod(s) {\n        return (~s.indexOf('.')) ? 'd' : 'f';\n    }\n\n    function createPartial(node, context) {\n        var prefix = \"<\" + (context.prefix || \"\");\n        var sym = prefix + node.n + serialNo++;\n        context.partials[sym] = {name: node.n, partials: {}};\n        context.code += 't.b(t.rp(\"' +  esc(sym) + '\",c,p,\"' + (node.indent || '') + '\"));';\n        return sym;\n    }\n\n    Hogan.codegen = {\n        '#': function(node, context) {\n            context.code += 'if(t.s(t.' + chooseMethod(node.n) + '(\"' + esc(node.n) + '\",c,p,1),' +\n            'c,p,0,' + node.i + ',' + node.end + ',\"' + node.otag + \" \" + node.ctag + '\")){' +\n            't.rs(c,p,' + 'function(c,p,t){';\n            Hogan.walk(node.nodes, context);\n            context.code += '});c.pop();}';\n        },\n\n        '^': function(node, context) {\n            context.code += 'if(!t.s(t.' + chooseMethod(node.n) + '(\"' + esc(node.n) + '\",c,p,1),c,p,1,0,0,\"\")){';\n            Hogan.walk(node.nodes, context);\n            context.code += '};';\n        },\n\n        '>': createPartial,\n        '<': function(node, context) {\n            var ctx = {partials: {}, code: '', subs: {}, inPartial: true};\n            Hogan.walk(node.nodes, ctx);\n            var template = context.partials[createPartial(node, context)];\n            template.subs = ctx.subs;\n            template.partials = ctx.partials;\n        },\n\n        '$': function(node, context) {\n            var ctx = {subs: {}, code: '', partials: context.partials, prefix: node.n};\n            Hogan.walk(node.nodes, ctx);\n            context.subs[node.n] = ctx.code;\n            if (!context.inPartial) {\n                context.code += 't.sub(\"' + esc(node.n) + '\",c,p,i);';\n            }\n        },\n\n        '\\n': function(node, context) {\n            context.code += write('\"\\\\n\"' + (node.last ? '' : ' + i'));\n        },\n\n        '_v': function(node, context) {\n            context.code += 't.b(t.v(t.' + chooseMethod(node.n) + '(\"' + esc(node.n) + '\",c,p,0)));';\n        },\n\n        '_t': function(node, context) {\n            context.code += write('\"' + esc(node.text) + '\"');\n        },\n\n        '{': tripleStache,\n\n        '&': tripleStache\n    }\n\n    function tripleStache(node, context) {\n        context.code += 't.b(t.t(t.' + chooseMethod(node.n) + '(\"' + esc(node.n) + '\",c,p,0)));';\n    }\n\n    function write(s) {\n        return 't.b(' + s + ');';\n    }\n\n    Hogan.walk = function(nodelist, context) {\n        var func;\n        for (var i = 0, l = nodelist.length; i < l; i++) {\n            func = Hogan.codegen[nodelist[i].tag];\n            func && func(nodelist[i], context);\n        }\n        return context;\n    }\n\n    Hogan.parse = function(tokens, text, options) {\n        options = options || {};\n        return buildTree(tokens, '', [], options.sectionTags || []);\n    }\n\n    Hogan.cache = {};\n\n    Hogan.cacheKey = function(text, options) {\n        return [text, !!options.asString, !!options.disableLambda, options.delimiters, !!options.modelGet].join('||');\n    }\n\n    Hogan.compile = function(text, options) {\n        options = options || {};\n        var key = Hogan.cacheKey(text, options);\n        var template = this.cache[key];\n\n        if (template) {\n            var partials = template.partials;\n            for (var name in partials) {\n                delete partials[name].instance;\n            }\n            return template;\n        }\n\n        template = this.generate(this.parse(this.scan(text, options.delimiters), text, options), text, options);\n        return this.cache[key] = template;\n    }\n})( true ? exports : Hogan);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9yZXNvdXJjZXMvYXNzZXRzL2pzL3ZlbmRvci9ob2dhbi5qcz8zMjU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogIENvcHlyaWdodCAyMDExIFR3aXR0ZXIsIEluYy5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuXG52YXIgSG9nYW4gPSB7fTtcblxuKGZ1bmN0aW9uIChIb2dhbikge1xuICAgIEhvZ2FuLlRlbXBsYXRlID0gZnVuY3Rpb24gKGNvZGVPYmosIHRleHQsIGNvbXBpbGVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvZGVPYmogPSBjb2RlT2JqIHx8IHt9O1xuICAgICAgICB0aGlzLnIgPSBjb2RlT2JqLmNvZGUgfHwgdGhpcy5yO1xuICAgICAgICB0aGlzLmMgPSBjb21waWxlcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dCB8fCAnJztcbiAgICAgICAgdGhpcy5wYXJ0aWFscyA9IGNvZGVPYmoucGFydGlhbHMgfHwge307XG4gICAgICAgIHRoaXMuc3VicyA9IGNvZGVPYmouc3VicyB8fCB7fTtcbiAgICAgICAgdGhpcy5idWYgPSAnJztcbiAgICB9XG5cbiAgICBIb2dhbi5UZW1wbGF0ZS5wcm90b3R5cGUgPSB7XG4gICAgICAgIC8vIHJlbmRlcjogcmVwbGFjZWQgYnkgZ2VuZXJhdGVkIGNvZGUuXG4gICAgICAgIHI6IGZ1bmN0aW9uIChjb250ZXh0LCBwYXJ0aWFscywgaW5kZW50KSB7IHJldHVybiAnJzsgfSxcblxuICAgICAgICAvLyB2YXJpYWJsZSBlc2NhcGluZ1xuICAgICAgICB2OiBob2dhbkVzY2FwZSxcblxuICAgICAgICAvLyB0cmlwbGUgc3RhY2hlXG4gICAgICAgIHQ6IGNvZXJjZVRvU3RyaW5nLFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGNvbnRleHQsIHBhcnRpYWxzLCBpbmRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpKFtjb250ZXh0XSwgcGFydGlhbHMgfHwge30sIGluZGVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gcmVuZGVyIGludGVybmFsIC0tIGEgaG9vayBmb3Igb3ZlcnJpZGVzIHRoYXQgY2F0Y2hlcyBwYXJ0aWFscyB0b29cbiAgICAgICAgcmk6IGZ1bmN0aW9uIChjb250ZXh0LCBwYXJ0aWFscywgaW5kZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yKGNvbnRleHQsIHBhcnRpYWxzLCBpbmRlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGVuc3VyZVBhcnRpYWxcbiAgICAgICAgZXA6IGZ1bmN0aW9uKHN5bWJvbCwgcGFydGlhbHMpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0aWFsID0gdGhpcy5wYXJ0aWFsc1tzeW1ib2xdO1xuXG4gICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgdGhhdCBpZiB3ZSd2ZSBpbnN0YW50aWF0ZWQgdGhpcyBwYXJ0aWFsIGJlZm9yZVxuICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gcGFydGlhbHNbcGFydGlhbC5uYW1lXTtcbiAgICAgICAgICAgIGlmIChwYXJ0aWFsLmluc3RhbmNlICYmIHBhcnRpYWwuYmFzZSA9PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0aWFsLmluc3RhbmNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY29tcGlsZXIgYXZhaWxhYmxlLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGVtcGxhdGUgPSB0aGlzLmMuY29tcGlsZSh0ZW1wbGF0ZSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXZSB1c2UgdGhpcyB0byBjaGVjayB3aGV0aGVyIHRoZSBwYXJ0aWFscyBkaWN0aW9uYXJ5IGhhcyBjaGFuZ2VkXG4gICAgICAgICAgICB0aGlzLnBhcnRpYWxzW3N5bWJvbF0uYmFzZSA9IHRlbXBsYXRlO1xuXG4gICAgICAgICAgICBpZiAocGFydGlhbC5zdWJzKSB7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGNvbnNpZGVyIHBhcmVudCB0ZW1wbGF0ZSBub3dcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnRpYWxzLnN0YWNrVGV4dCkgcGFydGlhbHMuc3RhY2tUZXh0ID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gcGFydGlhbC5zdWJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFydGlhbHMuc3RhY2tUZXh0W2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxzLnN0YWNrVGV4dFtrZXldID0gKHRoaXMuYWN0aXZlU3ViICE9PSB1bmRlZmluZWQgJiYgcGFydGlhbHMuc3RhY2tUZXh0W3RoaXMuYWN0aXZlU3ViXSkgPyBwYXJ0aWFscy5zdGFja1RleHRbdGhpcy5hY3RpdmVTdWJdIDogdGhpcy50ZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gY3JlYXRlU3BlY2lhbGl6ZWRQYXJ0aWFsKHRlbXBsYXRlLCBwYXJ0aWFsLnN1YnMsIHBhcnRpYWwucGFydGlhbHMsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2tTdWJzLCB0aGlzLnN0YWNrUGFydGlhbHMsIHBhcnRpYWxzLnN0YWNrVGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhcnRpYWxzW3N5bWJvbF0uaW5zdGFuY2UgPSB0ZW1wbGF0ZTtcblxuICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHRyaWVzIHRvIGZpbmQgYSBwYXJ0aWFsIGluIHRoZSBjdXJyZW50IHNjb3BlIGFuZCByZW5kZXIgaXRcbiAgICAgICAgcnA6IGZ1bmN0aW9uKHN5bWJvbCwgY29udGV4dCwgcGFydGlhbHMsIGluZGVudCkge1xuICAgICAgICAgICAgdmFyIHBhcnRpYWwgPSB0aGlzLmVwKHN5bWJvbCwgcGFydGlhbHMpO1xuICAgICAgICAgICAgaWYgKCFwYXJ0aWFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcGFydGlhbC5yaShjb250ZXh0LCBwYXJ0aWFscywgaW5kZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyByZW5kZXIgYSBzZWN0aW9uXG4gICAgICAgIHJzOiBmdW5jdGlvbihjb250ZXh0LCBwYXJ0aWFscywgc2VjdGlvbikge1xuICAgICAgICAgICAgdmFyIHRhaWwgPSBjb250ZXh0W2NvbnRleHQubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgIGlmICghaXNBcnJheSh0YWlsKSkge1xuICAgICAgICAgICAgICAgIHNlY3Rpb24oY29udGV4dCwgcGFydGlhbHMsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWlsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5wdXNoKHRhaWxbaV0pO1xuICAgICAgICAgICAgICAgIHNlY3Rpb24oY29udGV4dCwgcGFydGlhbHMsIHRoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gbWF5YmUgc3RhcnQgYSBzZWN0aW9uXG4gICAgICAgIHM6IGZ1bmN0aW9uKHZhbCwgY3R4LCBwYXJ0aWFscywgaW52ZXJ0ZWQsIHN0YXJ0LCBlbmQsIHRhZ3MpIHtcbiAgICAgICAgICAgIHZhciBwYXNzO1xuXG4gICAgICAgICAgICBpZiAoaXNBcnJheSh2YWwpICYmIHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSB0aGlzLm1zKHZhbCwgY3R4LCBwYXJ0aWFscywgaW52ZXJ0ZWQsIHN0YXJ0LCBlbmQsIHRhZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXNzID0gISF2YWw7XG5cbiAgICAgICAgICAgIGlmICghaW52ZXJ0ZWQgJiYgcGFzcyAmJiBjdHgpIHtcbiAgICAgICAgICAgICAgICBjdHgucHVzaCgodHlwZW9mIHZhbCA9PSAnb2JqZWN0JykgPyB2YWwgOiBjdHhbY3R4Lmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBhc3M7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gZmluZCB2YWx1ZXMgd2l0aCBkb3R0ZWQgbmFtZXNcbiAgICAgICAgZDogZnVuY3Rpb24oa2V5LCBjdHgsIHBhcnRpYWxzLCByZXR1cm5Gb3VuZCkge1xuICAgICAgICAgICAgdmFyIGZvdW5kLFxuICAgICAgICAgICAgICAgIG5hbWVzID0ga2V5LnNwbGl0KCcuJyksXG4gICAgICAgICAgICAgICAgdmFsID0gdGhpcy5mKG5hbWVzWzBdLCBjdHgsIHBhcnRpYWxzLCByZXR1cm5Gb3VuZCksXG4gICAgICAgICAgICAgICAgZG9Nb2RlbEdldCA9IHRoaXMub3B0aW9ucy5tb2RlbEdldCxcbiAgICAgICAgICAgICAgICBjeCA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChrZXkgPT09ICcuJyAmJiBpc0FycmF5KGN0eFtjdHgubGVuZ3RoIC0gMl0pKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gY3R4W2N0eC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGZpbmRJblNjb3BlKG5hbWVzW2ldLCB2YWwsIGRvTW9kZWxHZXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3ggPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBmb3VuZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmV0dXJuRm91bmQgJiYgIXZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFyZXR1cm5Gb3VuZCAmJiB0eXBlb2YgdmFsID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjdHgucHVzaChjeCk7XG4gICAgICAgICAgICAgICAgdmFsID0gdGhpcy5tdih2YWwsIGN0eCwgcGFydGlhbHMpO1xuICAgICAgICAgICAgICAgIGN0eC5wb3AoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBmaW5kIHZhbHVlcyB3aXRoIG5vcm1hbCBuYW1lc1xuICAgICAgICBmOiBmdW5jdGlvbihrZXksIGN0eCwgcGFydGlhbHMsIHJldHVybkZvdW5kKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgdiA9IG51bGwsXG4gICAgICAgICAgICAgICAgZm91bmQgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBkb01vZGVsR2V0ID0gdGhpcy5vcHRpb25zLm1vZGVsR2V0O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gY3R4Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdiA9IGN0eFtpXTtcbiAgICAgICAgICAgICAgICB2YWwgPSBmaW5kSW5TY29wZShrZXksIHYsIGRvTW9kZWxHZXQpO1xuICAgICAgICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAocmV0dXJuRm91bmQpID8gZmFsc2UgOiBcIlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXJldHVybkZvdW5kICYmIHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHZhbCA9IHRoaXMubXYodmFsLCBjdHgsIHBhcnRpYWxzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBoaWdoZXIgb3JkZXIgdGVtcGxhdGVzXG4gICAgICAgIGxzOiBmdW5jdGlvbihmdW5jLCBjeCwgcGFydGlhbHMsIHRleHQsIHRhZ3MpIHtcbiAgICAgICAgICAgIHZhciBvbGRUYWdzID0gdGhpcy5vcHRpb25zLmRlbGltaXRlcnM7XG5cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kZWxpbWl0ZXJzID0gdGFncztcbiAgICAgICAgICAgIHRoaXMuYih0aGlzLmN0KGNvZXJjZVRvU3RyaW5nKGZ1bmMuY2FsbChjeCwgdGV4dCkpLCBjeCwgcGFydGlhbHMpKTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kZWxpbWl0ZXJzID0gb2xkVGFncztcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGNvbXBpbGUgdGV4dFxuICAgICAgICBjdDogZnVuY3Rpb24odGV4dCwgY3gsIHBhcnRpYWxzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRpc2FibGVMYW1iZGEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xhbWJkYSBmZWF0dXJlcyBkaXNhYmxlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmMuY29tcGlsZSh0ZXh0LCB0aGlzLm9wdGlvbnMpLnJlbmRlcihjeCwgcGFydGlhbHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHRlbXBsYXRlIHJlc3VsdCBidWZmZXJpbmdcbiAgICAgICAgYjogZnVuY3Rpb24ocykgeyB0aGlzLmJ1ZiArPSBzOyB9LFxuXG4gICAgICAgIGZsOiBmdW5jdGlvbigpIHsgdmFyIHIgPSB0aGlzLmJ1ZjsgdGhpcy5idWYgPSAnJzsgcmV0dXJuIHI7IH0sXG5cbiAgICAgICAgLy8gbWV0aG9kIHJlcGxhY2Ugc2VjdGlvblxuICAgICAgICBtczogZnVuY3Rpb24oZnVuYywgY3R4LCBwYXJ0aWFscywgaW52ZXJ0ZWQsIHN0YXJ0LCBlbmQsIHRhZ3MpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0U291cmNlLFxuICAgICAgICAgICAgICAgIGN4ID0gY3R4W2N0eC5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmNhbGwoY3gpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGludmVydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRTb3VyY2UgPSAodGhpcy5hY3RpdmVTdWIgJiYgdGhpcy5zdWJzVGV4dCAmJiB0aGlzLnN1YnNUZXh0W3RoaXMuYWN0aXZlU3ViXSkgPyB0aGlzLnN1YnNUZXh0W3RoaXMuYWN0aXZlU3ViXSA6IHRoaXMudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubHMocmVzdWx0LCBjeCwgcGFydGlhbHMsIHRleHRTb3VyY2Uuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpLCB0YWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gbWV0aG9kIHJlcGxhY2UgdmFyaWFibGVcbiAgICAgICAgbXY6IGZ1bmN0aW9uKGZ1bmMsIGN0eCwgcGFydGlhbHMpIHtcbiAgICAgICAgICAgIHZhciBjeCA9IGN0eFtjdHgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5jYWxsKGN4KTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmN0KGNvZXJjZVRvU3RyaW5nKHJlc3VsdC5jYWxsKGN4KSksIGN4LCBwYXJ0aWFscyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3ViOiBmdW5jdGlvbihuYW1lLCBjb250ZXh0LCBwYXJ0aWFscywgaW5kZW50KSB7XG4gICAgICAgICAgICB2YXIgZiA9IHRoaXMuc3Vic1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVTdWIgPSBuYW1lO1xuICAgICAgICAgICAgICAgIGYoY29udGV4dCwgcGFydGlhbHMsIHRoaXMsIGluZGVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVTdWIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8vRmluZCBhIGtleSBpbiBhbiBvYmplY3RcbiAgICBmdW5jdGlvbiBmaW5kSW5TY29wZShrZXksIHNjb3BlLCBkb01vZGVsR2V0KSB7XG4gICAgICAgIHZhciB2YWw7XG5cbiAgICAgICAgaWYgKHNjb3BlICYmIHR5cGVvZiBzY29wZSA9PSAnb2JqZWN0Jykge1xuXG4gICAgICAgICAgICBpZiAoc2NvcGVba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gc2NvcGVba2V5XTtcblxuICAgICAgICAgICAgICAgIC8vIHRyeSBsb29rdXAgd2l0aCBnZXQgZm9yIGJhY2tib25lIG9yIHNpbWlsYXIgbW9kZWwgZGF0YVxuICAgICAgICAgICAgfSBlbHNlIGlmIChkb01vZGVsR2V0ICYmIHNjb3BlLmdldCAmJiB0eXBlb2Ygc2NvcGUuZ2V0ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBzY29wZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlU3BlY2lhbGl6ZWRQYXJ0aWFsKGluc3RhbmNlLCBzdWJzLCBwYXJ0aWFscywgc3RhY2tTdWJzLCBzdGFja1BhcnRpYWxzLCBzdGFja1RleHQpIHtcbiAgICAgICAgZnVuY3Rpb24gUGFydGlhbFRlbXBsYXRlKCkge307XG4gICAgICAgIFBhcnRpYWxUZW1wbGF0ZS5wcm90b3R5cGUgPSBpbnN0YW5jZTtcbiAgICAgICAgZnVuY3Rpb24gU3Vic3RpdHV0aW9ucygpIHt9O1xuICAgICAgICBTdWJzdGl0dXRpb25zLnByb3RvdHlwZSA9IGluc3RhbmNlLnN1YnM7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIHZhciBwYXJ0aWFsID0gbmV3IFBhcnRpYWxUZW1wbGF0ZSgpO1xuICAgICAgICBwYXJ0aWFsLnN1YnMgPSBuZXcgU3Vic3RpdHV0aW9ucygpO1xuICAgICAgICBwYXJ0aWFsLnN1YnNUZXh0ID0ge307ICAvL2hlaGUuIHN1YnN0ZXh0LlxuICAgICAgICBwYXJ0aWFsLmJ1ZiA9ICcnO1xuXG4gICAgICAgIHN0YWNrU3VicyA9IHN0YWNrU3VicyB8fCB7fTtcbiAgICAgICAgcGFydGlhbC5zdGFja1N1YnMgPSBzdGFja1N1YnM7XG4gICAgICAgIHBhcnRpYWwuc3Vic1RleHQgPSBzdGFja1RleHQ7XG4gICAgICAgIGZvciAoa2V5IGluIHN1YnMpIHtcbiAgICAgICAgICAgIGlmICghc3RhY2tTdWJzW2tleV0pIHN0YWNrU3Vic1trZXldID0gc3Vic1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoa2V5IGluIHN0YWNrU3Vicykge1xuICAgICAgICAgICAgcGFydGlhbC5zdWJzW2tleV0gPSBzdGFja1N1YnNba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YWNrUGFydGlhbHMgPSBzdGFja1BhcnRpYWxzIHx8IHt9O1xuICAgICAgICBwYXJ0aWFsLnN0YWNrUGFydGlhbHMgPSBzdGFja1BhcnRpYWxzO1xuICAgICAgICBmb3IgKGtleSBpbiBwYXJ0aWFscykge1xuICAgICAgICAgICAgaWYgKCFzdGFja1BhcnRpYWxzW2tleV0pIHN0YWNrUGFydGlhbHNba2V5XSA9IHBhcnRpYWxzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChrZXkgaW4gc3RhY2tQYXJ0aWFscykge1xuICAgICAgICAgICAgcGFydGlhbC5wYXJ0aWFsc1trZXldID0gc3RhY2tQYXJ0aWFsc1trZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnRpYWw7XG4gICAgfVxuXG4gICAgdmFyIHJBbXAgPSAvJi9nLFxuICAgICAgICByTHQgPSAvPC9nLFxuICAgICAgICByR3QgPSAvPi9nLFxuICAgICAgICByQXBvcyA9IC9cXCcvZyxcbiAgICAgICAgclF1b3QgPSAvXFxcIi9nLFxuICAgICAgICBoQ2hhcnMgPSAvWyY8PlxcXCJcXCddLztcblxuICAgIGZ1bmN0aW9uIGNvZXJjZVRvU3RyaW5nKHZhbCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKCh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpID8gJycgOiB2YWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhvZ2FuRXNjYXBlKHN0cikge1xuICAgICAgICBzdHIgPSBjb2VyY2VUb1N0cmluZyhzdHIpO1xuICAgICAgICByZXR1cm4gaENoYXJzLnRlc3Qoc3RyKSA/XG4gICAgICAgICAgICBzdHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZShyQW1wLCAnJmFtcDsnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKHJMdCwgJyZsdDsnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKHJHdCwgJyZndDsnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKHJBcG9zLCAnJiMzOTsnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKHJRdW90LCAnJnF1b3Q7JykgOlxuICAgICAgICAgICAgc3RyO1xuICAgIH1cblxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgICAgICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogSG9nYW4pO1xuXG5cblxuKGZ1bmN0aW9uIChIb2dhbikge1xuICAgIC8vIFNldHVwIHJlZ2V4ICBhc3NpZ25tZW50c1xuICAgIC8vIHJlbW92ZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBNdXN0YWNoZSBzcGVjXG4gICAgdmFyIHJJc1doaXRlc3BhY2UgPSAvXFxTLyxcbiAgICAgICAgclF1b3QgPSAvXFxcIi9nLFxuICAgICAgICByTmV3bGluZSA9ICAvXFxuL2csXG4gICAgICAgIHJDciA9IC9cXHIvZyxcbiAgICAgICAgclNsYXNoID0gL1xcXFwvZyxcbiAgICAgICAgckxpbmVTZXAgPSAvXFx1MjAyOC8sXG4gICAgICAgIHJQYXJhZ3JhcGhTZXAgPSAvXFx1MjAyOS87XG5cbiAgICBIb2dhbi50YWdzID0ge1xuICAgICAgICAnIyc6IDEsICdeJzogMiwgJzwnOiAzLCAnJCc6IDQsXG4gICAgICAgICcvJzogNSwgJyEnOiA2LCAnPic6IDcsICc9JzogOCwgJ192JzogOSxcbiAgICAgICAgJ3snOiAxMCwgJyYnOiAxMSwgJ190JzogMTJcbiAgICB9O1xuXG4gICAgSG9nYW4uc2NhbiA9IGZ1bmN0aW9uIHNjYW4odGV4dCwgZGVsaW1pdGVycykge1xuICAgICAgICB2YXIgbGVuID0gdGV4dC5sZW5ndGgsXG4gICAgICAgICAgICBJTl9URVhUID0gMCxcbiAgICAgICAgICAgIElOX1RBR19UWVBFID0gMSxcbiAgICAgICAgICAgIElOX1RBRyA9IDIsXG4gICAgICAgICAgICBzdGF0ZSA9IElOX1RFWFQsXG4gICAgICAgICAgICB0YWdUeXBlID0gbnVsbCxcbiAgICAgICAgICAgIHRhZyA9IG51bGwsXG4gICAgICAgICAgICBidWYgPSAnJyxcbiAgICAgICAgICAgIHRva2VucyA9IFtdLFxuICAgICAgICAgICAgc2VlblRhZyA9IGZhbHNlLFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBsaW5lU3RhcnQgPSAwLFxuICAgICAgICAgICAgb3RhZyA9ICd7eycsXG4gICAgICAgICAgICBjdGFnID0gJ319JztcblxuICAgICAgICBmdW5jdGlvbiBhZGRCdWYoKSB7XG4gICAgICAgICAgICBpZiAoYnVmLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7dGFnOiAnX3QnLCB0ZXh0OiBuZXcgU3RyaW5nKGJ1Zil9KTtcbiAgICAgICAgICAgICAgICBidWYgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGxpbmVJc1doaXRlc3BhY2UoKSB7XG4gICAgICAgICAgICB2YXIgaXNBbGxXaGl0ZXNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBsaW5lU3RhcnQ7IGogPCB0b2tlbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpc0FsbFdoaXRlc3BhY2UgPVxuICAgICAgICAgICAgICAgICAgICAoSG9nYW4udGFnc1t0b2tlbnNbal0udGFnXSA8IEhvZ2FuLnRhZ3NbJ192J10pIHx8XG4gICAgICAgICAgICAgICAgICAgICh0b2tlbnNbal0udGFnID09ICdfdCcgJiYgdG9rZW5zW2pdLnRleHQubWF0Y2gocklzV2hpdGVzcGFjZSkgPT09IG51bGwpO1xuICAgICAgICAgICAgICAgIGlmICghaXNBbGxXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpc0FsbFdoaXRlc3BhY2U7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmaWx0ZXJMaW5lKGhhdmVTZWVuVGFnLCBub05ld0xpbmUpIHtcbiAgICAgICAgICAgIGFkZEJ1ZigpO1xuXG4gICAgICAgICAgICBpZiAoaGF2ZVNlZW5UYWcgJiYgbGluZUlzV2hpdGVzcGFjZSgpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGxpbmVTdGFydCwgbmV4dDsgaiA8IHRva2Vucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5zW2pdLnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobmV4dCA9IHRva2Vuc1tqKzFdKSAmJiBuZXh0LnRhZyA9PSAnPicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgaW5kZW50IHRvIHRva2VuIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5pbmRlbnQgPSB0b2tlbnNbal0udGV4dC50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghbm9OZXdMaW5lKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe3RhZzonXFxuJ30pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWVuVGFnID0gZmFsc2U7XG4gICAgICAgICAgICBsaW5lU3RhcnQgPSB0b2tlbnMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2hhbmdlRGVsaW1pdGVycyh0ZXh0LCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGNsb3NlID0gJz0nICsgY3RhZyxcbiAgICAgICAgICAgICAgICBjbG9zZUluZGV4ID0gdGV4dC5pbmRleE9mKGNsb3NlLCBpbmRleCksXG4gICAgICAgICAgICAgICAgZGVsaW1pdGVycyA9IHRyaW0oXG4gICAgICAgICAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKHRleHQuaW5kZXhPZignPScsIGluZGV4KSArIDEsIGNsb3NlSW5kZXgpXG4gICAgICAgICAgICAgICAgKS5zcGxpdCgnICcpO1xuXG4gICAgICAgICAgICBvdGFnID0gZGVsaW1pdGVyc1swXTtcbiAgICAgICAgICAgIGN0YWcgPSBkZWxpbWl0ZXJzW2RlbGltaXRlcnMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgIHJldHVybiBjbG9zZUluZGV4ICsgY2xvc2UubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWxpbWl0ZXJzKSB7XG4gICAgICAgICAgICBkZWxpbWl0ZXJzID0gZGVsaW1pdGVycy5zcGxpdCgnICcpO1xuICAgICAgICAgICAgb3RhZyA9IGRlbGltaXRlcnNbMF07XG4gICAgICAgICAgICBjdGFnID0gZGVsaW1pdGVyc1sxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKHN0YXRlID09IElOX1RFWFQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFnQ2hhbmdlKG90YWcsIHRleHQsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgYWRkQnVmKCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gSU5fVEFHX1RZUEU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQuY2hhckF0KGkpID09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJMaW5lKHNlZW5UYWcpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmICs9IHRleHQuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PSBJTl9UQUdfVFlQRSkge1xuICAgICAgICAgICAgICAgIGkgKz0gb3RhZy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHRhZyA9IEhvZ2FuLnRhZ3NbdGV4dC5jaGFyQXQoaSArIDEpXTtcbiAgICAgICAgICAgICAgICB0YWdUeXBlID0gdGFnID8gdGV4dC5jaGFyQXQoaSArIDEpIDogJ192JztcbiAgICAgICAgICAgICAgICBpZiAodGFnVHlwZSA9PSAnPScpIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGNoYW5nZURlbGltaXRlcnModGV4dCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gSU5fVEVYVDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBJTl9UQUc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlZW5UYWcgPSBpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGFnQ2hhbmdlKGN0YWcsIHRleHQsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0YWc6IHRhZ1R5cGUsIG46IHRyaW0oYnVmKSwgb3RhZzogb3RhZywgY3RhZzogY3RhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGk6ICh0YWdUeXBlID09ICcvJykgPyBzZWVuVGFnIC0gb3RhZy5sZW5ndGggOiBpICsgY3RhZy5sZW5ndGh9KTtcbiAgICAgICAgICAgICAgICAgICAgYnVmID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gY3RhZy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IElOX1RFWFQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdUeXBlID09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0YWcgPT0gJ319Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW5UcmlwbGVTdGFjaGUodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidWYgKz0gdGV4dC5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZmlsdGVyTGluZShzZWVuVGFnLCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFuVHJpcGxlU3RhY2hlKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbi5uLnN1YnN0cih0b2tlbi5uLmxlbmd0aCAtIDEpID09PSAnfScpIHtcbiAgICAgICAgICAgIHRva2VuLm4gPSB0b2tlbi5uLnN1YnN0cmluZygwLCB0b2tlbi5uLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJpbShzKSB7XG4gICAgICAgIGlmIChzLnRyaW0pIHtcbiAgICAgICAgICAgIHJldHVybiBzLnRyaW0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0YWdDaGFuZ2UodGFnLCB0ZXh0LCBpbmRleCkge1xuICAgICAgICBpZiAodGV4dC5jaGFyQXQoaW5kZXgpICE9IHRhZy5jaGFyQXQoMCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gdGFnLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRleHQuY2hhckF0KGluZGV4ICsgaSkgIT0gdGFnLmNoYXJBdChpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIHRoZSB0YWdzIGFsbG93ZWQgaW5zaWRlIHN1cGVyIHRlbXBsYXRlc1xuICAgIHZhciBhbGxvd2VkSW5TdXBlciA9IHsnX3QnOiB0cnVlLCAnXFxuJzogdHJ1ZSwgJyQnOiB0cnVlLCAnLyc6IHRydWV9O1xuXG4gICAgZnVuY3Rpb24gYnVpbGRUcmVlKHRva2Vucywga2luZCwgc3RhY2ssIGN1c3RvbVRhZ3MpIHtcbiAgICAgICAgdmFyIGluc3RydWN0aW9ucyA9IFtdLFxuICAgICAgICAgICAgb3BlbmVyID0gbnVsbCxcbiAgICAgICAgICAgIHRhaWwgPSBudWxsLFxuICAgICAgICAgICAgdG9rZW4gPSBudWxsO1xuXG4gICAgICAgIHRhaWwgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcblxuICAgICAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgIGlmICh0YWlsICYmIHRhaWwudGFnID09ICc8JyAmJiAhKHRva2VuLnRhZyBpbiBhbGxvd2VkSW5TdXBlcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgY29udGVudCBpbiA8IHN1cGVyIHRhZy4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKEhvZ2FuLnRhZ3NbdG9rZW4udGFnXSA8PSBIb2dhbi50YWdzWyckJ10gfHwgaXNPcGVuZXIodG9rZW4sIGN1c3RvbVRhZ3MpKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgdG9rZW4ubm9kZXMgPSBidWlsZFRyZWUodG9rZW5zLCB0b2tlbi50YWcsIHN0YWNrLCBjdXN0b21UYWdzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4udGFnID09ICcvJykge1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbG9zaW5nIHRhZyB3aXRob3V0IG9wZW5lcjogLycgKyB0b2tlbi5uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3BlbmVyID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLm4gIT0gb3BlbmVyLm4gJiYgIWlzQ2xvc2VyKHRva2VuLm4sIG9wZW5lci5uLCBjdXN0b21UYWdzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lc3RpbmcgZXJyb3I6ICcgKyBvcGVuZXIubiArICcgdnMuICcgKyB0b2tlbi5uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3BlbmVyLmVuZCA9IHRva2VuLmk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RydWN0aW9ucztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4udGFnID09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4ubGFzdCA9ICh0b2tlbnMubGVuZ3RoID09IDApIHx8ICh0b2tlbnNbMF0udGFnID09ICdcXG4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBjbG9zaW5nIHRhZzogJyArIHN0YWNrLnBvcCgpLm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9ucztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09wZW5lcih0b2tlbiwgdGFncykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRhZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGFnc1tpXS5vID09IHRva2VuLm4pIHtcbiAgICAgICAgICAgICAgICB0b2tlbi50YWcgPSAnIyc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0Nsb3NlcihjbG9zZSwgb3BlbiwgdGFncykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRhZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGFnc1tpXS5jID09IGNsb3NlICYmIHRhZ3NbaV0ubyA9PSBvcGVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHJpbmdpZnlTdWJzdGl0dXRpb25zKG9iaikge1xuICAgICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaXRlbXMucHVzaCgnXCInICsgZXNjKGtleSkgKyAnXCI6IGZ1bmN0aW9uKGMscCx0LGkpIHsnICsgb2JqW2tleV0gKyAnfScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcInsgXCIgKyBpdGVtcy5qb2luKFwiLFwiKSArIFwiIH1cIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHJpbmdpZnlQYXJ0aWFscyhjb2RlT2JqKSB7XG4gICAgICAgIHZhciBwYXJ0aWFscyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY29kZU9iai5wYXJ0aWFscykge1xuICAgICAgICAgICAgcGFydGlhbHMucHVzaCgnXCInICsgZXNjKGtleSkgKyAnXCI6e25hbWU6XCInICsgZXNjKGNvZGVPYmoucGFydGlhbHNba2V5XS5uYW1lKSArICdcIiwgJyArIHN0cmluZ2lmeVBhcnRpYWxzKGNvZGVPYmoucGFydGlhbHNba2V5XSkgKyBcIn1cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwicGFydGlhbHM6IHtcIiArIHBhcnRpYWxzLmpvaW4oXCIsXCIpICsgXCJ9LCBzdWJzOiBcIiArIHN0cmluZ2lmeVN1YnN0aXR1dGlvbnMoY29kZU9iai5zdWJzKTtcbiAgICB9XG5cbiAgICBIb2dhbi5zdHJpbmdpZnkgPSBmdW5jdGlvbihjb2RlT2JqLCB0ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBcIntjb2RlOiBmdW5jdGlvbiAoYyxwLGkpIHsgXCIgKyBIb2dhbi53cmFwTWFpbihjb2RlT2JqLmNvZGUpICsgXCIgfSxcIiArIHN0cmluZ2lmeVBhcnRpYWxzKGNvZGVPYmopICsgIFwifVwiO1xuICAgIH1cblxuICAgIHZhciBzZXJpYWxObyA9IDA7XG4gICAgSG9nYW4uZ2VuZXJhdGUgPSBmdW5jdGlvbih0cmVlLCB0ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIHNlcmlhbE5vID0gMDtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB7IGNvZGU6ICcnLCBzdWJzOiB7fSwgcGFydGlhbHM6IHt9IH07XG4gICAgICAgIEhvZ2FuLndhbGsodHJlZSwgY29udGV4dCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXNTdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZ2lmeShjb250ZXh0LCB0ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm1ha2VUZW1wbGF0ZShjb250ZXh0LCB0ZXh0LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBIb2dhbi53cmFwTWFpbiA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAgICAgcmV0dXJuICd2YXIgdD10aGlzO3QuYihpPWl8fFwiXCIpOycgKyBjb2RlICsgJ3JldHVybiB0LmZsKCk7JztcbiAgICB9XG5cbiAgICBIb2dhbi50ZW1wbGF0ZSA9IEhvZ2FuLlRlbXBsYXRlO1xuXG4gICAgSG9nYW4ubWFrZVRlbXBsYXRlID0gZnVuY3Rpb24oY29kZU9iaiwgdGV4dCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLm1ha2VQYXJ0aWFscyhjb2RlT2JqKTtcbiAgICAgICAgdGVtcGxhdGUuY29kZSA9IG5ldyBGdW5jdGlvbignYycsICdwJywgJ2knLCB0aGlzLndyYXBNYWluKGNvZGVPYmouY29kZSkpO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMudGVtcGxhdGUodGVtcGxhdGUsIHRleHQsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIEhvZ2FuLm1ha2VQYXJ0aWFscyA9IGZ1bmN0aW9uKGNvZGVPYmopIHtcbiAgICAgICAgdmFyIGtleSwgdGVtcGxhdGUgPSB7c3Viczoge30sIHBhcnRpYWxzOiBjb2RlT2JqLnBhcnRpYWxzLCBuYW1lOiBjb2RlT2JqLm5hbWV9O1xuICAgICAgICBmb3IgKGtleSBpbiB0ZW1wbGF0ZS5wYXJ0aWFscykge1xuICAgICAgICAgICAgdGVtcGxhdGUucGFydGlhbHNba2V5XSA9IHRoaXMubWFrZVBhcnRpYWxzKHRlbXBsYXRlLnBhcnRpYWxzW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoa2V5IGluIGNvZGVPYmouc3Vicykge1xuICAgICAgICAgICAgdGVtcGxhdGUuc3Vic1trZXldID0gbmV3IEZ1bmN0aW9uKCdjJywgJ3AnLCAndCcsICdpJywgY29kZU9iai5zdWJzW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc2Mocykge1xuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKHJTbGFzaCwgJ1xcXFxcXFxcJylcbiAgICAgICAgICAgIC5yZXBsYWNlKHJRdW90LCAnXFxcXFxcXCInKVxuICAgICAgICAgICAgLnJlcGxhY2Uock5ld2xpbmUsICdcXFxcbicpXG4gICAgICAgICAgICAucmVwbGFjZShyQ3IsICdcXFxccicpXG4gICAgICAgICAgICAucmVwbGFjZShyTGluZVNlcCwgJ1xcXFx1MjAyOCcpXG4gICAgICAgICAgICAucmVwbGFjZShyUGFyYWdyYXBoU2VwLCAnXFxcXHUyMDI5Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hvb3NlTWV0aG9kKHMpIHtcbiAgICAgICAgcmV0dXJuICh+cy5pbmRleE9mKCcuJykpID8gJ2QnIDogJ2YnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhcnRpYWwobm9kZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgcHJlZml4ID0gXCI8XCIgKyAoY29udGV4dC5wcmVmaXggfHwgXCJcIik7XG4gICAgICAgIHZhciBzeW0gPSBwcmVmaXggKyBub2RlLm4gKyBzZXJpYWxObysrO1xuICAgICAgICBjb250ZXh0LnBhcnRpYWxzW3N5bV0gPSB7bmFtZTogbm9kZS5uLCBwYXJ0aWFsczoge319O1xuICAgICAgICBjb250ZXh0LmNvZGUgKz0gJ3QuYih0LnJwKFwiJyArICBlc2Moc3ltKSArICdcIixjLHAsXCInICsgKG5vZGUuaW5kZW50IHx8ICcnKSArICdcIikpOyc7XG4gICAgICAgIHJldHVybiBzeW07XG4gICAgfVxuXG4gICAgSG9nYW4uY29kZWdlbiA9IHtcbiAgICAgICAgJyMnOiBmdW5jdGlvbihub2RlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0LmNvZGUgKz0gJ2lmKHQucyh0LicgKyBjaG9vc2VNZXRob2Qobm9kZS5uKSArICcoXCInICsgZXNjKG5vZGUubikgKyAnXCIsYyxwLDEpLCcgK1xuICAgICAgICAgICAgJ2MscCwwLCcgKyBub2RlLmkgKyAnLCcgKyBub2RlLmVuZCArICcsXCInICsgbm9kZS5vdGFnICsgXCIgXCIgKyBub2RlLmN0YWcgKyAnXCIpKXsnICtcbiAgICAgICAgICAgICd0LnJzKGMscCwnICsgJ2Z1bmN0aW9uKGMscCx0KXsnO1xuICAgICAgICAgICAgSG9nYW4ud2Fsayhub2RlLm5vZGVzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnRleHQuY29kZSArPSAnfSk7Yy5wb3AoKTt9JztcbiAgICAgICAgfSxcblxuICAgICAgICAnXic6IGZ1bmN0aW9uKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnRleHQuY29kZSArPSAnaWYoIXQucyh0LicgKyBjaG9vc2VNZXRob2Qobm9kZS5uKSArICcoXCInICsgZXNjKG5vZGUubikgKyAnXCIsYyxwLDEpLGMscCwxLDAsMCxcIlwiKSl7JztcbiAgICAgICAgICAgIEhvZ2FuLndhbGsobm9kZS5ub2RlcywgY29udGV4dCk7XG4gICAgICAgICAgICBjb250ZXh0LmNvZGUgKz0gJ307JztcbiAgICAgICAgfSxcblxuICAgICAgICAnPic6IGNyZWF0ZVBhcnRpYWwsXG4gICAgICAgICc8JzogZnVuY3Rpb24obm9kZSwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGN0eCA9IHtwYXJ0aWFsczoge30sIGNvZGU6ICcnLCBzdWJzOiB7fSwgaW5QYXJ0aWFsOiB0cnVlfTtcbiAgICAgICAgICAgIEhvZ2FuLndhbGsobm9kZS5ub2RlcywgY3R4KTtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IGNvbnRleHQucGFydGlhbHNbY3JlYXRlUGFydGlhbChub2RlLCBjb250ZXh0KV07XG4gICAgICAgICAgICB0ZW1wbGF0ZS5zdWJzID0gY3R4LnN1YnM7XG4gICAgICAgICAgICB0ZW1wbGF0ZS5wYXJ0aWFscyA9IGN0eC5wYXJ0aWFscztcbiAgICAgICAgfSxcblxuICAgICAgICAnJCc6IGZ1bmN0aW9uKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSB7c3Viczoge30sIGNvZGU6ICcnLCBwYXJ0aWFsczogY29udGV4dC5wYXJ0aWFscywgcHJlZml4OiBub2RlLm59O1xuICAgICAgICAgICAgSG9nYW4ud2Fsayhub2RlLm5vZGVzLCBjdHgpO1xuICAgICAgICAgICAgY29udGV4dC5zdWJzW25vZGUubl0gPSBjdHguY29kZTtcbiAgICAgICAgICAgIGlmICghY29udGV4dC5pblBhcnRpYWwpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNvZGUgKz0gJ3Quc3ViKFwiJyArIGVzYyhub2RlLm4pICsgJ1wiLGMscCxpKTsnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgICdcXG4nOiBmdW5jdGlvbihub2RlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0LmNvZGUgKz0gd3JpdGUoJ1wiXFxcXG5cIicgKyAobm9kZS5sYXN0ID8gJycgOiAnICsgaScpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAnX3YnOiBmdW5jdGlvbihub2RlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0LmNvZGUgKz0gJ3QuYih0LnYodC4nICsgY2hvb3NlTWV0aG9kKG5vZGUubikgKyAnKFwiJyArIGVzYyhub2RlLm4pICsgJ1wiLGMscCwwKSkpOyc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgJ190JzogZnVuY3Rpb24obm9kZSwgY29udGV4dCkge1xuICAgICAgICAgICAgY29udGV4dC5jb2RlICs9IHdyaXRlKCdcIicgKyBlc2Mobm9kZS50ZXh0KSArICdcIicpO1xuICAgICAgICB9LFxuXG4gICAgICAgICd7JzogdHJpcGxlU3RhY2hlLFxuXG4gICAgICAgICcmJzogdHJpcGxlU3RhY2hlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJpcGxlU3RhY2hlKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC5jb2RlICs9ICd0LmIodC50KHQuJyArIGNob29zZU1ldGhvZChub2RlLm4pICsgJyhcIicgKyBlc2Mobm9kZS5uKSArICdcIixjLHAsMCkpKTsnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyaXRlKHMpIHtcbiAgICAgICAgcmV0dXJuICd0LmIoJyArIHMgKyAnKTsnO1xuICAgIH1cblxuICAgIEhvZ2FuLndhbGsgPSBmdW5jdGlvbihub2RlbGlzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgZnVuYztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGZ1bmMgPSBIb2dhbi5jb2RlZ2VuW25vZGVsaXN0W2ldLnRhZ107XG4gICAgICAgICAgICBmdW5jICYmIGZ1bmMobm9kZWxpc3RbaV0sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cblxuICAgIEhvZ2FuLnBhcnNlID0gZnVuY3Rpb24odG9rZW5zLCB0ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICByZXR1cm4gYnVpbGRUcmVlKHRva2VucywgJycsIFtdLCBvcHRpb25zLnNlY3Rpb25UYWdzIHx8IFtdKTtcbiAgICB9XG5cbiAgICBIb2dhbi5jYWNoZSA9IHt9O1xuXG4gICAgSG9nYW4uY2FjaGVLZXkgPSBmdW5jdGlvbih0ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBbdGV4dCwgISFvcHRpb25zLmFzU3RyaW5nLCAhIW9wdGlvbnMuZGlzYWJsZUxhbWJkYSwgb3B0aW9ucy5kZWxpbWl0ZXJzLCAhIW9wdGlvbnMubW9kZWxHZXRdLmpvaW4oJ3x8Jyk7XG4gICAgfVxuXG4gICAgSG9nYW4uY29tcGlsZSA9IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciBrZXkgPSBIb2dhbi5jYWNoZUtleSh0ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gdGhpcy5jYWNoZVtrZXldO1xuXG4gICAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgdmFyIHBhcnRpYWxzID0gdGVtcGxhdGUucGFydGlhbHM7XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHBhcnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBhcnRpYWxzW25hbWVdLmluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGVtcGxhdGUgPSB0aGlzLmdlbmVyYXRlKHRoaXMucGFyc2UodGhpcy5zY2FuKHRleHQsIG9wdGlvbnMuZGVsaW1pdGVycyksIHRleHQsIG9wdGlvbnMpLCB0ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVba2V5XSA9IHRlbXBsYXRlO1xuICAgIH1cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiBIb2dhbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcmVzb3VyY2VzL2Fzc2V0cy9qcy92ZW5kb3IvaG9nYW4uanMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! jQuery v1.10.2 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license\n//@ sourceMappingURL=jquery-1.10.2.min.map\n*/\n(function(e,t){var n,r,i=typeof t,o=e.location,a=e.document,s=a.documentElement,l=e.jQuery,u=e.$,c={},p=[],f=\"1.10.2\",d=p.concat,h=p.push,g=p.slice,m=p.indexOf,y=c.toString,v=c.hasOwnProperty,b=f.trim,x=function(e,t){return new x.fn.init(e,t,r)},w=/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,T=/\\S+/g,C=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,N=/^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,k=/^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,E=/^[\\],:{}\\s]*$/,S=/(?:^|:|,)(?:\\s*\\[)+/g,A=/\\\\(?:[\"\\\\\\/bfnrt]|u[\\da-fA-F]{4})/g,j=/\"[^\"\\\\\\r\\n]*\"|true|false|null|-?(?:\\d+\\.|)\\d+(?:[eE][+-]?\\d+|)/g,D=/^-ms-/,L=/-([\\da-z])/gi,H=function(e,t){return t.toUpperCase()},q=function(e){(a.addEventListener||\"load\"===e.type||\"complete\"===a.readyState)&&(_(),x.ready())},_=function(){a.addEventListener?(a.removeEventListener(\"DOMContentLoaded\",q,!1),e.removeEventListener(\"load\",q,!1)):(a.detachEvent(\"onreadystatechange\",q),e.detachEvent(\"onload\",q))};x.fn=x.prototype={jquery:f,constructor:x,init:function(e,n,r){\nvar this$1 = this;\nvar i,o;if(!e)return this;if(\"string\"==typeof e){if(i=\"<\"===e.charAt(0)&&\">\"===e.charAt(e.length-1)&&e.length>=3?[null,e,null]:N.exec(e),!i||!i[1]&&n)return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e);if(i[1]){if(n=n instanceof x?n[0]:n,x.merge(this,x.parseHTML(i[1],n&&n.nodeType?n.ownerDocument||n:a,!0)),k.test(i[1])&&x.isPlainObject(n))for(i in n)x.isFunction(this$1[i])?this$1[i](n[i]):this$1.attr(i,n[i]);return this}if(o=a.getElementById(i[2]),o&&o.parentNode){if(o.id!==i[2])return r.find(e);this.length=1,this[0]=o}return this.context=a,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):x.isFunction(e)?r.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),x.makeArray(e,this))},selector:\"\",length:0,toArray:function(){return g.call(this)},get:function(e){return null==e?this.toArray():0>e?this[this.length+e]:this[e]},pushStack:function(e){var t=x.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return x.each(this,e,t)},ready:function(e){return x.ready.promise().done(e),this},slice:function(){return this.pushStack(g.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},map:function(e){return this.pushStack(x.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:h,sort:[].sort,splice:[].splice},x.fn.init.prototype=x.fn,x.extend=x.fn.extend=function(){\nvar arguments$1 = arguments;\nvar e,n,r,i,o,a,s=arguments[0]||{},l=1,u=arguments.length,c=!1;for(\"boolean\"==typeof s&&(c=s,s=arguments[1]||{},l=2),\"object\"==typeof s||x.isFunction(s)||(s={}),u===l&&(s=this,--l);u>l;l++)if(null!=(o=arguments$1[l]))for(i in o)e=s[i],r=o[i],s!==r&&(c&&r&&(x.isPlainObject(r)||(n=x.isArray(r)))?(n?(n=!1,a=e&&x.isArray(e)?e:[]):a=e&&x.isPlainObject(e)?e:{},s[i]=x.extend(c,a,r)):r!==t&&(s[i]=r));return s},x.extend({expando:\"jQuery\"+(f+Math.random()).replace(/\\D/g,\"\"),noConflict:function(t){return e.$===x&&(e.$=u),t&&e.jQuery===x&&(e.jQuery=l),x},isReady:!1,readyWait:1,holdReady:function(e){e?x.readyWait++:x.ready(!0)},ready:function(e){if(e===!0?!--x.readyWait:!x.isReady){if(!a.body)return setTimeout(x.ready);x.isReady=!0,e!==!0&&--x.readyWait>0||(n.resolveWith(a,[x]),x.fn.trigger&&x(a).trigger(\"ready\").off(\"ready\"))}},isFunction:function(e){return\"function\"===x.type(e)},isArray:Array.isArray||function(e){return\"array\"===x.type(e)},isWindow:function(e){return null!=e&&e==e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?c[y.call(e)]||\"object\":typeof e},isPlainObject:function(e){var n;if(!e||\"object\"!==x.type(e)||e.nodeType||x.isWindow(e))return!1;try{if(e.constructor&&!v.call(e,\"constructor\")&&!v.call(e.constructor.prototype,\"isPrototypeOf\"))return!1}catch(r){return!1}if(x.support.ownLast)for(n in e)return v.call(e,n);for(n in e);return n===t||v.call(e,n)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw Error(e)},parseHTML:function(e,t,n){if(!e||\"string\"!=typeof e)return null;\"boolean\"==typeof t&&(n=t,t=!1),t=t||a;var r=k.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=x.buildFragment([e],t,i),i&&x(i).remove(),x.merge([],r.childNodes))},parseJSON:function(n){return e.JSON&&e.JSON.parse?e.JSON.parse(n):null===n?n:\"string\"==typeof n&&(n=x.trim(n),n&&E.test(n.replace(A,\"@\").replace(j,\"]\").replace(S,\"\")))?Function(\"return \"+n)():(x.error(\"Invalid JSON: \"+n),t)},parseXML:function(n){var r,i;if(!n||\"string\"!=typeof n)return null;try{e.DOMParser?(i=new DOMParser,r=i.parseFromString(n,\"text/xml\")):(r=new ActiveXObject(\"Microsoft.XMLDOM\"),r.async=\"false\",r.loadXML(n))}catch(o){r=t}return r&&r.documentElement&&!r.getElementsByTagName(\"parsererror\").length||x.error(\"Invalid XML: \"+n),r},noop:function(){},globalEval:function(t){t&&x.trim(t)&&(e.execScript||function(t){e.eval.call(e,t)})(t)},camelCase:function(e){return e.replace(D,\"ms-\").replace(L,H)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,n){var r,i=0,o=e.length,a=M(e);if(n){if(a){for(;o>i;i++)if(r=t.apply(e[i],n),r===!1)break}else for(i in e)if(r=t.apply(e[i],n),r===!1)break}else if(a){for(;o>i;i++)if(r=t.call(e[i],i,e[i]),r===!1)break}else for(i in e)if(r=t.call(e[i],i,e[i]),r===!1)break;return e},trim:b&&!b.call(\"\\ufeff\\u00a0\")?function(e){return null==e?\"\":b.call(e)}:function(e){return null==e?\"\":(e+\"\").replace(C,\"\")},makeArray:function(e,t){var n=t||[];return null!=e&&(M(Object(e))?x.merge(n,\"string\"==typeof e?[e]:e):h.call(n,e)),n},inArray:function(e,t,n){var r;if(t){if(m)return m.call(t,e,n);for(r=t.length,n=n?0>n?Math.max(0,r+n):n:0;r>n;n++)if(n in t&&t[n]===e)return n}return-1},merge:function(e,n){var r=n.length,i=e.length,o=0;if(\"number\"==typeof r)for(;r>o;o++)e[i++]=n[o];else while(n[o]!==t)e[i++]=n[o++];return e.length=i,e},grep:function(e,t,n){var r,i=[],o=0,a=e.length;for(n=!!n;a>o;o++)r=!!t(e[o],o),n!==r&&i.push(e[o]);return i},map:function(e,t,n){var r,i=0,o=e.length,a=M(e),s=[];if(a)for(;o>i;i++)r=t(e[i],i,n),null!=r&&(s[s.length]=r);else for(i in e)r=t(e[i],i,n),null!=r&&(s[s.length]=r);return d.apply([],s)},guid:1,proxy:function(e,n){var r,i,o;return\"string\"==typeof n&&(o=e[n],n=e,e=o),x.isFunction(e)?(r=g.call(arguments,2),i=function(){return e.apply(n||this,r.concat(g.call(arguments)))},i.guid=e.guid=e.guid||x.guid++,i):t},access:function(e,n,r,i,o,a,s){var l=0,u=e.length,c=null==r;if(\"object\"===x.type(r)){o=!0;for(l in r)x.access(e,n,l,r[l],!0,a,s)}else if(i!==t&&(o=!0,x.isFunction(i)||(s=!0),c&&(s?(n.call(e,i),n=null):(c=n,n=function(e,t,n){return c.call(x(e),n)})),n))for(;u>l;l++)n(e[l],r,s?i:i.call(e[l],l,n(e[l],r)));return o?e:c?n.call(e):u?n(e[0],r):a},now:function(){return(new Date).getTime()},swap:function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=a[o];return i}}),x.ready.promise=function(t){if(!n)if(n=x.Deferred(),\"complete\"===a.readyState)setTimeout(x.ready);else if(a.addEventListener)a.addEventListener(\"DOMContentLoaded\",q,!1),e.addEventListener(\"load\",q,!1);else{a.attachEvent(\"onreadystatechange\",q),e.attachEvent(\"onload\",q);var r=!1;try{r=null==e.frameElement&&a.documentElement}catch(i){}r&&r.doScroll&&function o(){if(!x.isReady){try{r.doScroll(\"left\")}catch(e){return setTimeout(o,50)}_(),x.ready()}}()}return n.promise(t)},x.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"),function(e,t){c[\"[object \"+t+\"]\"]=t.toLowerCase()});function M(e){var t=e.length,n=x.type(e);return x.isWindow(e)?!1:1===e.nodeType&&t?!0:\"array\"===n||\"function\"!==n&&(0===t||\"number\"==typeof t&&t>0&&t-1 in e)}r=x(a),function(e,t){var n,r,i,o,a,s,l,u,c,p,f,d,h,g,m,y,v,b=\"sizzle\"+-new Date,w=e.document,T=0,C=0,N=st(),k=st(),E=st(),S=!1,A=function(e,t){return e===t?(S=!0,0):0},j=typeof t,D=1<<31,L={}.hasOwnProperty,H=[],q=H.pop,_=H.push,M=H.push,O=H.slice,F=H.indexOf||function(e){\nvar this$1 = this;\nvar t=0,n=this.length;for(;n>t;t++)if(this$1[t]===e)return t;return-1},B=\"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",P=\"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",R=\"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",W=R.replace(\"w\",\"w#\"),$=\"\\\\[\"+P+\"*(\"+R+\")\"+P+\"*(?:([*^$|!~]?=)\"+P+\"*(?:(['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|(\"+W+\")|)|)\"+P+\"*\\\\]\",I=\":(\"+R+\")(?:\\\\(((['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\"+$.replace(3,8)+\")*)|.*)\\\\)|)\",z=RegExp(\"^\"+P+\"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\"+P+\"+$\",\"g\"),X=RegExp(\"^\"+P+\"*,\"+P+\"*\"),U=RegExp(\"^\"+P+\"*([>+~]|\"+P+\")\"+P+\"*\"),V=RegExp(P+\"*[+~]\"),Y=RegExp(\"=\"+P+\"*([^\\\\]'\\\"]*)\"+P+\"*\\\\]\",\"g\"),J=RegExp(I),G=RegExp(\"^\"+W+\"$\"),Q={ID:RegExp(\"^#(\"+R+\")\"),CLASS:RegExp(\"^\\\\.(\"+R+\")\"),TAG:RegExp(\"^(\"+R.replace(\"w\",\"w*\")+\")\"),ATTR:RegExp(\"^\"+$),PSEUDO:RegExp(\"^\"+I),CHILD:RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\"+P+\"*(even|odd|(([+-]|)(\\\\d*)n|)\"+P+\"*(?:([+-]|)\"+P+\"*(\\\\d+)|))\"+P+\"*\\\\)|)\",\"i\"),bool:RegExp(\"^(?:\"+B+\")$\",\"i\"),needsContext:RegExp(\"^\"+P+\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\"+P+\"*((?:-\\\\d)?\\\\d*)\"+P+\"*\\\\)|)(?=[^-]|$)\",\"i\")},K=/^[^{]+\\{\\s*\\[native \\w/,Z=/^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,et=/^(?:input|select|textarea|button)$/i,tt=/^h\\d$/i,nt=/'|\\\\/g,rt=RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\"+P+\"?|(\"+P+\")|.)\",\"ig\"),it=function(e,t,n){var r=\"0x\"+t-65536;return r!==r||n?t:0>r?String.fromCharCode(r+65536):String.fromCharCode(55296|r>>10,56320|1023&r)};try{M.apply(H=O.call(w.childNodes),w.childNodes),H[w.childNodes.length].nodeType}catch(ot){M={apply:H.length?function(e,t){_.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function at(e,t,n,i){var o,a,s,l,u,c,d,m,y,x;if((t?t.ownerDocument||t:w)!==f&&p(t),t=t||f,n=n||[],!e||\"string\"!=typeof e)return n;if(1!==(l=t.nodeType)&&9!==l)return[];if(h&&!i){if(o=Z.exec(e))if(s=o[1]){if(9===l){if(a=t.getElementById(s),!a||!a.parentNode)return n;if(a.id===s)return n.push(a),n}else if(t.ownerDocument&&(a=t.ownerDocument.getElementById(s))&&v(t,a)&&a.id===s)return n.push(a),n}else{if(o[2])return M.apply(n,t.getElementsByTagName(e)),n;if((s=o[3])&&r.getElementsByClassName&&t.getElementsByClassName)return M.apply(n,t.getElementsByClassName(s)),n}if(r.qsa&&(!g||!g.test(e))){if(m=d=b,y=t,x=9===l&&e,1===l&&\"object\"!==t.nodeName.toLowerCase()){c=mt(e),(d=t.getAttribute(\"id\"))?m=d.replace(nt,\"\\\\$&\"):t.setAttribute(\"id\",m),m=\"[id='\"+m+\"'] \",u=c.length;while(u--)c[u]=m+yt(c[u]);y=V.test(e)&&t.parentNode||t,x=c.join(\",\")}if(x)try{return M.apply(n,y.querySelectorAll(x)),n}catch(T){}finally{d||t.removeAttribute(\"id\")}}}return kt(e.replace(z,\"$1\"),t,n,i)}function st(){var e=[];function t(n,r){return e.push(n+=\" \")>o.cacheLength&&delete t[e.shift()],t[n]=r}return t}function lt(e){return e[b]=!0,e}function ut(e){var t=f.createElement(\"div\");try{return!!e(t)}catch(n){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function ct(e,t){var n=e.split(\"|\"),r=e.length;while(r--)o.attrHandle[n[r]]=t}function pt(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&(~t.sourceIndex||D)-(~e.sourceIndex||D);if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function ft(e){return function(t){var n=t.nodeName.toLowerCase();return\"input\"===n&&t.type===e}}function dt(e){return function(t){var n=t.nodeName.toLowerCase();return(\"input\"===n||\"button\"===n)&&t.type===e}}function ht(e){return lt(function(t){return t=+t,lt(function(n,r){var i,o=e([],n.length,t),a=o.length;while(a--)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}s=at.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?\"HTML\"!==t.nodeName:!1},r=at.support={},p=at.setDocument=function(e){var n=e?e.ownerDocument||e:w,i=n.defaultView;return n!==f&&9===n.nodeType&&n.documentElement?(f=n,d=n.documentElement,h=!s(n),i&&i.attachEvent&&i!==i.top&&i.attachEvent(\"onbeforeunload\",function(){p()}),r.attributes=ut(function(e){return e.className=\"i\",!e.getAttribute(\"className\")}),r.getElementsByTagName=ut(function(e){return e.appendChild(n.createComment(\"\")),!e.getElementsByTagName(\"*\").length}),r.getElementsByClassName=ut(function(e){return e.innerHTML=\"<div class='a'></div><div class='a i'></div>\",e.firstChild.className=\"i\",2===e.getElementsByClassName(\"i\").length}),r.getById=ut(function(e){return d.appendChild(e).id=b,!n.getElementsByName||!n.getElementsByName(b).length}),r.getById?(o.find.ID=function(e,t){if(typeof t.getElementById!==j&&h){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},o.filter.ID=function(e){var t=e.replace(rt,it);return function(e){return e.getAttribute(\"id\")===t}}):(delete o.find.ID,o.filter.ID=function(e){var t=e.replace(rt,it);return function(e){var n=typeof e.getAttributeNode!==j&&e.getAttributeNode(\"id\");return n&&n.value===t}}),o.find.TAG=r.getElementsByTagName?function(e,n){return typeof n.getElementsByTagName!==j?n.getElementsByTagName(e):t}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if(\"*\"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},o.find.CLASS=r.getElementsByClassName&&function(e,n){return typeof n.getElementsByClassName!==j&&h?n.getElementsByClassName(e):t},m=[],g=[],(r.qsa=K.test(n.querySelectorAll))&&(ut(function(e){e.innerHTML=\"<select><option selected=''></option></select>\",e.querySelectorAll(\"[selected]\").length||g.push(\"\\\\[\"+P+\"*(?:value|\"+B+\")\"),e.querySelectorAll(\":checked\").length||g.push(\":checked\")}),ut(function(e){var t=n.createElement(\"input\");t.setAttribute(\"type\",\"hidden\"),e.appendChild(t).setAttribute(\"t\",\"\"),e.querySelectorAll(\"[t^='']\").length&&g.push(\"[*^$]=\"+P+\"*(?:''|\\\"\\\")\"),e.querySelectorAll(\":enabled\").length||g.push(\":enabled\",\":disabled\"),e.querySelectorAll(\"*,:x\"),g.push(\",.*:\")})),(r.matchesSelector=K.test(y=d.webkitMatchesSelector||d.mozMatchesSelector||d.oMatchesSelector||d.msMatchesSelector))&&ut(function(e){r.disconnectedMatch=y.call(e,\"div\"),y.call(e,\"[s!='']:x\"),m.push(\"!=\",I)}),g=g.length&&RegExp(g.join(\"|\")),m=m.length&&RegExp(m.join(\"|\")),v=K.test(d.contains)||d.compareDocumentPosition?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},A=d.compareDocumentPosition?function(e,t){if(e===t)return S=!0,0;var i=t.compareDocumentPosition&&e.compareDocumentPosition&&e.compareDocumentPosition(t);return i?1&i||!r.sortDetached&&t.compareDocumentPosition(e)===i?e===n||v(w,e)?-1:t===n||v(w,t)?1:c?F.call(c,e)-F.call(c,t):0:4&i?-1:1:e.compareDocumentPosition?-1:1}:function(e,t){var r,i=0,o=e.parentNode,a=t.parentNode,s=[e],l=[t];if(e===t)return S=!0,0;if(!o||!a)return e===n?-1:t===n?1:o?-1:a?1:c?F.call(c,e)-F.call(c,t):0;if(o===a)return pt(e,t);r=e;while(r=r.parentNode)s.unshift(r);r=t;while(r=r.parentNode)l.unshift(r);while(s[i]===l[i])i++;return i?pt(s[i],l[i]):s[i]===w?-1:l[i]===w?1:0},n):f},at.matches=function(e,t){return at(e,null,null,t)},at.matchesSelector=function(e,t){if((e.ownerDocument||e)!==f&&p(e),t=t.replace(Y,\"='$1']\"),!(!r.matchesSelector||!h||m&&m.test(t)||g&&g.test(t)))try{var n=y.call(e,t);if(n||r.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(i){}return at(t,f,null,[e]).length>0},at.contains=function(e,t){return(e.ownerDocument||e)!==f&&p(e),v(e,t)},at.attr=function(e,n){(e.ownerDocument||e)!==f&&p(e);var i=o.attrHandle[n.toLowerCase()],a=i&&L.call(o.attrHandle,n.toLowerCase())?i(e,n,!h):t;return a===t?r.attributes||!h?e.getAttribute(n):(a=e.getAttributeNode(n))&&a.specified?a.value:null:a},at.error=function(e){throw Error(\"Syntax error, unrecognized expression: \"+e)},at.uniqueSort=function(e){var t,n=[],i=0,o=0;if(S=!r.detectDuplicates,c=!r.sortStable&&e.slice(0),e.sort(A),S){while(t=e[o++])t===e[o]&&(i=n.push(o));while(i--)e.splice(n[i],1)}return e},a=at.getText=function(e){var t,n=\"\",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if(\"string\"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=a(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r];r++)n+=a(t);return n},o=at.selectors={cacheLength:50,createPseudo:lt,match:Q,attrHandle:{},find:{},relative:{\">\":{dir:\"parentNode\",first:!0},\" \":{dir:\"parentNode\"},\"+\":{dir:\"previousSibling\",first:!0},\"~\":{dir:\"previousSibling\"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(rt,it),e[3]=(e[4]||e[5]||\"\").replace(rt,it),\"~=\"===e[2]&&(e[3]=\" \"+e[3]+\" \"),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),\"nth\"===e[1].slice(0,3)?(e[3]||at.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*(\"even\"===e[3]||\"odd\"===e[3])),e[5]=+(e[7]+e[8]||\"odd\"===e[3])):e[3]&&at.error(e[0]),e},PSEUDO:function(e){var n,r=!e[5]&&e[2];return Q.CHILD.test(e[0])?null:(e[3]&&e[4]!==t?e[2]=e[4]:r&&J.test(r)&&(n=mt(r,!0))&&(n=r.indexOf(\")\",r.length-n)-r.length)&&(e[0]=e[0].slice(0,n),e[2]=r.slice(0,n)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(rt,it).toLowerCase();return\"*\"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=N[e+\" \"];return t||(t=RegExp(\"(^|\"+P+\")\"+e+\"(\"+P+\"|$)\"))&&N(e,function(e){return t.test(\"string\"==typeof e.className&&e.className||typeof e.getAttribute!==j&&e.getAttribute(\"class\")||\"\")})},ATTR:function(e,t,n){return function(r){var i=at.attr(r,e);return null==i?\"!=\"===t:t?(i+=\"\",\"=\"===t?i===n:\"!=\"===t?i!==n:\"^=\"===t?n&&0===i.indexOf(n):\"*=\"===t?n&&i.indexOf(n)>-1:\"$=\"===t?n&&i.slice(-n.length)===n:\"~=\"===t?(\" \"+i+\" \").indexOf(n)>-1:\"|=\"===t?i===n||i.slice(0,n.length+1)===n+\"-\":!1):!0}},CHILD:function(e,t,n,r,i){var o=\"nth\"!==e.slice(0,3),a=\"last\"!==e.slice(-4),s=\"of-type\"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,l){var u,c,p,f,d,h,g=o!==a?\"nextSibling\":\"previousSibling\",m=t.parentNode,y=s&&t.nodeName.toLowerCase(),v=!l&&!s;if(m){if(o){while(g){p=t;while(p=p[g])if(s?p.nodeName.toLowerCase()===y:1===p.nodeType)return!1;h=g=\"only\"===e&&!h&&\"nextSibling\"}return!0}if(h=[a?m.firstChild:m.lastChild],a&&v){c=m[b]||(m[b]={}),u=c[e]||[],d=u[0]===T&&u[1],f=u[0]===T&&u[2],p=d&&m.childNodes[d];while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if(1===p.nodeType&&++f&&p===t){c[e]=[T,d,f];break}}else if(v&&(u=(t[b]||(t[b]={}))[e])&&u[0]===T)f=u[1];else while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if((s?p.nodeName.toLowerCase()===y:1===p.nodeType)&&++f&&(v&&((p[b]||(p[b]={}))[e]=[T,f]),p===t))break;return f-=i,f===r||0===f%r&&f/r>=0}}},PSEUDO:function(e,t){var n,r=o.pseudos[e]||o.setFilters[e.toLowerCase()]||at.error(\"unsupported pseudo: \"+e);return r[b]?r(t):r.length>1?(n=[e,e,\"\",t],o.setFilters.hasOwnProperty(e.toLowerCase())?lt(function(e,n){var i,o=r(e,t),a=o.length;while(a--)i=F.call(e,o[a]),e[i]=!(n[i]=o[a])}):function(e){return r(e,0,n)}):r}},pseudos:{not:lt(function(e){var t=[],n=[],r=l(e.replace(z,\"$1\"));return r[b]?lt(function(e,t,n,i){var o,a=r(e,null,i,[]),s=e.length;while(s--)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),!n.pop()}}),has:lt(function(e){return function(t){return at(e,t).length>0}}),contains:lt(function(e){return function(t){return(t.textContent||t.innerText||a(t)).indexOf(e)>-1}}),lang:lt(function(e){return G.test(e||\"\")||at.error(\"unsupported lang: \"+e),e=e.replace(rt,it).toLowerCase(),function(t){var n;do if(n=h?t.lang:t.getAttribute(\"xml:lang\")||t.getAttribute(\"lang\"))return n=n.toLowerCase(),n===e||0===n.indexOf(e+\"-\");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===d},focus:function(e){return e===f.activeElement&&(!f.hasFocus||f.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return\"input\"===t&&!!e.checked||\"option\"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeName>\"@\"||3===e.nodeType||4===e.nodeType)return!1;return!0},parent:function(e){return!o.pseudos.empty(e)},header:function(e){return tt.test(e.nodeName)},input:function(e){return et.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return\"input\"===t&&\"button\"===e.type||\"button\"===t},text:function(e){var t;return\"input\"===e.nodeName.toLowerCase()&&\"text\"===e.type&&(null==(t=e.getAttribute(\"type\"))||t.toLowerCase()===e.type)},first:ht(function(){return[0]}),last:ht(function(e,t){return[t-1]}),eq:ht(function(e,t,n){return[0>n?n+t:n]}),even:ht(function(e,t){var n=0;for(;t>n;n+=2)e.push(n);return e}),odd:ht(function(e,t){var n=1;for(;t>n;n+=2)e.push(n);return e}),lt:ht(function(e,t,n){var r=0>n?n+t:n;for(;--r>=0;)e.push(r);return e}),gt:ht(function(e,t,n){var r=0>n?n+t:n;for(;t>++r;)e.push(r);return e})}},o.pseudos.nth=o.pseudos.eq;for(n in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})o.pseudos[n]=ft(n);for(n in{submit:!0,reset:!0})o.pseudos[n]=dt(n);function gt(){}gt.prototype=o.filters=o.pseudos,o.setFilters=new gt;function mt(e,t){var n,r,i,a,s,l,u,c=k[e+\" \"];if(c)return t?0:c.slice(0);s=e,l=[],u=o.preFilter;while(s){(!n||(r=X.exec(s)))&&(r&&(s=s.slice(r[0].length)||s),l.push(i=[])),n=!1,(r=U.exec(s))&&(n=r.shift(),i.push({value:n,type:r[0].replace(z,\" \")}),s=s.slice(n.length));for(a in o.filter)!(r=Q[a].exec(s))||u[a]&&!(r=u[a](r))||(n=r.shift(),i.push({value:n,type:a,matches:r}),s=s.slice(n.length));if(!n)break}return t?s.length:s?at.error(e):k(e,l).slice(0)}function yt(e){var t=0,n=e.length,r=\"\";for(;n>t;t++)r+=e[t].value;return r}function vt(e,t,n){var r=t.dir,o=n&&\"parentNode\"===r,a=C++;return t.first?function(t,n,i){while(t=t[r])if(1===t.nodeType||o)return e(t,n,i)}:function(t,n,s){var l,u,c,p=T+\" \"+a;if(s){while(t=t[r])if((1===t.nodeType||o)&&e(t,n,s))return!0}else while(t=t[r])if(1===t.nodeType||o)if(c=t[b]||(t[b]={}),(u=c[r])&&u[0]===p){if((l=u[1])===!0||l===i)return l===!0}else if(u=c[r]=[p],u[1]=e(t,n,s)||i,u[1]===!0)return!0}}function bt(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function xt(e,t,n,r,i){var o,a=[],s=0,l=e.length,u=null!=t;for(;l>s;s++)(o=e[s])&&(!n||n(o,r,i))&&(a.push(o),u&&t.push(s));return a}function wt(e,t,n,r,i,o){return r&&!r[b]&&(r=wt(r)),i&&!i[b]&&(i=wt(i,o)),lt(function(o,a,s,l){var u,c,p,f=[],d=[],h=a.length,g=o||Nt(t||\"*\",s.nodeType?[s]:s,[]),m=!e||!o&&t?g:xt(g,f,e,s,l),y=n?i||(o?e:h||r)?[]:a:m;if(n&&n(m,y,s,l),r){u=xt(y,d),r(u,[],s,l),c=u.length;while(c--)(p=u[c])&&(y[d[c]]=!(m[d[c]]=p))}if(o){if(i||e){if(i){u=[],c=y.length;while(c--)(p=y[c])&&u.push(m[c]=p);i(null,y=[],u,l)}c=y.length;while(c--)(p=y[c])&&(u=i?F.call(o,p):f[c])>-1&&(o[u]=!(a[u]=p))}}else y=xt(y===a?y.splice(h,y.length):y),i?i(null,a,y,l):M.apply(a,y)})}function Tt(e){var t,n,r,i=e.length,a=o.relative[e[0].type],s=a||o.relative[\" \"],l=a?1:0,c=vt(function(e){return e===t},s,!0),p=vt(function(e){return F.call(t,e)>-1},s,!0),f=[function(e,n,r){return!a&&(r||n!==u)||((t=n).nodeType?c(e,n,r):p(e,n,r))}];for(;i>l;l++)if(n=o.relative[e[l].type])f=[vt(bt(f),n)];else{if(n=o.filter[e[l].type].apply(null,e[l].matches),n[b]){for(r=++l;i>r;r++)if(o.relative[e[r].type])break;return wt(l>1&&bt(f),l>1&&yt(e.slice(0,l-1).concat({value:\" \"===e[l-2].type?\"*\":\"\"})).replace(z,\"$1\"),n,r>l&&Tt(e.slice(l,r)),i>r&&Tt(e=e.slice(r)),i>r&&yt(e))}f.push(n)}return bt(f)}function Ct(e,t){var n=0,r=t.length>0,a=e.length>0,s=function(s,l,c,p,d){var h,g,m,y=[],v=0,b=\"0\",x=s&&[],w=null!=d,C=u,N=s||a&&o.find.TAG(\"*\",d&&l.parentNode||l),k=T+=null==C?1:Math.random()||.1;for(w&&(u=l!==f&&l,i=n);null!=(h=N[b]);b++){if(a&&h){g=0;while(m=e[g++])if(m(h,l,c)){p.push(h);break}w&&(T=k,i=++n)}r&&((h=!m&&h)&&v--,s&&x.push(h))}if(v+=b,r&&b!==v){g=0;while(m=t[g++])m(x,y,l,c);if(s){if(v>0)while(b--)x[b]||y[b]||(y[b]=q.call(p));y=xt(y)}M.apply(p,y),w&&!s&&y.length>0&&v+t.length>1&&at.uniqueSort(p)}return w&&(T=k,u=C),x};return r?lt(s):s}l=at.compile=function(e,t){var n,r=[],i=[],o=E[e+\" \"];if(!o){t||(t=mt(e)),n=t.length;while(n--)o=Tt(t[n]),o[b]?r.push(o):i.push(o);o=E(e,Ct(i,r))}return o};function Nt(e,t,n){var r=0,i=t.length;for(;i>r;r++)at(e,t[r],n);return n}function kt(e,t,n,i){var a,s,u,c,p,f=mt(e);if(!i&&1===f.length){if(s=f[0]=f[0].slice(0),s.length>2&&\"ID\"===(u=s[0]).type&&r.getById&&9===t.nodeType&&h&&o.relative[s[1].type]){if(t=(o.find.ID(u.matches[0].replace(rt,it),t)||[])[0],!t)return n;e=e.slice(s.shift().value.length)}a=Q.needsContext.test(e)?0:s.length;while(a--){if(u=s[a],o.relative[c=u.type])break;if((p=o.find[c])&&(i=p(u.matches[0].replace(rt,it),V.test(s[0].type)&&t.parentNode||t))){if(s.splice(a,1),e=i.length&&yt(s),!e)return M.apply(n,i),n;break}}}return l(e,f)(i,t,!h,n,V.test(e)),n}r.sortStable=b.split(\"\").sort(A).join(\"\")===b,r.detectDuplicates=S,p(),r.sortDetached=ut(function(e){return 1&e.compareDocumentPosition(f.createElement(\"div\"))}),ut(function(e){return e.innerHTML=\"<a href='#'></a>\",\"#\"===e.firstChild.getAttribute(\"href\")})||ct(\"type|href|height|width\",function(e,n,r){return r?t:e.getAttribute(n,\"type\"===n.toLowerCase()?1:2)}),r.attributes&&ut(function(e){return e.innerHTML=\"<input/>\",e.firstChild.setAttribute(\"value\",\"\"),\"\"===e.firstChild.getAttribute(\"value\")})||ct(\"value\",function(e,n,r){return r||\"input\"!==e.nodeName.toLowerCase()?t:e.defaultValue}),ut(function(e){return null==e.getAttribute(\"disabled\")})||ct(B,function(e,n,r){var i;return r?t:(i=e.getAttributeNode(n))&&i.specified?i.value:e[n]===!0?n.toLowerCase():null}),x.find=at,x.expr=at.selectors,x.expr[\":\"]=x.expr.pseudos,x.unique=at.uniqueSort,x.text=at.getText,x.isXMLDoc=at.isXML,x.contains=at.contains}(e);var O={};function F(e){var t=O[e]={};return x.each(e.match(T)||[],function(e,n){t[n]=!0}),t}x.Callbacks=function(e){e=\"string\"==typeof e?O[e]||F(e):x.extend({},e);var n,r,i,o,a,s,l=[],u=!e.once&&[],c=function(t){for(r=e.memory&&t,i=!0,a=s||0,s=0,o=l.length,n=!0;l&&o>a;a++)if(l[a].apply(t[0],t[1])===!1&&e.stopOnFalse){r=!1;break}n=!1,l&&(u?u.length&&c(u.shift()):r?l=[]:p.disable())},p={add:function(){if(l){var t=l.length;(function i(t){x.each(t,function(t,n){var r=x.type(n);\"function\"===r?e.unique&&p.has(n)||l.push(n):n&&n.length&&\"string\"!==r&&i(n)})})(arguments),n?o=l.length:r&&(s=t,c(r))}return this},remove:function(){return l&&x.each(arguments,function(e,t){var r;while((r=x.inArray(t,l,r))>-1)l.splice(r,1),n&&(o>=r&&o--,a>=r&&a--)}),this},has:function(e){return e?x.inArray(e,l)>-1:!(!l||!l.length)},empty:function(){return l=[],o=0,this},disable:function(){return l=u=r=t,this},disabled:function(){return!l},lock:function(){return u=t,r||p.disable(),this},locked:function(){return!u},fireWith:function(e,t){return!l||i&&!u||(t=t||[],t=[e,t.slice?t.slice():t],n?u.push(t):c(t)),this},fire:function(){return p.fireWith(this,arguments),this},fired:function(){return!!i}};return p},x.extend({Deferred:function(e){var t=[[\"resolve\",\"done\",x.Callbacks(\"once memory\"),\"resolved\"],[\"reject\",\"fail\",x.Callbacks(\"once memory\"),\"rejected\"],[\"notify\",\"progress\",x.Callbacks(\"memory\")]],n=\"pending\",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return x.Deferred(function(n){x.each(t,function(t,o){var a=o[0],s=x.isFunction(e[t])&&e[t];i[o[1]](function(){var e=s&&s.apply(this,arguments);e&&x.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[a+\"With\"](this===r?n.promise():this,s?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?x.extend(e,r):r}},i={};return r.pipe=r.then,x.each(t,function(e,o){var a=o[2],s=o[3];r[o[1]]=a.add,s&&a.add(function(){n=s},t[1^e][2].disable,t[2][2].lock),i[o[0]]=function(){return i[o[0]+\"With\"](this===i?r:this,arguments),this},i[o[0]+\"With\"]=a.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=g.call(arguments),r=n.length,i=1!==r||e&&x.isFunction(e.promise)?r:0,o=1===i?e:x.Deferred(),a=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?g.call(arguments):r,n===s?o.notifyWith(t,n):--i||o.resolveWith(t,n)}},s,l,u;if(r>1)for(s=Array(r),l=Array(r),u=Array(r);r>t;t++)n[t]&&x.isFunction(n[t].promise)?n[t].promise().done(a(t,u,n)).fail(o.reject).progress(a(t,l,s)):--i;return i||o.resolveWith(u,n),o.promise()}}),x.support=function(t){var n,r,o,s,l,u,c,p,f,d=a.createElement(\"div\");if(d.setAttribute(\"className\",\"t\"),d.innerHTML=\"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\",n=d.getElementsByTagName(\"*\")||[],r=d.getElementsByTagName(\"a\")[0],!r||!r.style||!n.length)return t;s=a.createElement(\"select\"),u=s.appendChild(a.createElement(\"option\")),o=d.getElementsByTagName(\"input\")[0],r.style.cssText=\"top:1px;float:left;opacity:.5\",t.getSetAttribute=\"t\"!==d.className,t.leadingWhitespace=3===d.firstChild.nodeType,t.tbody=!d.getElementsByTagName(\"tbody\").length,t.htmlSerialize=!!d.getElementsByTagName(\"link\").length,t.style=/top/.test(r.getAttribute(\"style\")),t.hrefNormalized=\"/a\"===r.getAttribute(\"href\"),t.opacity=/^0.5/.test(r.style.opacity),t.cssFloat=!!r.style.cssFloat,t.checkOn=!!o.value,t.optSelected=u.selected,t.enctype=!!a.createElement(\"form\").enctype,t.html5Clone=\"<:nav></:nav>\"!==a.createElement(\"nav\").cloneNode(!0).outerHTML,t.inlineBlockNeedsLayout=!1,t.shrinkWrapBlocks=!1,t.pixelPosition=!1,t.deleteExpando=!0,t.noCloneEvent=!0,t.reliableMarginRight=!0,t.boxSizingReliable=!0,o.checked=!0,t.noCloneChecked=o.cloneNode(!0).checked,s.disabled=!0,t.optDisabled=!u.disabled;try{delete d.test}catch(h){t.deleteExpando=!1}o=a.createElement(\"input\"),o.setAttribute(\"value\",\"\"),t.input=\"\"===o.getAttribute(\"value\"),o.value=\"t\",o.setAttribute(\"type\",\"radio\"),t.radioValue=\"t\"===o.value,o.setAttribute(\"checked\",\"t\"),o.setAttribute(\"name\",\"t\"),l=a.createDocumentFragment(),l.appendChild(o),t.appendChecked=o.checked,t.checkClone=l.cloneNode(!0).cloneNode(!0).lastChild.checked,d.attachEvent&&(d.attachEvent(\"onclick\",function(){t.noCloneEvent=!1}),d.cloneNode(!0).click());for(f in{submit:!0,change:!0,focusin:!0})d.setAttribute(c=\"on\"+f,\"t\"),t[f+\"Bubbles\"]=c in e||d.attributes[c].expando===!1;d.style.backgroundClip=\"content-box\",d.cloneNode(!0).style.backgroundClip=\"\",t.clearCloneStyle=\"content-box\"===d.style.backgroundClip;for(f in x(t))break;return t.ownLast=\"0\"!==f,x(function(){var n,r,o,s=\"padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;\",l=a.getElementsByTagName(\"body\")[0];l&&(n=a.createElement(\"div\"),n.style.cssText=\"border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px\",l.appendChild(n).appendChild(d),d.innerHTML=\"<table><tr><td></td><td>t</td></tr></table>\",o=d.getElementsByTagName(\"td\"),o[0].style.cssText=\"padding:0;margin:0;border:0;display:none\",p=0===o[0].offsetHeight,o[0].style.display=\"\",o[1].style.display=\"none\",t.reliableHiddenOffsets=p&&0===o[0].offsetHeight,d.innerHTML=\"\",d.style.cssText=\"box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;\",x.swap(l,null!=l.style.zoom?{zoom:1}:{},function(){t.boxSizing=4===d.offsetWidth}),e.getComputedStyle&&(t.pixelPosition=\"1%\"!==(e.getComputedStyle(d,null)||{}).top,t.boxSizingReliable=\"4px\"===(e.getComputedStyle(d,null)||{width:\"4px\"}).width,r=d.appendChild(a.createElement(\"div\")),r.style.cssText=d.style.cssText=s,r.style.marginRight=r.style.width=\"0\",d.style.width=\"1px\",t.reliableMarginRight=!parseFloat((e.getComputedStyle(r,null)||{}).marginRight)),typeof d.style.zoom!==i&&(d.innerHTML=\"\",d.style.cssText=s+\"width:1px;padding:1px;display:inline;zoom:1\",t.inlineBlockNeedsLayout=3===d.offsetWidth,d.style.display=\"block\",d.innerHTML=\"<div></div>\",d.firstChild.style.width=\"5px\",t.shrinkWrapBlocks=3!==d.offsetWidth,t.inlineBlockNeedsLayout&&(l.style.zoom=1)),l.removeChild(n),n=d=o=r=null)}),n=s=l=u=r=o=null,t\n}({});var B=/(?:\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/,P=/([A-Z])/g;function R(e,n,r,i){if(x.acceptData(e)){var o,a,s=x.expando,l=e.nodeType,u=l?x.cache:e,c=l?e[s]:e[s]&&s;if(c&&u[c]&&(i||u[c].data)||r!==t||\"string\"!=typeof n)return c||(c=l?e[s]=p.pop()||x.guid++:s),u[c]||(u[c]=l?{}:{toJSON:x.noop}),(\"object\"==typeof n||\"function\"==typeof n)&&(i?u[c]=x.extend(u[c],n):u[c].data=x.extend(u[c].data,n)),a=u[c],i||(a.data||(a.data={}),a=a.data),r!==t&&(a[x.camelCase(n)]=r),\"string\"==typeof n?(o=a[n],null==o&&(o=a[x.camelCase(n)])):o=a,o}}function W(e,t,n){if(x.acceptData(e)){var r,i,o=e.nodeType,a=o?x.cache:e,s=o?e[x.expando]:x.expando;if(a[s]){if(t&&(r=n?a[s]:a[s].data)){x.isArray(t)?t=t.concat(x.map(t,x.camelCase)):t in r?t=[t]:(t=x.camelCase(t),t=t in r?[t]:t.split(\" \")),i=t.length;while(i--)delete r[t[i]];if(n?!I(r):!x.isEmptyObject(r))return}(n||(delete a[s].data,I(a[s])))&&(o?x.cleanData([e],!0):x.support.deleteExpando||a!=a.window?delete a[s]:a[s]=null)}}}x.extend({cache:{},noData:{applet:!0,embed:!0,object:\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"},hasData:function(e){return e=e.nodeType?x.cache[e[x.expando]]:e[x.expando],!!e&&!I(e)},data:function(e,t,n){return R(e,t,n)},removeData:function(e,t){return W(e,t)},_data:function(e,t,n){return R(e,t,n,!0)},_removeData:function(e,t){return W(e,t,!0)},acceptData:function(e){if(e.nodeType&&1!==e.nodeType&&9!==e.nodeType)return!1;var t=e.nodeName&&x.noData[e.nodeName.toLowerCase()];return!t||t!==!0&&e.getAttribute(\"classid\")===t}}),x.fn.extend({data:function(e,n){var r,i,o=null,a=0,s=this[0];if(e===t){if(this.length&&(o=x.data(s),1===s.nodeType&&!x._data(s,\"parsedAttrs\"))){for(r=s.attributes;r.length>a;a++)i=r[a].name,0===i.indexOf(\"data-\")&&(i=x.camelCase(i.slice(5)),$(s,i,o[i]));x._data(s,\"parsedAttrs\",!0)}return o}return\"object\"==typeof e?this.each(function(){x.data(this,e)}):arguments.length>1?this.each(function(){x.data(this,e,n)}):s?$(s,e,x.data(s,e)):null},removeData:function(e){return this.each(function(){x.removeData(this,e)})}});function $(e,n,r){if(r===t&&1===e.nodeType){var i=\"data-\"+n.replace(P,\"-$1\").toLowerCase();if(r=e.getAttribute(i),\"string\"==typeof r){try{r=\"true\"===r?!0:\"false\"===r?!1:\"null\"===r?null:+r+\"\"===r?+r:B.test(r)?x.parseJSON(r):r}catch(o){}x.data(e,n,r)}else r=t}return r}function I(e){var t;for(t in e)if((\"data\"!==t||!x.isEmptyObject(e[t]))&&\"toJSON\"!==t)return!1;return!0}x.extend({queue:function(e,n,r){var i;return e?(n=(n||\"fx\")+\"queue\",i=x._data(e,n),r&&(!i||x.isArray(r)?i=x._data(e,n,x.makeArray(r)):i.push(r)),i||[]):t},dequeue:function(e,t){t=t||\"fx\";var n=x.queue(e,t),r=n.length,i=n.shift(),o=x._queueHooks(e,t),a=function(){x.dequeue(e,t)};\"inprogress\"===i&&(i=n.shift(),r--),i&&(\"fx\"===t&&n.unshift(\"inprogress\"),delete o.stop,i.call(e,a,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+\"queueHooks\";return x._data(e,n)||x._data(e,n,{empty:x.Callbacks(\"once memory\").add(function(){x._removeData(e,t+\"queue\"),x._removeData(e,n)})})}}),x.fn.extend({queue:function(e,n){var r=2;return\"string\"!=typeof e&&(n=e,e=\"fx\",r--),r>arguments.length?x.queue(this[0],e):n===t?this:this.each(function(){var t=x.queue(this,e,n);x._queueHooks(this,e),\"fx\"===e&&\"inprogress\"!==t[0]&&x.dequeue(this,e)})},dequeue:function(e){return this.each(function(){x.dequeue(this,e)})},delay:function(e,t){return e=x.fx?x.fx.speeds[e]||e:e,t=t||\"fx\",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||\"fx\",[])},promise:function(e,n){var r,i=1,o=x.Deferred(),a=this,s=this.length,l=function(){--i||o.resolveWith(a,[a])};\"string\"!=typeof e&&(n=e,e=t),e=e||\"fx\";while(s--)r=x._data(a[s],e+\"queueHooks\"),r&&r.empty&&(i++,r.empty.add(l));return l(),o.promise(n)}});var z,X,U=/[\\t\\r\\n\\f]/g,V=/\\r/g,Y=/^(?:input|select|textarea|button|object)$/i,J=/^(?:a|area)$/i,G=/^(?:checked|selected)$/i,Q=x.support.getSetAttribute,K=x.support.input;x.fn.extend({attr:function(e,t){return x.access(this,x.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){x.removeAttr(this,e)})},prop:function(e,t){return x.access(this,x.prop,e,t,arguments.length>1)},removeProp:function(e){return e=x.propFix[e]||e,this.each(function(){try{this[e]=t,delete this[e]}catch(n){}})},addClass:function(e){\nvar this$1 = this;\nvar t,n,r,i,o,a=0,s=this.length,l=\"string\"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).addClass(e.call(this,t,this.className))});if(l)for(t=(e||\"\").match(T)||[];s>a;a++)if(n=this$1[a],r=1===n.nodeType&&(n.className?(\" \"+n.className+\" \").replace(U,\" \"):\" \")){o=0;while(i=t[o++])0>r.indexOf(\" \"+i+\" \")&&(r+=i+\" \");n.className=x.trim(r)}return this},removeClass:function(e){\nvar this$1 = this;\nvar t,n,r,i,o,a=0,s=this.length,l=0===arguments.length||\"string\"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).removeClass(e.call(this,t,this.className))});if(l)for(t=(e||\"\").match(T)||[];s>a;a++)if(n=this$1[a],r=1===n.nodeType&&(n.className?(\" \"+n.className+\" \").replace(U,\" \"):\"\")){o=0;while(i=t[o++])while(r.indexOf(\" \"+i+\" \")>=0)r=r.replace(\" \"+i+\" \",\" \");n.className=e?x.trim(r):\"\"}return this},toggleClass:function(e,t){var n=typeof e;return\"boolean\"==typeof t&&\"string\"===n?t?this.addClass(e):this.removeClass(e):x.isFunction(e)?this.each(function(n){x(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if(\"string\"===n){var t,r=0,o=x(this),a=e.match(T)||[];while(t=a[r++])o.hasClass(t)?o.removeClass(t):o.addClass(t)}else(n===i||\"boolean\"===n)&&(this.className&&x._data(this,\"__className__\",this.className),this.className=this.className||e===!1?\"\":x._data(this,\"__className__\")||\"\")})},hasClass:function(e){\nvar this$1 = this;\nvar t=\" \"+e+\" \",n=0,r=this.length;for(;r>n;n++)if(1===this$1[n].nodeType&&(\" \"+this$1[n].className+\" \").replace(U,\" \").indexOf(t)>=0)return!0;return!1},val:function(e){var n,r,i,o=this[0];{if(arguments.length)return i=x.isFunction(e),this.each(function(n){var o;1===this.nodeType&&(o=i?e.call(this,n,x(this).val()):e,null==o?o=\"\":\"number\"==typeof o?o+=\"\":x.isArray(o)&&(o=x.map(o,function(e){return null==e?\"\":e+\"\"})),r=x.valHooks[this.type]||x.valHooks[this.nodeName.toLowerCase()],r&&\"set\"in r&&r.set(this,o,\"value\")!==t||(this.value=o))});if(o)return r=x.valHooks[o.type]||x.valHooks[o.nodeName.toLowerCase()],r&&\"get\"in r&&(n=r.get(o,\"value\"))!==t?n:(n=o.value,\"string\"==typeof n?n.replace(V,\"\"):null==n?\"\":n)}}}),x.extend({valHooks:{option:{get:function(e){var t=x.find.attr(e,\"value\");return null!=t?t:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,o=\"select-one\"===e.type||0>i,a=o?null:[],s=o?i+1:r.length,l=0>i?s:o?i:0;for(;s>l;l++)if(n=r[l],!(!n.selected&&l!==i||(x.support.optDisabled?n.disabled:null!==n.getAttribute(\"disabled\"))||n.parentNode.disabled&&x.nodeName(n.parentNode,\"optgroup\"))){if(t=x(n).val(),o)return t;a.push(t)}return a},set:function(e,t){var n,r,i=e.options,o=x.makeArray(t),a=i.length;while(a--)r=i[a],(r.selected=x.inArray(x(r).val(),o)>=0)&&(n=!0);return n||(e.selectedIndex=-1),o}}},attr:function(e,n,r){var o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return typeof e.getAttribute===i?x.prop(e,n,r):(1===s&&x.isXMLDoc(e)||(n=n.toLowerCase(),o=x.attrHooks[n]||(x.expr.match.bool.test(n)?X:z)),r===t?o&&\"get\"in o&&null!==(a=o.get(e,n))?a:(a=x.find.attr(e,n),null==a?t:a):null!==r?o&&\"set\"in o&&(a=o.set(e,r,n))!==t?a:(e.setAttribute(n,r+\"\"),r):(x.removeAttr(e,n),t))},removeAttr:function(e,t){var n,r,i=0,o=t&&t.match(T);if(o&&1===e.nodeType)while(n=o[i++])r=x.propFix[n]||n,x.expr.match.bool.test(n)?K&&Q||!G.test(n)?e[r]=!1:e[x.camelCase(\"default-\"+n)]=e[r]=!1:x.attr(e,n,\"\"),e.removeAttribute(Q?n:r)},attrHooks:{type:{set:function(e,t){if(!x.support.radioValue&&\"radio\"===t&&x.nodeName(e,\"input\")){var n=e.value;return e.setAttribute(\"type\",t),n&&(e.value=n),t}}}},propFix:{\"for\":\"htmlFor\",\"class\":\"className\"},prop:function(e,n,r){var i,o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return a=1!==s||!x.isXMLDoc(e),a&&(n=x.propFix[n]||n,o=x.propHooks[n]),r!==t?o&&\"set\"in o&&(i=o.set(e,r,n))!==t?i:e[n]=r:o&&\"get\"in o&&null!==(i=o.get(e,n))?i:e[n]},propHooks:{tabIndex:{get:function(e){var t=x.find.attr(e,\"tabindex\");return t?parseInt(t,10):Y.test(e.nodeName)||J.test(e.nodeName)&&e.href?0:-1}}}}),X={set:function(e,t,n){return t===!1?x.removeAttr(e,n):K&&Q||!G.test(n)?e.setAttribute(!Q&&x.propFix[n]||n,n):e[x.camelCase(\"default-\"+n)]=e[n]=!0,n}},x.each(x.expr.match.bool.source.match(/\\w+/g),function(e,n){var r=x.expr.attrHandle[n]||x.find.attr;x.expr.attrHandle[n]=K&&Q||!G.test(n)?function(e,n,i){var o=x.expr.attrHandle[n],a=i?t:(x.expr.attrHandle[n]=t)!=r(e,n,i)?n.toLowerCase():null;return x.expr.attrHandle[n]=o,a}:function(e,n,r){return r?t:e[x.camelCase(\"default-\"+n)]?n.toLowerCase():null}}),K&&Q||(x.attrHooks.value={set:function(e,n,r){return x.nodeName(e,\"input\")?(e.defaultValue=n,t):z&&z.set(e,n,r)}}),Q||(z={set:function(e,n,r){var i=e.getAttributeNode(r);return i||e.setAttributeNode(i=e.ownerDocument.createAttribute(r)),i.value=n+=\"\",\"value\"===r||n===e.getAttribute(r)?n:t}},x.expr.attrHandle.id=x.expr.attrHandle.name=x.expr.attrHandle.coords=function(e,n,r){var i;return r?t:(i=e.getAttributeNode(n))&&\"\"!==i.value?i.value:null},x.valHooks.button={get:function(e,n){var r=e.getAttributeNode(n);return r&&r.specified?r.value:t},set:z.set},x.attrHooks.contenteditable={set:function(e,t,n){z.set(e,\"\"===t?!1:t,n)}},x.each([\"width\",\"height\"],function(e,n){x.attrHooks[n]={set:function(e,r){return\"\"===r?(e.setAttribute(n,\"auto\"),r):t}}})),x.support.hrefNormalized||x.each([\"href\",\"src\"],function(e,t){x.propHooks[t]={get:function(e){return e.getAttribute(t,4)}}}),x.support.style||(x.attrHooks.style={get:function(e){return e.style.cssText||t},set:function(e,t){return e.style.cssText=t+\"\"}}),x.support.optSelected||(x.propHooks.selected={get:function(e){var t=e.parentNode;return t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex),null}}),x.each([\"tabIndex\",\"readOnly\",\"maxLength\",\"cellSpacing\",\"cellPadding\",\"rowSpan\",\"colSpan\",\"useMap\",\"frameBorder\",\"contentEditable\"],function(){x.propFix[this.toLowerCase()]=this}),x.support.enctype||(x.propFix.enctype=\"encoding\"),x.each([\"radio\",\"checkbox\"],function(){x.valHooks[this]={set:function(e,n){return x.isArray(n)?e.checked=x.inArray(x(e).val(),n)>=0:t}},x.support.checkOn||(x.valHooks[this].get=function(e){return null===e.getAttribute(\"value\")?\"on\":e.value})});var Z=/^(?:input|select|textarea)$/i,et=/^key/,tt=/^(?:mouse|contextmenu)|click/,nt=/^(?:focusinfocus|focusoutblur)$/,rt=/^([^.]*)(?:\\.(.+)|)$/;function it(){return!0}function ot(){return!1}function at(){try{return a.activeElement}catch(e){}}x.event={global:{},add:function(e,n,r,o,a){var s,l,u,c,p,f,d,h,g,m,y,v=x._data(e);if(v){r.handler&&(c=r,r=c.handler,a=c.selector),r.guid||(r.guid=x.guid++),(l=v.events)||(l=v.events={}),(f=v.handle)||(f=v.handle=function(e){return typeof x===i||e&&x.event.triggered===e.type?t:x.event.dispatch.apply(f.elem,arguments)},f.elem=e),n=(n||\"\").match(T)||[\"\"],u=n.length;while(u--)s=rt.exec(n[u])||[],g=y=s[1],m=(s[2]||\"\").split(\".\").sort(),g&&(p=x.event.special[g]||{},g=(a?p.delegateType:p.bindType)||g,p=x.event.special[g]||{},d=x.extend({type:g,origType:y,data:o,handler:r,guid:r.guid,selector:a,needsContext:a&&x.expr.match.needsContext.test(a),namespace:m.join(\".\")},c),(h=l[g])||(h=l[g]=[],h.delegateCount=0,p.setup&&p.setup.call(e,o,m,f)!==!1||(e.addEventListener?e.addEventListener(g,f,!1):e.attachEvent&&e.attachEvent(\"on\"+g,f))),p.add&&(p.add.call(e,d),d.handler.guid||(d.handler.guid=r.guid)),a?h.splice(h.delegateCount++,0,d):h.push(d),x.event.global[g]=!0);e=null}},remove:function(e,t,n,r,i){var o,a,s,l,u,c,p,f,d,h,g,m=x.hasData(e)&&x._data(e);if(m&&(c=m.events)){t=(t||\"\").match(T)||[\"\"],u=t.length;while(u--)if(s=rt.exec(t[u])||[],d=g=s[1],h=(s[2]||\"\").split(\".\").sort(),d){p=x.event.special[d]||{},d=(r?p.delegateType:p.bindType)||d,f=c[d]||[],s=s[2]&&RegExp(\"(^|\\\\.)\"+h.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"),l=o=f.length;while(o--)a=f[o],!i&&g!==a.origType||n&&n.guid!==a.guid||s&&!s.test(a.namespace)||r&&r!==a.selector&&(\"**\"!==r||!a.selector)||(f.splice(o,1),a.selector&&f.delegateCount--,p.remove&&p.remove.call(e,a));l&&!f.length&&(p.teardown&&p.teardown.call(e,h,m.handle)!==!1||x.removeEvent(e,d,m.handle),delete c[d])}else for(d in c)x.event.remove(e,d+t[u],n,r,!0);x.isEmptyObject(c)&&(delete m.handle,x._removeData(e,\"events\"))}},trigger:function(n,r,i,o){var s,l,u,c,p,f,d,h=[i||a],g=v.call(n,\"type\")?n.type:n,m=v.call(n,\"namespace\")?n.namespace.split(\".\"):[];if(u=f=i=i||a,3!==i.nodeType&&8!==i.nodeType&&!nt.test(g+x.event.triggered)&&(g.indexOf(\".\")>=0&&(m=g.split(\".\"),g=m.shift(),m.sort()),l=0>g.indexOf(\":\")&&\"on\"+g,n=n[x.expando]?n:new x.Event(g,\"object\"==typeof n&&n),n.isTrigger=o?2:3,n.namespace=m.join(\".\"),n.namespace_re=n.namespace?RegExp(\"(^|\\\\.)\"+m.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"):null,n.result=t,n.target||(n.target=i),r=null==r?[n]:x.makeArray(r,[n]),p=x.event.special[g]||{},o||!p.trigger||p.trigger.apply(i,r)!==!1)){if(!o&&!p.noBubble&&!x.isWindow(i)){for(c=p.delegateType||g,nt.test(c+g)||(u=u.parentNode);u;u=u.parentNode)h.push(u),f=u;f===(i.ownerDocument||a)&&h.push(f.defaultView||f.parentWindow||e)}d=0;while((u=h[d++])&&!n.isPropagationStopped())n.type=d>1?c:p.bindType||g,s=(x._data(u,\"events\")||{})[n.type]&&x._data(u,\"handle\"),s&&s.apply(u,r),s=l&&u[l],s&&x.acceptData(u)&&s.apply&&s.apply(u,r)===!1&&n.preventDefault();if(n.type=g,!o&&!n.isDefaultPrevented()&&(!p._default||p._default.apply(h.pop(),r)===!1)&&x.acceptData(i)&&l&&i[g]&&!x.isWindow(i)){f=i[l],f&&(i[l]=null),x.event.triggered=g;try{i[g]()}catch(y){}x.event.triggered=t,f&&(i[l]=f)}return n.result}},dispatch:function(e){e=x.event.fix(e);var n,r,i,o,a,s=[],l=g.call(arguments),u=(x._data(this,\"events\")||{})[e.type]||[],c=x.event.special[e.type]||{};if(l[0]=e,e.delegateTarget=this,!c.preDispatch||c.preDispatch.call(this,e)!==!1){s=x.event.handlers.call(this,e,u),n=0;while((o=s[n++])&&!e.isPropagationStopped()){e.currentTarget=o.elem,a=0;while((i=o.handlers[a++])&&!e.isImmediatePropagationStopped())(!e.namespace_re||e.namespace_re.test(i.namespace))&&(e.handleObj=i,e.data=i.data,r=((x.event.special[i.origType]||{}).handle||i.handler).apply(o.elem,l),r!==t&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,e),e.result}},handlers:function(e,n){\nvar this$1 = this;\nvar r,i,o,a,s=[],l=n.delegateCount,u=e.target;if(l&&u.nodeType&&(!e.button||\"click\"!==e.type))for(;u!=this;u=u.parentNode||this)if(1===u.nodeType&&(u.disabled!==!0||\"click\"!==e.type)){for(o=[],a=0;l>a;a++)i=n[a],r=i.selector+\" \",o[r]===t&&(o[r]=i.needsContext?x(r,this$1).index(u)>=0:x.find(r,this$1,null,[u]).length),o[r]&&o.push(i);o.length&&s.push({elem:u,handlers:o})}return n.length>l&&s.push({elem:this,handlers:n.slice(l)}),s},fix:function(e){if(e[x.expando])return e;var t,n,r,i=e.type,o=e,s=this.fixHooks[i];s||(this.fixHooks[i]=s=tt.test(i)?this.mouseHooks:et.test(i)?this.keyHooks:{}),r=s.props?this.props.concat(s.props):this.props,e=new x.Event(o),t=r.length;while(t--)n=r[t],e[n]=o[n];return e.target||(e.target=o.srcElement||a),3===e.target.nodeType&&(e.target=e.target.parentNode),e.metaKey=!!e.metaKey,s.filter?s.filter(e,o):e},props:\"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),fixHooks:{},keyHooks:{props:\"char charCode key keyCode\".split(\" \"),filter:function(e,t){return null==e.which&&(e.which=null!=t.charCode?t.charCode:t.keyCode),e}},mouseHooks:{props:\"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),filter:function(e,n){var r,i,o,s=n.button,l=n.fromElement;return null==e.pageX&&null!=n.clientX&&(i=e.target.ownerDocument||a,o=i.documentElement,r=i.body,e.pageX=n.clientX+(o&&o.scrollLeft||r&&r.scrollLeft||0)-(o&&o.clientLeft||r&&r.clientLeft||0),e.pageY=n.clientY+(o&&o.scrollTop||r&&r.scrollTop||0)-(o&&o.clientTop||r&&r.clientTop||0)),!e.relatedTarget&&l&&(e.relatedTarget=l===e.target?n.toElement:l),e.which||s===t||(e.which=1&s?1:2&s?3:4&s?2:0),e}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==at()&&this.focus)try{return this.focus(),!1}catch(e){}},delegateType:\"focusin\"},blur:{trigger:function(){return this===at()&&this.blur?(this.blur(),!1):t},delegateType:\"focusout\"},click:{trigger:function(){return x.nodeName(this,\"input\")&&\"checkbox\"===this.type&&this.click?(this.click(),!1):t},_default:function(e){return x.nodeName(e.target,\"a\")}},beforeunload:{postDispatch:function(e){e.result!==t&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=x.extend(new x.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?x.event.trigger(i,null,t):x.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},x.removeEvent=a.removeEventListener?function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)}:function(e,t,n){var r=\"on\"+t;e.detachEvent&&(typeof e[r]===i&&(e[r]=null),e.detachEvent(r,n))},x.Event=function(e,n){return this instanceof x.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.returnValue===!1||e.getPreventDefault&&e.getPreventDefault()?it:ot):this.type=e,n&&x.extend(this,n),this.timeStamp=e&&e.timeStamp||x.now(),this[x.expando]=!0,t):new x.Event(e,n)},x.Event.prototype={isDefaultPrevented:ot,isPropagationStopped:ot,isImmediatePropagationStopped:ot,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=it,e&&(e.preventDefault?e.preventDefault():e.returnValue=!1)},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=it,e&&(e.stopPropagation&&e.stopPropagation(),e.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=it,this.stopPropagation()}},x.each({mouseenter:\"mouseover\",mouseleave:\"mouseout\"},function(e,t){x.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;return(!i||i!==r&&!x.contains(r,i))&&(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),x.support.submitBubbles||(x.event.special.submit={setup:function(){return x.nodeName(this,\"form\")?!1:(x.event.add(this,\"click._submit keypress._submit\",function(e){var n=e.target,r=x.nodeName(n,\"input\")||x.nodeName(n,\"button\")?n.form:t;r&&!x._data(r,\"submitBubbles\")&&(x.event.add(r,\"submit._submit\",function(e){e._submit_bubble=!0}),x._data(r,\"submitBubbles\",!0))}),t)},postDispatch:function(e){e._submit_bubble&&(delete e._submit_bubble,this.parentNode&&!e.isTrigger&&x.event.simulate(\"submit\",this.parentNode,e,!0))},teardown:function(){return x.nodeName(this,\"form\")?!1:(x.event.remove(this,\"._submit\"),t)}}),x.support.changeBubbles||(x.event.special.change={setup:function(){return Z.test(this.nodeName)?((\"checkbox\"===this.type||\"radio\"===this.type)&&(x.event.add(this,\"propertychange._change\",function(e){\"checked\"===e.originalEvent.propertyName&&(this._just_changed=!0)}),x.event.add(this,\"click._change\",function(e){this._just_changed&&!e.isTrigger&&(this._just_changed=!1),x.event.simulate(\"change\",this,e,!0)})),!1):(x.event.add(this,\"beforeactivate._change\",function(e){var t=e.target;Z.test(t.nodeName)&&!x._data(t,\"changeBubbles\")&&(x.event.add(t,\"change._change\",function(e){!this.parentNode||e.isSimulated||e.isTrigger||x.event.simulate(\"change\",this.parentNode,e,!0)}),x._data(t,\"changeBubbles\",!0))}),t)},handle:function(e){var n=e.target;return this!==n||e.isSimulated||e.isTrigger||\"radio\"!==n.type&&\"checkbox\"!==n.type?e.handleObj.handler.apply(this,arguments):t},teardown:function(){return x.event.remove(this,\"._change\"),!Z.test(this.nodeName)}}),x.support.focusinBubbles||x.each({focus:\"focusin\",blur:\"focusout\"},function(e,t){var n=0,r=function(e){x.event.simulate(t,e.target,x.event.fix(e),!0)};x.event.special[t]={setup:function(){0===n++&&a.addEventListener(e,r,!0)},teardown:function(){0===--n&&a.removeEventListener(e,r,!0)}}}),x.fn.extend({on:function(e,n,r,i,o){\nvar this$1 = this;\nvar a,s;if(\"object\"==typeof e){\"string\"!=typeof n&&(r=r||n,n=t);for(a in e)this$1.on(a,n,r,e[a],o);return this}if(null==r&&null==i?(i=n,r=n=t):null==i&&(\"string\"==typeof n?(i=r,r=t):(i=r,r=n,n=t)),i===!1)i=ot;else if(!i)return this;return 1===o&&(s=i,i=function(e){return x().off(e),s.apply(this,arguments)},i.guid=s.guid||(s.guid=x.guid++)),this.each(function(){x.event.add(this,e,i,r,n)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,n,r){\nvar this$1 = this;\nvar i,o;if(e&&e.preventDefault&&e.handleObj)return i=e.handleObj,x(e.delegateTarget).off(i.namespace?i.origType+\".\"+i.namespace:i.origType,i.selector,i.handler),this;if(\"object\"==typeof e){for(o in e)this$1.off(o,n,e[o]);return this}return(n===!1||\"function\"==typeof n)&&(r=n,n=t),r===!1&&(r=ot),this.each(function(){x.event.remove(this,e,r,n)})},trigger:function(e,t){return this.each(function(){x.event.trigger(e,t,this)})},triggerHandler:function(e,n){var r=this[0];return r?x.event.trigger(e,n,r,!0):t}});var st=/^.[^:#\\[\\.,]*$/,lt=/^(?:parents|prev(?:Until|All))/,ut=x.expr.match.needsContext,ct={children:!0,contents:!0,next:!0,prev:!0};x.fn.extend({find:function(e){var t,n=[],r=this,i=r.length;if(\"string\"!=typeof e)return this.pushStack(x(e).filter(function(){\nvar this$1 = this;\nfor(t=0;i>t;t++)if(x.contains(r[t],this$1))return!0}));for(t=0;i>t;t++)x.find(e,r[t],n);return n=this.pushStack(i>1?x.unique(n):n),n.selector=this.selector?this.selector+\" \"+e:e,n},has:function(e){var t,n=x(e,this),r=n.length;return this.filter(function(){\nvar this$1 = this;\nfor(t=0;r>t;t++)if(x.contains(this$1,n[t]))return!0})},not:function(e){return this.pushStack(ft(this,e||[],!0))},filter:function(e){return this.pushStack(ft(this,e||[],!1))},is:function(e){return!!ft(this,\"string\"==typeof e&&ut.test(e)?x(e):e||[],!1).length},closest:function(e,t){var n,r=0,i=this.length,o=[],a=ut.test(e)||\"string\"!=typeof e?x(e,t||this.context):0;for(;i>r;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(11>n.nodeType&&(a?a.index(n)>-1:1===n.nodeType&&x.find.matchesSelector(n,e))){n=o.push(n);break}return this.pushStack(o.length>1?x.unique(o):o)},index:function(e){return e?\"string\"==typeof e?x.inArray(this[0],x(e)):x.inArray(e.jquery?e[0]:e,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){var n=\"string\"==typeof e?x(e,t):x.makeArray(e&&e.nodeType?[e]:e),r=x.merge(this.get(),n);return this.pushStack(x.unique(r))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}});function pt(e,t){do e=e[t];while(e&&1!==e.nodeType);return e}x.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return x.dir(e,\"parentNode\")},parentsUntil:function(e,t,n){return x.dir(e,\"parentNode\",n)},next:function(e){return pt(e,\"nextSibling\")},prev:function(e){return pt(e,\"previousSibling\")},nextAll:function(e){return x.dir(e,\"nextSibling\")},prevAll:function(e){return x.dir(e,\"previousSibling\")},nextUntil:function(e,t,n){return x.dir(e,\"nextSibling\",n)},prevUntil:function(e,t,n){return x.dir(e,\"previousSibling\",n)},siblings:function(e){return x.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return x.sibling(e.firstChild)},contents:function(e){return x.nodeName(e,\"iframe\")?e.contentDocument||e.contentWindow.document:x.merge([],e.childNodes)}},function(e,t){x.fn[e]=function(n,r){var i=x.map(this,t,n);return\"Until\"!==e.slice(-5)&&(r=n),r&&\"string\"==typeof r&&(i=x.filter(r,i)),this.length>1&&(ct[e]||(i=x.unique(i)),lt.test(e)&&(i=i.reverse())),this.pushStack(i)}}),x.extend({filter:function(e,t,n){var r=t[0];return n&&(e=\":not(\"+e+\")\"),1===t.length&&1===r.nodeType?x.find.matchesSelector(r,e)?[r]:[]:x.find.matches(e,x.grep(t,function(e){return 1===e.nodeType}))},dir:function(e,n,r){var i=[],o=e[n];while(o&&9!==o.nodeType&&(r===t||1!==o.nodeType||!x(o).is(r)))1===o.nodeType&&i.push(o),o=o[n];return i},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}});function ft(e,t,n){if(x.isFunction(t))return x.grep(e,function(e,r){return!!t.call(e,r,e)!==n});if(t.nodeType)return x.grep(e,function(e){return e===t!==n});if(\"string\"==typeof t){if(st.test(t))return x.filter(t,e,n);t=x.filter(t,e)}return x.grep(e,function(e){return x.inArray(e,t)>=0!==n})}function dt(e){var t=ht.split(\"|\"),n=e.createDocumentFragment();if(n.createElement)while(t.length)n.createElement(t.pop());return n}var ht=\"abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\",gt=/ jQuery\\d+=\"(?:null|\\d+)\"/g,mt=RegExp(\"<(?:\"+ht+\")[\\\\s/>]\",\"i\"),yt=/^\\s+/,vt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,bt=/<([\\w:]+)/,xt=/<tbody/i,wt=/<|&#?\\w+;/,Tt=/<(?:script|style|link)/i,Ct=/^(?:checkbox|radio)$/i,Nt=/checked\\s*(?:[^=]|=\\s*.checked.)/i,kt=/^$|\\/(?:java|ecma)script/i,Et=/^true\\/(.*)/,St=/^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,At={option:[1,\"<select multiple='multiple'>\",\"</select>\"],legend:[1,\"<fieldset>\",\"</fieldset>\"],area:[1,\"<map>\",\"</map>\"],param:[1,\"<object>\",\"</object>\"],thead:[1,\"<table>\",\"</table>\"],tr:[2,\"<table><tbody>\",\"</tbody></table>\"],col:[2,\"<table><tbody></tbody><colgroup>\",\"</colgroup></table>\"],td:[3,\"<table><tbody><tr>\",\"</tr></tbody></table>\"],_default:x.support.htmlSerialize?[0,\"\",\"\"]:[1,\"X<div>\",\"</div>\"]},jt=dt(a),Dt=jt.appendChild(a.createElement(\"div\"));At.optgroup=At.option,At.tbody=At.tfoot=At.colgroup=At.caption=At.thead,At.th=At.td,x.fn.extend({text:function(e){return x.access(this,function(e){return e===t?x.text(this):this.empty().append((this[0]&&this[0].ownerDocument||a).createTextNode(e))},null,e,arguments.length)},append:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Lt(this,e);t.appendChild(e)}})},prepend:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Lt(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){var n,r=e?x.filter(e,this):this,i=0;for(;null!=(n=r[i]);i++)t||1!==n.nodeType||x.cleanData(Ft(n)),n.parentNode&&(t&&x.contains(n.ownerDocument,n)&&_t(Ft(n,\"script\")),n.parentNode.removeChild(n));return this},empty:function(){var e,t=0;for(;null!=(e=this[t]);t++){1===e.nodeType&&x.cleanData(Ft(e,!1));while(e.firstChild)e.removeChild(e.firstChild);e.options&&x.nodeName(e,\"select\")&&(e.options.length=0)}return this},clone:function(e,t){return e=null==e?!1:e,t=null==t?e:t,this.map(function(){return x.clone(this,e,t)})},html:function(e){return x.access(this,function(e){\nvar this$1 = this;\nvar n=this[0]||{},r=0,i=this.length;if(e===t)return 1===n.nodeType?n.innerHTML.replace(gt,\"\"):t;if(!(\"string\"!=typeof e||Tt.test(e)||!x.support.htmlSerialize&&mt.test(e)||!x.support.leadingWhitespace&&yt.test(e)||At[(bt.exec(e)||[\"\",\"\"])[1].toLowerCase()])){e=e.replace(vt,\"<$1></$2>\");try{for(;i>r;r++)n=this$1[r]||{},1===n.nodeType&&(x.cleanData(Ft(n,!1)),n.innerHTML=e);n=0}catch(o){}}n&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=x.map(this,function(e){return[e.nextSibling,e.parentNode]}),t=0;return this.domManip(arguments,function(n){var r=e[t++],i=e[t++];i&&(r&&r.parentNode!==i&&(r=this.nextSibling),x(this).remove(),i.insertBefore(n,r))},!0),t?this:this.remove()},detach:function(e){return this.remove(e,!0)},domManip:function(e,t,n){\nvar this$1 = this;\ne=d.apply([],e);var r,i,o,a,s,l,u=0,c=this.length,p=this,f=c-1,h=e[0],g=x.isFunction(h);if(g||!(1>=c||\"string\"!=typeof h||x.support.checkClone)&&Nt.test(h))return this.each(function(r){var i=p.eq(r);g&&(e[0]=h.call(this,r,i.html())),i.domManip(e,t,n)});if(c&&(l=x.buildFragment(e,this[0].ownerDocument,!1,!n&&this),r=l.firstChild,1===l.childNodes.length&&(l=r),r)){for(a=x.map(Ft(l,\"script\"),Ht),o=a.length;c>u;u++)i=l,u!==f&&(i=x.clone(i,!0,!0),o&&x.merge(a,Ft(i,\"script\"))),t.call(this$1[u],i,u);if(o)for(s=a[a.length-1].ownerDocument,x.map(a,qt),u=0;o>u;u++)i=a[u],kt.test(i.type||\"\")&&!x._data(i,\"globalEval\")&&x.contains(s,i)&&(i.src?x._evalUrl(i.src):x.globalEval((i.text||i.textContent||i.innerHTML||\"\").replace(St,\"\")));l=r=null}return this}});function Lt(e,t){return x.nodeName(e,\"table\")&&x.nodeName(1===t.nodeType?t:t.firstChild,\"tr\")?e.getElementsByTagName(\"tbody\")[0]||e.appendChild(e.ownerDocument.createElement(\"tbody\")):e}function Ht(e){return e.type=(null!==x.find.attr(e,\"type\"))+\"/\"+e.type,e}function qt(e){var t=Et.exec(e.type);return t?e.type=t[1]:e.removeAttribute(\"type\"),e}function _t(e,t){var n,r=0;for(;null!=(n=e[r]);r++)x._data(n,\"globalEval\",!t||x._data(t[r],\"globalEval\"))}function Mt(e,t){if(1===t.nodeType&&x.hasData(e)){var n,r,i,o=x._data(e),a=x._data(t,o),s=o.events;if(s){delete a.handle,a.events={};for(n in s)for(r=0,i=s[n].length;i>r;r++)x.event.add(t,n,s[n][r])}a.data&&(a.data=x.extend({},a.data))}}function Ot(e,t){var n,r,i;if(1===t.nodeType){if(n=t.nodeName.toLowerCase(),!x.support.noCloneEvent&&t[x.expando]){i=x._data(t);for(r in i.events)x.removeEvent(t,r,i.handle);t.removeAttribute(x.expando)}\"script\"===n&&t.text!==e.text?(Ht(t).text=e.text,qt(t)):\"object\"===n?(t.parentNode&&(t.outerHTML=e.outerHTML),x.support.html5Clone&&e.innerHTML&&!x.trim(t.innerHTML)&&(t.innerHTML=e.innerHTML)):\"input\"===n&&Ct.test(e.type)?(t.defaultChecked=t.checked=e.checked,t.value!==e.value&&(t.value=e.value)):\"option\"===n?t.defaultSelected=t.selected=e.defaultSelected:(\"input\"===n||\"textarea\"===n)&&(t.defaultValue=e.defaultValue)}}x.each({appendTo:\"append\",prependTo:\"prepend\",insertBefore:\"before\",insertAfter:\"after\",replaceAll:\"replaceWith\"},function(e,t){x.fn[e]=function(e){\nvar this$1 = this;\nvar n,r=0,i=[],o=x(e),a=o.length-1;for(;a>=r;r++)n=r===a?this$1:this$1.clone(!0),x(o[r])[t](n),h.apply(i,n.get());return this.pushStack(i)}});function Ft(e,n){var r,o,a=0,s=typeof e.getElementsByTagName!==i?e.getElementsByTagName(n||\"*\"):typeof e.querySelectorAll!==i?e.querySelectorAll(n||\"*\"):t;if(!s)for(s=[],r=e.childNodes||e;null!=(o=r[a]);a++)!n||x.nodeName(o,n)?s.push(o):x.merge(s,Ft(o,n));return n===t||n&&x.nodeName(e,n)?x.merge([e],s):s}function Bt(e){Ct.test(e.type)&&(e.defaultChecked=e.checked)}x.extend({clone:function(e,t,n){var r,i,o,a,s,l=x.contains(e.ownerDocument,e);if(x.support.html5Clone||x.isXMLDoc(e)||!mt.test(\"<\"+e.nodeName+\">\")?o=e.cloneNode(!0):(Dt.innerHTML=e.outerHTML,Dt.removeChild(o=Dt.firstChild)),!(x.support.noCloneEvent&&x.support.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||x.isXMLDoc(e)))for(r=Ft(o),s=Ft(e),a=0;null!=(i=s[a]);++a)r[a]&&Ot(i,r[a]);if(t)if(n)for(s=s||Ft(e),r=r||Ft(o),a=0;null!=(i=s[a]);a++)Mt(i,r[a]);else Mt(e,o);return r=Ft(o,\"script\"),r.length>0&&_t(r,!l&&Ft(e,\"script\")),r=s=i=null,o},buildFragment:function(e,t,n,r){var i,o,a,s,l,u,c,p=e.length,f=dt(t),d=[],h=0;for(;p>h;h++)if(o=e[h],o||0===o)if(\"object\"===x.type(o))x.merge(d,o.nodeType?[o]:o);else if(wt.test(o)){s=s||f.appendChild(t.createElement(\"div\")),l=(bt.exec(o)||[\"\",\"\"])[1].toLowerCase(),c=At[l]||At._default,s.innerHTML=c[1]+o.replace(vt,\"<$1></$2>\")+c[2],i=c[0];while(i--)s=s.lastChild;if(!x.support.leadingWhitespace&&yt.test(o)&&d.push(t.createTextNode(yt.exec(o)[0])),!x.support.tbody){o=\"table\"!==l||xt.test(o)?\"<table>\"!==c[1]||xt.test(o)?0:s:s.firstChild,i=o&&o.childNodes.length;while(i--)x.nodeName(u=o.childNodes[i],\"tbody\")&&!u.childNodes.length&&o.removeChild(u)}x.merge(d,s.childNodes),s.textContent=\"\";while(s.firstChild)s.removeChild(s.firstChild);s=f.lastChild}else d.push(t.createTextNode(o));s&&f.removeChild(s),x.support.appendChecked||x.grep(Ft(d,\"input\"),Bt),h=0;while(o=d[h++])if((!r||-1===x.inArray(o,r))&&(a=x.contains(o.ownerDocument,o),s=Ft(f.appendChild(o),\"script\"),a&&_t(s),n)){i=0;while(o=s[i++])kt.test(o.type||\"\")&&n.push(o)}return s=null,f},cleanData:function(e,t){var n,r,o,a,s=0,l=x.expando,u=x.cache,c=x.support.deleteExpando,f=x.event.special;for(;null!=(n=e[s]);s++)if((t||x.acceptData(n))&&(o=n[l],a=o&&u[o])){if(a.events)for(r in a.events)f[r]?x.event.remove(n,r):x.removeEvent(n,r,a.handle);\nu[o]&&(delete u[o],c?delete n[l]:typeof n.removeAttribute!==i?n.removeAttribute(l):n[l]=null,p.push(o))}},_evalUrl:function(e){return x.ajax({url:e,type:\"GET\",dataType:\"script\",async:!1,global:!1,\"throws\":!0})}}),x.fn.extend({wrapAll:function(e){if(x.isFunction(e))return this.each(function(t){x(this).wrapAll(e.call(this,t))});if(this[0]){var t=x(e,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstChild&&1===e.firstChild.nodeType)e=e.firstChild;return e}).append(this)}return this},wrapInner:function(e){return x.isFunction(e)?this.each(function(t){x(this).wrapInner(e.call(this,t))}):this.each(function(){var t=x(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=x.isFunction(e);return this.each(function(n){x(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){x.nodeName(this,\"body\")||x(this).replaceWith(this.childNodes)}).end()}});var Pt,Rt,Wt,$t=/alpha\\([^)]*\\)/i,It=/opacity\\s*=\\s*([^)]*)/,zt=/^(top|right|bottom|left)$/,Xt=/^(none|table(?!-c[ea]).+)/,Ut=/^margin/,Vt=RegExp(\"^(\"+w+\")(.*)$\",\"i\"),Yt=RegExp(\"^(\"+w+\")(?!px)[a-z%]+$\",\"i\"),Jt=RegExp(\"^([+-])=(\"+w+\")\",\"i\"),Gt={BODY:\"block\"},Qt={position:\"absolute\",visibility:\"hidden\",display:\"block\"},Kt={letterSpacing:0,fontWeight:400},Zt=[\"Top\",\"Right\",\"Bottom\",\"Left\"],en=[\"Webkit\",\"O\",\"Moz\",\"ms\"];function tn(e,t){if(t in e)return t;var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=en.length;while(i--)if(t=en[i]+n,t in e)return t;return r}function nn(e,t){return e=t||e,\"none\"===x.css(e,\"display\")||!x.contains(e.ownerDocument,e)}function rn(e,t){var n,r,i,o=[],a=0,s=e.length;for(;s>a;a++)r=e[a],r.style&&(o[a]=x._data(r,\"olddisplay\"),n=r.style.display,t?(o[a]||\"none\"!==n||(r.style.display=\"\"),\"\"===r.style.display&&nn(r)&&(o[a]=x._data(r,\"olddisplay\",ln(r.nodeName)))):o[a]||(i=nn(r),(n&&\"none\"!==n||!i)&&x._data(r,\"olddisplay\",i?n:x.css(r,\"display\"))));for(a=0;s>a;a++)r=e[a],r.style&&(t&&\"none\"!==r.style.display&&\"\"!==r.style.display||(r.style.display=t?o[a]||\"\":\"none\"));return e}x.fn.extend({css:function(e,n){return x.access(this,function(e,n,r){var i,o,a={},s=0;if(x.isArray(n)){for(o=Rt(e),i=n.length;i>s;s++)a[n[s]]=x.css(e,n[s],!1,o);return a}return r!==t?x.style(e,n,r):x.css(e,n)},e,n,arguments.length>1)},show:function(){return rn(this,!0)},hide:function(){return rn(this)},toggle:function(e){return\"boolean\"==typeof e?e?this.show():this.hide():this.each(function(){nn(this)?x(this).show():x(this).hide()})}}),x.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Wt(e,\"opacity\");return\"\"===n?\"1\":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{\"float\":x.support.cssFloat?\"cssFloat\":\"styleFloat\"},style:function(e,n,r,i){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var o,a,s,l=x.camelCase(n),u=e.style;if(n=x.cssProps[l]||(x.cssProps[l]=tn(u,l)),s=x.cssHooks[n]||x.cssHooks[l],r===t)return s&&\"get\"in s&&(o=s.get(e,!1,i))!==t?o:u[n];if(a=typeof r,\"string\"===a&&(o=Jt.exec(r))&&(r=(o[1]+1)*o[2]+parseFloat(x.css(e,n)),a=\"number\"),!(null==r||\"number\"===a&&isNaN(r)||(\"number\"!==a||x.cssNumber[l]||(r+=\"px\"),x.support.clearCloneStyle||\"\"!==r||0!==n.indexOf(\"background\")||(u[n]=\"inherit\"),s&&\"set\"in s&&(r=s.set(e,r,i))===t)))try{u[n]=r}catch(c){}}},css:function(e,n,r,i){var o,a,s,l=x.camelCase(n);return n=x.cssProps[l]||(x.cssProps[l]=tn(e.style,l)),s=x.cssHooks[n]||x.cssHooks[l],s&&\"get\"in s&&(a=s.get(e,!0,r)),a===t&&(a=Wt(e,n,i)),\"normal\"===a&&n in Kt&&(a=Kt[n]),\"\"===r||r?(o=parseFloat(a),r===!0||x.isNumeric(o)?o||0:a):a}}),e.getComputedStyle?(Rt=function(t){return e.getComputedStyle(t,null)},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),l=s?s.getPropertyValue(n)||s[n]:t,u=e.style;return s&&(\"\"!==l||x.contains(e.ownerDocument,e)||(l=x.style(e,n)),Yt.test(l)&&Ut.test(n)&&(i=u.width,o=u.minWidth,a=u.maxWidth,u.minWidth=u.maxWidth=u.width=l,l=s.width,u.width=i,u.minWidth=o,u.maxWidth=a)),l}):a.documentElement.currentStyle&&(Rt=function(e){return e.currentStyle},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),l=s?s[n]:t,u=e.style;return null==l&&u&&u[n]&&(l=u[n]),Yt.test(l)&&!zt.test(n)&&(i=u.left,o=e.runtimeStyle,a=o&&o.left,a&&(o.left=e.currentStyle.left),u.left=\"fontSize\"===n?\"1em\":l,l=u.pixelLeft+\"px\",u.left=i,a&&(o.left=a)),\"\"===l?\"auto\":l});function on(e,t,n){var r=Vt.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||\"px\"):t}function an(e,t,n,r,i){var o=n===(r?\"border\":\"content\")?4:\"width\"===t?1:0,a=0;for(;4>o;o+=2)\"margin\"===n&&(a+=x.css(e,n+Zt[o],!0,i)),r?(\"content\"===n&&(a-=x.css(e,\"padding\"+Zt[o],!0,i)),\"margin\"!==n&&(a-=x.css(e,\"border\"+Zt[o]+\"Width\",!0,i))):(a+=x.css(e,\"padding\"+Zt[o],!0,i),\"padding\"!==n&&(a+=x.css(e,\"border\"+Zt[o]+\"Width\",!0,i)));return a}function sn(e,t,n){var r=!0,i=\"width\"===t?e.offsetWidth:e.offsetHeight,o=Rt(e),a=x.support.boxSizing&&\"border-box\"===x.css(e,\"boxSizing\",!1,o);if(0>=i||null==i){if(i=Wt(e,t,o),(0>i||null==i)&&(i=e.style[t]),Yt.test(i))return i;r=a&&(x.support.boxSizingReliable||i===e.style[t]),i=parseFloat(i)||0}return i+an(e,t,n||(a?\"border\":\"content\"),r,o)+\"px\"}function ln(e){var t=a,n=Gt[e];return n||(n=un(e,t),\"none\"!==n&&n||(Pt=(Pt||x(\"<iframe frameborder='0' width='0' height='0'/>\").css(\"cssText\",\"display:block !important\")).appendTo(t.documentElement),t=(Pt[0].contentWindow||Pt[0].contentDocument).document,t.write(\"<!doctype html><html><body>\"),t.close(),n=un(e,t),Pt.detach()),Gt[e]=n),n}function un(e,t){var n=x(t.createElement(e)).appendTo(t.body),r=x.css(n[0],\"display\");return n.remove(),r}x.each([\"height\",\"width\"],function(e,n){x.cssHooks[n]={get:function(e,r,i){return r?0===e.offsetWidth&&Xt.test(x.css(e,\"display\"))?x.swap(e,Qt,function(){return sn(e,n,i)}):sn(e,n,i):t},set:function(e,t,r){var i=r&&Rt(e);return on(e,t,r?an(e,n,r,x.support.boxSizing&&\"border-box\"===x.css(e,\"boxSizing\",!1,i),i):0)}}}),x.support.opacity||(x.cssHooks.opacity={get:function(e,t){return It.test((t&&e.currentStyle?e.currentStyle.filter:e.style.filter)||\"\")?.01*parseFloat(RegExp.$1)+\"\":t?\"1\":\"\"},set:function(e,t){var n=e.style,r=e.currentStyle,i=x.isNumeric(t)?\"alpha(opacity=\"+100*t+\")\":\"\",o=r&&r.filter||n.filter||\"\";n.zoom=1,(t>=1||\"\"===t)&&\"\"===x.trim(o.replace($t,\"\"))&&n.removeAttribute&&(n.removeAttribute(\"filter\"),\"\"===t||r&&!r.filter)||(n.filter=$t.test(o)?o.replace($t,i):o+\" \"+i)}}),x(function(){x.support.reliableMarginRight||(x.cssHooks.marginRight={get:function(e,n){return n?x.swap(e,{display:\"inline-block\"},Wt,[e,\"marginRight\"]):t}}),!x.support.pixelPosition&&x.fn.position&&x.each([\"top\",\"left\"],function(e,n){x.cssHooks[n]={get:function(e,r){return r?(r=Wt(e,n),Yt.test(r)?x(e).position()[n]+\"px\":r):t}}})}),x.expr&&x.expr.filters&&(x.expr.filters.hidden=function(e){return 0>=e.offsetWidth&&0>=e.offsetHeight||!x.support.reliableHiddenOffsets&&\"none\"===(e.style&&e.style.display||x.css(e,\"display\"))},x.expr.filters.visible=function(e){return!x.expr.filters.hidden(e)}),x.each({margin:\"\",padding:\"\",border:\"Width\"},function(e,t){x.cssHooks[e+t]={expand:function(n){var r=0,i={},o=\"string\"==typeof n?n.split(\" \"):[n];for(;4>r;r++)i[e+Zt[r]+t]=o[r]||o[r-2]||o[0];return i}},Ut.test(e)||(x.cssHooks[e+t].set=on)});var cn=/%20/g,pn=/\\[\\]$/,fn=/\\r?\\n/g,dn=/^(?:submit|button|image|reset|file)$/i,hn=/^(?:input|select|textarea|keygen)/i;x.fn.extend({serialize:function(){return x.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=x.prop(this,\"elements\");return e?x.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!x(this).is(\":disabled\")&&hn.test(this.nodeName)&&!dn.test(e)&&(this.checked||!Ct.test(e))}).map(function(e,t){var n=x(this).val();return null==n?null:x.isArray(n)?x.map(n,function(e){return{name:t.name,value:e.replace(fn,\"\\r\\n\")}}):{name:t.name,value:n.replace(fn,\"\\r\\n\")}}).get()}}),x.param=function(e,n){var r,i=[],o=function(e,t){t=x.isFunction(t)?t():null==t?\"\":t,i[i.length]=encodeURIComponent(e)+\"=\"+encodeURIComponent(t)};if(n===t&&(n=x.ajaxSettings&&x.ajaxSettings.traditional),x.isArray(e)||e.jquery&&!x.isPlainObject(e))x.each(e,function(){o(this.name,this.value)});else for(r in e)gn(r,e[r],n,o);return i.join(\"&\").replace(cn,\"+\")};function gn(e,t,n,r){var i;if(x.isArray(t))x.each(t,function(t,i){n||pn.test(e)?r(e,i):gn(e+\"[\"+(\"object\"==typeof i?t:\"\")+\"]\",i,n,r)});else if(n||\"object\"!==x.type(t))r(e,t);else for(i in t)gn(e+\"[\"+i+\"]\",t[i],n,r)}x.each(\"blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu\".split(\" \"),function(e,t){x.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),x.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,\"**\"):this.off(t,e||\"**\",n)}});var mn,yn,vn=x.now(),bn=/\\?/,xn=/#.*$/,wn=/([?&])_=[^&]*/,Tn=/^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/gm,Cn=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Nn=/^(?:GET|HEAD)$/,kn=/^\\/\\//,En=/^([\\w.+-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+)|)|)/,Sn=x.fn.load,An={},jn={},Dn=\"*/\".concat(\"*\");try{yn=o.href}catch(Ln){yn=a.createElement(\"a\"),yn.href=\"\",yn=yn.href}mn=En.exec(yn.toLowerCase())||[];function Hn(e){return function(t,n){\"string\"!=typeof t&&(n=t,t=\"*\");var r,i=0,o=t.toLowerCase().match(T)||[];if(x.isFunction(n))while(r=o[i++])\"+\"===r[0]?(r=r.slice(1)||\"*\",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function qn(e,n,r,i){var o={},a=e===jn;function s(l){var u;return o[l]=!0,x.each(e[l]||[],function(e,l){var c=l(n,r,i);return\"string\"!=typeof c||a||o[c]?a?!(u=c):t:(n.dataTypes.unshift(c),s(c),!1)}),u}return s(n.dataTypes[0])||!o[\"*\"]&&s(\"*\")}function _n(e,n){var r,i,o=x.ajaxSettings.flatOptions||{};for(i in n)n[i]!==t&&((o[i]?e:r||(r={}))[i]=n[i]);return r&&x.extend(!0,e,r),e}x.fn.load=function(e,n,r){if(\"string\"!=typeof e&&Sn)return Sn.apply(this,arguments);var i,o,a,s=this,l=e.indexOf(\" \");return l>=0&&(i=e.slice(l,e.length),e=e.slice(0,l)),x.isFunction(n)?(r=n,n=t):n&&\"object\"==typeof n&&(a=\"POST\"),s.length>0&&x.ajax({url:e,type:a,dataType:\"html\",data:n}).done(function(e){o=arguments,s.html(i?x(\"<div>\").append(x.parseHTML(e)).find(i):e)}).complete(r&&function(e,t){s.each(r,o||[e.responseText,t,e])}),this},x.each([\"ajaxStart\",\"ajaxStop\",\"ajaxComplete\",\"ajaxError\",\"ajaxSuccess\",\"ajaxSend\"],function(e,t){x.fn[t]=function(e){return this.on(t,e)}}),x.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:yn,type:\"GET\",isLocal:Cn.test(mn[1]),global:!0,processData:!0,async:!0,contentType:\"application/x-www-form-urlencoded; charset=UTF-8\",accepts:{\"*\":Dn,text:\"text/plain\",html:\"text/html\",xml:\"application/xml, text/xml\",json:\"application/json, text/javascript\"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:\"responseXML\",text:\"responseText\",json:\"responseJSON\"},converters:{\"* text\":String,\"text html\":!0,\"text json\":x.parseJSON,\"text xml\":x.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?_n(_n(e,x.ajaxSettings),t):_n(x.ajaxSettings,e)},ajaxPrefilter:Hn(An),ajaxTransport:Hn(jn),ajax:function(e,n){\"object\"==typeof e&&(n=e,e=t),n=n||{};var r,i,o,a,s,l,u,c,p=x.ajaxSetup({},n),f=p.context||p,d=p.context&&(f.nodeType||f.jquery)?x(f):x.event,h=x.Deferred(),g=x.Callbacks(\"once memory\"),m=p.statusCode||{},y={},v={},b=0,w=\"canceled\",C={readyState:0,getResponseHeader:function(e){var t;if(2===b){if(!c){c={};while(t=Tn.exec(a))c[t[1].toLowerCase()]=t[2]}t=c[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return 2===b?a:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return b||(e=v[n]=v[n]||e,y[e]=t),this},overrideMimeType:function(e){return b||(p.mimeType=e),this},statusCode:function(e){var t;if(e)if(2>b)for(t in e)m[t]=[m[t],e[t]];else C.always(e[C.status]);return this},abort:function(e){var t=e||w;return u&&u.abort(t),k(0,t),this}};if(h.promise(C).complete=g.add,C.success=C.done,C.error=C.fail,p.url=((e||p.url||yn)+\"\").replace(xn,\"\").replace(kn,mn[1]+\"//\"),p.type=n.method||n.type||p.method||p.type,p.dataTypes=x.trim(p.dataType||\"*\").toLowerCase().match(T)||[\"\"],null==p.crossDomain&&(r=En.exec(p.url.toLowerCase()),p.crossDomain=!(!r||r[1]===mn[1]&&r[2]===mn[2]&&(r[3]||(\"http:\"===r[1]?\"80\":\"443\"))===(mn[3]||(\"http:\"===mn[1]?\"80\":\"443\")))),p.data&&p.processData&&\"string\"!=typeof p.data&&(p.data=x.param(p.data,p.traditional)),qn(An,p,n,C),2===b)return C;l=p.global,l&&0===x.active++&&x.event.trigger(\"ajaxStart\"),p.type=p.type.toUpperCase(),p.hasContent=!Nn.test(p.type),o=p.url,p.hasContent||(p.data&&(o=p.url+=(bn.test(o)?\"&\":\"?\")+p.data,delete p.data),p.cache===!1&&(p.url=wn.test(o)?o.replace(wn,\"$1_=\"+vn++):o+(bn.test(o)?\"&\":\"?\")+\"_=\"+vn++)),p.ifModified&&(x.lastModified[o]&&C.setRequestHeader(\"If-Modified-Since\",x.lastModified[o]),x.etag[o]&&C.setRequestHeader(\"If-None-Match\",x.etag[o])),(p.data&&p.hasContent&&p.contentType!==!1||n.contentType)&&C.setRequestHeader(\"Content-Type\",p.contentType),C.setRequestHeader(\"Accept\",p.dataTypes[0]&&p.accepts[p.dataTypes[0]]?p.accepts[p.dataTypes[0]]+(\"*\"!==p.dataTypes[0]?\", \"+Dn+\"; q=0.01\":\"\"):p.accepts[\"*\"]);for(i in p.headers)C.setRequestHeader(i,p.headers[i]);if(p.beforeSend&&(p.beforeSend.call(f,C,p)===!1||2===b))return C.abort();w=\"abort\";for(i in{success:1,error:1,complete:1})C[i](p[i]);if(u=qn(jn,p,n,C)){C.readyState=1,l&&d.trigger(\"ajaxSend\",[C,p]),p.async&&p.timeout>0&&(s=setTimeout(function(){C.abort(\"timeout\")},p.timeout));try{b=1,u.send(y,k)}catch(N){if(!(2>b))throw N;k(-1,N)}}else k(-1,\"No Transport\");function k(e,n,r,i){var c,y,v,w,T,N=n;2!==b&&(b=2,s&&clearTimeout(s),u=t,a=i||\"\",C.readyState=e>0?4:0,c=e>=200&&300>e||304===e,r&&(w=Mn(p,C,r)),w=On(p,w,C,c),c?(p.ifModified&&(T=C.getResponseHeader(\"Last-Modified\"),T&&(x.lastModified[o]=T),T=C.getResponseHeader(\"etag\"),T&&(x.etag[o]=T)),204===e||\"HEAD\"===p.type?N=\"nocontent\":304===e?N=\"notmodified\":(N=w.state,y=w.data,v=w.error,c=!v)):(v=N,(e||!N)&&(N=\"error\",0>e&&(e=0))),C.status=e,C.statusText=(n||N)+\"\",c?h.resolveWith(f,[y,N,C]):h.rejectWith(f,[C,N,v]),C.statusCode(m),m=t,l&&d.trigger(c?\"ajaxSuccess\":\"ajaxError\",[C,p,c?y:v]),g.fireWith(f,[C,N]),l&&(d.trigger(\"ajaxComplete\",[C,p]),--x.active||x.event.trigger(\"ajaxStop\")))}return C},getJSON:function(e,t,n){return x.get(e,t,n,\"json\")},getScript:function(e,n){return x.get(e,t,n,\"script\")}}),x.each([\"get\",\"post\"],function(e,n){x[n]=function(e,r,i,o){return x.isFunction(r)&&(o=o||i,i=r,r=t),x.ajax({url:e,type:n,dataType:o,data:r,success:i})}});function Mn(e,n,r){var i,o,a,s,l=e.contents,u=e.dataTypes;while(\"*\"===u[0])u.shift(),o===t&&(o=e.mimeType||n.getResponseHeader(\"Content-Type\"));if(o)for(s in l)if(l[s]&&l[s].test(o)){u.unshift(s);break}if(u[0]in r)a=u[0];else{for(s in r){if(!u[0]||e.converters[s+\" \"+u[0]]){a=s;break}i||(i=s)}a=a||i}return a?(a!==u[0]&&u.unshift(a),r[a]):t}function On(e,t,n,r){var i,o,a,s,l,u={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)u[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!l&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),l=o,o=c.shift())if(\"*\"===o)o=l;else if(\"*\"!==l&&l!==o){if(a=u[l+\" \"+o]||u[\"* \"+o],!a)for(i in u)if(s=i.split(\" \"),s[1]===o&&(a=u[l+\" \"+s[0]]||u[\"* \"+s[0]])){a===!0?a=u[i]:u[i]!==!0&&(o=s[0],c.unshift(s[1]));break}if(a!==!0)if(a&&e[\"throws\"])t=a(t);else try{t=a(t)}catch(p){return{state:\"parsererror\",error:a?p:\"No conversion from \"+l+\" to \"+o}}}return{state:\"success\",data:t}}x.ajaxSetup({accepts:{script:\"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"},contents:{script:/(?:java|ecma)script/},converters:{\"text script\":function(e){return x.globalEval(e),e}}}),x.ajaxPrefilter(\"script\",function(e){e.cache===t&&(e.cache=!1),e.crossDomain&&(e.type=\"GET\",e.global=!1)}),x.ajaxTransport(\"script\",function(e){if(e.crossDomain){var n,r=a.head||x(\"head\")[0]||a.documentElement;return{send:function(t,i){n=a.createElement(\"script\"),n.async=!0,e.scriptCharset&&(n.charset=e.scriptCharset),n.src=e.url,n.onload=n.onreadystatechange=function(e,t){(t||!n.readyState||/loaded|complete/.test(n.readyState))&&(n.onload=n.onreadystatechange=null,n.parentNode&&n.parentNode.removeChild(n),n=null,t||i(200,\"success\"))},r.insertBefore(n,r.firstChild)},abort:function(){n&&n.onload(t,!0)}}}});var Fn=[],Bn=/(=)\\?(?=&|$)|\\?\\?/;x.ajaxSetup({jsonp:\"callback\",jsonpCallback:function(){var e=Fn.pop()||x.expando+\"_\"+vn++;return this[e]=!0,e}}),x.ajaxPrefilter(\"json jsonp\",function(n,r,i){var o,a,s,l=n.jsonp!==!1&&(Bn.test(n.url)?\"url\":\"string\"==typeof n.data&&!(n.contentType||\"\").indexOf(\"application/x-www-form-urlencoded\")&&Bn.test(n.data)&&\"data\");return l||\"jsonp\"===n.dataTypes[0]?(o=n.jsonpCallback=x.isFunction(n.jsonpCallback)?n.jsonpCallback():n.jsonpCallback,l?n[l]=n[l].replace(Bn,\"$1\"+o):n.jsonp!==!1&&(n.url+=(bn.test(n.url)?\"&\":\"?\")+n.jsonp+\"=\"+o),n.converters[\"script json\"]=function(){return s||x.error(o+\" was not called\"),s[0]},n.dataTypes[0]=\"json\",a=e[o],e[o]=function(){s=arguments},i.always(function(){e[o]=a,n[o]&&(n.jsonpCallback=r.jsonpCallback,Fn.push(o)),s&&x.isFunction(a)&&a(s[0]),s=a=t}),\"script\"):t});var Pn,Rn,Wn=0,$n=e.ActiveXObject&&function(){var e;for(e in Pn)Pn[e](t,!0)};function In(){try{return new e.XMLHttpRequest}catch(t){}}function zn(){try{return new e.ActiveXObject(\"Microsoft.XMLHTTP\")}catch(t){}}x.ajaxSettings.xhr=e.ActiveXObject?function(){return!this.isLocal&&In()||zn()}:In,Rn=x.ajaxSettings.xhr(),x.support.cors=!!Rn&&\"withCredentials\"in Rn,Rn=x.support.ajax=!!Rn,Rn&&x.ajaxTransport(function(n){if(!n.crossDomain||x.support.cors){var r;return{send:function(i,o){var a,s,l=n.xhr();if(n.username?l.open(n.type,n.url,n.async,n.username,n.password):l.open(n.type,n.url,n.async),n.xhrFields)for(s in n.xhrFields)l[s]=n.xhrFields[s];n.mimeType&&l.overrideMimeType&&l.overrideMimeType(n.mimeType),n.crossDomain||i[\"X-Requested-With\"]||(i[\"X-Requested-With\"]=\"XMLHttpRequest\");try{for(s in i)l.setRequestHeader(s,i[s])}catch(u){}l.send(n.hasContent&&n.data||null),r=function(e,i){var s,u,c,p;try{if(r&&(i||4===l.readyState))if(r=t,a&&(l.onreadystatechange=x.noop,$n&&delete Pn[a]),i)4!==l.readyState&&l.abort();else{p={},s=l.status,u=l.getAllResponseHeaders(),\"string\"==typeof l.responseText&&(p.text=l.responseText);try{c=l.statusText}catch(f){c=\"\"}s||!n.isLocal||n.crossDomain?1223===s&&(s=204):s=p.text?200:404}}catch(d){i||o(-1,d)}p&&o(s,c,p,u)},n.async?4===l.readyState?setTimeout(r):(a=++Wn,$n&&(Pn||(Pn={},x(e).unload($n)),Pn[a]=r),l.onreadystatechange=r):r()},abort:function(){r&&r(t,!0)}}}});var Xn,Un,Vn=/^(?:toggle|show|hide)$/,Yn=RegExp(\"^(?:([+-])=|)(\"+w+\")([a-z%]*)$\",\"i\"),Jn=/queueHooks$/,Gn=[nr],Qn={\"*\":[function(e,t){var n=this.createTween(e,t),r=n.cur(),i=Yn.exec(t),o=i&&i[3]||(x.cssNumber[e]?\"\":\"px\"),a=(x.cssNumber[e]||\"px\"!==o&&+r)&&Yn.exec(x.css(n.elem,e)),s=1,l=20;if(a&&a[3]!==o){o=o||a[3],i=i||[],a=+r||1;do s=s||\".5\",a/=s,x.style(n.elem,e,a+o);while(s!==(s=n.cur()/r)&&1!==s&&--l)}return i&&(a=n.start=+a||+r||0,n.unit=o,n.end=i[1]?a+(i[1]+1)*i[2]:+i[2]),n}]};function Kn(){return setTimeout(function(){Xn=t}),Xn=x.now()}function Zn(e,t,n){var r,i=(Qn[t]||[]).concat(Qn[\"*\"]),o=0,a=i.length;for(;a>o;o++)if(r=i[o].call(n,t,e))return r}function er(e,t,n){var r,i,o=0,a=Gn.length,s=x.Deferred().always(function(){delete l.elem}),l=function(){if(i)return!1;var t=Xn||Kn(),n=Math.max(0,u.startTime+u.duration-t),r=n/u.duration||0,o=1-r,a=0,l=u.tweens.length;for(;l>a;a++)u.tweens[a].run(o);return s.notifyWith(e,[u,o,n]),1>o&&l?n:(s.resolveWith(e,[u]),!1)},u=s.promise({elem:e,props:x.extend({},t),opts:x.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:Xn||Kn(),duration:n.duration,tweens:[],createTween:function(t,n){var r=x.Tween(e,u.opts,t,n,u.opts.specialEasing[t]||u.opts.easing);return u.tweens.push(r),r},stop:function(t){var n=0,r=t?u.tweens.length:0;if(i)return this;for(i=!0;r>n;n++)u.tweens[n].run(1);return t?s.resolveWith(e,[u,t]):s.rejectWith(e,[u,t]),this}}),c=u.props;for(tr(c,u.opts.specialEasing);a>o;o++)if(r=Gn[o].call(u,e,c,u.opts))return r;return x.map(c,Zn,u),x.isFunction(u.opts.start)&&u.opts.start.call(e,u),x.fx.timer(x.extend(l,{elem:e,anim:u,queue:u.opts.queue})),u.progress(u.opts.progress).done(u.opts.done,u.opts.complete).fail(u.opts.fail).always(u.opts.always)}function tr(e,t){var n,r,i,o,a;for(n in e)if(r=x.camelCase(n),i=t[r],o=e[n],x.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),a=x.cssHooks[r],a&&\"expand\"in a){o=a.expand(o),delete e[r];for(n in o)n in e||(e[n]=o[n],t[n]=i)}else t[r]=i}x.Animation=x.extend(er,{tweener:function(e,t){x.isFunction(e)?(t=e,e=[\"*\"]):e=e.split(\" \");var n,r=0,i=e.length;for(;i>r;r++)n=e[r],Qn[n]=Qn[n]||[],Qn[n].unshift(t)},prefilter:function(e,t){t?Gn.unshift(e):Gn.push(e)}});function nr(e,t,n){var r,i,o,a,s,l,u=this,c={},p=e.style,f=e.nodeType&&nn(e),d=x._data(e,\"fxshow\");n.queue||(s=x._queueHooks(e,\"fx\"),null==s.unqueued&&(s.unqueued=0,l=s.empty.fire,s.empty.fire=function(){s.unqueued||l()}),s.unqueued++,u.always(function(){u.always(function(){s.unqueued--,x.queue(e,\"fx\").length||s.empty.fire()})})),1===e.nodeType&&(\"height\"in t||\"width\"in t)&&(n.overflow=[p.overflow,p.overflowX,p.overflowY],\"inline\"===x.css(e,\"display\")&&\"none\"===x.css(e,\"float\")&&(x.support.inlineBlockNeedsLayout&&\"inline\"!==ln(e.nodeName)?p.zoom=1:p.display=\"inline-block\")),n.overflow&&(p.overflow=\"hidden\",x.support.shrinkWrapBlocks||u.always(function(){p.overflow=n.overflow[0],p.overflowX=n.overflow[1],p.overflowY=n.overflow[2]}));for(r in t)if(i=t[r],Vn.exec(i)){if(delete t[r],o=o||\"toggle\"===i,i===(f?\"hide\":\"show\"))continue;c[r]=d&&d[r]||x.style(e,r)}if(!x.isEmptyObject(c)){d?\"hidden\"in d&&(f=d.hidden):d=x._data(e,\"fxshow\",{}),o&&(d.hidden=!f),f?x(e).show():u.done(function(){x(e).hide()}),u.done(function(){var t;x._removeData(e,\"fxshow\");for(t in c)x.style(e,t,c[t])});for(r in c)a=Zn(f?d[r]:0,r,u),r in d||(d[r]=a.start,f&&(a.end=a.start,a.start=\"width\"===r||\"height\"===r?1:0))}}function rr(e,t,n,r,i){return new rr.prototype.init(e,t,n,r,i)}x.Tween=rr,rr.prototype={constructor:rr,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||\"swing\",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(x.cssNumber[n]?\"\":\"px\")},cur:function(){var e=rr.propHooks[this.prop];return e&&e.get?e.get(this):rr.propHooks._default.get(this)},run:function(e){var t,n=rr.propHooks[this.prop];return this.pos=t=this.options.duration?x.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):rr.propHooks._default.set(this),this}},rr.prototype.init.prototype=rr.prototype,rr.propHooks={_default:{get:function(e){var t;return null==e.elem[e.prop]||e.elem.style&&null!=e.elem.style[e.prop]?(t=x.css(e.elem,e.prop,\"\"),t&&\"auto\"!==t?t:0):e.elem[e.prop]},set:function(e){x.fx.step[e.prop]?x.fx.step[e.prop](e):e.elem.style&&(null!=e.elem.style[x.cssProps[e.prop]]||x.cssHooks[e.prop])?x.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},rr.propHooks.scrollTop=rr.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},x.each([\"toggle\",\"show\",\"hide\"],function(e,t){var n=x.fn[t];x.fn[t]=function(e,r,i){return null==e||\"boolean\"==typeof e?n.apply(this,arguments):this.animate(ir(t,!0),e,r,i)}}),x.fn.extend({fadeTo:function(e,t,n,r){return this.filter(nn).css(\"opacity\",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=x.isEmptyObject(e),o=x.speed(t,n,r),a=function(){var t=er(this,x.extend({},e),o);(i||x._data(this,\"finish\"))&&t.stop(!0)};return a.finish=a,i||o.queue===!1?this.each(a):this.queue(o.queue,a)},stop:function(e,n,r){var i=function(e){var t=e.stop;delete e.stop,t(r)};return\"string\"!=typeof e&&(r=n,n=e,e=t),n&&e!==!1&&this.queue(e||\"fx\",[]),this.each(function(){\nvar this$1 = this;\nvar t=!0,n=null!=e&&e+\"queueHooks\",o=x.timers,a=x._data(this);if(n)a[n]&&a[n].stop&&i(a[n]);else for(n in a)a[n]&&a[n].stop&&Jn.test(n)&&i(a[n]);for(n=o.length;n--;)o[n].elem!==this$1||null!=e&&o[n].queue!==e||(o[n].anim.stop(r),t=!1,o.splice(n,1));(t||!r)&&x.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||\"fx\"),this.each(function(){\nvar this$1 = this;\nvar t,n=x._data(this),r=n[e+\"queue\"],i=n[e+\"queueHooks\"],o=x.timers,a=r?r.length:0;for(n.finish=!0,x.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),t=o.length;t--;)o[t].elem===this$1&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;a>t;t++)r[t]&&r[t].finish&&r[t].finish.call(this$1);delete n.finish})}});function ir(e,t){var n,r={height:e},i=0;for(t=t?1:0;4>i;i+=2-t)n=Zt[i],r[\"margin\"+n]=r[\"padding\"+n]=e;return t&&(r.opacity=r.width=e),r}x.each({slideDown:ir(\"show\"),slideUp:ir(\"hide\"),slideToggle:ir(\"toggle\"),fadeIn:{opacity:\"show\"},fadeOut:{opacity:\"hide\"},fadeToggle:{opacity:\"toggle\"}},function(e,t){x.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),x.speed=function(e,t,n){var r=e&&\"object\"==typeof e?x.extend({},e):{complete:n||!n&&t||x.isFunction(e)&&e,duration:e,easing:n&&t||t&&!x.isFunction(t)&&t};return r.duration=x.fx.off?0:\"number\"==typeof r.duration?r.duration:r.duration in x.fx.speeds?x.fx.speeds[r.duration]:x.fx.speeds._default,(null==r.queue||r.queue===!0)&&(r.queue=\"fx\"),r.old=r.complete,r.complete=function(){x.isFunction(r.old)&&r.old.call(this),r.queue&&x.dequeue(this,r.queue)},r},x.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},x.timers=[],x.fx=rr.prototype.init,x.fx.tick=function(){var e,n=x.timers,r=0;for(Xn=x.now();n.length>r;r++)e=n[r],e()||n[r]!==e||n.splice(r--,1);n.length||x.fx.stop(),Xn=t},x.fx.timer=function(e){e()&&x.timers.push(e)&&x.fx.start()},x.fx.interval=13,x.fx.start=function(){Un||(Un=setInterval(x.fx.tick,x.fx.interval))},x.fx.stop=function(){clearInterval(Un),Un=null},x.fx.speeds={slow:600,fast:200,_default:400},x.fx.step={},x.expr&&x.expr.filters&&(x.expr.filters.animated=function(e){return x.grep(x.timers,function(t){return e===t.elem}).length}),x.fn.offset=function(e){if(arguments.length)return e===t?this:this.each(function(t){x.offset.setOffset(this,e,t)});var n,r,o={top:0,left:0},a=this[0],s=a&&a.ownerDocument;if(s)return n=s.documentElement,x.contains(n,a)?(typeof a.getBoundingClientRect!==i&&(o=a.getBoundingClientRect()),r=or(s),{top:o.top+(r.pageYOffset||n.scrollTop)-(n.clientTop||0),left:o.left+(r.pageXOffset||n.scrollLeft)-(n.clientLeft||0)}):o},x.offset={setOffset:function(e,t,n){var r=x.css(e,\"position\");\"static\"===r&&(e.style.position=\"relative\");var i=x(e),o=i.offset(),a=x.css(e,\"top\"),s=x.css(e,\"left\"),l=(\"absolute\"===r||\"fixed\"===r)&&x.inArray(\"auto\",[a,s])>-1,u={},c={},p,f;l?(c=i.position(),p=c.top,f=c.left):(p=parseFloat(a)||0,f=parseFloat(s)||0),x.isFunction(t)&&(t=t.call(e,n,o)),null!=t.top&&(u.top=t.top-o.top+p),null!=t.left&&(u.left=t.left-o.left+f),\"using\"in t?t.using.call(e,u):i.css(u)}},x.fn.extend({position:function(){if(this[0]){var e,t,n={top:0,left:0},r=this[0];return\"fixed\"===x.css(r,\"position\")?t=r.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),x.nodeName(e[0],\"html\")||(n=e.offset()),n.top+=x.css(e[0],\"borderTopWidth\",!0),n.left+=x.css(e[0],\"borderLeftWidth\",!0)),{top:t.top-n.top-x.css(r,\"marginTop\",!0),left:t.left-n.left-x.css(r,\"marginLeft\",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent||s;while(e&&!x.nodeName(e,\"html\")&&\"static\"===x.css(e,\"position\"))e=e.offsetParent;return e||s})}}),x.each({scrollLeft:\"pageXOffset\",scrollTop:\"pageYOffset\"},function(e,n){var r=/Y/.test(n);x.fn[e]=function(i){return x.access(this,function(e,i,o){var a=or(e);return o===t?a?n in a?a[n]:a.document.documentElement[i]:e[i]:(a?a.scrollTo(r?x(a).scrollLeft():o,r?o:x(a).scrollTop()):e[i]=o,t)},e,i,arguments.length,null)}});function or(e){return x.isWindow(e)?e:9===e.nodeType?e.defaultView||e.parentWindow:!1}x.each({Height:\"height\",Width:\"width\"},function(e,n){x.each({padding:\"inner\"+e,content:n,\"\":\"outer\"+e},function(r,i){x.fn[i]=function(i,o){var a=arguments.length&&(r||\"boolean\"!=typeof i),s=r||(i===!0||o===!0?\"margin\":\"border\");return x.access(this,function(n,r,i){var o;return x.isWindow(n)?n.document.documentElement[\"client\"+e]:9===n.nodeType?(o=n.documentElement,Math.max(n.body[\"scroll\"+e],o[\"scroll\"+e],n.body[\"offset\"+e],o[\"offset\"+e],o[\"client\"+e])):i===t?x.css(n,r,s):x.style(n,r,i,s)},n,a?i:t,a,null)}})}),x.fn.size=function(){return this.length},x.fn.andSelf=x.fn.addBack,\"object\"==typeof module&&module&&\"object\"==typeof module.exports?module.exports=x:(e.jQuery=e.$=x,\"function\"==\"function\"&&__webpack_require__(1)&&!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function(){return x}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)))})(window);\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)(module)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9yZXNvdXJjZXMvYXNzZXRzL2pzL3ZlbmRvci9qcXVlcnkuanM/MThkNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgalF1ZXJ5IHYxLjEwLjIgfCAoYykgMjAwNSwgMjAxMyBqUXVlcnkgRm91bmRhdGlvbiwgSW5jLiB8IGpxdWVyeS5vcmcvbGljZW5zZVxuLy9AIHNvdXJjZU1hcHBpbmdVUkw9anF1ZXJ5LTEuMTAuMi5taW4ubWFwXG4qL1xuKGZ1bmN0aW9uKGUsdCl7dmFyIG4scixpPXR5cGVvZiB0LG89ZS5sb2NhdGlvbixhPWUuZG9jdW1lbnQscz1hLmRvY3VtZW50RWxlbWVudCxsPWUualF1ZXJ5LHU9ZS4kLGM9e30scD1bXSxmPVwiMS4xMC4yXCIsZD1wLmNvbmNhdCxoPXAucHVzaCxnPXAuc2xpY2UsbT1wLmluZGV4T2YseT1jLnRvU3RyaW5nLHY9Yy5oYXNPd25Qcm9wZXJ0eSxiPWYudHJpbSx4PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyB4LmZuLmluaXQoZSx0LHIpfSx3PS9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvLnNvdXJjZSxUPS9cXFMrL2csQz0vXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csTj0vXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0qKSkkLyxrPS9ePChcXHcrKVxccypcXC8/Pig/OjxcXC9cXDE+fCkkLyxFPS9eW1xcXSw6e31cXHNdKiQvLFM9Lyg/Ol58OnwsKSg/OlxccypcXFspKy9nLEE9L1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbXFxkYS1mQS1GXXs0fSkvZyxqPS9cIlteXCJcXFxcXFxyXFxuXSpcInx0cnVlfGZhbHNlfG51bGx8LT8oPzpcXGQrXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpL2csRD0vXi1tcy0vLEw9Ly0oW1xcZGEtel0pL2dpLEg9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdC50b1VwcGVyQ2FzZSgpfSxxPWZ1bmN0aW9uKGUpeyhhLmFkZEV2ZW50TGlzdGVuZXJ8fFwibG9hZFwiPT09ZS50eXBlfHxcImNvbXBsZXRlXCI9PT1hLnJlYWR5U3RhdGUpJiYoXygpLHgucmVhZHkoKSl9LF89ZnVuY3Rpb24oKXthLmFkZEV2ZW50TGlzdGVuZXI/KGEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixxLCExKSxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIscSwhMSkpOihhLmRldGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIscSksZS5kZXRhY2hFdmVudChcIm9ubG9hZFwiLHEpKX07eC5mbj14LnByb3RvdHlwZT17anF1ZXJ5OmYsY29uc3RydWN0b3I6eCxpbml0OmZ1bmN0aW9uKGUsbixyKXt2YXIgaSxvO2lmKCFlKXJldHVybiB0aGlzO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXtpZihpPVwiPFwiPT09ZS5jaGFyQXQoMCkmJlwiPlwiPT09ZS5jaGFyQXQoZS5sZW5ndGgtMSkmJmUubGVuZ3RoPj0zP1tudWxsLGUsbnVsbF06Ti5leGVjKGUpLCFpfHwhaVsxXSYmbilyZXR1cm4hbnx8bi5qcXVlcnk/KG58fHIpLmZpbmQoZSk6dGhpcy5jb25zdHJ1Y3RvcihuKS5maW5kKGUpO2lmKGlbMV0pe2lmKG49biBpbnN0YW5jZW9mIHg/blswXTpuLHgubWVyZ2UodGhpcyx4LnBhcnNlSFRNTChpWzFdLG4mJm4ubm9kZVR5cGU/bi5vd25lckRvY3VtZW50fHxuOmEsITApKSxrLnRlc3QoaVsxXSkmJnguaXNQbGFpbk9iamVjdChuKSlmb3IoaSBpbiBuKXguaXNGdW5jdGlvbih0aGlzW2ldKT90aGlzW2ldKG5baV0pOnRoaXMuYXR0cihpLG5baV0pO3JldHVybiB0aGlzfWlmKG89YS5nZXRFbGVtZW50QnlJZChpWzJdKSxvJiZvLnBhcmVudE5vZGUpe2lmKG8uaWQhPT1pWzJdKXJldHVybiByLmZpbmQoZSk7dGhpcy5sZW5ndGg9MSx0aGlzWzBdPW99cmV0dXJuIHRoaXMuY29udGV4dD1hLHRoaXMuc2VsZWN0b3I9ZSx0aGlzfXJldHVybiBlLm5vZGVUeXBlPyh0aGlzLmNvbnRleHQ9dGhpc1swXT1lLHRoaXMubGVuZ3RoPTEsdGhpcyk6eC5pc0Z1bmN0aW9uKGUpP3IucmVhZHkoZSk6KGUuc2VsZWN0b3IhPT10JiYodGhpcy5zZWxlY3Rvcj1lLnNlbGVjdG9yLHRoaXMuY29udGV4dD1lLmNvbnRleHQpLHgubWFrZUFycmF5KGUsdGhpcykpfSxzZWxlY3RvcjpcIlwiLGxlbmd0aDowLHRvQXJyYXk6ZnVuY3Rpb24oKXtyZXR1cm4gZy5jYWxsKHRoaXMpfSxnZXQ6ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWU/dGhpcy50b0FycmF5KCk6MD5lP3RoaXNbdGhpcy5sZW5ndGgrZV06dGhpc1tlXX0scHVzaFN0YWNrOmZ1bmN0aW9uKGUpe3ZhciB0PXgubWVyZ2UodGhpcy5jb25zdHJ1Y3RvcigpLGUpO3JldHVybiB0LnByZXZPYmplY3Q9dGhpcyx0LmNvbnRleHQ9dGhpcy5jb250ZXh0LHR9LGVhY2g6ZnVuY3Rpb24oZSx0KXtyZXR1cm4geC5lYWNoKHRoaXMsZSx0KX0scmVhZHk6ZnVuY3Rpb24oZSl7cmV0dXJuIHgucmVhZHkucHJvbWlzZSgpLmRvbmUoZSksdGhpc30sc2xpY2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soZy5hcHBseSh0aGlzLGFyZ3VtZW50cykpfSxmaXJzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVxKDApfSxsYXN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXEoLTEpfSxlcTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLmxlbmd0aCxuPStlKygwPmU/dDowKTtyZXR1cm4gdGhpcy5wdXNoU3RhY2sobj49MCYmdD5uP1t0aGlzW25dXTpbXSl9LG1hcDpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soeC5tYXAodGhpcyxmdW5jdGlvbih0LG4pe3JldHVybiBlLmNhbGwodCxuLHQpfSkpfSxlbmQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcmV2T2JqZWN0fHx0aGlzLmNvbnN0cnVjdG9yKG51bGwpfSxwdXNoOmgsc29ydDpbXS5zb3J0LHNwbGljZTpbXS5zcGxpY2V9LHguZm4uaW5pdC5wcm90b3R5cGU9eC5mbix4LmV4dGVuZD14LmZuLmV4dGVuZD1mdW5jdGlvbigpe3ZhciBlLG4scixpLG8sYSxzPWFyZ3VtZW50c1swXXx8e30sbD0xLHU9YXJndW1lbnRzLmxlbmd0aCxjPSExO2ZvcihcImJvb2xlYW5cIj09dHlwZW9mIHMmJihjPXMscz1hcmd1bWVudHNbMV18fHt9LGw9MiksXCJvYmplY3RcIj09dHlwZW9mIHN8fHguaXNGdW5jdGlvbihzKXx8KHM9e30pLHU9PT1sJiYocz10aGlzLC0tbCk7dT5sO2wrKylpZihudWxsIT0obz1hcmd1bWVudHNbbF0pKWZvcihpIGluIG8pZT1zW2ldLHI9b1tpXSxzIT09ciYmKGMmJnImJih4LmlzUGxhaW5PYmplY3Qocil8fChuPXguaXNBcnJheShyKSkpPyhuPyhuPSExLGE9ZSYmeC5pc0FycmF5KGUpP2U6W10pOmE9ZSYmeC5pc1BsYWluT2JqZWN0KGUpP2U6e30sc1tpXT14LmV4dGVuZChjLGEscikpOnIhPT10JiYoc1tpXT1yKSk7cmV0dXJuIHN9LHguZXh0ZW5kKHtleHBhbmRvOlwialF1ZXJ5XCIrKGYrTWF0aC5yYW5kb20oKSkucmVwbGFjZSgvXFxEL2csXCJcIiksbm9Db25mbGljdDpmdW5jdGlvbih0KXtyZXR1cm4gZS4kPT09eCYmKGUuJD11KSx0JiZlLmpRdWVyeT09PXgmJihlLmpRdWVyeT1sKSx4fSxpc1JlYWR5OiExLHJlYWR5V2FpdDoxLGhvbGRSZWFkeTpmdW5jdGlvbihlKXtlP3gucmVhZHlXYWl0Kys6eC5yZWFkeSghMCl9LHJlYWR5OmZ1bmN0aW9uKGUpe2lmKGU9PT0hMD8hLS14LnJlYWR5V2FpdDoheC5pc1JlYWR5KXtpZighYS5ib2R5KXJldHVybiBzZXRUaW1lb3V0KHgucmVhZHkpO3guaXNSZWFkeT0hMCxlIT09ITAmJi0teC5yZWFkeVdhaXQ+MHx8KG4ucmVzb2x2ZVdpdGgoYSxbeF0pLHguZm4udHJpZ2dlciYmeChhKS50cmlnZ2VyKFwicmVhZHlcIikub2ZmKFwicmVhZHlcIikpfX0saXNGdW5jdGlvbjpmdW5jdGlvbihlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PT14LnR5cGUoZSl9LGlzQXJyYXk6QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oZSl7cmV0dXJuXCJhcnJheVwiPT09eC50eXBlKGUpfSxpc1dpbmRvdzpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9ZSYmZT09ZS53aW5kb3d9LGlzTnVtZXJpYzpmdW5jdGlvbihlKXtyZXR1cm4haXNOYU4ocGFyc2VGbG9hdChlKSkmJmlzRmluaXRlKGUpfSx0eXBlOmZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1lP2UrXCJcIjpcIm9iamVjdFwiPT10eXBlb2YgZXx8XCJmdW5jdGlvblwiPT10eXBlb2YgZT9jW3kuY2FsbChlKV18fFwib2JqZWN0XCI6dHlwZW9mIGV9LGlzUGxhaW5PYmplY3Q6ZnVuY3Rpb24oZSl7dmFyIG47aWYoIWV8fFwib2JqZWN0XCIhPT14LnR5cGUoZSl8fGUubm9kZVR5cGV8fHguaXNXaW5kb3coZSkpcmV0dXJuITE7dHJ5e2lmKGUuY29uc3RydWN0b3ImJiF2LmNhbGwoZSxcImNvbnN0cnVjdG9yXCIpJiYhdi5jYWxsKGUuY29uc3RydWN0b3IucHJvdG90eXBlLFwiaXNQcm90b3R5cGVPZlwiKSlyZXR1cm4hMX1jYXRjaChyKXtyZXR1cm4hMX1pZih4LnN1cHBvcnQub3duTGFzdClmb3IobiBpbiBlKXJldHVybiB2LmNhbGwoZSxuKTtmb3IobiBpbiBlKTtyZXR1cm4gbj09PXR8fHYuY2FsbChlLG4pfSxpc0VtcHR5T2JqZWN0OmZ1bmN0aW9uKGUpe3ZhciB0O2Zvcih0IGluIGUpcmV0dXJuITE7cmV0dXJuITB9LGVycm9yOmZ1bmN0aW9uKGUpe3Rocm93IEVycm9yKGUpfSxwYXJzZUhUTUw6ZnVuY3Rpb24oZSx0LG4pe2lmKCFlfHxcInN0cmluZ1wiIT10eXBlb2YgZSlyZXR1cm4gbnVsbDtcImJvb2xlYW5cIj09dHlwZW9mIHQmJihuPXQsdD0hMSksdD10fHxhO3ZhciByPWsuZXhlYyhlKSxpPSFuJiZbXTtyZXR1cm4gcj9bdC5jcmVhdGVFbGVtZW50KHJbMV0pXToocj14LmJ1aWxkRnJhZ21lbnQoW2VdLHQsaSksaSYmeChpKS5yZW1vdmUoKSx4Lm1lcmdlKFtdLHIuY2hpbGROb2RlcykpfSxwYXJzZUpTT046ZnVuY3Rpb24obil7cmV0dXJuIGUuSlNPTiYmZS5KU09OLnBhcnNlP2UuSlNPTi5wYXJzZShuKTpudWxsPT09bj9uOlwic3RyaW5nXCI9PXR5cGVvZiBuJiYobj14LnRyaW0obiksbiYmRS50ZXN0KG4ucmVwbGFjZShBLFwiQFwiKS5yZXBsYWNlKGosXCJdXCIpLnJlcGxhY2UoUyxcIlwiKSkpP0Z1bmN0aW9uKFwicmV0dXJuIFwiK24pKCk6KHguZXJyb3IoXCJJbnZhbGlkIEpTT046IFwiK24pLHQpfSxwYXJzZVhNTDpmdW5jdGlvbihuKXt2YXIgcixpO2lmKCFufHxcInN0cmluZ1wiIT10eXBlb2YgbilyZXR1cm4gbnVsbDt0cnl7ZS5ET01QYXJzZXI/KGk9bmV3IERPTVBhcnNlcixyPWkucGFyc2VGcm9tU3RyaW5nKG4sXCJ0ZXh0L3htbFwiKSk6KHI9bmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MRE9NXCIpLHIuYXN5bmM9XCJmYWxzZVwiLHIubG9hZFhNTChuKSl9Y2F0Y2gobyl7cj10fXJldHVybiByJiZyLmRvY3VtZW50RWxlbWVudCYmIXIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwYXJzZXJlcnJvclwiKS5sZW5ndGh8fHguZXJyb3IoXCJJbnZhbGlkIFhNTDogXCIrbikscn0sbm9vcDpmdW5jdGlvbigpe30sZ2xvYmFsRXZhbDpmdW5jdGlvbih0KXt0JiZ4LnRyaW0odCkmJihlLmV4ZWNTY3JpcHR8fGZ1bmN0aW9uKHQpe2UuZXZhbC5jYWxsKGUsdCl9KSh0KX0sY2FtZWxDYXNlOmZ1bmN0aW9uKGUpe3JldHVybiBlLnJlcGxhY2UoRCxcIm1zLVwiKS5yZXBsYWNlKEwsSCl9LG5vZGVOYW1lOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUubm9kZU5hbWUmJmUubm9kZU5hbWUudG9Mb3dlckNhc2UoKT09PXQudG9Mb3dlckNhc2UoKX0sZWFjaDpmdW5jdGlvbihlLHQsbil7dmFyIHIsaT0wLG89ZS5sZW5ndGgsYT1NKGUpO2lmKG4pe2lmKGEpe2Zvcig7bz5pO2krKylpZihyPXQuYXBwbHkoZVtpXSxuKSxyPT09ITEpYnJlYWt9ZWxzZSBmb3IoaSBpbiBlKWlmKHI9dC5hcHBseShlW2ldLG4pLHI9PT0hMSlicmVha31lbHNlIGlmKGEpe2Zvcig7bz5pO2krKylpZihyPXQuY2FsbChlW2ldLGksZVtpXSkscj09PSExKWJyZWFrfWVsc2UgZm9yKGkgaW4gZSlpZihyPXQuY2FsbChlW2ldLGksZVtpXSkscj09PSExKWJyZWFrO3JldHVybiBlfSx0cmltOmImJiFiLmNhbGwoXCJcXHVmZWZmXFx1MDBhMFwiKT9mdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09ZT9cIlwiOmIuY2FsbChlKX06ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWU/XCJcIjooZStcIlwiKS5yZXBsYWNlKEMsXCJcIil9LG1ha2VBcnJheTpmdW5jdGlvbihlLHQpe3ZhciBuPXR8fFtdO3JldHVybiBudWxsIT1lJiYoTShPYmplY3QoZSkpP3gubWVyZ2UobixcInN0cmluZ1wiPT10eXBlb2YgZT9bZV06ZSk6aC5jYWxsKG4sZSkpLG59LGluQXJyYXk6ZnVuY3Rpb24oZSx0LG4pe3ZhciByO2lmKHQpe2lmKG0pcmV0dXJuIG0uY2FsbCh0LGUsbik7Zm9yKHI9dC5sZW5ndGgsbj1uPzA+bj9NYXRoLm1heCgwLHIrbik6bjowO3I+bjtuKyspaWYobiBpbiB0JiZ0W25dPT09ZSlyZXR1cm4gbn1yZXR1cm4tMX0sbWVyZ2U6ZnVuY3Rpb24oZSxuKXt2YXIgcj1uLmxlbmd0aCxpPWUubGVuZ3RoLG89MDtpZihcIm51bWJlclwiPT10eXBlb2Ygcilmb3IoO3I+bztvKyspZVtpKytdPW5bb107ZWxzZSB3aGlsZShuW29dIT09dCllW2krK109bltvKytdO3JldHVybiBlLmxlbmd0aD1pLGV9LGdyZXA6ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGk9W10sbz0wLGE9ZS5sZW5ndGg7Zm9yKG49ISFuO2E+bztvKyspcj0hIXQoZVtvXSxvKSxuIT09ciYmaS5wdXNoKGVbb10pO3JldHVybiBpfSxtYXA6ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGk9MCxvPWUubGVuZ3RoLGE9TShlKSxzPVtdO2lmKGEpZm9yKDtvPmk7aSsrKXI9dChlW2ldLGksbiksbnVsbCE9ciYmKHNbcy5sZW5ndGhdPXIpO2Vsc2UgZm9yKGkgaW4gZSlyPXQoZVtpXSxpLG4pLG51bGwhPXImJihzW3MubGVuZ3RoXT1yKTtyZXR1cm4gZC5hcHBseShbXSxzKX0sZ3VpZDoxLHByb3h5OmZ1bmN0aW9uKGUsbil7dmFyIHIsaSxvO3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBuJiYobz1lW25dLG49ZSxlPW8pLHguaXNGdW5jdGlvbihlKT8ocj1nLmNhbGwoYXJndW1lbnRzLDIpLGk9ZnVuY3Rpb24oKXtyZXR1cm4gZS5hcHBseShufHx0aGlzLHIuY29uY2F0KGcuY2FsbChhcmd1bWVudHMpKSl9LGkuZ3VpZD1lLmd1aWQ9ZS5ndWlkfHx4Lmd1aWQrKyxpKTp0fSxhY2Nlc3M6ZnVuY3Rpb24oZSxuLHIsaSxvLGEscyl7dmFyIGw9MCx1PWUubGVuZ3RoLGM9bnVsbD09cjtpZihcIm9iamVjdFwiPT09eC50eXBlKHIpKXtvPSEwO2ZvcihsIGluIHIpeC5hY2Nlc3MoZSxuLGwscltsXSwhMCxhLHMpfWVsc2UgaWYoaSE9PXQmJihvPSEwLHguaXNGdW5jdGlvbihpKXx8KHM9ITApLGMmJihzPyhuLmNhbGwoZSxpKSxuPW51bGwpOihjPW4sbj1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGMuY2FsbCh4KGUpLG4pfSkpLG4pKWZvcig7dT5sO2wrKyluKGVbbF0scixzP2k6aS5jYWxsKGVbbF0sbCxuKGVbbF0scikpKTtyZXR1cm4gbz9lOmM/bi5jYWxsKGUpOnU/bihlWzBdLHIpOmF9LG5vdzpmdW5jdGlvbigpe3JldHVybihuZXcgRGF0ZSkuZ2V0VGltZSgpfSxzd2FwOmZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpLG8sYT17fTtmb3IobyBpbiB0KWFbb109ZS5zdHlsZVtvXSxlLnN0eWxlW29dPXRbb107aT1uLmFwcGx5KGUscnx8W10pO2ZvcihvIGluIHQpZS5zdHlsZVtvXT1hW29dO3JldHVybiBpfX0pLHgucmVhZHkucHJvbWlzZT1mdW5jdGlvbih0KXtpZighbilpZihuPXguRGVmZXJyZWQoKSxcImNvbXBsZXRlXCI9PT1hLnJlYWR5U3RhdGUpc2V0VGltZW91dCh4LnJlYWR5KTtlbHNlIGlmKGEuYWRkRXZlbnRMaXN0ZW5lcilhLmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIscSwhMSksZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLHEsITEpO2Vsc2V7YS5hdHRhY2hFdmVudChcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLHEpLGUuYXR0YWNoRXZlbnQoXCJvbmxvYWRcIixxKTt2YXIgcj0hMTt0cnl7cj1udWxsPT1lLmZyYW1lRWxlbWVudCYmYS5kb2N1bWVudEVsZW1lbnR9Y2F0Y2goaSl7fXImJnIuZG9TY3JvbGwmJmZ1bmN0aW9uIG8oKXtpZigheC5pc1JlYWR5KXt0cnl7ci5kb1Njcm9sbChcImxlZnRcIil9Y2F0Y2goZSl7cmV0dXJuIHNldFRpbWVvdXQobyw1MCl9XygpLHgucmVhZHkoKX19KCl9cmV0dXJuIG4ucHJvbWlzZSh0KX0seC5lYWNoKFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvclwiLnNwbGl0KFwiIFwiKSxmdW5jdGlvbihlLHQpe2NbXCJbb2JqZWN0IFwiK3QrXCJdXCJdPXQudG9Mb3dlckNhc2UoKX0pO2Z1bmN0aW9uIE0oZSl7dmFyIHQ9ZS5sZW5ndGgsbj14LnR5cGUoZSk7cmV0dXJuIHguaXNXaW5kb3coZSk/ITE6MT09PWUubm9kZVR5cGUmJnQ/ITA6XCJhcnJheVwiPT09bnx8XCJmdW5jdGlvblwiIT09biYmKDA9PT10fHxcIm51bWJlclwiPT10eXBlb2YgdCYmdD4wJiZ0LTEgaW4gZSl9cj14KGEpLGZ1bmN0aW9uKGUsdCl7dmFyIG4scixpLG8sYSxzLGwsdSxjLHAsZixkLGgsZyxtLHksdixiPVwic2l6emxlXCIrLW5ldyBEYXRlLHc9ZS5kb2N1bWVudCxUPTAsQz0wLE49c3QoKSxrPXN0KCksRT1zdCgpLFM9ITEsQT1mdW5jdGlvbihlLHQpe3JldHVybiBlPT09dD8oUz0hMCwwKTowfSxqPXR5cGVvZiB0LEQ9MTw8MzEsTD17fS5oYXNPd25Qcm9wZXJ0eSxIPVtdLHE9SC5wb3AsXz1ILnB1c2gsTT1ILnB1c2gsTz1ILnNsaWNlLEY9SC5pbmRleE9mfHxmdW5jdGlvbihlKXt2YXIgdD0wLG49dGhpcy5sZW5ndGg7Zm9yKDtuPnQ7dCsrKWlmKHRoaXNbdF09PT1lKXJldHVybiB0O3JldHVybi0xfSxCPVwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixQPVwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixSPVwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFxcXHgwMC1cXFxceGEwXSkrXCIsVz1SLnJlcGxhY2UoXCJ3XCIsXCJ3I1wiKSwkPVwiXFxcXFtcIitQK1wiKihcIitSK1wiKVwiK1ArXCIqKD86KFsqXiR8IX5dPz0pXCIrUCtcIiooPzooWydcXFwiXSkoKD86XFxcXFxcXFwufFteXFxcXFxcXFxdKSo/KVxcXFwzfChcIitXK1wiKXwpfClcIitQK1wiKlxcXFxdXCIsST1cIjooXCIrUitcIikoPzpcXFxcKCgoWydcXFwiXSkoKD86XFxcXFxcXFwufFteXFxcXFxcXFxdKSo/KVxcXFwzfCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiskLnJlcGxhY2UoMyw4KStcIikqKXwuKilcXFxcKXwpXCIsej1SZWdFeHAoXCJeXCIrUCtcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIrUCtcIiskXCIsXCJnXCIpLFg9UmVnRXhwKFwiXlwiK1ArXCIqLFwiK1ArXCIqXCIpLFU9UmVnRXhwKFwiXlwiK1ArXCIqKFs+K35dfFwiK1ArXCIpXCIrUCtcIipcIiksVj1SZWdFeHAoUCtcIipbK35dXCIpLFk9UmVnRXhwKFwiPVwiK1ArXCIqKFteXFxcXF0nXFxcIl0qKVwiK1ArXCIqXFxcXF1cIixcImdcIiksSj1SZWdFeHAoSSksRz1SZWdFeHAoXCJeXCIrVytcIiRcIiksUT17SUQ6UmVnRXhwKFwiXiMoXCIrUitcIilcIiksQ0xBU1M6UmVnRXhwKFwiXlxcXFwuKFwiK1IrXCIpXCIpLFRBRzpSZWdFeHAoXCJeKFwiK1IucmVwbGFjZShcIndcIixcIncqXCIpK1wiKVwiKSxBVFRSOlJlZ0V4cChcIl5cIiskKSxQU0VVRE86UmVnRXhwKFwiXlwiK0kpLENISUxEOlJlZ0V4cChcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIrUCtcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiK1ArXCIqKD86KFsrLV18KVwiK1ArXCIqKFxcXFxkKyl8KSlcIitQK1wiKlxcXFwpfClcIixcImlcIiksYm9vbDpSZWdFeHAoXCJeKD86XCIrQitcIikkXCIsXCJpXCIpLG5lZWRzQ29udGV4dDpSZWdFeHAoXCJeXCIrUCtcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIrUCtcIiooKD86LVxcXFxkKT9cXFxcZCopXCIrUCtcIipcXFxcKXwpKD89W14tXXwkKVwiLFwiaVwiKX0sSz0vXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFo9L14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sZXQ9L14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSx0dD0vXmhcXGQkL2ksbnQ9Lyd8XFxcXC9nLHJ0PVJlZ0V4cChcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiK1ArXCI/fChcIitQK1wiKXwuKVwiLFwiaWdcIiksaXQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPVwiMHhcIit0LTY1NTM2O3JldHVybiByIT09cnx8bj90OjA+cj9TdHJpbmcuZnJvbUNoYXJDb2RlKHIrNjU1MzYpOlN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8cj4+MTAsNTYzMjB8MTAyMyZyKX07dHJ5e00uYXBwbHkoSD1PLmNhbGwody5jaGlsZE5vZGVzKSx3LmNoaWxkTm9kZXMpLEhbdy5jaGlsZE5vZGVzLmxlbmd0aF0ubm9kZVR5cGV9Y2F0Y2gob3Qpe009e2FwcGx5OkgubGVuZ3RoP2Z1bmN0aW9uKGUsdCl7Xy5hcHBseShlLE8uY2FsbCh0KSl9OmZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5sZW5ndGgscj0wO3doaWxlKGVbbisrXT10W3IrK10pO2UubGVuZ3RoPW4tMX19fWZ1bmN0aW9uIGF0KGUsdCxuLGkpe3ZhciBvLGEscyxsLHUsYyxkLG0seSx4O2lmKCh0P3Qub3duZXJEb2N1bWVudHx8dDp3KSE9PWYmJnAodCksdD10fHxmLG49bnx8W10sIWV8fFwic3RyaW5nXCIhPXR5cGVvZiBlKXJldHVybiBuO2lmKDEhPT0obD10Lm5vZGVUeXBlKSYmOSE9PWwpcmV0dXJuW107aWYoaCYmIWkpe2lmKG89Wi5leGVjKGUpKWlmKHM9b1sxXSl7aWYoOT09PWwpe2lmKGE9dC5nZXRFbGVtZW50QnlJZChzKSwhYXx8IWEucGFyZW50Tm9kZSlyZXR1cm4gbjtpZihhLmlkPT09cylyZXR1cm4gbi5wdXNoKGEpLG59ZWxzZSBpZih0Lm93bmVyRG9jdW1lbnQmJihhPXQub3duZXJEb2N1bWVudC5nZXRFbGVtZW50QnlJZChzKSkmJnYodCxhKSYmYS5pZD09PXMpcmV0dXJuIG4ucHVzaChhKSxufWVsc2V7aWYob1syXSlyZXR1cm4gTS5hcHBseShuLHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoZSkpLG47aWYoKHM9b1szXSkmJnIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSYmdC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKXJldHVybiBNLmFwcGx5KG4sdC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKHMpKSxufWlmKHIucXNhJiYoIWd8fCFnLnRlc3QoZSkpKXtpZihtPWQ9Yix5PXQseD05PT09bCYmZSwxPT09bCYmXCJvYmplY3RcIiE9PXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSl7Yz1tdChlKSwoZD10LmdldEF0dHJpYnV0ZShcImlkXCIpKT9tPWQucmVwbGFjZShudCxcIlxcXFwkJlwiKTp0LnNldEF0dHJpYnV0ZShcImlkXCIsbSksbT1cIltpZD0nXCIrbStcIiddIFwiLHU9Yy5sZW5ndGg7d2hpbGUodS0tKWNbdV09bSt5dChjW3VdKTt5PVYudGVzdChlKSYmdC5wYXJlbnROb2RlfHx0LHg9Yy5qb2luKFwiLFwiKX1pZih4KXRyeXtyZXR1cm4gTS5hcHBseShuLHkucXVlcnlTZWxlY3RvckFsbCh4KSksbn1jYXRjaChUKXt9ZmluYWxseXtkfHx0LnJlbW92ZUF0dHJpYnV0ZShcImlkXCIpfX19cmV0dXJuIGt0KGUucmVwbGFjZSh6LFwiJDFcIiksdCxuLGkpfWZ1bmN0aW9uIHN0KCl7dmFyIGU9W107ZnVuY3Rpb24gdChuLHIpe3JldHVybiBlLnB1c2gobis9XCIgXCIpPm8uY2FjaGVMZW5ndGgmJmRlbGV0ZSB0W2Uuc2hpZnQoKV0sdFtuXT1yfXJldHVybiB0fWZ1bmN0aW9uIGx0KGUpe3JldHVybiBlW2JdPSEwLGV9ZnVuY3Rpb24gdXQoZSl7dmFyIHQ9Zi5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3RyeXtyZXR1cm4hIWUodCl9Y2F0Y2gobil7cmV0dXJuITF9ZmluYWxseXt0LnBhcmVudE5vZGUmJnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KSx0PW51bGx9fWZ1bmN0aW9uIGN0KGUsdCl7dmFyIG49ZS5zcGxpdChcInxcIikscj1lLmxlbmd0aDt3aGlsZShyLS0pby5hdHRySGFuZGxlW25bcl1dPXR9ZnVuY3Rpb24gcHQoZSx0KXt2YXIgbj10JiZlLHI9biYmMT09PWUubm9kZVR5cGUmJjE9PT10Lm5vZGVUeXBlJiYofnQuc291cmNlSW5kZXh8fEQpLSh+ZS5zb3VyY2VJbmRleHx8RCk7aWYocilyZXR1cm4gcjtpZihuKXdoaWxlKG49bi5uZXh0U2libGluZylpZihuPT09dClyZXR1cm4tMTtyZXR1cm4gZT8xOi0xfWZ1bmN0aW9uIGZ0KGUpe3JldHVybiBmdW5jdGlvbih0KXt2YXIgbj10Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJpbnB1dFwiPT09biYmdC50eXBlPT09ZX19ZnVuY3Rpb24gZHQoZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBuPXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4oXCJpbnB1dFwiPT09bnx8XCJidXR0b25cIj09PW4pJiZ0LnR5cGU9PT1lfX1mdW5jdGlvbiBodChlKXtyZXR1cm4gbHQoZnVuY3Rpb24odCl7cmV0dXJuIHQ9K3QsbHQoZnVuY3Rpb24obixyKXt2YXIgaSxvPWUoW10sbi5sZW5ndGgsdCksYT1vLmxlbmd0aDt3aGlsZShhLS0pbltpPW9bYV1dJiYobltpXT0hKHJbaV09bltpXSkpfSl9KX1zPWF0LmlzWE1MPWZ1bmN0aW9uKGUpe3ZhciB0PWUmJihlLm93bmVyRG9jdW1lbnR8fGUpLmRvY3VtZW50RWxlbWVudDtyZXR1cm4gdD9cIkhUTUxcIiE9PXQubm9kZU5hbWU6ITF9LHI9YXQuc3VwcG9ydD17fSxwPWF0LnNldERvY3VtZW50PWZ1bmN0aW9uKGUpe3ZhciBuPWU/ZS5vd25lckRvY3VtZW50fHxlOncsaT1uLmRlZmF1bHRWaWV3O3JldHVybiBuIT09ZiYmOT09PW4ubm9kZVR5cGUmJm4uZG9jdW1lbnRFbGVtZW50PyhmPW4sZD1uLmRvY3VtZW50RWxlbWVudCxoPSFzKG4pLGkmJmkuYXR0YWNoRXZlbnQmJmkhPT1pLnRvcCYmaS5hdHRhY2hFdmVudChcIm9uYmVmb3JldW5sb2FkXCIsZnVuY3Rpb24oKXtwKCl9KSxyLmF0dHJpYnV0ZXM9dXQoZnVuY3Rpb24oZSl7cmV0dXJuIGUuY2xhc3NOYW1lPVwiaVwiLCFlLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKX0pLHIuZ2V0RWxlbWVudHNCeVRhZ05hbWU9dXQoZnVuY3Rpb24oZSl7cmV0dXJuIGUuYXBwZW5kQ2hpbGQobi5jcmVhdGVDb21tZW50KFwiXCIpKSwhZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RofSksci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lPXV0KGZ1bmN0aW9uKGUpe3JldHVybiBlLmlubmVySFRNTD1cIjxkaXYgY2xhc3M9J2EnPjwvZGl2PjxkaXYgY2xhc3M9J2EgaSc+PC9kaXY+XCIsZS5maXJzdENoaWxkLmNsYXNzTmFtZT1cImlcIiwyPT09ZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiaVwiKS5sZW5ndGh9KSxyLmdldEJ5SWQ9dXQoZnVuY3Rpb24oZSl7cmV0dXJuIGQuYXBwZW5kQ2hpbGQoZSkuaWQ9Yiwhbi5nZXRFbGVtZW50c0J5TmFtZXx8IW4uZ2V0RWxlbWVudHNCeU5hbWUoYikubGVuZ3RofSksci5nZXRCeUlkPyhvLmZpbmQuSUQ9ZnVuY3Rpb24oZSx0KXtpZih0eXBlb2YgdC5nZXRFbGVtZW50QnlJZCE9PWomJmgpe3ZhciBuPXQuZ2V0RWxlbWVudEJ5SWQoZSk7cmV0dXJuIG4mJm4ucGFyZW50Tm9kZT9bbl06W119fSxvLmZpbHRlci5JRD1mdW5jdGlvbihlKXt2YXIgdD1lLnJlcGxhY2UocnQsaXQpO3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKT09PXR9fSk6KGRlbGV0ZSBvLmZpbmQuSUQsby5maWx0ZXIuSUQ9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5yZXBsYWNlKHJ0LGl0KTtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIG49dHlwZW9mIGUuZ2V0QXR0cmlidXRlTm9kZSE9PWomJmUuZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO3JldHVybiBuJiZuLnZhbHVlPT09dH19KSxvLmZpbmQuVEFHPXIuZ2V0RWxlbWVudHNCeVRhZ05hbWU/ZnVuY3Rpb24oZSxuKXtyZXR1cm4gdHlwZW9mIG4uZ2V0RWxlbWVudHNCeVRhZ05hbWUhPT1qP24uZ2V0RWxlbWVudHNCeVRhZ05hbWUoZSk6dH06ZnVuY3Rpb24oZSx0KXt2YXIgbixyPVtdLGk9MCxvPXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoZSk7aWYoXCIqXCI9PT1lKXt3aGlsZShuPW9baSsrXSkxPT09bi5ub2RlVHlwZSYmci5wdXNoKG4pO3JldHVybiByfXJldHVybiBvfSxvLmZpbmQuQ0xBU1M9ci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lJiZmdW5jdGlvbihlLG4pe3JldHVybiB0eXBlb2Ygbi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lIT09aiYmaD9uLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoZSk6dH0sbT1bXSxnPVtdLChyLnFzYT1LLnRlc3Qobi5xdWVyeVNlbGVjdG9yQWxsKSkmJih1dChmdW5jdGlvbihlKXtlLmlubmVySFRNTD1cIjxzZWxlY3Q+PG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIixlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aHx8Zy5wdXNoKFwiXFxcXFtcIitQK1wiKig/OnZhbHVlfFwiK0IrXCIpXCIpLGUucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aHx8Zy5wdXNoKFwiOmNoZWNrZWRcIil9KSx1dChmdW5jdGlvbihlKXt2YXIgdD1uLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTt0LnNldEF0dHJpYnV0ZShcInR5cGVcIixcImhpZGRlblwiKSxlLmFwcGVuZENoaWxkKHQpLnNldEF0dHJpYnV0ZShcInRcIixcIlwiKSxlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbdF49JyddXCIpLmxlbmd0aCYmZy5wdXNoKFwiWypeJF09XCIrUCtcIiooPzonJ3xcXFwiXFxcIilcIiksZS5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RofHxnLnB1c2goXCI6ZW5hYmxlZFwiLFwiOmRpc2FibGVkXCIpLGUucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIiksZy5wdXNoKFwiLC4qOlwiKX0pKSwoci5tYXRjaGVzU2VsZWN0b3I9Sy50ZXN0KHk9ZC53ZWJraXRNYXRjaGVzU2VsZWN0b3J8fGQubW96TWF0Y2hlc1NlbGVjdG9yfHxkLm9NYXRjaGVzU2VsZWN0b3J8fGQubXNNYXRjaGVzU2VsZWN0b3IpKSYmdXQoZnVuY3Rpb24oZSl7ci5kaXNjb25uZWN0ZWRNYXRjaD15LmNhbGwoZSxcImRpdlwiKSx5LmNhbGwoZSxcIltzIT0nJ106eFwiKSxtLnB1c2goXCIhPVwiLEkpfSksZz1nLmxlbmd0aCYmUmVnRXhwKGcuam9pbihcInxcIikpLG09bS5sZW5ndGgmJlJlZ0V4cChtLmpvaW4oXCJ8XCIpKSx2PUsudGVzdChkLmNvbnRhaW5zKXx8ZC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbj9mdW5jdGlvbihlLHQpe3ZhciBuPTk9PT1lLm5vZGVUeXBlP2UuZG9jdW1lbnRFbGVtZW50OmUscj10JiZ0LnBhcmVudE5vZGU7cmV0dXJuIGU9PT1yfHwhKCFyfHwxIT09ci5ub2RlVHlwZXx8IShuLmNvbnRhaW5zP24uY29udGFpbnMocik6ZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiYmMTYmZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihyKSkpfTpmdW5jdGlvbihlLHQpe2lmKHQpd2hpbGUodD10LnBhcmVudE5vZGUpaWYodD09PWUpcmV0dXJuITA7cmV0dXJuITF9LEE9ZC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbj9mdW5jdGlvbihlLHQpe2lmKGU9PT10KXJldHVybiBTPSEwLDA7dmFyIGk9dC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiYmZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiYmZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0KTtyZXR1cm4gaT8xJml8fCFyLnNvcnREZXRhY2hlZCYmdC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlKT09PWk/ZT09PW58fHYodyxlKT8tMTp0PT09bnx8dih3LHQpPzE6Yz9GLmNhbGwoYyxlKS1GLmNhbGwoYyx0KTowOjQmaT8tMToxOmUuY29tcGFyZURvY3VtZW50UG9zaXRpb24/LTE6MX06ZnVuY3Rpb24oZSx0KXt2YXIgcixpPTAsbz1lLnBhcmVudE5vZGUsYT10LnBhcmVudE5vZGUscz1bZV0sbD1bdF07aWYoZT09PXQpcmV0dXJuIFM9ITAsMDtpZighb3x8IWEpcmV0dXJuIGU9PT1uPy0xOnQ9PT1uPzE6bz8tMTphPzE6Yz9GLmNhbGwoYyxlKS1GLmNhbGwoYyx0KTowO2lmKG89PT1hKXJldHVybiBwdChlLHQpO3I9ZTt3aGlsZShyPXIucGFyZW50Tm9kZSlzLnVuc2hpZnQocik7cj10O3doaWxlKHI9ci5wYXJlbnROb2RlKWwudW5zaGlmdChyKTt3aGlsZShzW2ldPT09bFtpXSlpKys7cmV0dXJuIGk/cHQoc1tpXSxsW2ldKTpzW2ldPT09dz8tMTpsW2ldPT09dz8xOjB9LG4pOmZ9LGF0Lm1hdGNoZXM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gYXQoZSxudWxsLG51bGwsdCl9LGF0Lm1hdGNoZXNTZWxlY3Rvcj1mdW5jdGlvbihlLHQpe2lmKChlLm93bmVyRG9jdW1lbnR8fGUpIT09ZiYmcChlKSx0PXQucmVwbGFjZShZLFwiPSckMSddXCIpLCEoIXIubWF0Y2hlc1NlbGVjdG9yfHwhaHx8bSYmbS50ZXN0KHQpfHxnJiZnLnRlc3QodCkpKXRyeXt2YXIgbj15LmNhbGwoZSx0KTtpZihufHxyLmRpc2Nvbm5lY3RlZE1hdGNofHxlLmRvY3VtZW50JiYxMSE9PWUuZG9jdW1lbnQubm9kZVR5cGUpcmV0dXJuIG59Y2F0Y2goaSl7fXJldHVybiBhdCh0LGYsbnVsbCxbZV0pLmxlbmd0aD4wfSxhdC5jb250YWlucz1mdW5jdGlvbihlLHQpe3JldHVybihlLm93bmVyRG9jdW1lbnR8fGUpIT09ZiYmcChlKSx2KGUsdCl9LGF0LmF0dHI9ZnVuY3Rpb24oZSxuKXsoZS5vd25lckRvY3VtZW50fHxlKSE9PWYmJnAoZSk7dmFyIGk9by5hdHRySGFuZGxlW24udG9Mb3dlckNhc2UoKV0sYT1pJiZMLmNhbGwoby5hdHRySGFuZGxlLG4udG9Mb3dlckNhc2UoKSk/aShlLG4sIWgpOnQ7cmV0dXJuIGE9PT10P3IuYXR0cmlidXRlc3x8IWg/ZS5nZXRBdHRyaWJ1dGUobik6KGE9ZS5nZXRBdHRyaWJ1dGVOb2RlKG4pKSYmYS5zcGVjaWZpZWQ/YS52YWx1ZTpudWxsOmF9LGF0LmVycm9yPWZ1bmN0aW9uKGUpe3Rocm93IEVycm9yKFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIrZSl9LGF0LnVuaXF1ZVNvcnQ9ZnVuY3Rpb24oZSl7dmFyIHQsbj1bXSxpPTAsbz0wO2lmKFM9IXIuZGV0ZWN0RHVwbGljYXRlcyxjPSFyLnNvcnRTdGFibGUmJmUuc2xpY2UoMCksZS5zb3J0KEEpLFMpe3doaWxlKHQ9ZVtvKytdKXQ9PT1lW29dJiYoaT1uLnB1c2gobykpO3doaWxlKGktLSllLnNwbGljZShuW2ldLDEpfXJldHVybiBlfSxhPWF0LmdldFRleHQ9ZnVuY3Rpb24oZSl7dmFyIHQsbj1cIlwiLHI9MCxpPWUubm9kZVR5cGU7aWYoaSl7aWYoMT09PWl8fDk9PT1pfHwxMT09PWkpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlLnRleHRDb250ZW50KXJldHVybiBlLnRleHRDb250ZW50O2ZvcihlPWUuZmlyc3RDaGlsZDtlO2U9ZS5uZXh0U2libGluZyluKz1hKGUpfWVsc2UgaWYoMz09PWl8fDQ9PT1pKXJldHVybiBlLm5vZGVWYWx1ZX1lbHNlIGZvcig7dD1lW3JdO3IrKyluKz1hKHQpO3JldHVybiBufSxvPWF0LnNlbGVjdG9ycz17Y2FjaGVMZW5ndGg6NTAsY3JlYXRlUHNldWRvOmx0LG1hdGNoOlEsYXR0ckhhbmRsZTp7fSxmaW5kOnt9LHJlbGF0aXZlOntcIj5cIjp7ZGlyOlwicGFyZW50Tm9kZVwiLGZpcnN0OiEwfSxcIiBcIjp7ZGlyOlwicGFyZW50Tm9kZVwifSxcIitcIjp7ZGlyOlwicHJldmlvdXNTaWJsaW5nXCIsZmlyc3Q6ITB9LFwiflwiOntkaXI6XCJwcmV2aW91c1NpYmxpbmdcIn19LHByZUZpbHRlcjp7QVRUUjpmdW5jdGlvbihlKXtyZXR1cm4gZVsxXT1lWzFdLnJlcGxhY2UocnQsaXQpLGVbM109KGVbNF18fGVbNV18fFwiXCIpLnJlcGxhY2UocnQsaXQpLFwifj1cIj09PWVbMl0mJihlWzNdPVwiIFwiK2VbM10rXCIgXCIpLGUuc2xpY2UoMCw0KX0sQ0hJTEQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGVbMV09ZVsxXS50b0xvd2VyQ2FzZSgpLFwibnRoXCI9PT1lWzFdLnNsaWNlKDAsMyk/KGVbM118fGF0LmVycm9yKGVbMF0pLGVbNF09KyhlWzRdP2VbNV0rKGVbNl18fDEpOjIqKFwiZXZlblwiPT09ZVszXXx8XCJvZGRcIj09PWVbM10pKSxlWzVdPSsoZVs3XStlWzhdfHxcIm9kZFwiPT09ZVszXSkpOmVbM10mJmF0LmVycm9yKGVbMF0pLGV9LFBTRVVETzpmdW5jdGlvbihlKXt2YXIgbixyPSFlWzVdJiZlWzJdO3JldHVybiBRLkNISUxELnRlc3QoZVswXSk/bnVsbDooZVszXSYmZVs0XSE9PXQ/ZVsyXT1lWzRdOnImJkoudGVzdChyKSYmKG49bXQociwhMCkpJiYobj1yLmluZGV4T2YoXCIpXCIsci5sZW5ndGgtbiktci5sZW5ndGgpJiYoZVswXT1lWzBdLnNsaWNlKDAsbiksZVsyXT1yLnNsaWNlKDAsbikpLGUuc2xpY2UoMCwzKSl9fSxmaWx0ZXI6e1RBRzpmdW5jdGlvbihlKXt2YXIgdD1lLnJlcGxhY2UocnQsaXQpLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCIqXCI9PT1lP2Z1bmN0aW9uKCl7cmV0dXJuITB9OmZ1bmN0aW9uKGUpe3JldHVybiBlLm5vZGVOYW1lJiZlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT10fX0sQ0xBU1M6ZnVuY3Rpb24oZSl7dmFyIHQ9TltlK1wiIFwiXTtyZXR1cm4gdHx8KHQ9UmVnRXhwKFwiKF58XCIrUCtcIilcIitlK1wiKFwiK1ArXCJ8JClcIikpJiZOKGUsZnVuY3Rpb24oZSl7cmV0dXJuIHQudGVzdChcInN0cmluZ1wiPT10eXBlb2YgZS5jbGFzc05hbWUmJmUuY2xhc3NOYW1lfHx0eXBlb2YgZS5nZXRBdHRyaWJ1dGUhPT1qJiZlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpfHxcIlwiKX0pfSxBVFRSOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZnVuY3Rpb24ocil7dmFyIGk9YXQuYXR0cihyLGUpO3JldHVybiBudWxsPT1pP1wiIT1cIj09PXQ6dD8oaSs9XCJcIixcIj1cIj09PXQ/aT09PW46XCIhPVwiPT09dD9pIT09bjpcIl49XCI9PT10P24mJjA9PT1pLmluZGV4T2Yobik6XCIqPVwiPT09dD9uJiZpLmluZGV4T2Yobik+LTE6XCIkPVwiPT09dD9uJiZpLnNsaWNlKC1uLmxlbmd0aCk9PT1uOlwifj1cIj09PXQ/KFwiIFwiK2krXCIgXCIpLmluZGV4T2Yobik+LTE6XCJ8PVwiPT09dD9pPT09bnx8aS5zbGljZSgwLG4ubGVuZ3RoKzEpPT09bitcIi1cIjohMSk6ITB9fSxDSElMRDpmdW5jdGlvbihlLHQsbixyLGkpe3ZhciBvPVwibnRoXCIhPT1lLnNsaWNlKDAsMyksYT1cImxhc3RcIiE9PWUuc2xpY2UoLTQpLHM9XCJvZi10eXBlXCI9PT10O3JldHVybiAxPT09ciYmMD09PWk/ZnVuY3Rpb24oZSl7cmV0dXJuISFlLnBhcmVudE5vZGV9OmZ1bmN0aW9uKHQsbixsKXt2YXIgdSxjLHAsZixkLGgsZz1vIT09YT9cIm5leHRTaWJsaW5nXCI6XCJwcmV2aW91c1NpYmxpbmdcIixtPXQucGFyZW50Tm9kZSx5PXMmJnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSx2PSFsJiYhcztpZihtKXtpZihvKXt3aGlsZShnKXtwPXQ7d2hpbGUocD1wW2ddKWlmKHM/cC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09eToxPT09cC5ub2RlVHlwZSlyZXR1cm4hMTtoPWc9XCJvbmx5XCI9PT1lJiYhaCYmXCJuZXh0U2libGluZ1wifXJldHVybiEwfWlmKGg9W2E/bS5maXJzdENoaWxkOm0ubGFzdENoaWxkXSxhJiZ2KXtjPW1bYl18fChtW2JdPXt9KSx1PWNbZV18fFtdLGQ9dVswXT09PVQmJnVbMV0sZj11WzBdPT09VCYmdVsyXSxwPWQmJm0uY2hpbGROb2Rlc1tkXTt3aGlsZShwPSsrZCYmcCYmcFtnXXx8KGY9ZD0wKXx8aC5wb3AoKSlpZigxPT09cC5ub2RlVHlwZSYmKytmJiZwPT09dCl7Y1tlXT1bVCxkLGZdO2JyZWFrfX1lbHNlIGlmKHYmJih1PSh0W2JdfHwodFtiXT17fSkpW2VdKSYmdVswXT09PVQpZj11WzFdO2Vsc2Ugd2hpbGUocD0rK2QmJnAmJnBbZ118fChmPWQ9MCl8fGgucG9wKCkpaWYoKHM/cC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09eToxPT09cC5ub2RlVHlwZSkmJisrZiYmKHYmJigocFtiXXx8KHBbYl09e30pKVtlXT1bVCxmXSkscD09PXQpKWJyZWFrO3JldHVybiBmLT1pLGY9PT1yfHwwPT09ZiVyJiZmL3I+PTB9fX0sUFNFVURPOmZ1bmN0aW9uKGUsdCl7dmFyIG4scj1vLnBzZXVkb3NbZV18fG8uc2V0RmlsdGVyc1tlLnRvTG93ZXJDYXNlKCldfHxhdC5lcnJvcihcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIrZSk7cmV0dXJuIHJbYl0/cih0KTpyLmxlbmd0aD4xPyhuPVtlLGUsXCJcIix0XSxvLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoZS50b0xvd2VyQ2FzZSgpKT9sdChmdW5jdGlvbihlLG4pe3ZhciBpLG89cihlLHQpLGE9by5sZW5ndGg7d2hpbGUoYS0tKWk9Ri5jYWxsKGUsb1thXSksZVtpXT0hKG5baV09b1thXSl9KTpmdW5jdGlvbihlKXtyZXR1cm4gcihlLDAsbil9KTpyfX0scHNldWRvczp7bm90Omx0KGZ1bmN0aW9uKGUpe3ZhciB0PVtdLG49W10scj1sKGUucmVwbGFjZSh6LFwiJDFcIikpO3JldHVybiByW2JdP2x0KGZ1bmN0aW9uKGUsdCxuLGkpe3ZhciBvLGE9cihlLG51bGwsaSxbXSkscz1lLmxlbmd0aDt3aGlsZShzLS0pKG89YVtzXSkmJihlW3NdPSEodFtzXT1vKSl9KTpmdW5jdGlvbihlLGksbyl7cmV0dXJuIHRbMF09ZSxyKHQsbnVsbCxvLG4pLCFuLnBvcCgpfX0pLGhhczpsdChmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIGF0KGUsdCkubGVuZ3RoPjB9fSksY29udGFpbnM6bHQoZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybih0LnRleHRDb250ZW50fHx0LmlubmVyVGV4dHx8YSh0KSkuaW5kZXhPZihlKT4tMX19KSxsYW5nOmx0KGZ1bmN0aW9uKGUpe3JldHVybiBHLnRlc3QoZXx8XCJcIil8fGF0LmVycm9yKFwidW5zdXBwb3J0ZWQgbGFuZzogXCIrZSksZT1lLnJlcGxhY2UocnQsaXQpLnRvTG93ZXJDYXNlKCksZnVuY3Rpb24odCl7dmFyIG47ZG8gaWYobj1oP3QubGFuZzp0LmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpfHx0LmdldEF0dHJpYnV0ZShcImxhbmdcIikpcmV0dXJuIG49bi50b0xvd2VyQ2FzZSgpLG49PT1lfHwwPT09bi5pbmRleE9mKGUrXCItXCIpO3doaWxlKCh0PXQucGFyZW50Tm9kZSkmJjE9PT10Lm5vZGVUeXBlKTtyZXR1cm4hMX19KSx0YXJnZXQ6ZnVuY3Rpb24odCl7dmFyIG49ZS5sb2NhdGlvbiYmZS5sb2NhdGlvbi5oYXNoO3JldHVybiBuJiZuLnNsaWNlKDEpPT09dC5pZH0scm9vdDpmdW5jdGlvbihlKXtyZXR1cm4gZT09PWR9LGZvY3VzOmZ1bmN0aW9uKGUpe3JldHVybiBlPT09Zi5hY3RpdmVFbGVtZW50JiYoIWYuaGFzRm9jdXN8fGYuaGFzRm9jdXMoKSkmJiEhKGUudHlwZXx8ZS5ocmVmfHx+ZS50YWJJbmRleCl9LGVuYWJsZWQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuZGlzYWJsZWQ9PT0hMX0sZGlzYWJsZWQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuZGlzYWJsZWQ9PT0hMH0sY2hlY2tlZDpmdW5jdGlvbihlKXt2YXIgdD1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJpbnB1dFwiPT09dCYmISFlLmNoZWNrZWR8fFwib3B0aW9uXCI9PT10JiYhIWUuc2VsZWN0ZWR9LHNlbGVjdGVkOmZ1bmN0aW9uKGUpe3JldHVybiBlLnBhcmVudE5vZGUmJmUucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4LGUuc2VsZWN0ZWQ9PT0hMH0sZW1wdHk6ZnVuY3Rpb24oZSl7Zm9yKGU9ZS5maXJzdENoaWxkO2U7ZT1lLm5leHRTaWJsaW5nKWlmKGUubm9kZU5hbWU+XCJAXCJ8fDM9PT1lLm5vZGVUeXBlfHw0PT09ZS5ub2RlVHlwZSlyZXR1cm4hMTtyZXR1cm4hMH0scGFyZW50OmZ1bmN0aW9uKGUpe3JldHVybiFvLnBzZXVkb3MuZW1wdHkoZSl9LGhlYWRlcjpmdW5jdGlvbihlKXtyZXR1cm4gdHQudGVzdChlLm5vZGVOYW1lKX0saW5wdXQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGV0LnRlc3QoZS5ub2RlTmFtZSl9LGJ1dHRvbjpmdW5jdGlvbihlKXt2YXIgdD1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJpbnB1dFwiPT09dCYmXCJidXR0b25cIj09PWUudHlwZXx8XCJidXR0b25cIj09PXR9LHRleHQ6ZnVuY3Rpb24oZSl7dmFyIHQ7cmV0dXJuXCJpbnB1dFwiPT09ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpJiZcInRleHRcIj09PWUudHlwZSYmKG51bGw9PSh0PWUuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSl8fHQudG9Mb3dlckNhc2UoKT09PWUudHlwZSl9LGZpcnN0Omh0KGZ1bmN0aW9uKCl7cmV0dXJuWzBdfSksbGFzdDpodChmdW5jdGlvbihlLHQpe3JldHVyblt0LTFdfSksZXE6aHQoZnVuY3Rpb24oZSx0LG4pe3JldHVyblswPm4/bit0Om5dfSksZXZlbjpodChmdW5jdGlvbihlLHQpe3ZhciBuPTA7Zm9yKDt0Pm47bis9MillLnB1c2gobik7cmV0dXJuIGV9KSxvZGQ6aHQoZnVuY3Rpb24oZSx0KXt2YXIgbj0xO2Zvcig7dD5uO24rPTIpZS5wdXNoKG4pO3JldHVybiBlfSksbHQ6aHQoZnVuY3Rpb24oZSx0LG4pe3ZhciByPTA+bj9uK3Q6bjtmb3IoOy0tcj49MDspZS5wdXNoKHIpO3JldHVybiBlfSksZ3Q6aHQoZnVuY3Rpb24oZSx0LG4pe3ZhciByPTA+bj9uK3Q6bjtmb3IoO3Q+KytyOyllLnB1c2gocik7cmV0dXJuIGV9KX19LG8ucHNldWRvcy5udGg9by5wc2V1ZG9zLmVxO2ZvcihuIGlue3JhZGlvOiEwLGNoZWNrYm94OiEwLGZpbGU6ITAscGFzc3dvcmQ6ITAsaW1hZ2U6ITB9KW8ucHNldWRvc1tuXT1mdChuKTtmb3IobiBpbntzdWJtaXQ6ITAscmVzZXQ6ITB9KW8ucHNldWRvc1tuXT1kdChuKTtmdW5jdGlvbiBndCgpe31ndC5wcm90b3R5cGU9by5maWx0ZXJzPW8ucHNldWRvcyxvLnNldEZpbHRlcnM9bmV3IGd0O2Z1bmN0aW9uIG10KGUsdCl7dmFyIG4scixpLGEscyxsLHUsYz1rW2UrXCIgXCJdO2lmKGMpcmV0dXJuIHQ/MDpjLnNsaWNlKDApO3M9ZSxsPVtdLHU9by5wcmVGaWx0ZXI7d2hpbGUocyl7KCFufHwocj1YLmV4ZWMocykpKSYmKHImJihzPXMuc2xpY2UoclswXS5sZW5ndGgpfHxzKSxsLnB1c2goaT1bXSkpLG49ITEsKHI9VS5leGVjKHMpKSYmKG49ci5zaGlmdCgpLGkucHVzaCh7dmFsdWU6bix0eXBlOnJbMF0ucmVwbGFjZSh6LFwiIFwiKX0pLHM9cy5zbGljZShuLmxlbmd0aCkpO2ZvcihhIGluIG8uZmlsdGVyKSEocj1RW2FdLmV4ZWMocykpfHx1W2FdJiYhKHI9dVthXShyKSl8fChuPXIuc2hpZnQoKSxpLnB1c2goe3ZhbHVlOm4sdHlwZTphLG1hdGNoZXM6cn0pLHM9cy5zbGljZShuLmxlbmd0aCkpO2lmKCFuKWJyZWFrfXJldHVybiB0P3MubGVuZ3RoOnM/YXQuZXJyb3IoZSk6ayhlLGwpLnNsaWNlKDApfWZ1bmN0aW9uIHl0KGUpe3ZhciB0PTAsbj1lLmxlbmd0aCxyPVwiXCI7Zm9yKDtuPnQ7dCsrKXIrPWVbdF0udmFsdWU7cmV0dXJuIHJ9ZnVuY3Rpb24gdnQoZSx0LG4pe3ZhciByPXQuZGlyLG89biYmXCJwYXJlbnROb2RlXCI9PT1yLGE9QysrO3JldHVybiB0LmZpcnN0P2Z1bmN0aW9uKHQsbixpKXt3aGlsZSh0PXRbcl0paWYoMT09PXQubm9kZVR5cGV8fG8pcmV0dXJuIGUodCxuLGkpfTpmdW5jdGlvbih0LG4scyl7dmFyIGwsdSxjLHA9VCtcIiBcIithO2lmKHMpe3doaWxlKHQ9dFtyXSlpZigoMT09PXQubm9kZVR5cGV8fG8pJiZlKHQsbixzKSlyZXR1cm4hMH1lbHNlIHdoaWxlKHQ9dFtyXSlpZigxPT09dC5ub2RlVHlwZXx8bylpZihjPXRbYl18fCh0W2JdPXt9KSwodT1jW3JdKSYmdVswXT09PXApe2lmKChsPXVbMV0pPT09ITB8fGw9PT1pKXJldHVybiBsPT09ITB9ZWxzZSBpZih1PWNbcl09W3BdLHVbMV09ZSh0LG4scyl8fGksdVsxXT09PSEwKXJldHVybiEwfX1mdW5jdGlvbiBidChlKXtyZXR1cm4gZS5sZW5ndGg+MT9mdW5jdGlvbih0LG4scil7dmFyIGk9ZS5sZW5ndGg7d2hpbGUoaS0tKWlmKCFlW2ldKHQsbixyKSlyZXR1cm4hMTtyZXR1cm4hMH06ZVswXX1mdW5jdGlvbiB4dChlLHQsbixyLGkpe3ZhciBvLGE9W10scz0wLGw9ZS5sZW5ndGgsdT1udWxsIT10O2Zvcig7bD5zO3MrKykobz1lW3NdKSYmKCFufHxuKG8scixpKSkmJihhLnB1c2gobyksdSYmdC5wdXNoKHMpKTtyZXR1cm4gYX1mdW5jdGlvbiB3dChlLHQsbixyLGksbyl7cmV0dXJuIHImJiFyW2JdJiYocj13dChyKSksaSYmIWlbYl0mJihpPXd0KGksbykpLGx0KGZ1bmN0aW9uKG8sYSxzLGwpe3ZhciB1LGMscCxmPVtdLGQ9W10saD1hLmxlbmd0aCxnPW98fE50KHR8fFwiKlwiLHMubm9kZVR5cGU/W3NdOnMsW10pLG09IWV8fCFvJiZ0P2c6eHQoZyxmLGUscyxsKSx5PW4/aXx8KG8/ZTpofHxyKT9bXTphOm07aWYobiYmbihtLHkscyxsKSxyKXt1PXh0KHksZCkscih1LFtdLHMsbCksYz11Lmxlbmd0aDt3aGlsZShjLS0pKHA9dVtjXSkmJih5W2RbY11dPSEobVtkW2NdXT1wKSl9aWYobyl7aWYoaXx8ZSl7aWYoaSl7dT1bXSxjPXkubGVuZ3RoO3doaWxlKGMtLSkocD15W2NdKSYmdS5wdXNoKG1bY109cCk7aShudWxsLHk9W10sdSxsKX1jPXkubGVuZ3RoO3doaWxlKGMtLSkocD15W2NdKSYmKHU9aT9GLmNhbGwobyxwKTpmW2NdKT4tMSYmKG9bdV09IShhW3VdPXApKX19ZWxzZSB5PXh0KHk9PT1hP3kuc3BsaWNlKGgseS5sZW5ndGgpOnkpLGk/aShudWxsLGEseSxsKTpNLmFwcGx5KGEseSl9KX1mdW5jdGlvbiBUdChlKXt2YXIgdCxuLHIsaT1lLmxlbmd0aCxhPW8ucmVsYXRpdmVbZVswXS50eXBlXSxzPWF8fG8ucmVsYXRpdmVbXCIgXCJdLGw9YT8xOjAsYz12dChmdW5jdGlvbihlKXtyZXR1cm4gZT09PXR9LHMsITApLHA9dnQoZnVuY3Rpb24oZSl7cmV0dXJuIEYuY2FsbCh0LGUpPi0xfSxzLCEwKSxmPVtmdW5jdGlvbihlLG4scil7cmV0dXJuIWEmJihyfHxuIT09dSl8fCgodD1uKS5ub2RlVHlwZT9jKGUsbixyKTpwKGUsbixyKSl9XTtmb3IoO2k+bDtsKyspaWYobj1vLnJlbGF0aXZlW2VbbF0udHlwZV0pZj1bdnQoYnQoZiksbildO2Vsc2V7aWYobj1vLmZpbHRlcltlW2xdLnR5cGVdLmFwcGx5KG51bGwsZVtsXS5tYXRjaGVzKSxuW2JdKXtmb3Iocj0rK2w7aT5yO3IrKylpZihvLnJlbGF0aXZlW2Vbcl0udHlwZV0pYnJlYWs7cmV0dXJuIHd0KGw+MSYmYnQoZiksbD4xJiZ5dChlLnNsaWNlKDAsbC0xKS5jb25jYXQoe3ZhbHVlOlwiIFwiPT09ZVtsLTJdLnR5cGU/XCIqXCI6XCJcIn0pKS5yZXBsYWNlKHosXCIkMVwiKSxuLHI+bCYmVHQoZS5zbGljZShsLHIpKSxpPnImJlR0KGU9ZS5zbGljZShyKSksaT5yJiZ5dChlKSl9Zi5wdXNoKG4pfXJldHVybiBidChmKX1mdW5jdGlvbiBDdChlLHQpe3ZhciBuPTAscj10Lmxlbmd0aD4wLGE9ZS5sZW5ndGg+MCxzPWZ1bmN0aW9uKHMsbCxjLHAsZCl7dmFyIGgsZyxtLHk9W10sdj0wLGI9XCIwXCIseD1zJiZbXSx3PW51bGwhPWQsQz11LE49c3x8YSYmby5maW5kLlRBRyhcIipcIixkJiZsLnBhcmVudE5vZGV8fGwpLGs9VCs9bnVsbD09Qz8xOk1hdGgucmFuZG9tKCl8fC4xO2Zvcih3JiYodT1sIT09ZiYmbCxpPW4pO251bGwhPShoPU5bYl0pO2IrKyl7aWYoYSYmaCl7Zz0wO3doaWxlKG09ZVtnKytdKWlmKG0oaCxsLGMpKXtwLnB1c2goaCk7YnJlYWt9dyYmKFQ9ayxpPSsrbil9ciYmKChoPSFtJiZoKSYmdi0tLHMmJngucHVzaChoKSl9aWYodis9YixyJiZiIT09dil7Zz0wO3doaWxlKG09dFtnKytdKW0oeCx5LGwsYyk7aWYocyl7aWYodj4wKXdoaWxlKGItLSl4W2JdfHx5W2JdfHwoeVtiXT1xLmNhbGwocCkpO3k9eHQoeSl9TS5hcHBseShwLHkpLHcmJiFzJiZ5Lmxlbmd0aD4wJiZ2K3QubGVuZ3RoPjEmJmF0LnVuaXF1ZVNvcnQocCl9cmV0dXJuIHcmJihUPWssdT1DKSx4fTtyZXR1cm4gcj9sdChzKTpzfWw9YXQuY29tcGlsZT1mdW5jdGlvbihlLHQpe3ZhciBuLHI9W10saT1bXSxvPUVbZStcIiBcIl07aWYoIW8pe3R8fCh0PW10KGUpKSxuPXQubGVuZ3RoO3doaWxlKG4tLSlvPVR0KHRbbl0pLG9bYl0/ci5wdXNoKG8pOmkucHVzaChvKTtvPUUoZSxDdChpLHIpKX1yZXR1cm4gb307ZnVuY3Rpb24gTnQoZSx0LG4pe3ZhciByPTAsaT10Lmxlbmd0aDtmb3IoO2k+cjtyKyspYXQoZSx0W3JdLG4pO3JldHVybiBufWZ1bmN0aW9uIGt0KGUsdCxuLGkpe3ZhciBhLHMsdSxjLHAsZj1tdChlKTtpZighaSYmMT09PWYubGVuZ3RoKXtpZihzPWZbMF09ZlswXS5zbGljZSgwKSxzLmxlbmd0aD4yJiZcIklEXCI9PT0odT1zWzBdKS50eXBlJiZyLmdldEJ5SWQmJjk9PT10Lm5vZGVUeXBlJiZoJiZvLnJlbGF0aXZlW3NbMV0udHlwZV0pe2lmKHQ9KG8uZmluZC5JRCh1Lm1hdGNoZXNbMF0ucmVwbGFjZShydCxpdCksdCl8fFtdKVswXSwhdClyZXR1cm4gbjtlPWUuc2xpY2Uocy5zaGlmdCgpLnZhbHVlLmxlbmd0aCl9YT1RLm5lZWRzQ29udGV4dC50ZXN0KGUpPzA6cy5sZW5ndGg7d2hpbGUoYS0tKXtpZih1PXNbYV0sby5yZWxhdGl2ZVtjPXUudHlwZV0pYnJlYWs7aWYoKHA9by5maW5kW2NdKSYmKGk9cCh1Lm1hdGNoZXNbMF0ucmVwbGFjZShydCxpdCksVi50ZXN0KHNbMF0udHlwZSkmJnQucGFyZW50Tm9kZXx8dCkpKXtpZihzLnNwbGljZShhLDEpLGU9aS5sZW5ndGgmJnl0KHMpLCFlKXJldHVybiBNLmFwcGx5KG4saSksbjticmVha319fXJldHVybiBsKGUsZikoaSx0LCFoLG4sVi50ZXN0KGUpKSxufXIuc29ydFN0YWJsZT1iLnNwbGl0KFwiXCIpLnNvcnQoQSkuam9pbihcIlwiKT09PWIsci5kZXRlY3REdXBsaWNhdGVzPVMscCgpLHIuc29ydERldGFjaGVkPXV0KGZ1bmN0aW9uKGUpe3JldHVybiAxJmUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZi5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKX0pLHV0KGZ1bmN0aW9uKGUpe3JldHVybiBlLmlubmVySFRNTD1cIjxhIGhyZWY9JyMnPjwvYT5cIixcIiNcIj09PWUuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpfSl8fGN0KFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gcj90OmUuZ2V0QXR0cmlidXRlKG4sXCJ0eXBlXCI9PT1uLnRvTG93ZXJDYXNlKCk/MToyKX0pLHIuYXR0cmlidXRlcyYmdXQoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaW5uZXJIVE1MPVwiPGlucHV0Lz5cIixlLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFwidmFsdWVcIixcIlwiKSxcIlwiPT09ZS5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpfSl8fGN0KFwidmFsdWVcIixmdW5jdGlvbihlLG4scil7cmV0dXJuIHJ8fFwiaW5wdXRcIiE9PWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKT90OmUuZGVmYXVsdFZhbHVlfSksdXQoZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWUuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIil9KXx8Y3QoQixmdW5jdGlvbihlLG4scil7dmFyIGk7cmV0dXJuIHI/dDooaT1lLmdldEF0dHJpYnV0ZU5vZGUobikpJiZpLnNwZWNpZmllZD9pLnZhbHVlOmVbbl09PT0hMD9uLnRvTG93ZXJDYXNlKCk6bnVsbH0pLHguZmluZD1hdCx4LmV4cHI9YXQuc2VsZWN0b3JzLHguZXhwcltcIjpcIl09eC5leHByLnBzZXVkb3MseC51bmlxdWU9YXQudW5pcXVlU29ydCx4LnRleHQ9YXQuZ2V0VGV4dCx4LmlzWE1MRG9jPWF0LmlzWE1MLHguY29udGFpbnM9YXQuY29udGFpbnN9KGUpO3ZhciBPPXt9O2Z1bmN0aW9uIEYoZSl7dmFyIHQ9T1tlXT17fTtyZXR1cm4geC5lYWNoKGUubWF0Y2goVCl8fFtdLGZ1bmN0aW9uKGUsbil7dFtuXT0hMH0pLHR9eC5DYWxsYmFja3M9ZnVuY3Rpb24oZSl7ZT1cInN0cmluZ1wiPT10eXBlb2YgZT9PW2VdfHxGKGUpOnguZXh0ZW5kKHt9LGUpO3ZhciBuLHIsaSxvLGEscyxsPVtdLHU9IWUub25jZSYmW10sYz1mdW5jdGlvbih0KXtmb3Iocj1lLm1lbW9yeSYmdCxpPSEwLGE9c3x8MCxzPTAsbz1sLmxlbmd0aCxuPSEwO2wmJm8+YTthKyspaWYobFthXS5hcHBseSh0WzBdLHRbMV0pPT09ITEmJmUuc3RvcE9uRmFsc2Upe3I9ITE7YnJlYWt9bj0hMSxsJiYodT91Lmxlbmd0aCYmYyh1LnNoaWZ0KCkpOnI/bD1bXTpwLmRpc2FibGUoKSl9LHA9e2FkZDpmdW5jdGlvbigpe2lmKGwpe3ZhciB0PWwubGVuZ3RoOyhmdW5jdGlvbiBpKHQpe3guZWFjaCh0LGZ1bmN0aW9uKHQsbil7dmFyIHI9eC50eXBlKG4pO1wiZnVuY3Rpb25cIj09PXI/ZS51bmlxdWUmJnAuaGFzKG4pfHxsLnB1c2gobik6biYmbi5sZW5ndGgmJlwic3RyaW5nXCIhPT1yJiZpKG4pfSl9KShhcmd1bWVudHMpLG4/bz1sLmxlbmd0aDpyJiYocz10LGMocikpfXJldHVybiB0aGlzfSxyZW1vdmU6ZnVuY3Rpb24oKXtyZXR1cm4gbCYmeC5lYWNoKGFyZ3VtZW50cyxmdW5jdGlvbihlLHQpe3ZhciByO3doaWxlKChyPXguaW5BcnJheSh0LGwscikpPi0xKWwuc3BsaWNlKHIsMSksbiYmKG8+PXImJm8tLSxhPj1yJiZhLS0pfSksdGhpc30saGFzOmZ1bmN0aW9uKGUpe3JldHVybiBlP3guaW5BcnJheShlLGwpPi0xOiEoIWx8fCFsLmxlbmd0aCl9LGVtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIGw9W10sbz0wLHRoaXN9LGRpc2FibGU6ZnVuY3Rpb24oKXtyZXR1cm4gbD11PXI9dCx0aGlzfSxkaXNhYmxlZDpmdW5jdGlvbigpe3JldHVybiFsfSxsb2NrOmZ1bmN0aW9uKCl7cmV0dXJuIHU9dCxyfHxwLmRpc2FibGUoKSx0aGlzfSxsb2NrZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hdX0sZmlyZVdpdGg6ZnVuY3Rpb24oZSx0KXtyZXR1cm4hbHx8aSYmIXV8fCh0PXR8fFtdLHQ9W2UsdC5zbGljZT90LnNsaWNlKCk6dF0sbj91LnB1c2godCk6Yyh0KSksdGhpc30sZmlyZTpmdW5jdGlvbigpe3JldHVybiBwLmZpcmVXaXRoKHRoaXMsYXJndW1lbnRzKSx0aGlzfSxmaXJlZDpmdW5jdGlvbigpe3JldHVybiEhaX19O3JldHVybiBwfSx4LmV4dGVuZCh7RGVmZXJyZWQ6ZnVuY3Rpb24oZSl7dmFyIHQ9W1tcInJlc29sdmVcIixcImRvbmVcIix4LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLFwicmVzb2x2ZWRcIl0sW1wicmVqZWN0XCIsXCJmYWlsXCIseC5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcInJlamVjdGVkXCJdLFtcIm5vdGlmeVwiLFwicHJvZ3Jlc3NcIix4LkNhbGxiYWNrcyhcIm1lbW9yeVwiKV1dLG49XCJwZW5kaW5nXCIscj17c3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gbn0sYWx3YXlzOmZ1bmN0aW9uKCl7cmV0dXJuIGkuZG9uZShhcmd1bWVudHMpLmZhaWwoYXJndW1lbnRzKSx0aGlzfSx0aGVuOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzO3JldHVybiB4LkRlZmVycmVkKGZ1bmN0aW9uKG4pe3guZWFjaCh0LGZ1bmN0aW9uKHQsbyl7dmFyIGE9b1swXSxzPXguaXNGdW5jdGlvbihlW3RdKSYmZVt0XTtpW29bMV1dKGZ1bmN0aW9uKCl7dmFyIGU9cyYmcy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7ZSYmeC5pc0Z1bmN0aW9uKGUucHJvbWlzZSk/ZS5wcm9taXNlKCkuZG9uZShuLnJlc29sdmUpLmZhaWwobi5yZWplY3QpLnByb2dyZXNzKG4ubm90aWZ5KTpuW2ErXCJXaXRoXCJdKHRoaXM9PT1yP24ucHJvbWlzZSgpOnRoaXMscz9bZV06YXJndW1lbnRzKX0pfSksZT1udWxsfSkucHJvbWlzZSgpfSxwcm9taXNlOmZ1bmN0aW9uKGUpe3JldHVybiBudWxsIT1lP3guZXh0ZW5kKGUscik6cn19LGk9e307cmV0dXJuIHIucGlwZT1yLnRoZW4seC5lYWNoKHQsZnVuY3Rpb24oZSxvKXt2YXIgYT1vWzJdLHM9b1szXTtyW29bMV1dPWEuYWRkLHMmJmEuYWRkKGZ1bmN0aW9uKCl7bj1zfSx0WzFeZV1bMl0uZGlzYWJsZSx0WzJdWzJdLmxvY2spLGlbb1swXV09ZnVuY3Rpb24oKXtyZXR1cm4gaVtvWzBdK1wiV2l0aFwiXSh0aGlzPT09aT9yOnRoaXMsYXJndW1lbnRzKSx0aGlzfSxpW29bMF0rXCJXaXRoXCJdPWEuZmlyZVdpdGh9KSxyLnByb21pc2UoaSksZSYmZS5jYWxsKGksaSksaX0sd2hlbjpmdW5jdGlvbihlKXt2YXIgdD0wLG49Zy5jYWxsKGFyZ3VtZW50cykscj1uLmxlbmd0aCxpPTEhPT1yfHxlJiZ4LmlzRnVuY3Rpb24oZS5wcm9taXNlKT9yOjAsbz0xPT09aT9lOnguRGVmZXJyZWQoKSxhPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZnVuY3Rpb24ocil7dFtlXT10aGlzLG5bZV09YXJndW1lbnRzLmxlbmd0aD4xP2cuY2FsbChhcmd1bWVudHMpOnIsbj09PXM/by5ub3RpZnlXaXRoKHQsbik6LS1pfHxvLnJlc29sdmVXaXRoKHQsbil9fSxzLGwsdTtpZihyPjEpZm9yKHM9QXJyYXkociksbD1BcnJheShyKSx1PUFycmF5KHIpO3I+dDt0Kyspblt0XSYmeC5pc0Z1bmN0aW9uKG5bdF0ucHJvbWlzZSk/blt0XS5wcm9taXNlKCkuZG9uZShhKHQsdSxuKSkuZmFpbChvLnJlamVjdCkucHJvZ3Jlc3MoYSh0LGwscykpOi0taTtyZXR1cm4gaXx8by5yZXNvbHZlV2l0aCh1LG4pLG8ucHJvbWlzZSgpfX0pLHguc3VwcG9ydD1mdW5jdGlvbih0KXt2YXIgbixyLG8scyxsLHUsYyxwLGYsZD1hLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7aWYoZC5zZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIixcInRcIiksZC5pbm5lckhUTUw9XCIgIDxsaW5rLz48dGFibGU+PC90YWJsZT48YSBocmVmPScvYSc+YTwvYT48aW5wdXQgdHlwZT0nY2hlY2tib3gnLz5cIixuPWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpfHxbXSxyPWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJhXCIpWzBdLCFyfHwhci5zdHlsZXx8IW4ubGVuZ3RoKXJldHVybiB0O3M9YS5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpLHU9cy5hcHBlbmRDaGlsZChhLmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIikpLG89ZC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpWzBdLHIuc3R5bGUuY3NzVGV4dD1cInRvcDoxcHg7ZmxvYXQ6bGVmdDtvcGFjaXR5Oi41XCIsdC5nZXRTZXRBdHRyaWJ1dGU9XCJ0XCIhPT1kLmNsYXNzTmFtZSx0LmxlYWRpbmdXaGl0ZXNwYWNlPTM9PT1kLmZpcnN0Q2hpbGQubm9kZVR5cGUsdC50Ym9keT0hZC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRib2R5XCIpLmxlbmd0aCx0Lmh0bWxTZXJpYWxpemU9ISFkLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibGlua1wiKS5sZW5ndGgsdC5zdHlsZT0vdG9wLy50ZXN0KHIuZ2V0QXR0cmlidXRlKFwic3R5bGVcIikpLHQuaHJlZk5vcm1hbGl6ZWQ9XCIvYVwiPT09ci5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLHQub3BhY2l0eT0vXjAuNS8udGVzdChyLnN0eWxlLm9wYWNpdHkpLHQuY3NzRmxvYXQ9ISFyLnN0eWxlLmNzc0Zsb2F0LHQuY2hlY2tPbj0hIW8udmFsdWUsdC5vcHRTZWxlY3RlZD11LnNlbGVjdGVkLHQuZW5jdHlwZT0hIWEuY3JlYXRlRWxlbWVudChcImZvcm1cIikuZW5jdHlwZSx0Lmh0bWw1Q2xvbmU9XCI8Om5hdj48LzpuYXY+XCIhPT1hLmNyZWF0ZUVsZW1lbnQoXCJuYXZcIikuY2xvbmVOb2RlKCEwKS5vdXRlckhUTUwsdC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0PSExLHQuc2hyaW5rV3JhcEJsb2Nrcz0hMSx0LnBpeGVsUG9zaXRpb249ITEsdC5kZWxldGVFeHBhbmRvPSEwLHQubm9DbG9uZUV2ZW50PSEwLHQucmVsaWFibGVNYXJnaW5SaWdodD0hMCx0LmJveFNpemluZ1JlbGlhYmxlPSEwLG8uY2hlY2tlZD0hMCx0Lm5vQ2xvbmVDaGVja2VkPW8uY2xvbmVOb2RlKCEwKS5jaGVja2VkLHMuZGlzYWJsZWQ9ITAsdC5vcHREaXNhYmxlZD0hdS5kaXNhYmxlZDt0cnl7ZGVsZXRlIGQudGVzdH1jYXRjaChoKXt0LmRlbGV0ZUV4cGFuZG89ITF9bz1hLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSxvLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsXCJcIiksdC5pbnB1dD1cIlwiPT09by5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSxvLnZhbHVlPVwidFwiLG8uc2V0QXR0cmlidXRlKFwidHlwZVwiLFwicmFkaW9cIiksdC5yYWRpb1ZhbHVlPVwidFwiPT09by52YWx1ZSxvLnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIixcInRcIiksby5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsXCJ0XCIpLGw9YS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksbC5hcHBlbmRDaGlsZChvKSx0LmFwcGVuZENoZWNrZWQ9by5jaGVja2VkLHQuY2hlY2tDbG9uZT1sLmNsb25lTm9kZSghMCkuY2xvbmVOb2RlKCEwKS5sYXN0Q2hpbGQuY2hlY2tlZCxkLmF0dGFjaEV2ZW50JiYoZC5hdHRhY2hFdmVudChcIm9uY2xpY2tcIixmdW5jdGlvbigpe3Qubm9DbG9uZUV2ZW50PSExfSksZC5jbG9uZU5vZGUoITApLmNsaWNrKCkpO2ZvcihmIGlue3N1Ym1pdDohMCxjaGFuZ2U6ITAsZm9jdXNpbjohMH0pZC5zZXRBdHRyaWJ1dGUoYz1cIm9uXCIrZixcInRcIiksdFtmK1wiQnViYmxlc1wiXT1jIGluIGV8fGQuYXR0cmlidXRlc1tjXS5leHBhbmRvPT09ITE7ZC5zdHlsZS5iYWNrZ3JvdW5kQ2xpcD1cImNvbnRlbnQtYm94XCIsZC5jbG9uZU5vZGUoITApLnN0eWxlLmJhY2tncm91bmRDbGlwPVwiXCIsdC5jbGVhckNsb25lU3R5bGU9XCJjb250ZW50LWJveFwiPT09ZC5zdHlsZS5iYWNrZ3JvdW5kQ2xpcDtmb3IoZiBpbiB4KHQpKWJyZWFrO3JldHVybiB0Lm93bkxhc3Q9XCIwXCIhPT1mLHgoZnVuY3Rpb24oKXt2YXIgbixyLG8scz1cInBhZGRpbmc6MDttYXJnaW46MDtib3JkZXI6MDtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Y29udGVudC1ib3g7LW1vei1ib3gtc2l6aW5nOmNvbnRlbnQtYm94Oy13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDtcIixsPWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdO2wmJihuPWEuY3JlYXRlRWxlbWVudChcImRpdlwiKSxuLnN0eWxlLmNzc1RleHQ9XCJib3JkZXI6MDt3aWR0aDowO2hlaWdodDowO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6LTk5OTlweDttYXJnaW4tdG9wOjFweFwiLGwuYXBwZW5kQ2hpbGQobikuYXBwZW5kQ2hpbGQoZCksZC5pbm5lckhUTUw9XCI8dGFibGU+PHRyPjx0ZD48L3RkPjx0ZD50PC90ZD48L3RyPjwvdGFibGU+XCIsbz1kLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGRcIiksb1swXS5zdHlsZS5jc3NUZXh0PVwicGFkZGluZzowO21hcmdpbjowO2JvcmRlcjowO2Rpc3BsYXk6bm9uZVwiLHA9MD09PW9bMF0ub2Zmc2V0SGVpZ2h0LG9bMF0uc3R5bGUuZGlzcGxheT1cIlwiLG9bMV0uc3R5bGUuZGlzcGxheT1cIm5vbmVcIix0LnJlbGlhYmxlSGlkZGVuT2Zmc2V0cz1wJiYwPT09b1swXS5vZmZzZXRIZWlnaHQsZC5pbm5lckhUTUw9XCJcIixkLnN0eWxlLmNzc1RleHQ9XCJib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7cGFkZGluZzoxcHg7Ym9yZGVyOjFweDtkaXNwbGF5OmJsb2NrO3dpZHRoOjRweDttYXJnaW4tdG9wOjElO3Bvc2l0aW9uOmFic29sdXRlO3RvcDoxJTtcIix4LnN3YXAobCxudWxsIT1sLnN0eWxlLnpvb20/e3pvb206MX06e30sZnVuY3Rpb24oKXt0LmJveFNpemluZz00PT09ZC5vZmZzZXRXaWR0aH0pLGUuZ2V0Q29tcHV0ZWRTdHlsZSYmKHQucGl4ZWxQb3NpdGlvbj1cIjElXCIhPT0oZS5nZXRDb21wdXRlZFN0eWxlKGQsbnVsbCl8fHt9KS50b3AsdC5ib3hTaXppbmdSZWxpYWJsZT1cIjRweFwiPT09KGUuZ2V0Q29tcHV0ZWRTdHlsZShkLG51bGwpfHx7d2lkdGg6XCI0cHhcIn0pLndpZHRoLHI9ZC5hcHBlbmRDaGlsZChhLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLHIuc3R5bGUuY3NzVGV4dD1kLnN0eWxlLmNzc1RleHQ9cyxyLnN0eWxlLm1hcmdpblJpZ2h0PXIuc3R5bGUud2lkdGg9XCIwXCIsZC5zdHlsZS53aWR0aD1cIjFweFwiLHQucmVsaWFibGVNYXJnaW5SaWdodD0hcGFyc2VGbG9hdCgoZS5nZXRDb21wdXRlZFN0eWxlKHIsbnVsbCl8fHt9KS5tYXJnaW5SaWdodCkpLHR5cGVvZiBkLnN0eWxlLnpvb20hPT1pJiYoZC5pbm5lckhUTUw9XCJcIixkLnN0eWxlLmNzc1RleHQ9cytcIndpZHRoOjFweDtwYWRkaW5nOjFweDtkaXNwbGF5OmlubGluZTt6b29tOjFcIix0LmlubGluZUJsb2NrTmVlZHNMYXlvdXQ9Mz09PWQub2Zmc2V0V2lkdGgsZC5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIixkLmlubmVySFRNTD1cIjxkaXY+PC9kaXY+XCIsZC5maXJzdENoaWxkLnN0eWxlLndpZHRoPVwiNXB4XCIsdC5zaHJpbmtXcmFwQmxvY2tzPTMhPT1kLm9mZnNldFdpZHRoLHQuaW5saW5lQmxvY2tOZWVkc0xheW91dCYmKGwuc3R5bGUuem9vbT0xKSksbC5yZW1vdmVDaGlsZChuKSxuPWQ9bz1yPW51bGwpfSksbj1zPWw9dT1yPW89bnVsbCx0XG59KHt9KTt2YXIgQj0vKD86XFx7W1xcc1xcU10qXFx9fFxcW1tcXHNcXFNdKlxcXSkkLyxQPS8oW0EtWl0pL2c7ZnVuY3Rpb24gUihlLG4scixpKXtpZih4LmFjY2VwdERhdGEoZSkpe3ZhciBvLGEscz14LmV4cGFuZG8sbD1lLm5vZGVUeXBlLHU9bD94LmNhY2hlOmUsYz1sP2Vbc106ZVtzXSYmcztpZihjJiZ1W2NdJiYoaXx8dVtjXS5kYXRhKXx8ciE9PXR8fFwic3RyaW5nXCIhPXR5cGVvZiBuKXJldHVybiBjfHwoYz1sP2Vbc109cC5wb3AoKXx8eC5ndWlkKys6cyksdVtjXXx8KHVbY109bD97fTp7dG9KU09OOngubm9vcH0pLChcIm9iamVjdFwiPT10eXBlb2Ygbnx8XCJmdW5jdGlvblwiPT10eXBlb2YgbikmJihpP3VbY109eC5leHRlbmQodVtjXSxuKTp1W2NdLmRhdGE9eC5leHRlbmQodVtjXS5kYXRhLG4pKSxhPXVbY10saXx8KGEuZGF0YXx8KGEuZGF0YT17fSksYT1hLmRhdGEpLHIhPT10JiYoYVt4LmNhbWVsQ2FzZShuKV09ciksXCJzdHJpbmdcIj09dHlwZW9mIG4/KG89YVtuXSxudWxsPT1vJiYobz1hW3guY2FtZWxDYXNlKG4pXSkpOm89YSxvfX1mdW5jdGlvbiBXKGUsdCxuKXtpZih4LmFjY2VwdERhdGEoZSkpe3ZhciByLGksbz1lLm5vZGVUeXBlLGE9bz94LmNhY2hlOmUscz1vP2VbeC5leHBhbmRvXTp4LmV4cGFuZG87aWYoYVtzXSl7aWYodCYmKHI9bj9hW3NdOmFbc10uZGF0YSkpe3guaXNBcnJheSh0KT90PXQuY29uY2F0KHgubWFwKHQseC5jYW1lbENhc2UpKTp0IGluIHI/dD1bdF06KHQ9eC5jYW1lbENhc2UodCksdD10IGluIHI/W3RdOnQuc3BsaXQoXCIgXCIpKSxpPXQubGVuZ3RoO3doaWxlKGktLSlkZWxldGUgclt0W2ldXTtpZihuPyFJKHIpOiF4LmlzRW1wdHlPYmplY3QocikpcmV0dXJufShufHwoZGVsZXRlIGFbc10uZGF0YSxJKGFbc10pKSkmJihvP3guY2xlYW5EYXRhKFtlXSwhMCk6eC5zdXBwb3J0LmRlbGV0ZUV4cGFuZG98fGEhPWEud2luZG93P2RlbGV0ZSBhW3NdOmFbc109bnVsbCl9fX14LmV4dGVuZCh7Y2FjaGU6e30sbm9EYXRhOnthcHBsZXQ6ITAsZW1iZWQ6ITAsb2JqZWN0OlwiY2xzaWQ6RDI3Q0RCNkUtQUU2RC0xMWNmLTk2QjgtNDQ0NTUzNTQwMDAwXCJ9LGhhc0RhdGE6ZnVuY3Rpb24oZSl7cmV0dXJuIGU9ZS5ub2RlVHlwZT94LmNhY2hlW2VbeC5leHBhbmRvXV06ZVt4LmV4cGFuZG9dLCEhZSYmIUkoZSl9LGRhdGE6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBSKGUsdCxuKX0scmVtb3ZlRGF0YTpmdW5jdGlvbihlLHQpe3JldHVybiBXKGUsdCl9LF9kYXRhOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gUihlLHQsbiwhMCl9LF9yZW1vdmVEYXRhOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIFcoZSx0LCEwKX0sYWNjZXB0RGF0YTpmdW5jdGlvbihlKXtpZihlLm5vZGVUeXBlJiYxIT09ZS5ub2RlVHlwZSYmOSE9PWUubm9kZVR5cGUpcmV0dXJuITE7dmFyIHQ9ZS5ub2RlTmFtZSYmeC5ub0RhdGFbZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXTtyZXR1cm4hdHx8dCE9PSEwJiZlLmdldEF0dHJpYnV0ZShcImNsYXNzaWRcIik9PT10fX0pLHguZm4uZXh0ZW5kKHtkYXRhOmZ1bmN0aW9uKGUsbil7dmFyIHIsaSxvPW51bGwsYT0wLHM9dGhpc1swXTtpZihlPT09dCl7aWYodGhpcy5sZW5ndGgmJihvPXguZGF0YShzKSwxPT09cy5ub2RlVHlwZSYmIXguX2RhdGEocyxcInBhcnNlZEF0dHJzXCIpKSl7Zm9yKHI9cy5hdHRyaWJ1dGVzO3IubGVuZ3RoPmE7YSsrKWk9clthXS5uYW1lLDA9PT1pLmluZGV4T2YoXCJkYXRhLVwiKSYmKGk9eC5jYW1lbENhc2UoaS5zbGljZSg1KSksJChzLGksb1tpXSkpO3guX2RhdGEocyxcInBhcnNlZEF0dHJzXCIsITApfXJldHVybiBvfXJldHVyblwib2JqZWN0XCI9PXR5cGVvZiBlP3RoaXMuZWFjaChmdW5jdGlvbigpe3guZGF0YSh0aGlzLGUpfSk6YXJndW1lbnRzLmxlbmd0aD4xP3RoaXMuZWFjaChmdW5jdGlvbigpe3guZGF0YSh0aGlzLGUsbil9KTpzPyQocyxlLHguZGF0YShzLGUpKTpudWxsfSxyZW1vdmVEYXRhOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt4LnJlbW92ZURhdGEodGhpcyxlKX0pfX0pO2Z1bmN0aW9uICQoZSxuLHIpe2lmKHI9PT10JiYxPT09ZS5ub2RlVHlwZSl7dmFyIGk9XCJkYXRhLVwiK24ucmVwbGFjZShQLFwiLSQxXCIpLnRvTG93ZXJDYXNlKCk7aWYocj1lLmdldEF0dHJpYnV0ZShpKSxcInN0cmluZ1wiPT10eXBlb2Ygcil7dHJ5e3I9XCJ0cnVlXCI9PT1yPyEwOlwiZmFsc2VcIj09PXI/ITE6XCJudWxsXCI9PT1yP251bGw6K3IrXCJcIj09PXI/K3I6Qi50ZXN0KHIpP3gucGFyc2VKU09OKHIpOnJ9Y2F0Y2gobyl7fXguZGF0YShlLG4scil9ZWxzZSByPXR9cmV0dXJuIHJ9ZnVuY3Rpb24gSShlKXt2YXIgdDtmb3IodCBpbiBlKWlmKChcImRhdGFcIiE9PXR8fCF4LmlzRW1wdHlPYmplY3QoZVt0XSkpJiZcInRvSlNPTlwiIT09dClyZXR1cm4hMTtyZXR1cm4hMH14LmV4dGVuZCh7cXVldWU6ZnVuY3Rpb24oZSxuLHIpe3ZhciBpO3JldHVybiBlPyhuPShufHxcImZ4XCIpK1wicXVldWVcIixpPXguX2RhdGEoZSxuKSxyJiYoIWl8fHguaXNBcnJheShyKT9pPXguX2RhdGEoZSxuLHgubWFrZUFycmF5KHIpKTppLnB1c2gocikpLGl8fFtdKTp0fSxkZXF1ZXVlOmZ1bmN0aW9uKGUsdCl7dD10fHxcImZ4XCI7dmFyIG49eC5xdWV1ZShlLHQpLHI9bi5sZW5ndGgsaT1uLnNoaWZ0KCksbz14Ll9xdWV1ZUhvb2tzKGUsdCksYT1mdW5jdGlvbigpe3guZGVxdWV1ZShlLHQpfTtcImlucHJvZ3Jlc3NcIj09PWkmJihpPW4uc2hpZnQoKSxyLS0pLGkmJihcImZ4XCI9PT10JiZuLnVuc2hpZnQoXCJpbnByb2dyZXNzXCIpLGRlbGV0ZSBvLnN0b3AsaS5jYWxsKGUsYSxvKSksIXImJm8mJm8uZW1wdHkuZmlyZSgpfSxfcXVldWVIb29rczpmdW5jdGlvbihlLHQpe3ZhciBuPXQrXCJxdWV1ZUhvb2tzXCI7cmV0dXJuIHguX2RhdGEoZSxuKXx8eC5fZGF0YShlLG4se2VtcHR5OnguQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIikuYWRkKGZ1bmN0aW9uKCl7eC5fcmVtb3ZlRGF0YShlLHQrXCJxdWV1ZVwiKSx4Ll9yZW1vdmVEYXRhKGUsbil9KX0pfX0pLHguZm4uZXh0ZW5kKHtxdWV1ZTpmdW5jdGlvbihlLG4pe3ZhciByPTI7cmV0dXJuXCJzdHJpbmdcIiE9dHlwZW9mIGUmJihuPWUsZT1cImZ4XCIsci0tKSxyPmFyZ3VtZW50cy5sZW5ndGg/eC5xdWV1ZSh0aGlzWzBdLGUpOm49PT10P3RoaXM6dGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIHQ9eC5xdWV1ZSh0aGlzLGUsbik7eC5fcXVldWVIb29rcyh0aGlzLGUpLFwiZnhcIj09PWUmJlwiaW5wcm9ncmVzc1wiIT09dFswXSYmeC5kZXF1ZXVlKHRoaXMsZSl9KX0sZGVxdWV1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7eC5kZXF1ZXVlKHRoaXMsZSl9KX0sZGVsYXk6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT14LmZ4P3guZnguc3BlZWRzW2VdfHxlOmUsdD10fHxcImZ4XCIsdGhpcy5xdWV1ZSh0LGZ1bmN0aW9uKHQsbil7dmFyIHI9c2V0VGltZW91dCh0LGUpO24uc3RvcD1mdW5jdGlvbigpe2NsZWFyVGltZW91dChyKX19KX0sY2xlYXJRdWV1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5xdWV1ZShlfHxcImZ4XCIsW10pfSxwcm9taXNlOmZ1bmN0aW9uKGUsbil7dmFyIHIsaT0xLG89eC5EZWZlcnJlZCgpLGE9dGhpcyxzPXRoaXMubGVuZ3RoLGw9ZnVuY3Rpb24oKXstLWl8fG8ucmVzb2x2ZVdpdGgoYSxbYV0pfTtcInN0cmluZ1wiIT10eXBlb2YgZSYmKG49ZSxlPXQpLGU9ZXx8XCJmeFwiO3doaWxlKHMtLSlyPXguX2RhdGEoYVtzXSxlK1wicXVldWVIb29rc1wiKSxyJiZyLmVtcHR5JiYoaSsrLHIuZW1wdHkuYWRkKGwpKTtyZXR1cm4gbCgpLG8ucHJvbWlzZShuKX19KTt2YXIgeixYLFU9L1tcXHRcXHJcXG5cXGZdL2csVj0vXFxyL2csWT0vXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b258b2JqZWN0KSQvaSxKPS9eKD86YXxhcmVhKSQvaSxHPS9eKD86Y2hlY2tlZHxzZWxlY3RlZCkkL2ksUT14LnN1cHBvcnQuZ2V0U2V0QXR0cmlidXRlLEs9eC5zdXBwb3J0LmlucHV0O3guZm4uZXh0ZW5kKHthdHRyOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHguYWNjZXNzKHRoaXMseC5hdHRyLGUsdCxhcmd1bWVudHMubGVuZ3RoPjEpfSxyZW1vdmVBdHRyOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt4LnJlbW92ZUF0dHIodGhpcyxlKX0pfSxwcm9wOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHguYWNjZXNzKHRoaXMseC5wcm9wLGUsdCxhcmd1bWVudHMubGVuZ3RoPjEpfSxyZW1vdmVQcm9wOmZ1bmN0aW9uKGUpe3JldHVybiBlPXgucHJvcEZpeFtlXXx8ZSx0aGlzLmVhY2goZnVuY3Rpb24oKXt0cnl7dGhpc1tlXT10LGRlbGV0ZSB0aGlzW2VdfWNhdGNoKG4pe319KX0sYWRkQ2xhc3M6ZnVuY3Rpb24oZSl7dmFyIHQsbixyLGksbyxhPTAscz10aGlzLmxlbmd0aCxsPVwic3RyaW5nXCI9PXR5cGVvZiBlJiZlO2lmKHguaXNGdW5jdGlvbihlKSlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKHQpe3godGhpcykuYWRkQ2xhc3MoZS5jYWxsKHRoaXMsdCx0aGlzLmNsYXNzTmFtZSkpfSk7aWYobClmb3IodD0oZXx8XCJcIikubWF0Y2goVCl8fFtdO3M+YTthKyspaWYobj10aGlzW2FdLHI9MT09PW4ubm9kZVR5cGUmJihuLmNsYXNzTmFtZT8oXCIgXCIrbi5jbGFzc05hbWUrXCIgXCIpLnJlcGxhY2UoVSxcIiBcIik6XCIgXCIpKXtvPTA7d2hpbGUoaT10W28rK10pMD5yLmluZGV4T2YoXCIgXCIraStcIiBcIikmJihyKz1pK1wiIFwiKTtuLmNsYXNzTmFtZT14LnRyaW0ocil9cmV0dXJuIHRoaXN9LHJlbW92ZUNsYXNzOmZ1bmN0aW9uKGUpe3ZhciB0LG4scixpLG8sYT0wLHM9dGhpcy5sZW5ndGgsbD0wPT09YXJndW1lbnRzLmxlbmd0aHx8XCJzdHJpbmdcIj09dHlwZW9mIGUmJmU7aWYoeC5pc0Z1bmN0aW9uKGUpKXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24odCl7eCh0aGlzKS5yZW1vdmVDbGFzcyhlLmNhbGwodGhpcyx0LHRoaXMuY2xhc3NOYW1lKSl9KTtpZihsKWZvcih0PShlfHxcIlwiKS5tYXRjaChUKXx8W107cz5hO2ErKylpZihuPXRoaXNbYV0scj0xPT09bi5ub2RlVHlwZSYmKG4uY2xhc3NOYW1lPyhcIiBcIituLmNsYXNzTmFtZStcIiBcIikucmVwbGFjZShVLFwiIFwiKTpcIlwiKSl7bz0wO3doaWxlKGk9dFtvKytdKXdoaWxlKHIuaW5kZXhPZihcIiBcIitpK1wiIFwiKT49MClyPXIucmVwbGFjZShcIiBcIitpK1wiIFwiLFwiIFwiKTtuLmNsYXNzTmFtZT1lP3gudHJpbShyKTpcIlwifXJldHVybiB0aGlzfSx0b2dnbGVDbGFzczpmdW5jdGlvbihlLHQpe3ZhciBuPXR5cGVvZiBlO3JldHVyblwiYm9vbGVhblwiPT10eXBlb2YgdCYmXCJzdHJpbmdcIj09PW4/dD90aGlzLmFkZENsYXNzKGUpOnRoaXMucmVtb3ZlQ2xhc3MoZSk6eC5pc0Z1bmN0aW9uKGUpP3RoaXMuZWFjaChmdW5jdGlvbihuKXt4KHRoaXMpLnRvZ2dsZUNsYXNzKGUuY2FsbCh0aGlzLG4sdGhpcy5jbGFzc05hbWUsdCksdCl9KTp0aGlzLmVhY2goZnVuY3Rpb24oKXtpZihcInN0cmluZ1wiPT09bil7dmFyIHQscj0wLG89eCh0aGlzKSxhPWUubWF0Y2goVCl8fFtdO3doaWxlKHQ9YVtyKytdKW8uaGFzQ2xhc3ModCk/by5yZW1vdmVDbGFzcyh0KTpvLmFkZENsYXNzKHQpfWVsc2Uobj09PWl8fFwiYm9vbGVhblwiPT09bikmJih0aGlzLmNsYXNzTmFtZSYmeC5fZGF0YSh0aGlzLFwiX19jbGFzc05hbWVfX1wiLHRoaXMuY2xhc3NOYW1lKSx0aGlzLmNsYXNzTmFtZT10aGlzLmNsYXNzTmFtZXx8ZT09PSExP1wiXCI6eC5fZGF0YSh0aGlzLFwiX19jbGFzc05hbWVfX1wiKXx8XCJcIil9KX0saGFzQ2xhc3M6ZnVuY3Rpb24oZSl7dmFyIHQ9XCIgXCIrZStcIiBcIixuPTAscj10aGlzLmxlbmd0aDtmb3IoO3I+bjtuKyspaWYoMT09PXRoaXNbbl0ubm9kZVR5cGUmJihcIiBcIit0aGlzW25dLmNsYXNzTmFtZStcIiBcIikucmVwbGFjZShVLFwiIFwiKS5pbmRleE9mKHQpPj0wKXJldHVybiEwO3JldHVybiExfSx2YWw6ZnVuY3Rpb24oZSl7dmFyIG4scixpLG89dGhpc1swXTt7aWYoYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gaT14LmlzRnVuY3Rpb24oZSksdGhpcy5lYWNoKGZ1bmN0aW9uKG4pe3ZhciBvOzE9PT10aGlzLm5vZGVUeXBlJiYobz1pP2UuY2FsbCh0aGlzLG4seCh0aGlzKS52YWwoKSk6ZSxudWxsPT1vP289XCJcIjpcIm51bWJlclwiPT10eXBlb2Ygbz9vKz1cIlwiOnguaXNBcnJheShvKSYmKG89eC5tYXAobyxmdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09ZT9cIlwiOmUrXCJcIn0pKSxyPXgudmFsSG9va3NbdGhpcy50eXBlXXx8eC52YWxIb29rc1t0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldLHImJlwic2V0XCJpbiByJiZyLnNldCh0aGlzLG8sXCJ2YWx1ZVwiKSE9PXR8fCh0aGlzLnZhbHVlPW8pKX0pO2lmKG8pcmV0dXJuIHI9eC52YWxIb29rc1tvLnR5cGVdfHx4LnZhbEhvb2tzW28ubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0sciYmXCJnZXRcImluIHImJihuPXIuZ2V0KG8sXCJ2YWx1ZVwiKSkhPT10P246KG49by52YWx1ZSxcInN0cmluZ1wiPT10eXBlb2Ygbj9uLnJlcGxhY2UoVixcIlwiKTpudWxsPT1uP1wiXCI6bil9fX0pLHguZXh0ZW5kKHt2YWxIb29rczp7b3B0aW9uOntnZXQ6ZnVuY3Rpb24oZSl7dmFyIHQ9eC5maW5kLmF0dHIoZSxcInZhbHVlXCIpO3JldHVybiBudWxsIT10P3Q6ZS50ZXh0fX0sc2VsZWN0OntnZXQ6ZnVuY3Rpb24oZSl7dmFyIHQsbixyPWUub3B0aW9ucyxpPWUuc2VsZWN0ZWRJbmRleCxvPVwic2VsZWN0LW9uZVwiPT09ZS50eXBlfHwwPmksYT1vP251bGw6W10scz1vP2krMTpyLmxlbmd0aCxsPTA+aT9zOm8/aTowO2Zvcig7cz5sO2wrKylpZihuPXJbbF0sISghbi5zZWxlY3RlZCYmbCE9PWl8fCh4LnN1cHBvcnQub3B0RGlzYWJsZWQ/bi5kaXNhYmxlZDpudWxsIT09bi5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSl8fG4ucGFyZW50Tm9kZS5kaXNhYmxlZCYmeC5ub2RlTmFtZShuLnBhcmVudE5vZGUsXCJvcHRncm91cFwiKSkpe2lmKHQ9eChuKS52YWwoKSxvKXJldHVybiB0O2EucHVzaCh0KX1yZXR1cm4gYX0sc2V0OmZ1bmN0aW9uKGUsdCl7dmFyIG4scixpPWUub3B0aW9ucyxvPXgubWFrZUFycmF5KHQpLGE9aS5sZW5ndGg7d2hpbGUoYS0tKXI9aVthXSwoci5zZWxlY3RlZD14LmluQXJyYXkoeChyKS52YWwoKSxvKT49MCkmJihuPSEwKTtyZXR1cm4gbnx8KGUuc2VsZWN0ZWRJbmRleD0tMSksb319fSxhdHRyOmZ1bmN0aW9uKGUsbixyKXt2YXIgbyxhLHM9ZS5ub2RlVHlwZTtpZihlJiYzIT09cyYmOCE9PXMmJjIhPT1zKXJldHVybiB0eXBlb2YgZS5nZXRBdHRyaWJ1dGU9PT1pP3gucHJvcChlLG4scik6KDE9PT1zJiZ4LmlzWE1MRG9jKGUpfHwobj1uLnRvTG93ZXJDYXNlKCksbz14LmF0dHJIb29rc1tuXXx8KHguZXhwci5tYXRjaC5ib29sLnRlc3Qobik/WDp6KSkscj09PXQ/byYmXCJnZXRcImluIG8mJm51bGwhPT0oYT1vLmdldChlLG4pKT9hOihhPXguZmluZC5hdHRyKGUsbiksbnVsbD09YT90OmEpOm51bGwhPT1yP28mJlwic2V0XCJpbiBvJiYoYT1vLnNldChlLHIsbikpIT09dD9hOihlLnNldEF0dHJpYnV0ZShuLHIrXCJcIikscik6KHgucmVtb3ZlQXR0cihlLG4pLHQpKX0scmVtb3ZlQXR0cjpmdW5jdGlvbihlLHQpe3ZhciBuLHIsaT0wLG89dCYmdC5tYXRjaChUKTtpZihvJiYxPT09ZS5ub2RlVHlwZSl3aGlsZShuPW9baSsrXSlyPXgucHJvcEZpeFtuXXx8bix4LmV4cHIubWF0Y2guYm9vbC50ZXN0KG4pP0smJlF8fCFHLnRlc3Qobik/ZVtyXT0hMTplW3guY2FtZWxDYXNlKFwiZGVmYXVsdC1cIituKV09ZVtyXT0hMTp4LmF0dHIoZSxuLFwiXCIpLGUucmVtb3ZlQXR0cmlidXRlKFE/bjpyKX0sYXR0ckhvb2tzOnt0eXBlOntzZXQ6ZnVuY3Rpb24oZSx0KXtpZigheC5zdXBwb3J0LnJhZGlvVmFsdWUmJlwicmFkaW9cIj09PXQmJngubm9kZU5hbWUoZSxcImlucHV0XCIpKXt2YXIgbj1lLnZhbHVlO3JldHVybiBlLnNldEF0dHJpYnV0ZShcInR5cGVcIix0KSxuJiYoZS52YWx1ZT1uKSx0fX19fSxwcm9wRml4OntcImZvclwiOlwiaHRtbEZvclwiLFwiY2xhc3NcIjpcImNsYXNzTmFtZVwifSxwcm9wOmZ1bmN0aW9uKGUsbixyKXt2YXIgaSxvLGEscz1lLm5vZGVUeXBlO2lmKGUmJjMhPT1zJiY4IT09cyYmMiE9PXMpcmV0dXJuIGE9MSE9PXN8fCF4LmlzWE1MRG9jKGUpLGEmJihuPXgucHJvcEZpeFtuXXx8bixvPXgucHJvcEhvb2tzW25dKSxyIT09dD9vJiZcInNldFwiaW4gbyYmKGk9by5zZXQoZSxyLG4pKSE9PXQ/aTplW25dPXI6byYmXCJnZXRcImluIG8mJm51bGwhPT0oaT1vLmdldChlLG4pKT9pOmVbbl19LHByb3BIb29rczp7dGFiSW5kZXg6e2dldDpmdW5jdGlvbihlKXt2YXIgdD14LmZpbmQuYXR0cihlLFwidGFiaW5kZXhcIik7cmV0dXJuIHQ/cGFyc2VJbnQodCwxMCk6WS50ZXN0KGUubm9kZU5hbWUpfHxKLnRlc3QoZS5ub2RlTmFtZSkmJmUuaHJlZj8wOi0xfX19fSksWD17c2V0OmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdD09PSExP3gucmVtb3ZlQXR0cihlLG4pOksmJlF8fCFHLnRlc3Qobik/ZS5zZXRBdHRyaWJ1dGUoIVEmJngucHJvcEZpeFtuXXx8bixuKTplW3guY2FtZWxDYXNlKFwiZGVmYXVsdC1cIituKV09ZVtuXT0hMCxufX0seC5lYWNoKHguZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCgvXFx3Ky9nKSxmdW5jdGlvbihlLG4pe3ZhciByPXguZXhwci5hdHRySGFuZGxlW25dfHx4LmZpbmQuYXR0cjt4LmV4cHIuYXR0ckhhbmRsZVtuXT1LJiZRfHwhRy50ZXN0KG4pP2Z1bmN0aW9uKGUsbixpKXt2YXIgbz14LmV4cHIuYXR0ckhhbmRsZVtuXSxhPWk/dDooeC5leHByLmF0dHJIYW5kbGVbbl09dCkhPXIoZSxuLGkpP24udG9Mb3dlckNhc2UoKTpudWxsO3JldHVybiB4LmV4cHIuYXR0ckhhbmRsZVtuXT1vLGF9OmZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gcj90OmVbeC5jYW1lbENhc2UoXCJkZWZhdWx0LVwiK24pXT9uLnRvTG93ZXJDYXNlKCk6bnVsbH19KSxLJiZRfHwoeC5hdHRySG9va3MudmFsdWU9e3NldDpmdW5jdGlvbihlLG4scil7cmV0dXJuIHgubm9kZU5hbWUoZSxcImlucHV0XCIpPyhlLmRlZmF1bHRWYWx1ZT1uLHQpOnomJnouc2V0KGUsbixyKX19KSxRfHwoej17c2V0OmZ1bmN0aW9uKGUsbixyKXt2YXIgaT1lLmdldEF0dHJpYnV0ZU5vZGUocik7cmV0dXJuIGl8fGUuc2V0QXR0cmlidXRlTm9kZShpPWUub3duZXJEb2N1bWVudC5jcmVhdGVBdHRyaWJ1dGUocikpLGkudmFsdWU9bis9XCJcIixcInZhbHVlXCI9PT1yfHxuPT09ZS5nZXRBdHRyaWJ1dGUocik/bjp0fX0seC5leHByLmF0dHJIYW5kbGUuaWQ9eC5leHByLmF0dHJIYW5kbGUubmFtZT14LmV4cHIuYXR0ckhhbmRsZS5jb29yZHM9ZnVuY3Rpb24oZSxuLHIpe3ZhciBpO3JldHVybiByP3Q6KGk9ZS5nZXRBdHRyaWJ1dGVOb2RlKG4pKSYmXCJcIiE9PWkudmFsdWU/aS52YWx1ZTpudWxsfSx4LnZhbEhvb2tzLmJ1dHRvbj17Z2V0OmZ1bmN0aW9uKGUsbil7dmFyIHI9ZS5nZXRBdHRyaWJ1dGVOb2RlKG4pO3JldHVybiByJiZyLnNwZWNpZmllZD9yLnZhbHVlOnR9LHNldDp6LnNldH0seC5hdHRySG9va3MuY29udGVudGVkaXRhYmxlPXtzZXQ6ZnVuY3Rpb24oZSx0LG4pe3ouc2V0KGUsXCJcIj09PXQ/ITE6dCxuKX19LHguZWFjaChbXCJ3aWR0aFwiLFwiaGVpZ2h0XCJdLGZ1bmN0aW9uKGUsbil7eC5hdHRySG9va3Nbbl09e3NldDpmdW5jdGlvbihlLHIpe3JldHVyblwiXCI9PT1yPyhlLnNldEF0dHJpYnV0ZShuLFwiYXV0b1wiKSxyKTp0fX19KSkseC5zdXBwb3J0LmhyZWZOb3JtYWxpemVkfHx4LmVhY2goW1wiaHJlZlwiLFwic3JjXCJdLGZ1bmN0aW9uKGUsdCl7eC5wcm9wSG9va3NbdF09e2dldDpmdW5jdGlvbihlKXtyZXR1cm4gZS5nZXRBdHRyaWJ1dGUodCw0KX19fSkseC5zdXBwb3J0LnN0eWxlfHwoeC5hdHRySG9va3Muc3R5bGU9e2dldDpmdW5jdGlvbihlKXtyZXR1cm4gZS5zdHlsZS5jc3NUZXh0fHx0fSxzZXQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5zdHlsZS5jc3NUZXh0PXQrXCJcIn19KSx4LnN1cHBvcnQub3B0U2VsZWN0ZWR8fCh4LnByb3BIb29rcy5zZWxlY3RlZD17Z2V0OmZ1bmN0aW9uKGUpe3ZhciB0PWUucGFyZW50Tm9kZTtyZXR1cm4gdCYmKHQuc2VsZWN0ZWRJbmRleCx0LnBhcmVudE5vZGUmJnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4KSxudWxsfX0pLHguZWFjaChbXCJ0YWJJbmRleFwiLFwicmVhZE9ubHlcIixcIm1heExlbmd0aFwiLFwiY2VsbFNwYWNpbmdcIixcImNlbGxQYWRkaW5nXCIsXCJyb3dTcGFuXCIsXCJjb2xTcGFuXCIsXCJ1c2VNYXBcIixcImZyYW1lQm9yZGVyXCIsXCJjb250ZW50RWRpdGFibGVcIl0sZnVuY3Rpb24oKXt4LnByb3BGaXhbdGhpcy50b0xvd2VyQ2FzZSgpXT10aGlzfSkseC5zdXBwb3J0LmVuY3R5cGV8fCh4LnByb3BGaXguZW5jdHlwZT1cImVuY29kaW5nXCIpLHguZWFjaChbXCJyYWRpb1wiLFwiY2hlY2tib3hcIl0sZnVuY3Rpb24oKXt4LnZhbEhvb2tzW3RoaXNdPXtzZXQ6ZnVuY3Rpb24oZSxuKXtyZXR1cm4geC5pc0FycmF5KG4pP2UuY2hlY2tlZD14LmluQXJyYXkoeChlKS52YWwoKSxuKT49MDp0fX0seC5zdXBwb3J0LmNoZWNrT258fCh4LnZhbEhvb2tzW3RoaXNdLmdldD1mdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09PWUuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik/XCJvblwiOmUudmFsdWV9KX0pO3ZhciBaPS9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhKSQvaSxldD0vXmtleS8sdHQ9L14oPzptb3VzZXxjb250ZXh0bWVudSl8Y2xpY2svLG50PS9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxydD0vXihbXi5dKikoPzpcXC4oLispfCkkLztmdW5jdGlvbiBpdCgpe3JldHVybiEwfWZ1bmN0aW9uIG90KCl7cmV0dXJuITF9ZnVuY3Rpb24gYXQoKXt0cnl7cmV0dXJuIGEuYWN0aXZlRWxlbWVudH1jYXRjaChlKXt9fXguZXZlbnQ9e2dsb2JhbDp7fSxhZGQ6ZnVuY3Rpb24oZSxuLHIsbyxhKXt2YXIgcyxsLHUsYyxwLGYsZCxoLGcsbSx5LHY9eC5fZGF0YShlKTtpZih2KXtyLmhhbmRsZXImJihjPXIscj1jLmhhbmRsZXIsYT1jLnNlbGVjdG9yKSxyLmd1aWR8fChyLmd1aWQ9eC5ndWlkKyspLChsPXYuZXZlbnRzKXx8KGw9di5ldmVudHM9e30pLChmPXYuaGFuZGxlKXx8KGY9di5oYW5kbGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiB4PT09aXx8ZSYmeC5ldmVudC50cmlnZ2VyZWQ9PT1lLnR5cGU/dDp4LmV2ZW50LmRpc3BhdGNoLmFwcGx5KGYuZWxlbSxhcmd1bWVudHMpfSxmLmVsZW09ZSksbj0obnx8XCJcIikubWF0Y2goVCl8fFtcIlwiXSx1PW4ubGVuZ3RoO3doaWxlKHUtLSlzPXJ0LmV4ZWMoblt1XSl8fFtdLGc9eT1zWzFdLG09KHNbMl18fFwiXCIpLnNwbGl0KFwiLlwiKS5zb3J0KCksZyYmKHA9eC5ldmVudC5zcGVjaWFsW2ddfHx7fSxnPShhP3AuZGVsZWdhdGVUeXBlOnAuYmluZFR5cGUpfHxnLHA9eC5ldmVudC5zcGVjaWFsW2ddfHx7fSxkPXguZXh0ZW5kKHt0eXBlOmcsb3JpZ1R5cGU6eSxkYXRhOm8saGFuZGxlcjpyLGd1aWQ6ci5ndWlkLHNlbGVjdG9yOmEsbmVlZHNDb250ZXh0OmEmJnguZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdChhKSxuYW1lc3BhY2U6bS5qb2luKFwiLlwiKX0sYyksKGg9bFtnXSl8fChoPWxbZ109W10saC5kZWxlZ2F0ZUNvdW50PTAscC5zZXR1cCYmcC5zZXR1cC5jYWxsKGUsbyxtLGYpIT09ITF8fChlLmFkZEV2ZW50TGlzdGVuZXI/ZS5hZGRFdmVudExpc3RlbmVyKGcsZiwhMSk6ZS5hdHRhY2hFdmVudCYmZS5hdHRhY2hFdmVudChcIm9uXCIrZyxmKSkpLHAuYWRkJiYocC5hZGQuY2FsbChlLGQpLGQuaGFuZGxlci5ndWlkfHwoZC5oYW5kbGVyLmd1aWQ9ci5ndWlkKSksYT9oLnNwbGljZShoLmRlbGVnYXRlQ291bnQrKywwLGQpOmgucHVzaChkKSx4LmV2ZW50Lmdsb2JhbFtnXT0hMCk7ZT1udWxsfX0scmVtb3ZlOmZ1bmN0aW9uKGUsdCxuLHIsaSl7dmFyIG8sYSxzLGwsdSxjLHAsZixkLGgsZyxtPXguaGFzRGF0YShlKSYmeC5fZGF0YShlKTtpZihtJiYoYz1tLmV2ZW50cykpe3Q9KHR8fFwiXCIpLm1hdGNoKFQpfHxbXCJcIl0sdT10Lmxlbmd0aDt3aGlsZSh1LS0paWYocz1ydC5leGVjKHRbdV0pfHxbXSxkPWc9c1sxXSxoPShzWzJdfHxcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpLGQpe3A9eC5ldmVudC5zcGVjaWFsW2RdfHx7fSxkPShyP3AuZGVsZWdhdGVUeXBlOnAuYmluZFR5cGUpfHxkLGY9Y1tkXXx8W10scz1zWzJdJiZSZWdFeHAoXCIoXnxcXFxcLilcIitoLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKStcIihcXFxcLnwkKVwiKSxsPW89Zi5sZW5ndGg7d2hpbGUoby0tKWE9ZltvXSwhaSYmZyE9PWEub3JpZ1R5cGV8fG4mJm4uZ3VpZCE9PWEuZ3VpZHx8cyYmIXMudGVzdChhLm5hbWVzcGFjZSl8fHImJnIhPT1hLnNlbGVjdG9yJiYoXCIqKlwiIT09cnx8IWEuc2VsZWN0b3IpfHwoZi5zcGxpY2UobywxKSxhLnNlbGVjdG9yJiZmLmRlbGVnYXRlQ291bnQtLSxwLnJlbW92ZSYmcC5yZW1vdmUuY2FsbChlLGEpKTtsJiYhZi5sZW5ndGgmJihwLnRlYXJkb3duJiZwLnRlYXJkb3duLmNhbGwoZSxoLG0uaGFuZGxlKSE9PSExfHx4LnJlbW92ZUV2ZW50KGUsZCxtLmhhbmRsZSksZGVsZXRlIGNbZF0pfWVsc2UgZm9yKGQgaW4gYyl4LmV2ZW50LnJlbW92ZShlLGQrdFt1XSxuLHIsITApO3guaXNFbXB0eU9iamVjdChjKSYmKGRlbGV0ZSBtLmhhbmRsZSx4Ll9yZW1vdmVEYXRhKGUsXCJldmVudHNcIikpfX0sdHJpZ2dlcjpmdW5jdGlvbihuLHIsaSxvKXt2YXIgcyxsLHUsYyxwLGYsZCxoPVtpfHxhXSxnPXYuY2FsbChuLFwidHlwZVwiKT9uLnR5cGU6bixtPXYuY2FsbChuLFwibmFtZXNwYWNlXCIpP24ubmFtZXNwYWNlLnNwbGl0KFwiLlwiKTpbXTtpZih1PWY9aT1pfHxhLDMhPT1pLm5vZGVUeXBlJiY4IT09aS5ub2RlVHlwZSYmIW50LnRlc3QoZyt4LmV2ZW50LnRyaWdnZXJlZCkmJihnLmluZGV4T2YoXCIuXCIpPj0wJiYobT1nLnNwbGl0KFwiLlwiKSxnPW0uc2hpZnQoKSxtLnNvcnQoKSksbD0wPmcuaW5kZXhPZihcIjpcIikmJlwib25cIitnLG49blt4LmV4cGFuZG9dP246bmV3IHguRXZlbnQoZyxcIm9iamVjdFwiPT10eXBlb2YgbiYmbiksbi5pc1RyaWdnZXI9bz8yOjMsbi5uYW1lc3BhY2U9bS5qb2luKFwiLlwiKSxuLm5hbWVzcGFjZV9yZT1uLm5hbWVzcGFjZT9SZWdFeHAoXCIoXnxcXFxcLilcIittLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKStcIihcXFxcLnwkKVwiKTpudWxsLG4ucmVzdWx0PXQsbi50YXJnZXR8fChuLnRhcmdldD1pKSxyPW51bGw9PXI/W25dOngubWFrZUFycmF5KHIsW25dKSxwPXguZXZlbnQuc3BlY2lhbFtnXXx8e30sb3x8IXAudHJpZ2dlcnx8cC50cmlnZ2VyLmFwcGx5KGkscikhPT0hMSkpe2lmKCFvJiYhcC5ub0J1YmJsZSYmIXguaXNXaW5kb3coaSkpe2ZvcihjPXAuZGVsZWdhdGVUeXBlfHxnLG50LnRlc3QoYytnKXx8KHU9dS5wYXJlbnROb2RlKTt1O3U9dS5wYXJlbnROb2RlKWgucHVzaCh1KSxmPXU7Zj09PShpLm93bmVyRG9jdW1lbnR8fGEpJiZoLnB1c2goZi5kZWZhdWx0Vmlld3x8Zi5wYXJlbnRXaW5kb3d8fGUpfWQ9MDt3aGlsZSgodT1oW2QrK10pJiYhbi5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKW4udHlwZT1kPjE/YzpwLmJpbmRUeXBlfHxnLHM9KHguX2RhdGEodSxcImV2ZW50c1wiKXx8e30pW24udHlwZV0mJnguX2RhdGEodSxcImhhbmRsZVwiKSxzJiZzLmFwcGx5KHUscikscz1sJiZ1W2xdLHMmJnguYWNjZXB0RGF0YSh1KSYmcy5hcHBseSYmcy5hcHBseSh1LHIpPT09ITEmJm4ucHJldmVudERlZmF1bHQoKTtpZihuLnR5cGU9ZywhbyYmIW4uaXNEZWZhdWx0UHJldmVudGVkKCkmJighcC5fZGVmYXVsdHx8cC5fZGVmYXVsdC5hcHBseShoLnBvcCgpLHIpPT09ITEpJiZ4LmFjY2VwdERhdGEoaSkmJmwmJmlbZ10mJiF4LmlzV2luZG93KGkpKXtmPWlbbF0sZiYmKGlbbF09bnVsbCkseC5ldmVudC50cmlnZ2VyZWQ9Zzt0cnl7aVtnXSgpfWNhdGNoKHkpe314LmV2ZW50LnRyaWdnZXJlZD10LGYmJihpW2xdPWYpfXJldHVybiBuLnJlc3VsdH19LGRpc3BhdGNoOmZ1bmN0aW9uKGUpe2U9eC5ldmVudC5maXgoZSk7dmFyIG4scixpLG8sYSxzPVtdLGw9Zy5jYWxsKGFyZ3VtZW50cyksdT0oeC5fZGF0YSh0aGlzLFwiZXZlbnRzXCIpfHx7fSlbZS50eXBlXXx8W10sYz14LmV2ZW50LnNwZWNpYWxbZS50eXBlXXx8e307aWYobFswXT1lLGUuZGVsZWdhdGVUYXJnZXQ9dGhpcywhYy5wcmVEaXNwYXRjaHx8Yy5wcmVEaXNwYXRjaC5jYWxsKHRoaXMsZSkhPT0hMSl7cz14LmV2ZW50LmhhbmRsZXJzLmNhbGwodGhpcyxlLHUpLG49MDt3aGlsZSgobz1zW24rK10pJiYhZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKXtlLmN1cnJlbnRUYXJnZXQ9by5lbGVtLGE9MDt3aGlsZSgoaT1vLmhhbmRsZXJzW2ErK10pJiYhZS5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKSghZS5uYW1lc3BhY2VfcmV8fGUubmFtZXNwYWNlX3JlLnRlc3QoaS5uYW1lc3BhY2UpKSYmKGUuaGFuZGxlT2JqPWksZS5kYXRhPWkuZGF0YSxyPSgoeC5ldmVudC5zcGVjaWFsW2kub3JpZ1R5cGVdfHx7fSkuaGFuZGxlfHxpLmhhbmRsZXIpLmFwcGx5KG8uZWxlbSxsKSxyIT09dCYmKGUucmVzdWx0PXIpPT09ITEmJihlLnByZXZlbnREZWZhdWx0KCksZS5zdG9wUHJvcGFnYXRpb24oKSkpfXJldHVybiBjLnBvc3REaXNwYXRjaCYmYy5wb3N0RGlzcGF0Y2guY2FsbCh0aGlzLGUpLGUucmVzdWx0fX0saGFuZGxlcnM6ZnVuY3Rpb24oZSxuKXt2YXIgcixpLG8sYSxzPVtdLGw9bi5kZWxlZ2F0ZUNvdW50LHU9ZS50YXJnZXQ7aWYobCYmdS5ub2RlVHlwZSYmKCFlLmJ1dHRvbnx8XCJjbGlja1wiIT09ZS50eXBlKSlmb3IoO3UhPXRoaXM7dT11LnBhcmVudE5vZGV8fHRoaXMpaWYoMT09PXUubm9kZVR5cGUmJih1LmRpc2FibGVkIT09ITB8fFwiY2xpY2tcIiE9PWUudHlwZSkpe2ZvcihvPVtdLGE9MDtsPmE7YSsrKWk9blthXSxyPWkuc2VsZWN0b3IrXCIgXCIsb1tyXT09PXQmJihvW3JdPWkubmVlZHNDb250ZXh0P3gocix0aGlzKS5pbmRleCh1KT49MDp4LmZpbmQocix0aGlzLG51bGwsW3VdKS5sZW5ndGgpLG9bcl0mJm8ucHVzaChpKTtvLmxlbmd0aCYmcy5wdXNoKHtlbGVtOnUsaGFuZGxlcnM6b30pfXJldHVybiBuLmxlbmd0aD5sJiZzLnB1c2goe2VsZW06dGhpcyxoYW5kbGVyczpuLnNsaWNlKGwpfSksc30sZml4OmZ1bmN0aW9uKGUpe2lmKGVbeC5leHBhbmRvXSlyZXR1cm4gZTt2YXIgdCxuLHIsaT1lLnR5cGUsbz1lLHM9dGhpcy5maXhIb29rc1tpXTtzfHwodGhpcy5maXhIb29rc1tpXT1zPXR0LnRlc3QoaSk/dGhpcy5tb3VzZUhvb2tzOmV0LnRlc3QoaSk/dGhpcy5rZXlIb29rczp7fSkscj1zLnByb3BzP3RoaXMucHJvcHMuY29uY2F0KHMucHJvcHMpOnRoaXMucHJvcHMsZT1uZXcgeC5FdmVudChvKSx0PXIubGVuZ3RoO3doaWxlKHQtLSluPXJbdF0sZVtuXT1vW25dO3JldHVybiBlLnRhcmdldHx8KGUudGFyZ2V0PW8uc3JjRWxlbWVudHx8YSksMz09PWUudGFyZ2V0Lm5vZGVUeXBlJiYoZS50YXJnZXQ9ZS50YXJnZXQucGFyZW50Tm9kZSksZS5tZXRhS2V5PSEhZS5tZXRhS2V5LHMuZmlsdGVyP3MuZmlsdGVyKGUsbyk6ZX0scHJvcHM6XCJhbHRLZXkgYnViYmxlcyBjYW5jZWxhYmxlIGN0cmxLZXkgY3VycmVudFRhcmdldCBldmVudFBoYXNlIG1ldGFLZXkgcmVsYXRlZFRhcmdldCBzaGlmdEtleSB0YXJnZXQgdGltZVN0YW1wIHZpZXcgd2hpY2hcIi5zcGxpdChcIiBcIiksZml4SG9va3M6e30sa2V5SG9va3M6e3Byb3BzOlwiY2hhciBjaGFyQ29kZSBrZXkga2V5Q29kZVwiLnNwbGl0KFwiIFwiKSxmaWx0ZXI6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbnVsbD09ZS53aGljaCYmKGUud2hpY2g9bnVsbCE9dC5jaGFyQ29kZT90LmNoYXJDb2RlOnQua2V5Q29kZSksZX19LG1vdXNlSG9va3M6e3Byb3BzOlwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIGZyb21FbGVtZW50IG9mZnNldFggb2Zmc2V0WSBwYWdlWCBwYWdlWSBzY3JlZW5YIHNjcmVlblkgdG9FbGVtZW50XCIuc3BsaXQoXCIgXCIpLGZpbHRlcjpmdW5jdGlvbihlLG4pe3ZhciByLGksbyxzPW4uYnV0dG9uLGw9bi5mcm9tRWxlbWVudDtyZXR1cm4gbnVsbD09ZS5wYWdlWCYmbnVsbCE9bi5jbGllbnRYJiYoaT1lLnRhcmdldC5vd25lckRvY3VtZW50fHxhLG89aS5kb2N1bWVudEVsZW1lbnQscj1pLmJvZHksZS5wYWdlWD1uLmNsaWVudFgrKG8mJm8uc2Nyb2xsTGVmdHx8ciYmci5zY3JvbGxMZWZ0fHwwKS0obyYmby5jbGllbnRMZWZ0fHxyJiZyLmNsaWVudExlZnR8fDApLGUucGFnZVk9bi5jbGllbnRZKyhvJiZvLnNjcm9sbFRvcHx8ciYmci5zY3JvbGxUb3B8fDApLShvJiZvLmNsaWVudFRvcHx8ciYmci5jbGllbnRUb3B8fDApKSwhZS5yZWxhdGVkVGFyZ2V0JiZsJiYoZS5yZWxhdGVkVGFyZ2V0PWw9PT1lLnRhcmdldD9uLnRvRWxlbWVudDpsKSxlLndoaWNofHxzPT09dHx8KGUud2hpY2g9MSZzPzE6MiZzPzM6NCZzPzI6MCksZX19LHNwZWNpYWw6e2xvYWQ6e25vQnViYmxlOiEwfSxmb2N1czp7dHJpZ2dlcjpmdW5jdGlvbigpe2lmKHRoaXMhPT1hdCgpJiZ0aGlzLmZvY3VzKXRyeXtyZXR1cm4gdGhpcy5mb2N1cygpLCExfWNhdGNoKGUpe319LGRlbGVnYXRlVHlwZTpcImZvY3VzaW5cIn0sYmx1cjp7dHJpZ2dlcjpmdW5jdGlvbigpe3JldHVybiB0aGlzPT09YXQoKSYmdGhpcy5ibHVyPyh0aGlzLmJsdXIoKSwhMSk6dH0sZGVsZWdhdGVUeXBlOlwiZm9jdXNvdXRcIn0sY2xpY2s6e3RyaWdnZXI6ZnVuY3Rpb24oKXtyZXR1cm4geC5ub2RlTmFtZSh0aGlzLFwiaW5wdXRcIikmJlwiY2hlY2tib3hcIj09PXRoaXMudHlwZSYmdGhpcy5jbGljaz8odGhpcy5jbGljaygpLCExKTp0fSxfZGVmYXVsdDpmdW5jdGlvbihlKXtyZXR1cm4geC5ub2RlTmFtZShlLnRhcmdldCxcImFcIil9fSxiZWZvcmV1bmxvYWQ6e3Bvc3REaXNwYXRjaDpmdW5jdGlvbihlKXtlLnJlc3VsdCE9PXQmJihlLm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWU9ZS5yZXN1bHQpfX19LHNpbXVsYXRlOmZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpPXguZXh0ZW5kKG5ldyB4LkV2ZW50LG4se3R5cGU6ZSxpc1NpbXVsYXRlZDohMCxvcmlnaW5hbEV2ZW50Ont9fSk7cj94LmV2ZW50LnRyaWdnZXIoaSxudWxsLHQpOnguZXZlbnQuZGlzcGF0Y2guY2FsbCh0LGkpLGkuaXNEZWZhdWx0UHJldmVudGVkKCkmJm4ucHJldmVudERlZmF1bHQoKX19LHgucmVtb3ZlRXZlbnQ9YS5yZW1vdmVFdmVudExpc3RlbmVyP2Z1bmN0aW9uKGUsdCxuKXtlLnJlbW92ZUV2ZW50TGlzdGVuZXImJmUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LG4sITEpfTpmdW5jdGlvbihlLHQsbil7dmFyIHI9XCJvblwiK3Q7ZS5kZXRhY2hFdmVudCYmKHR5cGVvZiBlW3JdPT09aSYmKGVbcl09bnVsbCksZS5kZXRhY2hFdmVudChyLG4pKX0seC5FdmVudD1mdW5jdGlvbihlLG4pe3JldHVybiB0aGlzIGluc3RhbmNlb2YgeC5FdmVudD8oZSYmZS50eXBlPyh0aGlzLm9yaWdpbmFsRXZlbnQ9ZSx0aGlzLnR5cGU9ZS50eXBlLHRoaXMuaXNEZWZhdWx0UHJldmVudGVkPWUuZGVmYXVsdFByZXZlbnRlZHx8ZS5yZXR1cm5WYWx1ZT09PSExfHxlLmdldFByZXZlbnREZWZhdWx0JiZlLmdldFByZXZlbnREZWZhdWx0KCk/aXQ6b3QpOnRoaXMudHlwZT1lLG4mJnguZXh0ZW5kKHRoaXMsbiksdGhpcy50aW1lU3RhbXA9ZSYmZS50aW1lU3RhbXB8fHgubm93KCksdGhpc1t4LmV4cGFuZG9dPSEwLHQpOm5ldyB4LkV2ZW50KGUsbil9LHguRXZlbnQucHJvdG90eXBlPXtpc0RlZmF1bHRQcmV2ZW50ZWQ6b3QsaXNQcm9wYWdhdGlvblN0b3BwZWQ6b3QsaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6b3QscHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLm9yaWdpbmFsRXZlbnQ7dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQ9aXQsZSYmKGUucHJldmVudERlZmF1bHQ/ZS5wcmV2ZW50RGVmYXVsdCgpOmUucmV0dXJuVmFsdWU9ITEpfSxzdG9wUHJvcGFnYXRpb246ZnVuY3Rpb24oKXt2YXIgZT10aGlzLm9yaWdpbmFsRXZlbnQ7dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1pdCxlJiYoZS5zdG9wUHJvcGFnYXRpb24mJmUuc3RvcFByb3BhZ2F0aW9uKCksZS5jYW5jZWxCdWJibGU9ITApfSxzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246ZnVuY3Rpb24oKXt0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkPWl0LHRoaXMuc3RvcFByb3BhZ2F0aW9uKCl9fSx4LmVhY2goe21vdXNlZW50ZXI6XCJtb3VzZW92ZXJcIixtb3VzZWxlYXZlOlwibW91c2VvdXRcIn0sZnVuY3Rpb24oZSx0KXt4LmV2ZW50LnNwZWNpYWxbZV09e2RlbGVnYXRlVHlwZTp0LGJpbmRUeXBlOnQsaGFuZGxlOmZ1bmN0aW9uKGUpe3ZhciBuLHI9dGhpcyxpPWUucmVsYXRlZFRhcmdldCxvPWUuaGFuZGxlT2JqO3JldHVybighaXx8aSE9PXImJiF4LmNvbnRhaW5zKHIsaSkpJiYoZS50eXBlPW8ub3JpZ1R5cGUsbj1vLmhhbmRsZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpLGUudHlwZT10KSxufX19KSx4LnN1cHBvcnQuc3VibWl0QnViYmxlc3x8KHguZXZlbnQuc3BlY2lhbC5zdWJtaXQ9e3NldHVwOmZ1bmN0aW9uKCl7cmV0dXJuIHgubm9kZU5hbWUodGhpcyxcImZvcm1cIik/ITE6KHguZXZlbnQuYWRkKHRoaXMsXCJjbGljay5fc3VibWl0IGtleXByZXNzLl9zdWJtaXRcIixmdW5jdGlvbihlKXt2YXIgbj1lLnRhcmdldCxyPXgubm9kZU5hbWUobixcImlucHV0XCIpfHx4Lm5vZGVOYW1lKG4sXCJidXR0b25cIik/bi5mb3JtOnQ7ciYmIXguX2RhdGEocixcInN1Ym1pdEJ1YmJsZXNcIikmJih4LmV2ZW50LmFkZChyLFwic3VibWl0Ll9zdWJtaXRcIixmdW5jdGlvbihlKXtlLl9zdWJtaXRfYnViYmxlPSEwfSkseC5fZGF0YShyLFwic3VibWl0QnViYmxlc1wiLCEwKSl9KSx0KX0scG9zdERpc3BhdGNoOmZ1bmN0aW9uKGUpe2UuX3N1Ym1pdF9idWJibGUmJihkZWxldGUgZS5fc3VibWl0X2J1YmJsZSx0aGlzLnBhcmVudE5vZGUmJiFlLmlzVHJpZ2dlciYmeC5ldmVudC5zaW11bGF0ZShcInN1Ym1pdFwiLHRoaXMucGFyZW50Tm9kZSxlLCEwKSl9LHRlYXJkb3duOmZ1bmN0aW9uKCl7cmV0dXJuIHgubm9kZU5hbWUodGhpcyxcImZvcm1cIik/ITE6KHguZXZlbnQucmVtb3ZlKHRoaXMsXCIuX3N1Ym1pdFwiKSx0KX19KSx4LnN1cHBvcnQuY2hhbmdlQnViYmxlc3x8KHguZXZlbnQuc3BlY2lhbC5jaGFuZ2U9e3NldHVwOmZ1bmN0aW9uKCl7cmV0dXJuIFoudGVzdCh0aGlzLm5vZGVOYW1lKT8oKFwiY2hlY2tib3hcIj09PXRoaXMudHlwZXx8XCJyYWRpb1wiPT09dGhpcy50eXBlKSYmKHguZXZlbnQuYWRkKHRoaXMsXCJwcm9wZXJ0eWNoYW5nZS5fY2hhbmdlXCIsZnVuY3Rpb24oZSl7XCJjaGVja2VkXCI9PT1lLm9yaWdpbmFsRXZlbnQucHJvcGVydHlOYW1lJiYodGhpcy5fanVzdF9jaGFuZ2VkPSEwKX0pLHguZXZlbnQuYWRkKHRoaXMsXCJjbGljay5fY2hhbmdlXCIsZnVuY3Rpb24oZSl7dGhpcy5fanVzdF9jaGFuZ2VkJiYhZS5pc1RyaWdnZXImJih0aGlzLl9qdXN0X2NoYW5nZWQ9ITEpLHguZXZlbnQuc2ltdWxhdGUoXCJjaGFuZ2VcIix0aGlzLGUsITApfSkpLCExKTooeC5ldmVudC5hZGQodGhpcyxcImJlZm9yZWFjdGl2YXRlLl9jaGFuZ2VcIixmdW5jdGlvbihlKXt2YXIgdD1lLnRhcmdldDtaLnRlc3QodC5ub2RlTmFtZSkmJiF4Ll9kYXRhKHQsXCJjaGFuZ2VCdWJibGVzXCIpJiYoeC5ldmVudC5hZGQodCxcImNoYW5nZS5fY2hhbmdlXCIsZnVuY3Rpb24oZSl7IXRoaXMucGFyZW50Tm9kZXx8ZS5pc1NpbXVsYXRlZHx8ZS5pc1RyaWdnZXJ8fHguZXZlbnQuc2ltdWxhdGUoXCJjaGFuZ2VcIix0aGlzLnBhcmVudE5vZGUsZSwhMCl9KSx4Ll9kYXRhKHQsXCJjaGFuZ2VCdWJibGVzXCIsITApKX0pLHQpfSxoYW5kbGU6ZnVuY3Rpb24oZSl7dmFyIG49ZS50YXJnZXQ7cmV0dXJuIHRoaXMhPT1ufHxlLmlzU2ltdWxhdGVkfHxlLmlzVHJpZ2dlcnx8XCJyYWRpb1wiIT09bi50eXBlJiZcImNoZWNrYm94XCIhPT1uLnR5cGU/ZS5oYW5kbGVPYmouaGFuZGxlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk6dH0sdGVhcmRvd246ZnVuY3Rpb24oKXtyZXR1cm4geC5ldmVudC5yZW1vdmUodGhpcyxcIi5fY2hhbmdlXCIpLCFaLnRlc3QodGhpcy5ub2RlTmFtZSl9fSkseC5zdXBwb3J0LmZvY3VzaW5CdWJibGVzfHx4LmVhY2goe2ZvY3VzOlwiZm9jdXNpblwiLGJsdXI6XCJmb2N1c291dFwifSxmdW5jdGlvbihlLHQpe3ZhciBuPTAscj1mdW5jdGlvbihlKXt4LmV2ZW50LnNpbXVsYXRlKHQsZS50YXJnZXQseC5ldmVudC5maXgoZSksITApfTt4LmV2ZW50LnNwZWNpYWxbdF09e3NldHVwOmZ1bmN0aW9uKCl7MD09PW4rKyYmYS5hZGRFdmVudExpc3RlbmVyKGUsciwhMCl9LHRlYXJkb3duOmZ1bmN0aW9uKCl7MD09PS0tbiYmYS5yZW1vdmVFdmVudExpc3RlbmVyKGUsciwhMCl9fX0pLHguZm4uZXh0ZW5kKHtvbjpmdW5jdGlvbihlLG4scixpLG8pe3ZhciBhLHM7aWYoXCJvYmplY3RcIj09dHlwZW9mIGUpe1wic3RyaW5nXCIhPXR5cGVvZiBuJiYocj1yfHxuLG49dCk7Zm9yKGEgaW4gZSl0aGlzLm9uKGEsbixyLGVbYV0sbyk7cmV0dXJuIHRoaXN9aWYobnVsbD09ciYmbnVsbD09aT8oaT1uLHI9bj10KTpudWxsPT1pJiYoXCJzdHJpbmdcIj09dHlwZW9mIG4/KGk9cixyPXQpOihpPXIscj1uLG49dCkpLGk9PT0hMSlpPW90O2Vsc2UgaWYoIWkpcmV0dXJuIHRoaXM7cmV0dXJuIDE9PT1vJiYocz1pLGk9ZnVuY3Rpb24oZSl7cmV0dXJuIHgoKS5vZmYoZSkscy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGkuZ3VpZD1zLmd1aWR8fChzLmd1aWQ9eC5ndWlkKyspKSx0aGlzLmVhY2goZnVuY3Rpb24oKXt4LmV2ZW50LmFkZCh0aGlzLGUsaSxyLG4pfSl9LG9uZTpmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gdGhpcy5vbihlLHQsbixyLDEpfSxvZmY6ZnVuY3Rpb24oZSxuLHIpe3ZhciBpLG87aWYoZSYmZS5wcmV2ZW50RGVmYXVsdCYmZS5oYW5kbGVPYmopcmV0dXJuIGk9ZS5oYW5kbGVPYmoseChlLmRlbGVnYXRlVGFyZ2V0KS5vZmYoaS5uYW1lc3BhY2U/aS5vcmlnVHlwZStcIi5cIitpLm5hbWVzcGFjZTppLm9yaWdUeXBlLGkuc2VsZWN0b3IsaS5oYW5kbGVyKSx0aGlzO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBlKXtmb3IobyBpbiBlKXRoaXMub2ZmKG8sbixlW29dKTtyZXR1cm4gdGhpc31yZXR1cm4obj09PSExfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBuKSYmKHI9bixuPXQpLHI9PT0hMSYmKHI9b3QpLHRoaXMuZWFjaChmdW5jdGlvbigpe3guZXZlbnQucmVtb3ZlKHRoaXMsZSxyLG4pfSl9LHRyaWdnZXI6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7eC5ldmVudC50cmlnZ2VyKGUsdCx0aGlzKX0pfSx0cmlnZ2VySGFuZGxlcjpmdW5jdGlvbihlLG4pe3ZhciByPXRoaXNbMF07cmV0dXJuIHI/eC5ldmVudC50cmlnZ2VyKGUsbixyLCEwKTp0fX0pO3ZhciBzdD0vXi5bXjojXFxbXFwuLF0qJC8sbHQ9L14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sdXQ9eC5leHByLm1hdGNoLm5lZWRzQ29udGV4dCxjdD17Y2hpbGRyZW46ITAsY29udGVudHM6ITAsbmV4dDohMCxwcmV2OiEwfTt4LmZuLmV4dGVuZCh7ZmluZDpmdW5jdGlvbihlKXt2YXIgdCxuPVtdLHI9dGhpcyxpPXIubGVuZ3RoO2lmKFwic3RyaW5nXCIhPXR5cGVvZiBlKXJldHVybiB0aGlzLnB1c2hTdGFjayh4KGUpLmZpbHRlcihmdW5jdGlvbigpe2Zvcih0PTA7aT50O3QrKylpZih4LmNvbnRhaW5zKHJbdF0sdGhpcykpcmV0dXJuITB9KSk7Zm9yKHQ9MDtpPnQ7dCsrKXguZmluZChlLHJbdF0sbik7cmV0dXJuIG49dGhpcy5wdXNoU3RhY2soaT4xP3gudW5pcXVlKG4pOm4pLG4uc2VsZWN0b3I9dGhpcy5zZWxlY3Rvcj90aGlzLnNlbGVjdG9yK1wiIFwiK2U6ZSxufSxoYXM6ZnVuY3Rpb24oZSl7dmFyIHQsbj14KGUsdGhpcykscj1uLmxlbmd0aDtyZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oKXtmb3IodD0wO3I+dDt0KyspaWYoeC5jb250YWlucyh0aGlzLG5bdF0pKXJldHVybiEwfSl9LG5vdDpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soZnQodGhpcyxlfHxbXSwhMCkpfSxmaWx0ZXI6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKGZ0KHRoaXMsZXx8W10sITEpKX0saXM6ZnVuY3Rpb24oZSl7cmV0dXJuISFmdCh0aGlzLFwic3RyaW5nXCI9PXR5cGVvZiBlJiZ1dC50ZXN0KGUpP3goZSk6ZXx8W10sITEpLmxlbmd0aH0sY2xvc2VzdDpmdW5jdGlvbihlLHQpe3ZhciBuLHI9MCxpPXRoaXMubGVuZ3RoLG89W10sYT11dC50ZXN0KGUpfHxcInN0cmluZ1wiIT10eXBlb2YgZT94KGUsdHx8dGhpcy5jb250ZXh0KTowO2Zvcig7aT5yO3IrKylmb3Iobj10aGlzW3JdO24mJm4hPT10O249bi5wYXJlbnROb2RlKWlmKDExPm4ubm9kZVR5cGUmJihhP2EuaW5kZXgobik+LTE6MT09PW4ubm9kZVR5cGUmJnguZmluZC5tYXRjaGVzU2VsZWN0b3IobixlKSkpe249by5wdXNoKG4pO2JyZWFrfXJldHVybiB0aGlzLnB1c2hTdGFjayhvLmxlbmd0aD4xP3gudW5pcXVlKG8pOm8pfSxpbmRleDpmdW5jdGlvbihlKXtyZXR1cm4gZT9cInN0cmluZ1wiPT10eXBlb2YgZT94LmluQXJyYXkodGhpc1swXSx4KGUpKTp4LmluQXJyYXkoZS5qcXVlcnk/ZVswXTplLHRoaXMpOnRoaXNbMF0mJnRoaXNbMF0ucGFyZW50Tm9kZT90aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aDotMX0sYWRkOmZ1bmN0aW9uKGUsdCl7dmFyIG49XCJzdHJpbmdcIj09dHlwZW9mIGU/eChlLHQpOngubWFrZUFycmF5KGUmJmUubm9kZVR5cGU/W2VdOmUpLHI9eC5tZXJnZSh0aGlzLmdldCgpLG4pO3JldHVybiB0aGlzLnB1c2hTdGFjayh4LnVuaXF1ZShyKSl9LGFkZEJhY2s6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYWRkKG51bGw9PWU/dGhpcy5wcmV2T2JqZWN0OnRoaXMucHJldk9iamVjdC5maWx0ZXIoZSkpfX0pO2Z1bmN0aW9uIHB0KGUsdCl7ZG8gZT1lW3RdO3doaWxlKGUmJjEhPT1lLm5vZGVUeXBlKTtyZXR1cm4gZX14LmVhY2goe3BhcmVudDpmdW5jdGlvbihlKXt2YXIgdD1lLnBhcmVudE5vZGU7cmV0dXJuIHQmJjExIT09dC5ub2RlVHlwZT90Om51bGx9LHBhcmVudHM6ZnVuY3Rpb24oZSl7cmV0dXJuIHguZGlyKGUsXCJwYXJlbnROb2RlXCIpfSxwYXJlbnRzVW50aWw6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB4LmRpcihlLFwicGFyZW50Tm9kZVwiLG4pfSxuZXh0OmZ1bmN0aW9uKGUpe3JldHVybiBwdChlLFwibmV4dFNpYmxpbmdcIil9LHByZXY6ZnVuY3Rpb24oZSl7cmV0dXJuIHB0KGUsXCJwcmV2aW91c1NpYmxpbmdcIil9LG5leHRBbGw6ZnVuY3Rpb24oZSl7cmV0dXJuIHguZGlyKGUsXCJuZXh0U2libGluZ1wiKX0scHJldkFsbDpmdW5jdGlvbihlKXtyZXR1cm4geC5kaXIoZSxcInByZXZpb3VzU2libGluZ1wiKX0sbmV4dFVudGlsOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4geC5kaXIoZSxcIm5leHRTaWJsaW5nXCIsbil9LHByZXZVbnRpbDpmdW5jdGlvbihlLHQsbil7cmV0dXJuIHguZGlyKGUsXCJwcmV2aW91c1NpYmxpbmdcIixuKX0sc2libGluZ3M6ZnVuY3Rpb24oZSl7cmV0dXJuIHguc2libGluZygoZS5wYXJlbnROb2RlfHx7fSkuZmlyc3RDaGlsZCxlKX0sY2hpbGRyZW46ZnVuY3Rpb24oZSl7cmV0dXJuIHguc2libGluZyhlLmZpcnN0Q2hpbGQpfSxjb250ZW50czpmdW5jdGlvbihlKXtyZXR1cm4geC5ub2RlTmFtZShlLFwiaWZyYW1lXCIpP2UuY29udGVudERvY3VtZW50fHxlLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ6eC5tZXJnZShbXSxlLmNoaWxkTm9kZXMpfX0sZnVuY3Rpb24oZSx0KXt4LmZuW2VdPWZ1bmN0aW9uKG4scil7dmFyIGk9eC5tYXAodGhpcyx0LG4pO3JldHVyblwiVW50aWxcIiE9PWUuc2xpY2UoLTUpJiYocj1uKSxyJiZcInN0cmluZ1wiPT10eXBlb2YgciYmKGk9eC5maWx0ZXIocixpKSksdGhpcy5sZW5ndGg+MSYmKGN0W2VdfHwoaT14LnVuaXF1ZShpKSksbHQudGVzdChlKSYmKGk9aS5yZXZlcnNlKCkpKSx0aGlzLnB1c2hTdGFjayhpKX19KSx4LmV4dGVuZCh7ZmlsdGVyOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10WzBdO3JldHVybiBuJiYoZT1cIjpub3QoXCIrZStcIilcIiksMT09PXQubGVuZ3RoJiYxPT09ci5ub2RlVHlwZT94LmZpbmQubWF0Y2hlc1NlbGVjdG9yKHIsZSk/W3JdOltdOnguZmluZC5tYXRjaGVzKGUseC5ncmVwKHQsZnVuY3Rpb24oZSl7cmV0dXJuIDE9PT1lLm5vZGVUeXBlfSkpfSxkaXI6ZnVuY3Rpb24oZSxuLHIpe3ZhciBpPVtdLG89ZVtuXTt3aGlsZShvJiY5IT09by5ub2RlVHlwZSYmKHI9PT10fHwxIT09by5ub2RlVHlwZXx8IXgobykuaXMocikpKTE9PT1vLm5vZGVUeXBlJiZpLnB1c2gobyksbz1vW25dO3JldHVybiBpfSxzaWJsaW5nOmZ1bmN0aW9uKGUsdCl7dmFyIG49W107Zm9yKDtlO2U9ZS5uZXh0U2libGluZykxPT09ZS5ub2RlVHlwZSYmZSE9PXQmJm4ucHVzaChlKTtyZXR1cm4gbn19KTtmdW5jdGlvbiBmdChlLHQsbil7aWYoeC5pc0Z1bmN0aW9uKHQpKXJldHVybiB4LmdyZXAoZSxmdW5jdGlvbihlLHIpe3JldHVybiEhdC5jYWxsKGUscixlKSE9PW59KTtpZih0Lm5vZGVUeXBlKXJldHVybiB4LmdyZXAoZSxmdW5jdGlvbihlKXtyZXR1cm4gZT09PXQhPT1ufSk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpe2lmKHN0LnRlc3QodCkpcmV0dXJuIHguZmlsdGVyKHQsZSxuKTt0PXguZmlsdGVyKHQsZSl9cmV0dXJuIHguZ3JlcChlLGZ1bmN0aW9uKGUpe3JldHVybiB4LmluQXJyYXkoZSx0KT49MCE9PW59KX1mdW5jdGlvbiBkdChlKXt2YXIgdD1odC5zcGxpdChcInxcIiksbj1lLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtpZihuLmNyZWF0ZUVsZW1lbnQpd2hpbGUodC5sZW5ndGgpbi5jcmVhdGVFbGVtZW50KHQucG9wKCkpO3JldHVybiBufXZhciBodD1cImFiYnJ8YXJ0aWNsZXxhc2lkZXxhdWRpb3xiZGl8Y2FudmFzfGRhdGF8ZGF0YWxpc3R8ZGV0YWlsc3xmaWdjYXB0aW9ufGZpZ3VyZXxmb290ZXJ8aGVhZGVyfGhncm91cHxtYXJrfG1ldGVyfG5hdnxvdXRwdXR8cHJvZ3Jlc3N8c2VjdGlvbnxzdW1tYXJ5fHRpbWV8dmlkZW9cIixndD0vIGpRdWVyeVxcZCs9XCIoPzpudWxsfFxcZCspXCIvZyxtdD1SZWdFeHAoXCI8KD86XCIraHQrXCIpW1xcXFxzLz5dXCIsXCJpXCIpLHl0PS9eXFxzKy8sdnQ9LzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcdzpdKylbXj5dKilcXC8+L2dpLGJ0PS88KFtcXHc6XSspLyx4dD0vPHRib2R5L2ksd3Q9Lzx8JiM/XFx3KzsvLFR0PS88KD86c2NyaXB0fHN0eWxlfGxpbmspL2ksQ3Q9L14oPzpjaGVja2JveHxyYWRpbykkL2ksTnQ9L2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxrdD0vXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pLEV0PS9edHJ1ZVxcLyguKikvLFN0PS9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZyxBdD17b3B0aW9uOlsxLFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLFwiPC9zZWxlY3Q+XCJdLGxlZ2VuZDpbMSxcIjxmaWVsZHNldD5cIixcIjwvZmllbGRzZXQ+XCJdLGFyZWE6WzEsXCI8bWFwPlwiLFwiPC9tYXA+XCJdLHBhcmFtOlsxLFwiPG9iamVjdD5cIixcIjwvb2JqZWN0PlwiXSx0aGVhZDpbMSxcIjx0YWJsZT5cIixcIjwvdGFibGU+XCJdLHRyOlsyLFwiPHRhYmxlPjx0Ym9keT5cIixcIjwvdGJvZHk+PC90YWJsZT5cIl0sY29sOlsyLFwiPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD5cIixcIjwvY29sZ3JvdXA+PC90YWJsZT5cIl0sdGQ6WzMsXCI8dGFibGU+PHRib2R5Pjx0cj5cIixcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiXSxfZGVmYXVsdDp4LnN1cHBvcnQuaHRtbFNlcmlhbGl6ZT9bMCxcIlwiLFwiXCJdOlsxLFwiWDxkaXY+XCIsXCI8L2Rpdj5cIl19LGp0PWR0KGEpLER0PWp0LmFwcGVuZENoaWxkKGEuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7QXQub3B0Z3JvdXA9QXQub3B0aW9uLEF0LnRib2R5PUF0LnRmb290PUF0LmNvbGdyb3VwPUF0LmNhcHRpb249QXQudGhlYWQsQXQudGg9QXQudGQseC5mbi5leHRlbmQoe3RleHQ6ZnVuY3Rpb24oZSl7cmV0dXJuIHguYWNjZXNzKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT10P3gudGV4dCh0aGlzKTp0aGlzLmVtcHR5KCkuYXBwZW5kKCh0aGlzWzBdJiZ0aGlzWzBdLm93bmVyRG9jdW1lbnR8fGEpLmNyZWF0ZVRleHROb2RlKGUpKX0sbnVsbCxlLGFyZ3VtZW50cy5sZW5ndGgpfSxhcHBlbmQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsZnVuY3Rpb24oZSl7aWYoMT09PXRoaXMubm9kZVR5cGV8fDExPT09dGhpcy5ub2RlVHlwZXx8OT09PXRoaXMubm9kZVR5cGUpe3ZhciB0PUx0KHRoaXMsZSk7dC5hcHBlbmRDaGlsZChlKX19KX0scHJlcGVuZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cyxmdW5jdGlvbihlKXtpZigxPT09dGhpcy5ub2RlVHlwZXx8MTE9PT10aGlzLm5vZGVUeXBlfHw5PT09dGhpcy5ub2RlVHlwZSl7dmFyIHQ9THQodGhpcyxlKTt0Lmluc2VydEJlZm9yZShlLHQuZmlyc3RDaGlsZCl9fSl9LGJlZm9yZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cyxmdW5jdGlvbihlKXt0aGlzLnBhcmVudE5vZGUmJnRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZSx0aGlzKX0pfSxhZnRlcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cyxmdW5jdGlvbihlKXt0aGlzLnBhcmVudE5vZGUmJnRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZSx0aGlzLm5leHRTaWJsaW5nKX0pfSxyZW1vdmU6ZnVuY3Rpb24oZSx0KXt2YXIgbixyPWU/eC5maWx0ZXIoZSx0aGlzKTp0aGlzLGk9MDtmb3IoO251bGwhPShuPXJbaV0pO2krKyl0fHwxIT09bi5ub2RlVHlwZXx8eC5jbGVhbkRhdGEoRnQobikpLG4ucGFyZW50Tm9kZSYmKHQmJnguY29udGFpbnMobi5vd25lckRvY3VtZW50LG4pJiZfdChGdChuLFwic2NyaXB0XCIpKSxuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobikpO3JldHVybiB0aGlzfSxlbXB0eTpmdW5jdGlvbigpe3ZhciBlLHQ9MDtmb3IoO251bGwhPShlPXRoaXNbdF0pO3QrKyl7MT09PWUubm9kZVR5cGUmJnguY2xlYW5EYXRhKEZ0KGUsITEpKTt3aGlsZShlLmZpcnN0Q2hpbGQpZS5yZW1vdmVDaGlsZChlLmZpcnN0Q2hpbGQpO2Uub3B0aW9ucyYmeC5ub2RlTmFtZShlLFwic2VsZWN0XCIpJiYoZS5vcHRpb25zLmxlbmd0aD0wKX1yZXR1cm4gdGhpc30sY2xvbmU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT1udWxsPT1lPyExOmUsdD1udWxsPT10P2U6dCx0aGlzLm1hcChmdW5jdGlvbigpe3JldHVybiB4LmNsb25lKHRoaXMsZSx0KX0pfSxodG1sOmZ1bmN0aW9uKGUpe3JldHVybiB4LmFjY2Vzcyh0aGlzLGZ1bmN0aW9uKGUpe3ZhciBuPXRoaXNbMF18fHt9LHI9MCxpPXRoaXMubGVuZ3RoO2lmKGU9PT10KXJldHVybiAxPT09bi5ub2RlVHlwZT9uLmlubmVySFRNTC5yZXBsYWNlKGd0LFwiXCIpOnQ7aWYoIShcInN0cmluZ1wiIT10eXBlb2YgZXx8VHQudGVzdChlKXx8IXguc3VwcG9ydC5odG1sU2VyaWFsaXplJiZtdC50ZXN0KGUpfHwheC5zdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlJiZ5dC50ZXN0KGUpfHxBdFsoYnQuZXhlYyhlKXx8W1wiXCIsXCJcIl0pWzFdLnRvTG93ZXJDYXNlKCldKSl7ZT1lLnJlcGxhY2UodnQsXCI8JDE+PC8kMj5cIik7dHJ5e2Zvcig7aT5yO3IrKyluPXRoaXNbcl18fHt9LDE9PT1uLm5vZGVUeXBlJiYoeC5jbGVhbkRhdGEoRnQobiwhMSkpLG4uaW5uZXJIVE1MPWUpO249MH1jYXRjaChvKXt9fW4mJnRoaXMuZW1wdHkoKS5hcHBlbmQoZSl9LG51bGwsZSxhcmd1bWVudHMubGVuZ3RoKX0scmVwbGFjZVdpdGg6ZnVuY3Rpb24oKXt2YXIgZT14Lm1hcCh0aGlzLGZ1bmN0aW9uKGUpe3JldHVybltlLm5leHRTaWJsaW5nLGUucGFyZW50Tm9kZV19KSx0PTA7cmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLGZ1bmN0aW9uKG4pe3ZhciByPWVbdCsrXSxpPWVbdCsrXTtpJiYociYmci5wYXJlbnROb2RlIT09aSYmKHI9dGhpcy5uZXh0U2libGluZykseCh0aGlzKS5yZW1vdmUoKSxpLmluc2VydEJlZm9yZShuLHIpKX0sITApLHQ/dGhpczp0aGlzLnJlbW92ZSgpfSxkZXRhY2g6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVtb3ZlKGUsITApfSxkb21NYW5pcDpmdW5jdGlvbihlLHQsbil7ZT1kLmFwcGx5KFtdLGUpO3ZhciByLGksbyxhLHMsbCx1PTAsYz10aGlzLmxlbmd0aCxwPXRoaXMsZj1jLTEsaD1lWzBdLGc9eC5pc0Z1bmN0aW9uKGgpO2lmKGd8fCEoMT49Y3x8XCJzdHJpbmdcIiE9dHlwZW9mIGh8fHguc3VwcG9ydC5jaGVja0Nsb25lKSYmTnQudGVzdChoKSlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKHIpe3ZhciBpPXAuZXEocik7ZyYmKGVbMF09aC5jYWxsKHRoaXMscixpLmh0bWwoKSkpLGkuZG9tTWFuaXAoZSx0LG4pfSk7aWYoYyYmKGw9eC5idWlsZEZyYWdtZW50KGUsdGhpc1swXS5vd25lckRvY3VtZW50LCExLCFuJiZ0aGlzKSxyPWwuZmlyc3RDaGlsZCwxPT09bC5jaGlsZE5vZGVzLmxlbmd0aCYmKGw9cikscikpe2ZvcihhPXgubWFwKEZ0KGwsXCJzY3JpcHRcIiksSHQpLG89YS5sZW5ndGg7Yz51O3UrKylpPWwsdSE9PWYmJihpPXguY2xvbmUoaSwhMCwhMCksbyYmeC5tZXJnZShhLEZ0KGksXCJzY3JpcHRcIikpKSx0LmNhbGwodGhpc1t1XSxpLHUpO2lmKG8pZm9yKHM9YVthLmxlbmd0aC0xXS5vd25lckRvY3VtZW50LHgubWFwKGEscXQpLHU9MDtvPnU7dSsrKWk9YVt1XSxrdC50ZXN0KGkudHlwZXx8XCJcIikmJiF4Ll9kYXRhKGksXCJnbG9iYWxFdmFsXCIpJiZ4LmNvbnRhaW5zKHMsaSkmJihpLnNyYz94Ll9ldmFsVXJsKGkuc3JjKTp4Lmdsb2JhbEV2YWwoKGkudGV4dHx8aS50ZXh0Q29udGVudHx8aS5pbm5lckhUTUx8fFwiXCIpLnJlcGxhY2UoU3QsXCJcIikpKTtsPXI9bnVsbH1yZXR1cm4gdGhpc319KTtmdW5jdGlvbiBMdChlLHQpe3JldHVybiB4Lm5vZGVOYW1lKGUsXCJ0YWJsZVwiKSYmeC5ub2RlTmFtZSgxPT09dC5ub2RlVHlwZT90OnQuZmlyc3RDaGlsZCxcInRyXCIpP2UuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0Ym9keVwiKVswXXx8ZS5hcHBlbmRDaGlsZChlLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRib2R5XCIpKTplfWZ1bmN0aW9uIEh0KGUpe3JldHVybiBlLnR5cGU9KG51bGwhPT14LmZpbmQuYXR0cihlLFwidHlwZVwiKSkrXCIvXCIrZS50eXBlLGV9ZnVuY3Rpb24gcXQoZSl7dmFyIHQ9RXQuZXhlYyhlLnR5cGUpO3JldHVybiB0P2UudHlwZT10WzFdOmUucmVtb3ZlQXR0cmlidXRlKFwidHlwZVwiKSxlfWZ1bmN0aW9uIF90KGUsdCl7dmFyIG4scj0wO2Zvcig7bnVsbCE9KG49ZVtyXSk7cisrKXguX2RhdGEobixcImdsb2JhbEV2YWxcIiwhdHx8eC5fZGF0YSh0W3JdLFwiZ2xvYmFsRXZhbFwiKSl9ZnVuY3Rpb24gTXQoZSx0KXtpZigxPT09dC5ub2RlVHlwZSYmeC5oYXNEYXRhKGUpKXt2YXIgbixyLGksbz14Ll9kYXRhKGUpLGE9eC5fZGF0YSh0LG8pLHM9by5ldmVudHM7aWYocyl7ZGVsZXRlIGEuaGFuZGxlLGEuZXZlbnRzPXt9O2ZvcihuIGluIHMpZm9yKHI9MCxpPXNbbl0ubGVuZ3RoO2k+cjtyKyspeC5ldmVudC5hZGQodCxuLHNbbl1bcl0pfWEuZGF0YSYmKGEuZGF0YT14LmV4dGVuZCh7fSxhLmRhdGEpKX19ZnVuY3Rpb24gT3QoZSx0KXt2YXIgbixyLGk7aWYoMT09PXQubm9kZVR5cGUpe2lmKG49dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLCF4LnN1cHBvcnQubm9DbG9uZUV2ZW50JiZ0W3guZXhwYW5kb10pe2k9eC5fZGF0YSh0KTtmb3IociBpbiBpLmV2ZW50cyl4LnJlbW92ZUV2ZW50KHQscixpLmhhbmRsZSk7dC5yZW1vdmVBdHRyaWJ1dGUoeC5leHBhbmRvKX1cInNjcmlwdFwiPT09biYmdC50ZXh0IT09ZS50ZXh0PyhIdCh0KS50ZXh0PWUudGV4dCxxdCh0KSk6XCJvYmplY3RcIj09PW4/KHQucGFyZW50Tm9kZSYmKHQub3V0ZXJIVE1MPWUub3V0ZXJIVE1MKSx4LnN1cHBvcnQuaHRtbDVDbG9uZSYmZS5pbm5lckhUTUwmJiF4LnRyaW0odC5pbm5lckhUTUwpJiYodC5pbm5lckhUTUw9ZS5pbm5lckhUTUwpKTpcImlucHV0XCI9PT1uJiZDdC50ZXN0KGUudHlwZSk/KHQuZGVmYXVsdENoZWNrZWQ9dC5jaGVja2VkPWUuY2hlY2tlZCx0LnZhbHVlIT09ZS52YWx1ZSYmKHQudmFsdWU9ZS52YWx1ZSkpOlwib3B0aW9uXCI9PT1uP3QuZGVmYXVsdFNlbGVjdGVkPXQuc2VsZWN0ZWQ9ZS5kZWZhdWx0U2VsZWN0ZWQ6KFwiaW5wdXRcIj09PW58fFwidGV4dGFyZWFcIj09PW4pJiYodC5kZWZhdWx0VmFsdWU9ZS5kZWZhdWx0VmFsdWUpfX14LmVhY2goe2FwcGVuZFRvOlwiYXBwZW5kXCIscHJlcGVuZFRvOlwicHJlcGVuZFwiLGluc2VydEJlZm9yZTpcImJlZm9yZVwiLGluc2VydEFmdGVyOlwiYWZ0ZXJcIixyZXBsYWNlQWxsOlwicmVwbGFjZVdpdGhcIn0sZnVuY3Rpb24oZSx0KXt4LmZuW2VdPWZ1bmN0aW9uKGUpe3ZhciBuLHI9MCxpPVtdLG89eChlKSxhPW8ubGVuZ3RoLTE7Zm9yKDthPj1yO3IrKyluPXI9PT1hP3RoaXM6dGhpcy5jbG9uZSghMCkseChvW3JdKVt0XShuKSxoLmFwcGx5KGksbi5nZXQoKSk7cmV0dXJuIHRoaXMucHVzaFN0YWNrKGkpfX0pO2Z1bmN0aW9uIEZ0KGUsbil7dmFyIHIsbyxhPTAscz10eXBlb2YgZS5nZXRFbGVtZW50c0J5VGFnTmFtZSE9PWk/ZS5nZXRFbGVtZW50c0J5VGFnTmFtZShufHxcIipcIik6dHlwZW9mIGUucXVlcnlTZWxlY3RvckFsbCE9PWk/ZS5xdWVyeVNlbGVjdG9yQWxsKG58fFwiKlwiKTp0O2lmKCFzKWZvcihzPVtdLHI9ZS5jaGlsZE5vZGVzfHxlO251bGwhPShvPXJbYV0pO2ErKykhbnx8eC5ub2RlTmFtZShvLG4pP3MucHVzaChvKTp4Lm1lcmdlKHMsRnQobyxuKSk7cmV0dXJuIG49PT10fHxuJiZ4Lm5vZGVOYW1lKGUsbik/eC5tZXJnZShbZV0scyk6c31mdW5jdGlvbiBCdChlKXtDdC50ZXN0KGUudHlwZSkmJihlLmRlZmF1bHRDaGVja2VkPWUuY2hlY2tlZCl9eC5leHRlbmQoe2Nsb25lOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG8sYSxzLGw9eC5jb250YWlucyhlLm93bmVyRG9jdW1lbnQsZSk7aWYoeC5zdXBwb3J0Lmh0bWw1Q2xvbmV8fHguaXNYTUxEb2MoZSl8fCFtdC50ZXN0KFwiPFwiK2Uubm9kZU5hbWUrXCI+XCIpP289ZS5jbG9uZU5vZGUoITApOihEdC5pbm5lckhUTUw9ZS5vdXRlckhUTUwsRHQucmVtb3ZlQ2hpbGQobz1EdC5maXJzdENoaWxkKSksISh4LnN1cHBvcnQubm9DbG9uZUV2ZW50JiZ4LnN1cHBvcnQubm9DbG9uZUNoZWNrZWR8fDEhPT1lLm5vZGVUeXBlJiYxMSE9PWUubm9kZVR5cGV8fHguaXNYTUxEb2MoZSkpKWZvcihyPUZ0KG8pLHM9RnQoZSksYT0wO251bGwhPShpPXNbYV0pOysrYSlyW2FdJiZPdChpLHJbYV0pO2lmKHQpaWYobilmb3Iocz1zfHxGdChlKSxyPXJ8fEZ0KG8pLGE9MDtudWxsIT0oaT1zW2FdKTthKyspTXQoaSxyW2FdKTtlbHNlIE10KGUsbyk7cmV0dXJuIHI9RnQobyxcInNjcmlwdFwiKSxyLmxlbmd0aD4wJiZfdChyLCFsJiZGdChlLFwic2NyaXB0XCIpKSxyPXM9aT1udWxsLG99LGJ1aWxkRnJhZ21lbnQ6ZnVuY3Rpb24oZSx0LG4scil7dmFyIGksbyxhLHMsbCx1LGMscD1lLmxlbmd0aCxmPWR0KHQpLGQ9W10saD0wO2Zvcig7cD5oO2grKylpZihvPWVbaF0sb3x8MD09PW8paWYoXCJvYmplY3RcIj09PXgudHlwZShvKSl4Lm1lcmdlKGQsby5ub2RlVHlwZT9bb106byk7ZWxzZSBpZih3dC50ZXN0KG8pKXtzPXN8fGYuYXBwZW5kQ2hpbGQodC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSxsPShidC5leGVjKG8pfHxbXCJcIixcIlwiXSlbMV0udG9Mb3dlckNhc2UoKSxjPUF0W2xdfHxBdC5fZGVmYXVsdCxzLmlubmVySFRNTD1jWzFdK28ucmVwbGFjZSh2dCxcIjwkMT48LyQyPlwiKStjWzJdLGk9Y1swXTt3aGlsZShpLS0pcz1zLmxhc3RDaGlsZDtpZigheC5zdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlJiZ5dC50ZXN0KG8pJiZkLnB1c2godC5jcmVhdGVUZXh0Tm9kZSh5dC5leGVjKG8pWzBdKSksIXguc3VwcG9ydC50Ym9keSl7bz1cInRhYmxlXCIhPT1sfHx4dC50ZXN0KG8pP1wiPHRhYmxlPlwiIT09Y1sxXXx8eHQudGVzdChvKT8wOnM6cy5maXJzdENoaWxkLGk9byYmby5jaGlsZE5vZGVzLmxlbmd0aDt3aGlsZShpLS0peC5ub2RlTmFtZSh1PW8uY2hpbGROb2Rlc1tpXSxcInRib2R5XCIpJiYhdS5jaGlsZE5vZGVzLmxlbmd0aCYmby5yZW1vdmVDaGlsZCh1KX14Lm1lcmdlKGQscy5jaGlsZE5vZGVzKSxzLnRleHRDb250ZW50PVwiXCI7d2hpbGUocy5maXJzdENoaWxkKXMucmVtb3ZlQ2hpbGQocy5maXJzdENoaWxkKTtzPWYubGFzdENoaWxkfWVsc2UgZC5wdXNoKHQuY3JlYXRlVGV4dE5vZGUobykpO3MmJmYucmVtb3ZlQ2hpbGQocykseC5zdXBwb3J0LmFwcGVuZENoZWNrZWR8fHguZ3JlcChGdChkLFwiaW5wdXRcIiksQnQpLGg9MDt3aGlsZShvPWRbaCsrXSlpZigoIXJ8fC0xPT09eC5pbkFycmF5KG8scikpJiYoYT14LmNvbnRhaW5zKG8ub3duZXJEb2N1bWVudCxvKSxzPUZ0KGYuYXBwZW5kQ2hpbGQobyksXCJzY3JpcHRcIiksYSYmX3Qocyksbikpe2k9MDt3aGlsZShvPXNbaSsrXSlrdC50ZXN0KG8udHlwZXx8XCJcIikmJm4ucHVzaChvKX1yZXR1cm4gcz1udWxsLGZ9LGNsZWFuRGF0YTpmdW5jdGlvbihlLHQpe3ZhciBuLHIsbyxhLHM9MCxsPXguZXhwYW5kbyx1PXguY2FjaGUsYz14LnN1cHBvcnQuZGVsZXRlRXhwYW5kbyxmPXguZXZlbnQuc3BlY2lhbDtmb3IoO251bGwhPShuPWVbc10pO3MrKylpZigodHx8eC5hY2NlcHREYXRhKG4pKSYmKG89bltsXSxhPW8mJnVbb10pKXtpZihhLmV2ZW50cylmb3IociBpbiBhLmV2ZW50cylmW3JdP3guZXZlbnQucmVtb3ZlKG4scik6eC5yZW1vdmVFdmVudChuLHIsYS5oYW5kbGUpO1xudVtvXSYmKGRlbGV0ZSB1W29dLGM/ZGVsZXRlIG5bbF06dHlwZW9mIG4ucmVtb3ZlQXR0cmlidXRlIT09aT9uLnJlbW92ZUF0dHJpYnV0ZShsKTpuW2xdPW51bGwscC5wdXNoKG8pKX19LF9ldmFsVXJsOmZ1bmN0aW9uKGUpe3JldHVybiB4LmFqYXgoe3VybDplLHR5cGU6XCJHRVRcIixkYXRhVHlwZTpcInNjcmlwdFwiLGFzeW5jOiExLGdsb2JhbDohMSxcInRocm93c1wiOiEwfSl9fSkseC5mbi5leHRlbmQoe3dyYXBBbGw6ZnVuY3Rpb24oZSl7aWYoeC5pc0Z1bmN0aW9uKGUpKXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24odCl7eCh0aGlzKS53cmFwQWxsKGUuY2FsbCh0aGlzLHQpKX0pO2lmKHRoaXNbMF0pe3ZhciB0PXgoZSx0aGlzWzBdLm93bmVyRG9jdW1lbnQpLmVxKDApLmNsb25lKCEwKTt0aGlzWzBdLnBhcmVudE5vZGUmJnQuaW5zZXJ0QmVmb3JlKHRoaXNbMF0pLHQubWFwKGZ1bmN0aW9uKCl7dmFyIGU9dGhpczt3aGlsZShlLmZpcnN0Q2hpbGQmJjE9PT1lLmZpcnN0Q2hpbGQubm9kZVR5cGUpZT1lLmZpcnN0Q2hpbGQ7cmV0dXJuIGV9KS5hcHBlbmQodGhpcyl9cmV0dXJuIHRoaXN9LHdyYXBJbm5lcjpmdW5jdGlvbihlKXtyZXR1cm4geC5pc0Z1bmN0aW9uKGUpP3RoaXMuZWFjaChmdW5jdGlvbih0KXt4KHRoaXMpLndyYXBJbm5lcihlLmNhbGwodGhpcyx0KSl9KTp0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgdD14KHRoaXMpLG49dC5jb250ZW50cygpO24ubGVuZ3RoP24ud3JhcEFsbChlKTp0LmFwcGVuZChlKX0pfSx3cmFwOmZ1bmN0aW9uKGUpe3ZhciB0PXguaXNGdW5jdGlvbihlKTtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKG4pe3godGhpcykud3JhcEFsbCh0P2UuY2FsbCh0aGlzLG4pOmUpfSl9LHVud3JhcDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmVudCgpLmVhY2goZnVuY3Rpb24oKXt4Lm5vZGVOYW1lKHRoaXMsXCJib2R5XCIpfHx4KHRoaXMpLnJlcGxhY2VXaXRoKHRoaXMuY2hpbGROb2Rlcyl9KS5lbmQoKX19KTt2YXIgUHQsUnQsV3QsJHQ9L2FscGhhXFwoW14pXSpcXCkvaSxJdD0vb3BhY2l0eVxccyo9XFxzKihbXildKikvLHp0PS9eKHRvcHxyaWdodHxib3R0b218bGVmdCkkLyxYdD0vXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sVXQ9L15tYXJnaW4vLFZ0PVJlZ0V4cChcIl4oXCIrdytcIikoLiopJFwiLFwiaVwiKSxZdD1SZWdFeHAoXCJeKFwiK3crXCIpKD8hcHgpW2EteiVdKyRcIixcImlcIiksSnQ9UmVnRXhwKFwiXihbKy1dKT0oXCIrdytcIilcIixcImlcIiksR3Q9e0JPRFk6XCJibG9ja1wifSxRdD17cG9zaXRpb246XCJhYnNvbHV0ZVwiLHZpc2liaWxpdHk6XCJoaWRkZW5cIixkaXNwbGF5OlwiYmxvY2tcIn0sS3Q9e2xldHRlclNwYWNpbmc6MCxmb250V2VpZ2h0OjQwMH0sWnQ9W1wiVG9wXCIsXCJSaWdodFwiLFwiQm90dG9tXCIsXCJMZWZ0XCJdLGVuPVtcIldlYmtpdFwiLFwiT1wiLFwiTW96XCIsXCJtc1wiXTtmdW5jdGlvbiB0bihlLHQpe2lmKHQgaW4gZSlyZXR1cm4gdDt2YXIgbj10LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSkscj10LGk9ZW4ubGVuZ3RoO3doaWxlKGktLSlpZih0PWVuW2ldK24sdCBpbiBlKXJldHVybiB0O3JldHVybiByfWZ1bmN0aW9uIG5uKGUsdCl7cmV0dXJuIGU9dHx8ZSxcIm5vbmVcIj09PXguY3NzKGUsXCJkaXNwbGF5XCIpfHwheC5jb250YWlucyhlLm93bmVyRG9jdW1lbnQsZSl9ZnVuY3Rpb24gcm4oZSx0KXt2YXIgbixyLGksbz1bXSxhPTAscz1lLmxlbmd0aDtmb3IoO3M+YTthKyspcj1lW2FdLHIuc3R5bGUmJihvW2FdPXguX2RhdGEocixcIm9sZGRpc3BsYXlcIiksbj1yLnN0eWxlLmRpc3BsYXksdD8ob1thXXx8XCJub25lXCIhPT1ufHwoci5zdHlsZS5kaXNwbGF5PVwiXCIpLFwiXCI9PT1yLnN0eWxlLmRpc3BsYXkmJm5uKHIpJiYob1thXT14Ll9kYXRhKHIsXCJvbGRkaXNwbGF5XCIsbG4oci5ub2RlTmFtZSkpKSk6b1thXXx8KGk9bm4ociksKG4mJlwibm9uZVwiIT09bnx8IWkpJiZ4Ll9kYXRhKHIsXCJvbGRkaXNwbGF5XCIsaT9uOnguY3NzKHIsXCJkaXNwbGF5XCIpKSkpO2ZvcihhPTA7cz5hO2ErKylyPWVbYV0sci5zdHlsZSYmKHQmJlwibm9uZVwiIT09ci5zdHlsZS5kaXNwbGF5JiZcIlwiIT09ci5zdHlsZS5kaXNwbGF5fHwoci5zdHlsZS5kaXNwbGF5PXQ/b1thXXx8XCJcIjpcIm5vbmVcIikpO3JldHVybiBlfXguZm4uZXh0ZW5kKHtjc3M6ZnVuY3Rpb24oZSxuKXtyZXR1cm4geC5hY2Nlc3ModGhpcyxmdW5jdGlvbihlLG4scil7dmFyIGksbyxhPXt9LHM9MDtpZih4LmlzQXJyYXkobikpe2ZvcihvPVJ0KGUpLGk9bi5sZW5ndGg7aT5zO3MrKylhW25bc11dPXguY3NzKGUsbltzXSwhMSxvKTtyZXR1cm4gYX1yZXR1cm4gciE9PXQ/eC5zdHlsZShlLG4scik6eC5jc3MoZSxuKX0sZSxuLGFyZ3VtZW50cy5sZW5ndGg+MSl9LHNob3c6ZnVuY3Rpb24oKXtyZXR1cm4gcm4odGhpcywhMCl9LGhpZGU6ZnVuY3Rpb24oKXtyZXR1cm4gcm4odGhpcyl9LHRvZ2dsZTpmdW5jdGlvbihlKXtyZXR1cm5cImJvb2xlYW5cIj09dHlwZW9mIGU/ZT90aGlzLnNob3coKTp0aGlzLmhpZGUoKTp0aGlzLmVhY2goZnVuY3Rpb24oKXtubih0aGlzKT94KHRoaXMpLnNob3coKTp4KHRoaXMpLmhpZGUoKX0pfX0pLHguZXh0ZW5kKHtjc3NIb29rczp7b3BhY2l0eTp7Z2V0OmZ1bmN0aW9uKGUsdCl7aWYodCl7dmFyIG49V3QoZSxcIm9wYWNpdHlcIik7cmV0dXJuXCJcIj09PW4/XCIxXCI6bn19fX0sY3NzTnVtYmVyOntjb2x1bW5Db3VudDohMCxmaWxsT3BhY2l0eTohMCxmb250V2VpZ2h0OiEwLGxpbmVIZWlnaHQ6ITAsb3BhY2l0eTohMCxvcmRlcjohMCxvcnBoYW5zOiEwLHdpZG93czohMCx6SW5kZXg6ITAsem9vbTohMH0sY3NzUHJvcHM6e1wiZmxvYXRcIjp4LnN1cHBvcnQuY3NzRmxvYXQ/XCJjc3NGbG9hdFwiOlwic3R5bGVGbG9hdFwifSxzdHlsZTpmdW5jdGlvbihlLG4scixpKXtpZihlJiYzIT09ZS5ub2RlVHlwZSYmOCE9PWUubm9kZVR5cGUmJmUuc3R5bGUpe3ZhciBvLGEscyxsPXguY2FtZWxDYXNlKG4pLHU9ZS5zdHlsZTtpZihuPXguY3NzUHJvcHNbbF18fCh4LmNzc1Byb3BzW2xdPXRuKHUsbCkpLHM9eC5jc3NIb29rc1tuXXx8eC5jc3NIb29rc1tsXSxyPT09dClyZXR1cm4gcyYmXCJnZXRcImluIHMmJihvPXMuZ2V0KGUsITEsaSkpIT09dD9vOnVbbl07aWYoYT10eXBlb2YgcixcInN0cmluZ1wiPT09YSYmKG89SnQuZXhlYyhyKSkmJihyPShvWzFdKzEpKm9bMl0rcGFyc2VGbG9hdCh4LmNzcyhlLG4pKSxhPVwibnVtYmVyXCIpLCEobnVsbD09cnx8XCJudW1iZXJcIj09PWEmJmlzTmFOKHIpfHwoXCJudW1iZXJcIiE9PWF8fHguY3NzTnVtYmVyW2xdfHwocis9XCJweFwiKSx4LnN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlfHxcIlwiIT09cnx8MCE9PW4uaW5kZXhPZihcImJhY2tncm91bmRcIil8fCh1W25dPVwiaW5oZXJpdFwiKSxzJiZcInNldFwiaW4gcyYmKHI9cy5zZXQoZSxyLGkpKT09PXQpKSl0cnl7dVtuXT1yfWNhdGNoKGMpe319fSxjc3M6ZnVuY3Rpb24oZSxuLHIsaSl7dmFyIG8sYSxzLGw9eC5jYW1lbENhc2Uobik7cmV0dXJuIG49eC5jc3NQcm9wc1tsXXx8KHguY3NzUHJvcHNbbF09dG4oZS5zdHlsZSxsKSkscz14LmNzc0hvb2tzW25dfHx4LmNzc0hvb2tzW2xdLHMmJlwiZ2V0XCJpbiBzJiYoYT1zLmdldChlLCEwLHIpKSxhPT09dCYmKGE9V3QoZSxuLGkpKSxcIm5vcm1hbFwiPT09YSYmbiBpbiBLdCYmKGE9S3Rbbl0pLFwiXCI9PT1yfHxyPyhvPXBhcnNlRmxvYXQoYSkscj09PSEwfHx4LmlzTnVtZXJpYyhvKT9vfHwwOmEpOmF9fSksZS5nZXRDb21wdXRlZFN0eWxlPyhSdD1mdW5jdGlvbih0KXtyZXR1cm4gZS5nZXRDb21wdXRlZFN0eWxlKHQsbnVsbCl9LFd0PWZ1bmN0aW9uKGUsbixyKXt2YXIgaSxvLGEscz1yfHxSdChlKSxsPXM/cy5nZXRQcm9wZXJ0eVZhbHVlKG4pfHxzW25dOnQsdT1lLnN0eWxlO3JldHVybiBzJiYoXCJcIiE9PWx8fHguY29udGFpbnMoZS5vd25lckRvY3VtZW50LGUpfHwobD14LnN0eWxlKGUsbikpLFl0LnRlc3QobCkmJlV0LnRlc3QobikmJihpPXUud2lkdGgsbz11Lm1pbldpZHRoLGE9dS5tYXhXaWR0aCx1Lm1pbldpZHRoPXUubWF4V2lkdGg9dS53aWR0aD1sLGw9cy53aWR0aCx1LndpZHRoPWksdS5taW5XaWR0aD1vLHUubWF4V2lkdGg9YSkpLGx9KTphLmRvY3VtZW50RWxlbWVudC5jdXJyZW50U3R5bGUmJihSdD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jdXJyZW50U3R5bGV9LFd0PWZ1bmN0aW9uKGUsbixyKXt2YXIgaSxvLGEscz1yfHxSdChlKSxsPXM/c1tuXTp0LHU9ZS5zdHlsZTtyZXR1cm4gbnVsbD09bCYmdSYmdVtuXSYmKGw9dVtuXSksWXQudGVzdChsKSYmIXp0LnRlc3QobikmJihpPXUubGVmdCxvPWUucnVudGltZVN0eWxlLGE9byYmby5sZWZ0LGEmJihvLmxlZnQ9ZS5jdXJyZW50U3R5bGUubGVmdCksdS5sZWZ0PVwiZm9udFNpemVcIj09PW4/XCIxZW1cIjpsLGw9dS5waXhlbExlZnQrXCJweFwiLHUubGVmdD1pLGEmJihvLmxlZnQ9YSkpLFwiXCI9PT1sP1wiYXV0b1wiOmx9KTtmdW5jdGlvbiBvbihlLHQsbil7dmFyIHI9VnQuZXhlYyh0KTtyZXR1cm4gcj9NYXRoLm1heCgwLHJbMV0tKG58fDApKSsoclsyXXx8XCJweFwiKTp0fWZ1bmN0aW9uIGFuKGUsdCxuLHIsaSl7dmFyIG89bj09PShyP1wiYm9yZGVyXCI6XCJjb250ZW50XCIpPzQ6XCJ3aWR0aFwiPT09dD8xOjAsYT0wO2Zvcig7ND5vO28rPTIpXCJtYXJnaW5cIj09PW4mJihhKz14LmNzcyhlLG4rWnRbb10sITAsaSkpLHI/KFwiY29udGVudFwiPT09biYmKGEtPXguY3NzKGUsXCJwYWRkaW5nXCIrWnRbb10sITAsaSkpLFwibWFyZ2luXCIhPT1uJiYoYS09eC5jc3MoZSxcImJvcmRlclwiK1p0W29dK1wiV2lkdGhcIiwhMCxpKSkpOihhKz14LmNzcyhlLFwicGFkZGluZ1wiK1p0W29dLCEwLGkpLFwicGFkZGluZ1wiIT09biYmKGErPXguY3NzKGUsXCJib3JkZXJcIitadFtvXStcIldpZHRoXCIsITAsaSkpKTtyZXR1cm4gYX1mdW5jdGlvbiBzbihlLHQsbil7dmFyIHI9ITAsaT1cIndpZHRoXCI9PT10P2Uub2Zmc2V0V2lkdGg6ZS5vZmZzZXRIZWlnaHQsbz1SdChlKSxhPXguc3VwcG9ydC5ib3hTaXppbmcmJlwiYm9yZGVyLWJveFwiPT09eC5jc3MoZSxcImJveFNpemluZ1wiLCExLG8pO2lmKDA+PWl8fG51bGw9PWkpe2lmKGk9V3QoZSx0LG8pLCgwPml8fG51bGw9PWkpJiYoaT1lLnN0eWxlW3RdKSxZdC50ZXN0KGkpKXJldHVybiBpO3I9YSYmKHguc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZXx8aT09PWUuc3R5bGVbdF0pLGk9cGFyc2VGbG9hdChpKXx8MH1yZXR1cm4gaSthbihlLHQsbnx8KGE/XCJib3JkZXJcIjpcImNvbnRlbnRcIikscixvKStcInB4XCJ9ZnVuY3Rpb24gbG4oZSl7dmFyIHQ9YSxuPUd0W2VdO3JldHVybiBufHwobj11bihlLHQpLFwibm9uZVwiIT09biYmbnx8KFB0PShQdHx8eChcIjxpZnJhbWUgZnJhbWVib3JkZXI9JzAnIHdpZHRoPScwJyBoZWlnaHQ9JzAnLz5cIikuY3NzKFwiY3NzVGV4dFwiLFwiZGlzcGxheTpibG9jayAhaW1wb3J0YW50XCIpKS5hcHBlbmRUbyh0LmRvY3VtZW50RWxlbWVudCksdD0oUHRbMF0uY29udGVudFdpbmRvd3x8UHRbMF0uY29udGVudERvY3VtZW50KS5kb2N1bWVudCx0LndyaXRlKFwiPCFkb2N0eXBlIGh0bWw+PGh0bWw+PGJvZHk+XCIpLHQuY2xvc2UoKSxuPXVuKGUsdCksUHQuZGV0YWNoKCkpLEd0W2VdPW4pLG59ZnVuY3Rpb24gdW4oZSx0KXt2YXIgbj14KHQuY3JlYXRlRWxlbWVudChlKSkuYXBwZW5kVG8odC5ib2R5KSxyPXguY3NzKG5bMF0sXCJkaXNwbGF5XCIpO3JldHVybiBuLnJlbW92ZSgpLHJ9eC5lYWNoKFtcImhlaWdodFwiLFwid2lkdGhcIl0sZnVuY3Rpb24oZSxuKXt4LmNzc0hvb2tzW25dPXtnZXQ6ZnVuY3Rpb24oZSxyLGkpe3JldHVybiByPzA9PT1lLm9mZnNldFdpZHRoJiZYdC50ZXN0KHguY3NzKGUsXCJkaXNwbGF5XCIpKT94LnN3YXAoZSxRdCxmdW5jdGlvbigpe3JldHVybiBzbihlLG4saSl9KTpzbihlLG4saSk6dH0sc2V0OmZ1bmN0aW9uKGUsdCxyKXt2YXIgaT1yJiZSdChlKTtyZXR1cm4gb24oZSx0LHI/YW4oZSxuLHIseC5zdXBwb3J0LmJveFNpemluZyYmXCJib3JkZXItYm94XCI9PT14LmNzcyhlLFwiYm94U2l6aW5nXCIsITEsaSksaSk6MCl9fX0pLHguc3VwcG9ydC5vcGFjaXR5fHwoeC5jc3NIb29rcy5vcGFjaXR5PXtnZXQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gSXQudGVzdCgodCYmZS5jdXJyZW50U3R5bGU/ZS5jdXJyZW50U3R5bGUuZmlsdGVyOmUuc3R5bGUuZmlsdGVyKXx8XCJcIik/LjAxKnBhcnNlRmxvYXQoUmVnRXhwLiQxKStcIlwiOnQ/XCIxXCI6XCJcIn0sc2V0OmZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5zdHlsZSxyPWUuY3VycmVudFN0eWxlLGk9eC5pc051bWVyaWModCk/XCJhbHBoYShvcGFjaXR5PVwiKzEwMCp0K1wiKVwiOlwiXCIsbz1yJiZyLmZpbHRlcnx8bi5maWx0ZXJ8fFwiXCI7bi56b29tPTEsKHQ+PTF8fFwiXCI9PT10KSYmXCJcIj09PXgudHJpbShvLnJlcGxhY2UoJHQsXCJcIikpJiZuLnJlbW92ZUF0dHJpYnV0ZSYmKG4ucmVtb3ZlQXR0cmlidXRlKFwiZmlsdGVyXCIpLFwiXCI9PT10fHxyJiYhci5maWx0ZXIpfHwobi5maWx0ZXI9JHQudGVzdChvKT9vLnJlcGxhY2UoJHQsaSk6bytcIiBcIitpKX19KSx4KGZ1bmN0aW9uKCl7eC5zdXBwb3J0LnJlbGlhYmxlTWFyZ2luUmlnaHR8fCh4LmNzc0hvb2tzLm1hcmdpblJpZ2h0PXtnZXQ6ZnVuY3Rpb24oZSxuKXtyZXR1cm4gbj94LnN3YXAoZSx7ZGlzcGxheTpcImlubGluZS1ibG9ja1wifSxXdCxbZSxcIm1hcmdpblJpZ2h0XCJdKTp0fX0pLCF4LnN1cHBvcnQucGl4ZWxQb3NpdGlvbiYmeC5mbi5wb3NpdGlvbiYmeC5lYWNoKFtcInRvcFwiLFwibGVmdFwiXSxmdW5jdGlvbihlLG4pe3guY3NzSG9va3Nbbl09e2dldDpmdW5jdGlvbihlLHIpe3JldHVybiByPyhyPVd0KGUsbiksWXQudGVzdChyKT94KGUpLnBvc2l0aW9uKClbbl0rXCJweFwiOnIpOnR9fX0pfSkseC5leHByJiZ4LmV4cHIuZmlsdGVycyYmKHguZXhwci5maWx0ZXJzLmhpZGRlbj1mdW5jdGlvbihlKXtyZXR1cm4gMD49ZS5vZmZzZXRXaWR0aCYmMD49ZS5vZmZzZXRIZWlnaHR8fCF4LnN1cHBvcnQucmVsaWFibGVIaWRkZW5PZmZzZXRzJiZcIm5vbmVcIj09PShlLnN0eWxlJiZlLnN0eWxlLmRpc3BsYXl8fHguY3NzKGUsXCJkaXNwbGF5XCIpKX0seC5leHByLmZpbHRlcnMudmlzaWJsZT1mdW5jdGlvbihlKXtyZXR1cm4heC5leHByLmZpbHRlcnMuaGlkZGVuKGUpfSkseC5lYWNoKHttYXJnaW46XCJcIixwYWRkaW5nOlwiXCIsYm9yZGVyOlwiV2lkdGhcIn0sZnVuY3Rpb24oZSx0KXt4LmNzc0hvb2tzW2UrdF09e2V4cGFuZDpmdW5jdGlvbihuKXt2YXIgcj0wLGk9e30sbz1cInN0cmluZ1wiPT10eXBlb2Ygbj9uLnNwbGl0KFwiIFwiKTpbbl07Zm9yKDs0PnI7cisrKWlbZStadFtyXSt0XT1vW3JdfHxvW3ItMl18fG9bMF07cmV0dXJuIGl9fSxVdC50ZXN0KGUpfHwoeC5jc3NIb29rc1tlK3RdLnNldD1vbil9KTt2YXIgY249LyUyMC9nLHBuPS9cXFtcXF0kLyxmbj0vXFxyP1xcbi9nLGRuPS9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxobj0vXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7eC5mbi5leHRlbmQoe3NlcmlhbGl6ZTpmdW5jdGlvbigpe3JldHVybiB4LnBhcmFtKHRoaXMuc2VyaWFsaXplQXJyYXkoKSl9LHNlcmlhbGl6ZUFycmF5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCl7dmFyIGU9eC5wcm9wKHRoaXMsXCJlbGVtZW50c1wiKTtyZXR1cm4gZT94Lm1ha2VBcnJheShlKTp0aGlzfSkuZmlsdGVyKGZ1bmN0aW9uKCl7dmFyIGU9dGhpcy50eXBlO3JldHVybiB0aGlzLm5hbWUmJiF4KHRoaXMpLmlzKFwiOmRpc2FibGVkXCIpJiZobi50ZXN0KHRoaXMubm9kZU5hbWUpJiYhZG4udGVzdChlKSYmKHRoaXMuY2hlY2tlZHx8IUN0LnRlc3QoZSkpfSkubWFwKGZ1bmN0aW9uKGUsdCl7dmFyIG49eCh0aGlzKS52YWwoKTtyZXR1cm4gbnVsbD09bj9udWxsOnguaXNBcnJheShuKT94Lm1hcChuLGZ1bmN0aW9uKGUpe3JldHVybntuYW1lOnQubmFtZSx2YWx1ZTplLnJlcGxhY2UoZm4sXCJcXHJcXG5cIil9fSk6e25hbWU6dC5uYW1lLHZhbHVlOm4ucmVwbGFjZShmbixcIlxcclxcblwiKX19KS5nZXQoKX19KSx4LnBhcmFtPWZ1bmN0aW9uKGUsbil7dmFyIHIsaT1bXSxvPWZ1bmN0aW9uKGUsdCl7dD14LmlzRnVuY3Rpb24odCk/dCgpOm51bGw9PXQ/XCJcIjp0LGlbaS5sZW5ndGhdPWVuY29kZVVSSUNvbXBvbmVudChlKStcIj1cIitlbmNvZGVVUklDb21wb25lbnQodCl9O2lmKG49PT10JiYobj14LmFqYXhTZXR0aW5ncyYmeC5hamF4U2V0dGluZ3MudHJhZGl0aW9uYWwpLHguaXNBcnJheShlKXx8ZS5qcXVlcnkmJiF4LmlzUGxhaW5PYmplY3QoZSkpeC5lYWNoKGUsZnVuY3Rpb24oKXtvKHRoaXMubmFtZSx0aGlzLnZhbHVlKX0pO2Vsc2UgZm9yKHIgaW4gZSlnbihyLGVbcl0sbixvKTtyZXR1cm4gaS5qb2luKFwiJlwiKS5yZXBsYWNlKGNuLFwiK1wiKX07ZnVuY3Rpb24gZ24oZSx0LG4scil7dmFyIGk7aWYoeC5pc0FycmF5KHQpKXguZWFjaCh0LGZ1bmN0aW9uKHQsaSl7bnx8cG4udGVzdChlKT9yKGUsaSk6Z24oZStcIltcIisoXCJvYmplY3RcIj09dHlwZW9mIGk/dDpcIlwiKStcIl1cIixpLG4scil9KTtlbHNlIGlmKG58fFwib2JqZWN0XCIhPT14LnR5cGUodCkpcihlLHQpO2Vsc2UgZm9yKGkgaW4gdClnbihlK1wiW1wiK2krXCJdXCIsdFtpXSxuLHIpfXguZWFjaChcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCBsb2FkIHJlc2l6ZSBzY3JvbGwgdW5sb2FkIGNsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIGNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgZXJyb3IgY29udGV4dG1lbnVcIi5zcGxpdChcIiBcIiksZnVuY3Rpb24oZSx0KXt4LmZuW3RdPWZ1bmN0aW9uKGUsbil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg+MD90aGlzLm9uKHQsbnVsbCxlLG4pOnRoaXMudHJpZ2dlcih0KX19KSx4LmZuLmV4dGVuZCh7aG92ZXI6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5tb3VzZWVudGVyKGUpLm1vdXNlbGVhdmUodHx8ZSl9LGJpbmQ6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB0aGlzLm9uKGUsbnVsbCx0LG4pfSx1bmJpbmQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5vZmYoZSxudWxsLHQpfSxkZWxlZ2F0ZTpmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gdGhpcy5vbih0LGUsbixyKX0sdW5kZWxlZ2F0ZTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIDE9PT1hcmd1bWVudHMubGVuZ3RoP3RoaXMub2ZmKGUsXCIqKlwiKTp0aGlzLm9mZih0LGV8fFwiKipcIixuKX19KTt2YXIgbW4seW4sdm49eC5ub3coKSxibj0vXFw/Lyx4bj0vIy4qJC8sd249LyhbPyZdKV89W14mXSovLFRuPS9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKVxccj8kL2dtLENuPS9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLE5uPS9eKD86R0VUfEhFQUQpJC8sa249L15cXC9cXC8vLEVuPS9eKFtcXHcuKy1dKzopKD86XFwvXFwvKFteXFwvPyM6XSopKD86OihcXGQrKXwpfCkvLFNuPXguZm4ubG9hZCxBbj17fSxqbj17fSxEbj1cIiovXCIuY29uY2F0KFwiKlwiKTt0cnl7eW49by5ocmVmfWNhdGNoKExuKXt5bj1hLmNyZWF0ZUVsZW1lbnQoXCJhXCIpLHluLmhyZWY9XCJcIix5bj15bi5ocmVmfW1uPUVuLmV4ZWMoeW4udG9Mb3dlckNhc2UoKSl8fFtdO2Z1bmN0aW9uIEhuKGUpe3JldHVybiBmdW5jdGlvbih0LG4pe1wic3RyaW5nXCIhPXR5cGVvZiB0JiYobj10LHQ9XCIqXCIpO3ZhciByLGk9MCxvPXQudG9Mb3dlckNhc2UoKS5tYXRjaChUKXx8W107aWYoeC5pc0Z1bmN0aW9uKG4pKXdoaWxlKHI9b1tpKytdKVwiK1wiPT09clswXT8ocj1yLnNsaWNlKDEpfHxcIipcIiwoZVtyXT1lW3JdfHxbXSkudW5zaGlmdChuKSk6KGVbcl09ZVtyXXx8W10pLnB1c2gobil9fWZ1bmN0aW9uIHFuKGUsbixyLGkpe3ZhciBvPXt9LGE9ZT09PWpuO2Z1bmN0aW9uIHMobCl7dmFyIHU7cmV0dXJuIG9bbF09ITAseC5lYWNoKGVbbF18fFtdLGZ1bmN0aW9uKGUsbCl7dmFyIGM9bChuLHIsaSk7cmV0dXJuXCJzdHJpbmdcIiE9dHlwZW9mIGN8fGF8fG9bY10/YT8hKHU9Yyk6dDoobi5kYXRhVHlwZXMudW5zaGlmdChjKSxzKGMpLCExKX0pLHV9cmV0dXJuIHMobi5kYXRhVHlwZXNbMF0pfHwhb1tcIipcIl0mJnMoXCIqXCIpfWZ1bmN0aW9uIF9uKGUsbil7dmFyIHIsaSxvPXguYWpheFNldHRpbmdzLmZsYXRPcHRpb25zfHx7fTtmb3IoaSBpbiBuKW5baV0hPT10JiYoKG9baV0/ZTpyfHwocj17fSkpW2ldPW5baV0pO3JldHVybiByJiZ4LmV4dGVuZCghMCxlLHIpLGV9eC5mbi5sb2FkPWZ1bmN0aW9uKGUsbixyKXtpZihcInN0cmluZ1wiIT10eXBlb2YgZSYmU24pcmV0dXJuIFNuLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgaSxvLGEscz10aGlzLGw9ZS5pbmRleE9mKFwiIFwiKTtyZXR1cm4gbD49MCYmKGk9ZS5zbGljZShsLGUubGVuZ3RoKSxlPWUuc2xpY2UoMCxsKSkseC5pc0Z1bmN0aW9uKG4pPyhyPW4sbj10KTpuJiZcIm9iamVjdFwiPT10eXBlb2YgbiYmKGE9XCJQT1NUXCIpLHMubGVuZ3RoPjAmJnguYWpheCh7dXJsOmUsdHlwZTphLGRhdGFUeXBlOlwiaHRtbFwiLGRhdGE6bn0pLmRvbmUoZnVuY3Rpb24oZSl7bz1hcmd1bWVudHMscy5odG1sKGk/eChcIjxkaXY+XCIpLmFwcGVuZCh4LnBhcnNlSFRNTChlKSkuZmluZChpKTplKX0pLmNvbXBsZXRlKHImJmZ1bmN0aW9uKGUsdCl7cy5lYWNoKHIsb3x8W2UucmVzcG9uc2VUZXh0LHQsZV0pfSksdGhpc30seC5lYWNoKFtcImFqYXhTdGFydFwiLFwiYWpheFN0b3BcIixcImFqYXhDb21wbGV0ZVwiLFwiYWpheEVycm9yXCIsXCJhamF4U3VjY2Vzc1wiLFwiYWpheFNlbmRcIl0sZnVuY3Rpb24oZSx0KXt4LmZuW3RdPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm9uKHQsZSl9fSkseC5leHRlbmQoe2FjdGl2ZTowLGxhc3RNb2RpZmllZDp7fSxldGFnOnt9LGFqYXhTZXR0aW5nczp7dXJsOnluLHR5cGU6XCJHRVRcIixpc0xvY2FsOkNuLnRlc3QobW5bMV0pLGdsb2JhbDohMCxwcm9jZXNzRGF0YTohMCxhc3luYzohMCxjb250ZW50VHlwZTpcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLGFjY2VwdHM6e1wiKlwiOkRuLHRleHQ6XCJ0ZXh0L3BsYWluXCIsaHRtbDpcInRleHQvaHRtbFwiLHhtbDpcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixqc29uOlwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJ9LGNvbnRlbnRzOnt4bWw6L3htbC8saHRtbDovaHRtbC8sanNvbjovanNvbi99LHJlc3BvbnNlRmllbGRzOnt4bWw6XCJyZXNwb25zZVhNTFwiLHRleHQ6XCJyZXNwb25zZVRleHRcIixqc29uOlwicmVzcG9uc2VKU09OXCJ9LGNvbnZlcnRlcnM6e1wiKiB0ZXh0XCI6U3RyaW5nLFwidGV4dCBodG1sXCI6ITAsXCJ0ZXh0IGpzb25cIjp4LnBhcnNlSlNPTixcInRleHQgeG1sXCI6eC5wYXJzZVhNTH0sZmxhdE9wdGlvbnM6e3VybDohMCxjb250ZXh0OiEwfX0sYWpheFNldHVwOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQ/X24oX24oZSx4LmFqYXhTZXR0aW5ncyksdCk6X24oeC5hamF4U2V0dGluZ3MsZSl9LGFqYXhQcmVmaWx0ZXI6SG4oQW4pLGFqYXhUcmFuc3BvcnQ6SG4oam4pLGFqYXg6ZnVuY3Rpb24oZSxuKXtcIm9iamVjdFwiPT10eXBlb2YgZSYmKG49ZSxlPXQpLG49bnx8e307dmFyIHIsaSxvLGEscyxsLHUsYyxwPXguYWpheFNldHVwKHt9LG4pLGY9cC5jb250ZXh0fHxwLGQ9cC5jb250ZXh0JiYoZi5ub2RlVHlwZXx8Zi5qcXVlcnkpP3goZik6eC5ldmVudCxoPXguRGVmZXJyZWQoKSxnPXguQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksbT1wLnN0YXR1c0NvZGV8fHt9LHk9e30sdj17fSxiPTAsdz1cImNhbmNlbGVkXCIsQz17cmVhZHlTdGF0ZTowLGdldFJlc3BvbnNlSGVhZGVyOmZ1bmN0aW9uKGUpe3ZhciB0O2lmKDI9PT1iKXtpZighYyl7Yz17fTt3aGlsZSh0PVRuLmV4ZWMoYSkpY1t0WzFdLnRvTG93ZXJDYXNlKCldPXRbMl19dD1jW2UudG9Mb3dlckNhc2UoKV19cmV0dXJuIG51bGw9PXQ/bnVsbDp0fSxnZXRBbGxSZXNwb25zZUhlYWRlcnM6ZnVuY3Rpb24oKXtyZXR1cm4gMj09PWI/YTpudWxsfSxzZXRSZXF1ZXN0SGVhZGVyOmZ1bmN0aW9uKGUsdCl7dmFyIG49ZS50b0xvd2VyQ2FzZSgpO3JldHVybiBifHwoZT12W25dPXZbbl18fGUseVtlXT10KSx0aGlzfSxvdmVycmlkZU1pbWVUeXBlOmZ1bmN0aW9uKGUpe3JldHVybiBifHwocC5taW1lVHlwZT1lKSx0aGlzfSxzdGF0dXNDb2RlOmZ1bmN0aW9uKGUpe3ZhciB0O2lmKGUpaWYoMj5iKWZvcih0IGluIGUpbVt0XT1bbVt0XSxlW3RdXTtlbHNlIEMuYWx3YXlzKGVbQy5zdGF0dXNdKTtyZXR1cm4gdGhpc30sYWJvcnQ6ZnVuY3Rpb24oZSl7dmFyIHQ9ZXx8dztyZXR1cm4gdSYmdS5hYm9ydCh0KSxrKDAsdCksdGhpc319O2lmKGgucHJvbWlzZShDKS5jb21wbGV0ZT1nLmFkZCxDLnN1Y2Nlc3M9Qy5kb25lLEMuZXJyb3I9Qy5mYWlsLHAudXJsPSgoZXx8cC51cmx8fHluKStcIlwiKS5yZXBsYWNlKHhuLFwiXCIpLnJlcGxhY2Uoa24sbW5bMV0rXCIvL1wiKSxwLnR5cGU9bi5tZXRob2R8fG4udHlwZXx8cC5tZXRob2R8fHAudHlwZSxwLmRhdGFUeXBlcz14LnRyaW0ocC5kYXRhVHlwZXx8XCIqXCIpLnRvTG93ZXJDYXNlKCkubWF0Y2goVCl8fFtcIlwiXSxudWxsPT1wLmNyb3NzRG9tYWluJiYocj1Fbi5leGVjKHAudXJsLnRvTG93ZXJDYXNlKCkpLHAuY3Jvc3NEb21haW49ISghcnx8clsxXT09PW1uWzFdJiZyWzJdPT09bW5bMl0mJihyWzNdfHwoXCJodHRwOlwiPT09clsxXT9cIjgwXCI6XCI0NDNcIikpPT09KG1uWzNdfHwoXCJodHRwOlwiPT09bW5bMV0/XCI4MFwiOlwiNDQzXCIpKSkpLHAuZGF0YSYmcC5wcm9jZXNzRGF0YSYmXCJzdHJpbmdcIiE9dHlwZW9mIHAuZGF0YSYmKHAuZGF0YT14LnBhcmFtKHAuZGF0YSxwLnRyYWRpdGlvbmFsKSkscW4oQW4scCxuLEMpLDI9PT1iKXJldHVybiBDO2w9cC5nbG9iYWwsbCYmMD09PXguYWN0aXZlKysmJnguZXZlbnQudHJpZ2dlcihcImFqYXhTdGFydFwiKSxwLnR5cGU9cC50eXBlLnRvVXBwZXJDYXNlKCkscC5oYXNDb250ZW50PSFObi50ZXN0KHAudHlwZSksbz1wLnVybCxwLmhhc0NvbnRlbnR8fChwLmRhdGEmJihvPXAudXJsKz0oYm4udGVzdChvKT9cIiZcIjpcIj9cIikrcC5kYXRhLGRlbGV0ZSBwLmRhdGEpLHAuY2FjaGU9PT0hMSYmKHAudXJsPXduLnRlc3Qobyk/by5yZXBsYWNlKHduLFwiJDFfPVwiK3ZuKyspOm8rKGJuLnRlc3Qobyk/XCImXCI6XCI/XCIpK1wiXz1cIit2bisrKSkscC5pZk1vZGlmaWVkJiYoeC5sYXN0TW9kaWZpZWRbb10mJkMuc2V0UmVxdWVzdEhlYWRlcihcIklmLU1vZGlmaWVkLVNpbmNlXCIseC5sYXN0TW9kaWZpZWRbb10pLHguZXRhZ1tvXSYmQy5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTm9uZS1NYXRjaFwiLHguZXRhZ1tvXSkpLChwLmRhdGEmJnAuaGFzQ29udGVudCYmcC5jb250ZW50VHlwZSE9PSExfHxuLmNvbnRlbnRUeXBlKSYmQy5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIscC5jb250ZW50VHlwZSksQy5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIscC5kYXRhVHlwZXNbMF0mJnAuYWNjZXB0c1twLmRhdGFUeXBlc1swXV0/cC5hY2NlcHRzW3AuZGF0YVR5cGVzWzBdXSsoXCIqXCIhPT1wLmRhdGFUeXBlc1swXT9cIiwgXCIrRG4rXCI7IHE9MC4wMVwiOlwiXCIpOnAuYWNjZXB0c1tcIipcIl0pO2ZvcihpIGluIHAuaGVhZGVycylDLnNldFJlcXVlc3RIZWFkZXIoaSxwLmhlYWRlcnNbaV0pO2lmKHAuYmVmb3JlU2VuZCYmKHAuYmVmb3JlU2VuZC5jYWxsKGYsQyxwKT09PSExfHwyPT09YikpcmV0dXJuIEMuYWJvcnQoKTt3PVwiYWJvcnRcIjtmb3IoaSBpbntzdWNjZXNzOjEsZXJyb3I6MSxjb21wbGV0ZToxfSlDW2ldKHBbaV0pO2lmKHU9cW4oam4scCxuLEMpKXtDLnJlYWR5U3RhdGU9MSxsJiZkLnRyaWdnZXIoXCJhamF4U2VuZFwiLFtDLHBdKSxwLmFzeW5jJiZwLnRpbWVvdXQ+MCYmKHM9c2V0VGltZW91dChmdW5jdGlvbigpe0MuYWJvcnQoXCJ0aW1lb3V0XCIpfSxwLnRpbWVvdXQpKTt0cnl7Yj0xLHUuc2VuZCh5LGspfWNhdGNoKE4pe2lmKCEoMj5iKSl0aHJvdyBOO2soLTEsTil9fWVsc2UgaygtMSxcIk5vIFRyYW5zcG9ydFwiKTtmdW5jdGlvbiBrKGUsbixyLGkpe3ZhciBjLHksdix3LFQsTj1uOzIhPT1iJiYoYj0yLHMmJmNsZWFyVGltZW91dChzKSx1PXQsYT1pfHxcIlwiLEMucmVhZHlTdGF0ZT1lPjA/NDowLGM9ZT49MjAwJiYzMDA+ZXx8MzA0PT09ZSxyJiYodz1NbihwLEMscikpLHc9T24ocCx3LEMsYyksYz8ocC5pZk1vZGlmaWVkJiYoVD1DLmdldFJlc3BvbnNlSGVhZGVyKFwiTGFzdC1Nb2RpZmllZFwiKSxUJiYoeC5sYXN0TW9kaWZpZWRbb109VCksVD1DLmdldFJlc3BvbnNlSGVhZGVyKFwiZXRhZ1wiKSxUJiYoeC5ldGFnW29dPVQpKSwyMDQ9PT1lfHxcIkhFQURcIj09PXAudHlwZT9OPVwibm9jb250ZW50XCI6MzA0PT09ZT9OPVwibm90bW9kaWZpZWRcIjooTj13LnN0YXRlLHk9dy5kYXRhLHY9dy5lcnJvcixjPSF2KSk6KHY9TiwoZXx8IU4pJiYoTj1cImVycm9yXCIsMD5lJiYoZT0wKSkpLEMuc3RhdHVzPWUsQy5zdGF0dXNUZXh0PShufHxOKStcIlwiLGM/aC5yZXNvbHZlV2l0aChmLFt5LE4sQ10pOmgucmVqZWN0V2l0aChmLFtDLE4sdl0pLEMuc3RhdHVzQ29kZShtKSxtPXQsbCYmZC50cmlnZ2VyKGM/XCJhamF4U3VjY2Vzc1wiOlwiYWpheEVycm9yXCIsW0MscCxjP3k6dl0pLGcuZmlyZVdpdGgoZixbQyxOXSksbCYmKGQudHJpZ2dlcihcImFqYXhDb21wbGV0ZVwiLFtDLHBdKSwtLXguYWN0aXZlfHx4LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKSkpfXJldHVybiBDfSxnZXRKU09OOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4geC5nZXQoZSx0LG4sXCJqc29uXCIpfSxnZXRTY3JpcHQ6ZnVuY3Rpb24oZSxuKXtyZXR1cm4geC5nZXQoZSx0LG4sXCJzY3JpcHRcIil9fSkseC5lYWNoKFtcImdldFwiLFwicG9zdFwiXSxmdW5jdGlvbihlLG4pe3hbbl09ZnVuY3Rpb24oZSxyLGksbyl7cmV0dXJuIHguaXNGdW5jdGlvbihyKSYmKG89b3x8aSxpPXIscj10KSx4LmFqYXgoe3VybDplLHR5cGU6bixkYXRhVHlwZTpvLGRhdGE6cixzdWNjZXNzOml9KX19KTtmdW5jdGlvbiBNbihlLG4scil7dmFyIGksbyxhLHMsbD1lLmNvbnRlbnRzLHU9ZS5kYXRhVHlwZXM7d2hpbGUoXCIqXCI9PT11WzBdKXUuc2hpZnQoKSxvPT09dCYmKG89ZS5taW1lVHlwZXx8bi5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKSk7aWYobylmb3IocyBpbiBsKWlmKGxbc10mJmxbc10udGVzdChvKSl7dS51bnNoaWZ0KHMpO2JyZWFrfWlmKHVbMF1pbiByKWE9dVswXTtlbHNle2ZvcihzIGluIHIpe2lmKCF1WzBdfHxlLmNvbnZlcnRlcnNbcytcIiBcIit1WzBdXSl7YT1zO2JyZWFrfWl8fChpPXMpfWE9YXx8aX1yZXR1cm4gYT8oYSE9PXVbMF0mJnUudW5zaGlmdChhKSxyW2FdKTp0fWZ1bmN0aW9uIE9uKGUsdCxuLHIpe3ZhciBpLG8sYSxzLGwsdT17fSxjPWUuZGF0YVR5cGVzLnNsaWNlKCk7aWYoY1sxXSlmb3IoYSBpbiBlLmNvbnZlcnRlcnMpdVthLnRvTG93ZXJDYXNlKCldPWUuY29udmVydGVyc1thXTtvPWMuc2hpZnQoKTt3aGlsZShvKWlmKGUucmVzcG9uc2VGaWVsZHNbb10mJihuW2UucmVzcG9uc2VGaWVsZHNbb11dPXQpLCFsJiZyJiZlLmRhdGFGaWx0ZXImJih0PWUuZGF0YUZpbHRlcih0LGUuZGF0YVR5cGUpKSxsPW8sbz1jLnNoaWZ0KCkpaWYoXCIqXCI9PT1vKW89bDtlbHNlIGlmKFwiKlwiIT09bCYmbCE9PW8pe2lmKGE9dVtsK1wiIFwiK29dfHx1W1wiKiBcIitvXSwhYSlmb3IoaSBpbiB1KWlmKHM9aS5zcGxpdChcIiBcIiksc1sxXT09PW8mJihhPXVbbCtcIiBcIitzWzBdXXx8dVtcIiogXCIrc1swXV0pKXthPT09ITA/YT11W2ldOnVbaV0hPT0hMCYmKG89c1swXSxjLnVuc2hpZnQoc1sxXSkpO2JyZWFrfWlmKGEhPT0hMClpZihhJiZlW1widGhyb3dzXCJdKXQ9YSh0KTtlbHNlIHRyeXt0PWEodCl9Y2F0Y2gocCl7cmV0dXJue3N0YXRlOlwicGFyc2VyZXJyb3JcIixlcnJvcjphP3A6XCJObyBjb252ZXJzaW9uIGZyb20gXCIrbCtcIiB0byBcIitvfX19cmV0dXJue3N0YXRlOlwic3VjY2Vzc1wiLGRhdGE6dH19eC5hamF4U2V0dXAoe2FjY2VwdHM6e3NjcmlwdDpcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJ9LGNvbnRlbnRzOntzY3JpcHQ6Lyg/OmphdmF8ZWNtYSlzY3JpcHQvfSxjb252ZXJ0ZXJzOntcInRleHQgc2NyaXB0XCI6ZnVuY3Rpb24oZSl7cmV0dXJuIHguZ2xvYmFsRXZhbChlKSxlfX19KSx4LmFqYXhQcmVmaWx0ZXIoXCJzY3JpcHRcIixmdW5jdGlvbihlKXtlLmNhY2hlPT09dCYmKGUuY2FjaGU9ITEpLGUuY3Jvc3NEb21haW4mJihlLnR5cGU9XCJHRVRcIixlLmdsb2JhbD0hMSl9KSx4LmFqYXhUcmFuc3BvcnQoXCJzY3JpcHRcIixmdW5jdGlvbihlKXtpZihlLmNyb3NzRG9tYWluKXt2YXIgbixyPWEuaGVhZHx8eChcImhlYWRcIilbMF18fGEuZG9jdW1lbnRFbGVtZW50O3JldHVybntzZW5kOmZ1bmN0aW9uKHQsaSl7bj1hLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiksbi5hc3luYz0hMCxlLnNjcmlwdENoYXJzZXQmJihuLmNoYXJzZXQ9ZS5zY3JpcHRDaGFyc2V0KSxuLnNyYz1lLnVybCxuLm9ubG9hZD1uLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbihlLHQpeyh0fHwhbi5yZWFkeVN0YXRlfHwvbG9hZGVkfGNvbXBsZXRlLy50ZXN0KG4ucmVhZHlTdGF0ZSkpJiYobi5vbmxvYWQ9bi5vbnJlYWR5c3RhdGVjaGFuZ2U9bnVsbCxuLnBhcmVudE5vZGUmJm4ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuKSxuPW51bGwsdHx8aSgyMDAsXCJzdWNjZXNzXCIpKX0sci5pbnNlcnRCZWZvcmUobixyLmZpcnN0Q2hpbGQpfSxhYm9ydDpmdW5jdGlvbigpe24mJm4ub25sb2FkKHQsITApfX19fSk7dmFyIEZuPVtdLEJuPS8oPSlcXD8oPz0mfCQpfFxcP1xcPy87eC5hamF4U2V0dXAoe2pzb25wOlwiY2FsbGJhY2tcIixqc29ucENhbGxiYWNrOmZ1bmN0aW9uKCl7dmFyIGU9Rm4ucG9wKCl8fHguZXhwYW5kbytcIl9cIit2bisrO3JldHVybiB0aGlzW2VdPSEwLGV9fSkseC5hamF4UHJlZmlsdGVyKFwianNvbiBqc29ucFwiLGZ1bmN0aW9uKG4scixpKXt2YXIgbyxhLHMsbD1uLmpzb25wIT09ITEmJihCbi50ZXN0KG4udXJsKT9cInVybFwiOlwic3RyaW5nXCI9PXR5cGVvZiBuLmRhdGEmJiEobi5jb250ZW50VHlwZXx8XCJcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSYmQm4udGVzdChuLmRhdGEpJiZcImRhdGFcIik7cmV0dXJuIGx8fFwianNvbnBcIj09PW4uZGF0YVR5cGVzWzBdPyhvPW4uanNvbnBDYWxsYmFjaz14LmlzRnVuY3Rpb24obi5qc29ucENhbGxiYWNrKT9uLmpzb25wQ2FsbGJhY2soKTpuLmpzb25wQ2FsbGJhY2ssbD9uW2xdPW5bbF0ucmVwbGFjZShCbixcIiQxXCIrbyk6bi5qc29ucCE9PSExJiYobi51cmwrPShibi50ZXN0KG4udXJsKT9cIiZcIjpcIj9cIikrbi5qc29ucCtcIj1cIitvKSxuLmNvbnZlcnRlcnNbXCJzY3JpcHQganNvblwiXT1mdW5jdGlvbigpe3JldHVybiBzfHx4LmVycm9yKG8rXCIgd2FzIG5vdCBjYWxsZWRcIiksc1swXX0sbi5kYXRhVHlwZXNbMF09XCJqc29uXCIsYT1lW29dLGVbb109ZnVuY3Rpb24oKXtzPWFyZ3VtZW50c30saS5hbHdheXMoZnVuY3Rpb24oKXtlW29dPWEsbltvXSYmKG4uanNvbnBDYWxsYmFjaz1yLmpzb25wQ2FsbGJhY2ssRm4ucHVzaChvKSkscyYmeC5pc0Z1bmN0aW9uKGEpJiZhKHNbMF0pLHM9YT10fSksXCJzY3JpcHRcIik6dH0pO3ZhciBQbixSbixXbj0wLCRuPWUuQWN0aXZlWE9iamVjdCYmZnVuY3Rpb24oKXt2YXIgZTtmb3IoZSBpbiBQbilQbltlXSh0LCEwKX07ZnVuY3Rpb24gSW4oKXt0cnl7cmV0dXJuIG5ldyBlLlhNTEh0dHBSZXF1ZXN0fWNhdGNoKHQpe319ZnVuY3Rpb24gem4oKXt0cnl7cmV0dXJuIG5ldyBlLkFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKX1jYXRjaCh0KXt9fXguYWpheFNldHRpbmdzLnhocj1lLkFjdGl2ZVhPYmplY3Q/ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5pc0xvY2FsJiZJbigpfHx6bigpfTpJbixSbj14LmFqYXhTZXR0aW5ncy54aHIoKSx4LnN1cHBvcnQuY29ycz0hIVJuJiZcIndpdGhDcmVkZW50aWFsc1wiaW4gUm4sUm49eC5zdXBwb3J0LmFqYXg9ISFSbixSbiYmeC5hamF4VHJhbnNwb3J0KGZ1bmN0aW9uKG4pe2lmKCFuLmNyb3NzRG9tYWlufHx4LnN1cHBvcnQuY29ycyl7dmFyIHI7cmV0dXJue3NlbmQ6ZnVuY3Rpb24oaSxvKXt2YXIgYSxzLGw9bi54aHIoKTtpZihuLnVzZXJuYW1lP2wub3BlbihuLnR5cGUsbi51cmwsbi5hc3luYyxuLnVzZXJuYW1lLG4ucGFzc3dvcmQpOmwub3BlbihuLnR5cGUsbi51cmwsbi5hc3luYyksbi54aHJGaWVsZHMpZm9yKHMgaW4gbi54aHJGaWVsZHMpbFtzXT1uLnhockZpZWxkc1tzXTtuLm1pbWVUeXBlJiZsLm92ZXJyaWRlTWltZVR5cGUmJmwub3ZlcnJpZGVNaW1lVHlwZShuLm1pbWVUeXBlKSxuLmNyb3NzRG9tYWlufHxpW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXXx8KGlbXCJYLVJlcXVlc3RlZC1XaXRoXCJdPVwiWE1MSHR0cFJlcXVlc3RcIik7dHJ5e2ZvcihzIGluIGkpbC5zZXRSZXF1ZXN0SGVhZGVyKHMsaVtzXSl9Y2F0Y2godSl7fWwuc2VuZChuLmhhc0NvbnRlbnQmJm4uZGF0YXx8bnVsbCkscj1mdW5jdGlvbihlLGkpe3ZhciBzLHUsYyxwO3RyeXtpZihyJiYoaXx8ND09PWwucmVhZHlTdGF0ZSkpaWYocj10LGEmJihsLm9ucmVhZHlzdGF0ZWNoYW5nZT14Lm5vb3AsJG4mJmRlbGV0ZSBQblthXSksaSk0IT09bC5yZWFkeVN0YXRlJiZsLmFib3J0KCk7ZWxzZXtwPXt9LHM9bC5zdGF0dXMsdT1sLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLFwic3RyaW5nXCI9PXR5cGVvZiBsLnJlc3BvbnNlVGV4dCYmKHAudGV4dD1sLnJlc3BvbnNlVGV4dCk7dHJ5e2M9bC5zdGF0dXNUZXh0fWNhdGNoKGYpe2M9XCJcIn1zfHwhbi5pc0xvY2FsfHxuLmNyb3NzRG9tYWluPzEyMjM9PT1zJiYocz0yMDQpOnM9cC50ZXh0PzIwMDo0MDR9fWNhdGNoKGQpe2l8fG8oLTEsZCl9cCYmbyhzLGMscCx1KX0sbi5hc3luYz80PT09bC5yZWFkeVN0YXRlP3NldFRpbWVvdXQocik6KGE9KytXbiwkbiYmKFBufHwoUG49e30seChlKS51bmxvYWQoJG4pKSxQblthXT1yKSxsLm9ucmVhZHlzdGF0ZWNoYW5nZT1yKTpyKCl9LGFib3J0OmZ1bmN0aW9uKCl7ciYmcih0LCEwKX19fX0pO3ZhciBYbixVbixWbj0vXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sWW49UmVnRXhwKFwiXig/OihbKy1dKT18KShcIit3K1wiKShbYS16JV0qKSRcIixcImlcIiksSm49L3F1ZXVlSG9va3MkLyxHbj1bbnJdLFFuPXtcIipcIjpbZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLmNyZWF0ZVR3ZWVuKGUsdCkscj1uLmN1cigpLGk9WW4uZXhlYyh0KSxvPWkmJmlbM118fCh4LmNzc051bWJlcltlXT9cIlwiOlwicHhcIiksYT0oeC5jc3NOdW1iZXJbZV18fFwicHhcIiE9PW8mJityKSYmWW4uZXhlYyh4LmNzcyhuLmVsZW0sZSkpLHM9MSxsPTIwO2lmKGEmJmFbM10hPT1vKXtvPW98fGFbM10saT1pfHxbXSxhPStyfHwxO2RvIHM9c3x8XCIuNVwiLGEvPXMseC5zdHlsZShuLmVsZW0sZSxhK28pO3doaWxlKHMhPT0ocz1uLmN1cigpL3IpJiYxIT09cyYmLS1sKX1yZXR1cm4gaSYmKGE9bi5zdGFydD0rYXx8K3J8fDAsbi51bml0PW8sbi5lbmQ9aVsxXT9hKyhpWzFdKzEpKmlbMl06K2lbMl0pLG59XX07ZnVuY3Rpb24gS24oKXtyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe1huPXR9KSxYbj14Lm5vdygpfWZ1bmN0aW9uIFpuKGUsdCxuKXt2YXIgcixpPShRblt0XXx8W10pLmNvbmNhdChRbltcIipcIl0pLG89MCxhPWkubGVuZ3RoO2Zvcig7YT5vO28rKylpZihyPWlbb10uY2FsbChuLHQsZSkpcmV0dXJuIHJ9ZnVuY3Rpb24gZXIoZSx0LG4pe3ZhciByLGksbz0wLGE9R24ubGVuZ3RoLHM9eC5EZWZlcnJlZCgpLmFsd2F5cyhmdW5jdGlvbigpe2RlbGV0ZSBsLmVsZW19KSxsPWZ1bmN0aW9uKCl7aWYoaSlyZXR1cm4hMTt2YXIgdD1Ybnx8S24oKSxuPU1hdGgubWF4KDAsdS5zdGFydFRpbWUrdS5kdXJhdGlvbi10KSxyPW4vdS5kdXJhdGlvbnx8MCxvPTEtcixhPTAsbD11LnR3ZWVucy5sZW5ndGg7Zm9yKDtsPmE7YSsrKXUudHdlZW5zW2FdLnJ1bihvKTtyZXR1cm4gcy5ub3RpZnlXaXRoKGUsW3UsbyxuXSksMT5vJiZsP246KHMucmVzb2x2ZVdpdGgoZSxbdV0pLCExKX0sdT1zLnByb21pc2Uoe2VsZW06ZSxwcm9wczp4LmV4dGVuZCh7fSx0KSxvcHRzOnguZXh0ZW5kKCEwLHtzcGVjaWFsRWFzaW5nOnt9fSxuKSxvcmlnaW5hbFByb3BlcnRpZXM6dCxvcmlnaW5hbE9wdGlvbnM6bixzdGFydFRpbWU6WG58fEtuKCksZHVyYXRpb246bi5kdXJhdGlvbix0d2VlbnM6W10sY3JlYXRlVHdlZW46ZnVuY3Rpb24odCxuKXt2YXIgcj14LlR3ZWVuKGUsdS5vcHRzLHQsbix1Lm9wdHMuc3BlY2lhbEVhc2luZ1t0XXx8dS5vcHRzLmVhc2luZyk7cmV0dXJuIHUudHdlZW5zLnB1c2gocikscn0sc3RvcDpmdW5jdGlvbih0KXt2YXIgbj0wLHI9dD91LnR3ZWVucy5sZW5ndGg6MDtpZihpKXJldHVybiB0aGlzO2ZvcihpPSEwO3I+bjtuKyspdS50d2VlbnNbbl0ucnVuKDEpO3JldHVybiB0P3MucmVzb2x2ZVdpdGgoZSxbdSx0XSk6cy5yZWplY3RXaXRoKGUsW3UsdF0pLHRoaXN9fSksYz11LnByb3BzO2Zvcih0cihjLHUub3B0cy5zcGVjaWFsRWFzaW5nKTthPm87bysrKWlmKHI9R25bb10uY2FsbCh1LGUsYyx1Lm9wdHMpKXJldHVybiByO3JldHVybiB4Lm1hcChjLFpuLHUpLHguaXNGdW5jdGlvbih1Lm9wdHMuc3RhcnQpJiZ1Lm9wdHMuc3RhcnQuY2FsbChlLHUpLHguZngudGltZXIoeC5leHRlbmQobCx7ZWxlbTplLGFuaW06dSxxdWV1ZTp1Lm9wdHMucXVldWV9KSksdS5wcm9ncmVzcyh1Lm9wdHMucHJvZ3Jlc3MpLmRvbmUodS5vcHRzLmRvbmUsdS5vcHRzLmNvbXBsZXRlKS5mYWlsKHUub3B0cy5mYWlsKS5hbHdheXModS5vcHRzLmFsd2F5cyl9ZnVuY3Rpb24gdHIoZSx0KXt2YXIgbixyLGksbyxhO2ZvcihuIGluIGUpaWYocj14LmNhbWVsQ2FzZShuKSxpPXRbcl0sbz1lW25dLHguaXNBcnJheShvKSYmKGk9b1sxXSxvPWVbbl09b1swXSksbiE9PXImJihlW3JdPW8sZGVsZXRlIGVbbl0pLGE9eC5jc3NIb29rc1tyXSxhJiZcImV4cGFuZFwiaW4gYSl7bz1hLmV4cGFuZChvKSxkZWxldGUgZVtyXTtmb3IobiBpbiBvKW4gaW4gZXx8KGVbbl09b1tuXSx0W25dPWkpfWVsc2UgdFtyXT1pfXguQW5pbWF0aW9uPXguZXh0ZW5kKGVyLHt0d2VlbmVyOmZ1bmN0aW9uKGUsdCl7eC5pc0Z1bmN0aW9uKGUpPyh0PWUsZT1bXCIqXCJdKTplPWUuc3BsaXQoXCIgXCIpO3ZhciBuLHI9MCxpPWUubGVuZ3RoO2Zvcig7aT5yO3IrKyluPWVbcl0sUW5bbl09UW5bbl18fFtdLFFuW25dLnVuc2hpZnQodCl9LHByZWZpbHRlcjpmdW5jdGlvbihlLHQpe3Q/R24udW5zaGlmdChlKTpHbi5wdXNoKGUpfX0pO2Z1bmN0aW9uIG5yKGUsdCxuKXt2YXIgcixpLG8sYSxzLGwsdT10aGlzLGM9e30scD1lLnN0eWxlLGY9ZS5ub2RlVHlwZSYmbm4oZSksZD14Ll9kYXRhKGUsXCJmeHNob3dcIik7bi5xdWV1ZXx8KHM9eC5fcXVldWVIb29rcyhlLFwiZnhcIiksbnVsbD09cy51bnF1ZXVlZCYmKHMudW5xdWV1ZWQ9MCxsPXMuZW1wdHkuZmlyZSxzLmVtcHR5LmZpcmU9ZnVuY3Rpb24oKXtzLnVucXVldWVkfHxsKCl9KSxzLnVucXVldWVkKyssdS5hbHdheXMoZnVuY3Rpb24oKXt1LmFsd2F5cyhmdW5jdGlvbigpe3MudW5xdWV1ZWQtLSx4LnF1ZXVlKGUsXCJmeFwiKS5sZW5ndGh8fHMuZW1wdHkuZmlyZSgpfSl9KSksMT09PWUubm9kZVR5cGUmJihcImhlaWdodFwiaW4gdHx8XCJ3aWR0aFwiaW4gdCkmJihuLm92ZXJmbG93PVtwLm92ZXJmbG93LHAub3ZlcmZsb3dYLHAub3ZlcmZsb3dZXSxcImlubGluZVwiPT09eC5jc3MoZSxcImRpc3BsYXlcIikmJlwibm9uZVwiPT09eC5jc3MoZSxcImZsb2F0XCIpJiYoeC5zdXBwb3J0LmlubGluZUJsb2NrTmVlZHNMYXlvdXQmJlwiaW5saW5lXCIhPT1sbihlLm5vZGVOYW1lKT9wLnpvb209MTpwLmRpc3BsYXk9XCJpbmxpbmUtYmxvY2tcIikpLG4ub3ZlcmZsb3cmJihwLm92ZXJmbG93PVwiaGlkZGVuXCIseC5zdXBwb3J0LnNocmlua1dyYXBCbG9ja3N8fHUuYWx3YXlzKGZ1bmN0aW9uKCl7cC5vdmVyZmxvdz1uLm92ZXJmbG93WzBdLHAub3ZlcmZsb3dYPW4ub3ZlcmZsb3dbMV0scC5vdmVyZmxvd1k9bi5vdmVyZmxvd1syXX0pKTtmb3IociBpbiB0KWlmKGk9dFtyXSxWbi5leGVjKGkpKXtpZihkZWxldGUgdFtyXSxvPW98fFwidG9nZ2xlXCI9PT1pLGk9PT0oZj9cImhpZGVcIjpcInNob3dcIikpY29udGludWU7Y1tyXT1kJiZkW3JdfHx4LnN0eWxlKGUscil9aWYoIXguaXNFbXB0eU9iamVjdChjKSl7ZD9cImhpZGRlblwiaW4gZCYmKGY9ZC5oaWRkZW4pOmQ9eC5fZGF0YShlLFwiZnhzaG93XCIse30pLG8mJihkLmhpZGRlbj0hZiksZj94KGUpLnNob3coKTp1LmRvbmUoZnVuY3Rpb24oKXt4KGUpLmhpZGUoKX0pLHUuZG9uZShmdW5jdGlvbigpe3ZhciB0O3guX3JlbW92ZURhdGEoZSxcImZ4c2hvd1wiKTtmb3IodCBpbiBjKXguc3R5bGUoZSx0LGNbdF0pfSk7Zm9yKHIgaW4gYylhPVpuKGY/ZFtyXTowLHIsdSksciBpbiBkfHwoZFtyXT1hLnN0YXJ0LGYmJihhLmVuZD1hLnN0YXJ0LGEuc3RhcnQ9XCJ3aWR0aFwiPT09cnx8XCJoZWlnaHRcIj09PXI/MTowKSl9fWZ1bmN0aW9uIHJyKGUsdCxuLHIsaSl7cmV0dXJuIG5ldyByci5wcm90b3R5cGUuaW5pdChlLHQsbixyLGkpfXguVHdlZW49cnIscnIucHJvdG90eXBlPXtjb25zdHJ1Y3Rvcjpycixpbml0OmZ1bmN0aW9uKGUsdCxuLHIsaSxvKXt0aGlzLmVsZW09ZSx0aGlzLnByb3A9bix0aGlzLmVhc2luZz1pfHxcInN3aW5nXCIsdGhpcy5vcHRpb25zPXQsdGhpcy5zdGFydD10aGlzLm5vdz10aGlzLmN1cigpLHRoaXMuZW5kPXIsdGhpcy51bml0PW98fCh4LmNzc051bWJlcltuXT9cIlwiOlwicHhcIil9LGN1cjpmdW5jdGlvbigpe3ZhciBlPXJyLnByb3BIb29rc1t0aGlzLnByb3BdO3JldHVybiBlJiZlLmdldD9lLmdldCh0aGlzKTpyci5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KHRoaXMpfSxydW46ZnVuY3Rpb24oZSl7dmFyIHQsbj1yci5wcm9wSG9va3NbdGhpcy5wcm9wXTtyZXR1cm4gdGhpcy5wb3M9dD10aGlzLm9wdGlvbnMuZHVyYXRpb24/eC5lYXNpbmdbdGhpcy5lYXNpbmddKGUsdGhpcy5vcHRpb25zLmR1cmF0aW9uKmUsMCwxLHRoaXMub3B0aW9ucy5kdXJhdGlvbik6ZSx0aGlzLm5vdz0odGhpcy5lbmQtdGhpcy5zdGFydCkqdCt0aGlzLnN0YXJ0LHRoaXMub3B0aW9ucy5zdGVwJiZ0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKHRoaXMuZWxlbSx0aGlzLm5vdyx0aGlzKSxuJiZuLnNldD9uLnNldCh0aGlzKTpyci5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KHRoaXMpLHRoaXN9fSxyci5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGU9cnIucHJvdG90eXBlLHJyLnByb3BIb29rcz17X2RlZmF1bHQ6e2dldDpmdW5jdGlvbihlKXt2YXIgdDtyZXR1cm4gbnVsbD09ZS5lbGVtW2UucHJvcF18fGUuZWxlbS5zdHlsZSYmbnVsbCE9ZS5lbGVtLnN0eWxlW2UucHJvcF0/KHQ9eC5jc3MoZS5lbGVtLGUucHJvcCxcIlwiKSx0JiZcImF1dG9cIiE9PXQ/dDowKTplLmVsZW1bZS5wcm9wXX0sc2V0OmZ1bmN0aW9uKGUpe3guZnguc3RlcFtlLnByb3BdP3guZnguc3RlcFtlLnByb3BdKGUpOmUuZWxlbS5zdHlsZSYmKG51bGwhPWUuZWxlbS5zdHlsZVt4LmNzc1Byb3BzW2UucHJvcF1dfHx4LmNzc0hvb2tzW2UucHJvcF0pP3guc3R5bGUoZS5lbGVtLGUucHJvcCxlLm5vdytlLnVuaXQpOmUuZWxlbVtlLnByb3BdPWUubm93fX19LHJyLnByb3BIb29rcy5zY3JvbGxUb3A9cnIucHJvcEhvb2tzLnNjcm9sbExlZnQ9e3NldDpmdW5jdGlvbihlKXtlLmVsZW0ubm9kZVR5cGUmJmUuZWxlbS5wYXJlbnROb2RlJiYoZS5lbGVtW2UucHJvcF09ZS5ub3cpfX0seC5lYWNoKFtcInRvZ2dsZVwiLFwic2hvd1wiLFwiaGlkZVwiXSxmdW5jdGlvbihlLHQpe3ZhciBuPXguZm5bdF07eC5mblt0XT1mdW5jdGlvbihlLHIsaSl7cmV0dXJuIG51bGw9PWV8fFwiYm9vbGVhblwiPT10eXBlb2YgZT9uLmFwcGx5KHRoaXMsYXJndW1lbnRzKTp0aGlzLmFuaW1hdGUoaXIodCwhMCksZSxyLGkpfX0pLHguZm4uZXh0ZW5kKHtmYWRlVG86ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIHRoaXMuZmlsdGVyKG5uKS5jc3MoXCJvcGFjaXR5XCIsMCkuc2hvdygpLmVuZCgpLmFuaW1hdGUoe29wYWNpdHk6dH0sZSxuLHIpfSxhbmltYXRlOmZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpPXguaXNFbXB0eU9iamVjdChlKSxvPXguc3BlZWQodCxuLHIpLGE9ZnVuY3Rpb24oKXt2YXIgdD1lcih0aGlzLHguZXh0ZW5kKHt9LGUpLG8pOyhpfHx4Ll9kYXRhKHRoaXMsXCJmaW5pc2hcIikpJiZ0LnN0b3AoITApfTtyZXR1cm4gYS5maW5pc2g9YSxpfHxvLnF1ZXVlPT09ITE/dGhpcy5lYWNoKGEpOnRoaXMucXVldWUoby5xdWV1ZSxhKX0sc3RvcDpmdW5jdGlvbihlLG4scil7dmFyIGk9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5zdG9wO2RlbGV0ZSBlLnN0b3AsdChyKX07cmV0dXJuXCJzdHJpbmdcIiE9dHlwZW9mIGUmJihyPW4sbj1lLGU9dCksbiYmZSE9PSExJiZ0aGlzLnF1ZXVlKGV8fFwiZnhcIixbXSksdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIHQ9ITAsbj1udWxsIT1lJiZlK1wicXVldWVIb29rc1wiLG89eC50aW1lcnMsYT14Ll9kYXRhKHRoaXMpO2lmKG4pYVtuXSYmYVtuXS5zdG9wJiZpKGFbbl0pO2Vsc2UgZm9yKG4gaW4gYSlhW25dJiZhW25dLnN0b3AmJkpuLnRlc3QobikmJmkoYVtuXSk7Zm9yKG49by5sZW5ndGg7bi0tOylvW25dLmVsZW0hPT10aGlzfHxudWxsIT1lJiZvW25dLnF1ZXVlIT09ZXx8KG9bbl0uYW5pbS5zdG9wKHIpLHQ9ITEsby5zcGxpY2UobiwxKSk7KHR8fCFyKSYmeC5kZXF1ZXVlKHRoaXMsZSl9KX0sZmluaXNoOmZ1bmN0aW9uKGUpe3JldHVybiBlIT09ITEmJihlPWV8fFwiZnhcIiksdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIHQsbj14Ll9kYXRhKHRoaXMpLHI9bltlK1wicXVldWVcIl0saT1uW2UrXCJxdWV1ZUhvb2tzXCJdLG89eC50aW1lcnMsYT1yP3IubGVuZ3RoOjA7Zm9yKG4uZmluaXNoPSEwLHgucXVldWUodGhpcyxlLFtdKSxpJiZpLnN0b3AmJmkuc3RvcC5jYWxsKHRoaXMsITApLHQ9by5sZW5ndGg7dC0tOylvW3RdLmVsZW09PT10aGlzJiZvW3RdLnF1ZXVlPT09ZSYmKG9bdF0uYW5pbS5zdG9wKCEwKSxvLnNwbGljZSh0LDEpKTtmb3IodD0wO2E+dDt0Kyspclt0XSYmclt0XS5maW5pc2gmJnJbdF0uZmluaXNoLmNhbGwodGhpcyk7ZGVsZXRlIG4uZmluaXNofSl9fSk7ZnVuY3Rpb24gaXIoZSx0KXt2YXIgbixyPXtoZWlnaHQ6ZX0saT0wO2Zvcih0PXQ/MTowOzQ+aTtpKz0yLXQpbj1adFtpXSxyW1wibWFyZ2luXCIrbl09cltcInBhZGRpbmdcIituXT1lO3JldHVybiB0JiYoci5vcGFjaXR5PXIud2lkdGg9ZSkscn14LmVhY2goe3NsaWRlRG93bjppcihcInNob3dcIiksc2xpZGVVcDppcihcImhpZGVcIiksc2xpZGVUb2dnbGU6aXIoXCJ0b2dnbGVcIiksZmFkZUluOntvcGFjaXR5Olwic2hvd1wifSxmYWRlT3V0OntvcGFjaXR5OlwiaGlkZVwifSxmYWRlVG9nZ2xlOntvcGFjaXR5OlwidG9nZ2xlXCJ9fSxmdW5jdGlvbihlLHQpe3guZm5bZV09ZnVuY3Rpb24oZSxuLHIpe3JldHVybiB0aGlzLmFuaW1hdGUodCxlLG4scil9fSkseC5zcGVlZD1mdW5jdGlvbihlLHQsbil7dmFyIHI9ZSYmXCJvYmplY3RcIj09dHlwZW9mIGU/eC5leHRlbmQoe30sZSk6e2NvbXBsZXRlOm58fCFuJiZ0fHx4LmlzRnVuY3Rpb24oZSkmJmUsZHVyYXRpb246ZSxlYXNpbmc6biYmdHx8dCYmIXguaXNGdW5jdGlvbih0KSYmdH07cmV0dXJuIHIuZHVyYXRpb249eC5meC5vZmY/MDpcIm51bWJlclwiPT10eXBlb2Ygci5kdXJhdGlvbj9yLmR1cmF0aW9uOnIuZHVyYXRpb24gaW4geC5meC5zcGVlZHM/eC5meC5zcGVlZHNbci5kdXJhdGlvbl06eC5meC5zcGVlZHMuX2RlZmF1bHQsKG51bGw9PXIucXVldWV8fHIucXVldWU9PT0hMCkmJihyLnF1ZXVlPVwiZnhcIiksci5vbGQ9ci5jb21wbGV0ZSxyLmNvbXBsZXRlPWZ1bmN0aW9uKCl7eC5pc0Z1bmN0aW9uKHIub2xkKSYmci5vbGQuY2FsbCh0aGlzKSxyLnF1ZXVlJiZ4LmRlcXVldWUodGhpcyxyLnF1ZXVlKX0scn0seC5lYXNpbmc9e2xpbmVhcjpmdW5jdGlvbihlKXtyZXR1cm4gZX0sc3dpbmc6ZnVuY3Rpb24oZSl7cmV0dXJuLjUtTWF0aC5jb3MoZSpNYXRoLlBJKS8yfX0seC50aW1lcnM9W10seC5meD1yci5wcm90b3R5cGUuaW5pdCx4LmZ4LnRpY2s9ZnVuY3Rpb24oKXt2YXIgZSxuPXgudGltZXJzLHI9MDtmb3IoWG49eC5ub3coKTtuLmxlbmd0aD5yO3IrKyllPW5bcl0sZSgpfHxuW3JdIT09ZXx8bi5zcGxpY2Uoci0tLDEpO24ubGVuZ3RofHx4LmZ4LnN0b3AoKSxYbj10fSx4LmZ4LnRpbWVyPWZ1bmN0aW9uKGUpe2UoKSYmeC50aW1lcnMucHVzaChlKSYmeC5meC5zdGFydCgpfSx4LmZ4LmludGVydmFsPTEzLHguZnguc3RhcnQ9ZnVuY3Rpb24oKXtVbnx8KFVuPXNldEludGVydmFsKHguZngudGljayx4LmZ4LmludGVydmFsKSl9LHguZnguc3RvcD1mdW5jdGlvbigpe2NsZWFySW50ZXJ2YWwoVW4pLFVuPW51bGx9LHguZnguc3BlZWRzPXtzbG93OjYwMCxmYXN0OjIwMCxfZGVmYXVsdDo0MDB9LHguZnguc3RlcD17fSx4LmV4cHImJnguZXhwci5maWx0ZXJzJiYoeC5leHByLmZpbHRlcnMuYW5pbWF0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHguZ3JlcCh4LnRpbWVycyxmdW5jdGlvbih0KXtyZXR1cm4gZT09PXQuZWxlbX0pLmxlbmd0aH0pLHguZm4ub2Zmc2V0PWZ1bmN0aW9uKGUpe2lmKGFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIGU9PT10P3RoaXM6dGhpcy5lYWNoKGZ1bmN0aW9uKHQpe3gub2Zmc2V0LnNldE9mZnNldCh0aGlzLGUsdCl9KTt2YXIgbixyLG89e3RvcDowLGxlZnQ6MH0sYT10aGlzWzBdLHM9YSYmYS5vd25lckRvY3VtZW50O2lmKHMpcmV0dXJuIG49cy5kb2N1bWVudEVsZW1lbnQseC5jb250YWlucyhuLGEpPyh0eXBlb2YgYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QhPT1pJiYobz1hLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSxyPW9yKHMpLHt0b3A6by50b3ArKHIucGFnZVlPZmZzZXR8fG4uc2Nyb2xsVG9wKS0obi5jbGllbnRUb3B8fDApLGxlZnQ6by5sZWZ0KyhyLnBhZ2VYT2Zmc2V0fHxuLnNjcm9sbExlZnQpLShuLmNsaWVudExlZnR8fDApfSk6b30seC5vZmZzZXQ9e3NldE9mZnNldDpmdW5jdGlvbihlLHQsbil7dmFyIHI9eC5jc3MoZSxcInBvc2l0aW9uXCIpO1wic3RhdGljXCI9PT1yJiYoZS5zdHlsZS5wb3NpdGlvbj1cInJlbGF0aXZlXCIpO3ZhciBpPXgoZSksbz1pLm9mZnNldCgpLGE9eC5jc3MoZSxcInRvcFwiKSxzPXguY3NzKGUsXCJsZWZ0XCIpLGw9KFwiYWJzb2x1dGVcIj09PXJ8fFwiZml4ZWRcIj09PXIpJiZ4LmluQXJyYXkoXCJhdXRvXCIsW2Esc10pPi0xLHU9e30sYz17fSxwLGY7bD8oYz1pLnBvc2l0aW9uKCkscD1jLnRvcCxmPWMubGVmdCk6KHA9cGFyc2VGbG9hdChhKXx8MCxmPXBhcnNlRmxvYXQocyl8fDApLHguaXNGdW5jdGlvbih0KSYmKHQ9dC5jYWxsKGUsbixvKSksbnVsbCE9dC50b3AmJih1LnRvcD10LnRvcC1vLnRvcCtwKSxudWxsIT10LmxlZnQmJih1LmxlZnQ9dC5sZWZ0LW8ubGVmdCtmKSxcInVzaW5nXCJpbiB0P3QudXNpbmcuY2FsbChlLHUpOmkuY3NzKHUpfX0seC5mbi5leHRlbmQoe3Bvc2l0aW9uOmZ1bmN0aW9uKCl7aWYodGhpc1swXSl7dmFyIGUsdCxuPXt0b3A6MCxsZWZ0OjB9LHI9dGhpc1swXTtyZXR1cm5cImZpeGVkXCI9PT14LmNzcyhyLFwicG9zaXRpb25cIik/dD1yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOihlPXRoaXMub2Zmc2V0UGFyZW50KCksdD10aGlzLm9mZnNldCgpLHgubm9kZU5hbWUoZVswXSxcImh0bWxcIil8fChuPWUub2Zmc2V0KCkpLG4udG9wKz14LmNzcyhlWzBdLFwiYm9yZGVyVG9wV2lkdGhcIiwhMCksbi5sZWZ0Kz14LmNzcyhlWzBdLFwiYm9yZGVyTGVmdFdpZHRoXCIsITApKSx7dG9wOnQudG9wLW4udG9wLXguY3NzKHIsXCJtYXJnaW5Ub3BcIiwhMCksbGVmdDp0LmxlZnQtbi5sZWZ0LXguY3NzKHIsXCJtYXJnaW5MZWZ0XCIsITApfX19LG9mZnNldFBhcmVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe3ZhciBlPXRoaXMub2Zmc2V0UGFyZW50fHxzO3doaWxlKGUmJiF4Lm5vZGVOYW1lKGUsXCJodG1sXCIpJiZcInN0YXRpY1wiPT09eC5jc3MoZSxcInBvc2l0aW9uXCIpKWU9ZS5vZmZzZXRQYXJlbnQ7cmV0dXJuIGV8fHN9KX19KSx4LmVhY2goe3Njcm9sbExlZnQ6XCJwYWdlWE9mZnNldFwiLHNjcm9sbFRvcDpcInBhZ2VZT2Zmc2V0XCJ9LGZ1bmN0aW9uKGUsbil7dmFyIHI9L1kvLnRlc3Qobik7eC5mbltlXT1mdW5jdGlvbihpKXtyZXR1cm4geC5hY2Nlc3ModGhpcyxmdW5jdGlvbihlLGksbyl7dmFyIGE9b3IoZSk7cmV0dXJuIG89PT10P2E/biBpbiBhP2Fbbl06YS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbaV06ZVtpXTooYT9hLnNjcm9sbFRvKHI/eChhKS5zY3JvbGxMZWZ0KCk6byxyP286eChhKS5zY3JvbGxUb3AoKSk6ZVtpXT1vLHQpfSxlLGksYXJndW1lbnRzLmxlbmd0aCxudWxsKX19KTtmdW5jdGlvbiBvcihlKXtyZXR1cm4geC5pc1dpbmRvdyhlKT9lOjk9PT1lLm5vZGVUeXBlP2UuZGVmYXVsdFZpZXd8fGUucGFyZW50V2luZG93OiExfXguZWFjaCh7SGVpZ2h0OlwiaGVpZ2h0XCIsV2lkdGg6XCJ3aWR0aFwifSxmdW5jdGlvbihlLG4pe3guZWFjaCh7cGFkZGluZzpcImlubmVyXCIrZSxjb250ZW50Om4sXCJcIjpcIm91dGVyXCIrZX0sZnVuY3Rpb24ocixpKXt4LmZuW2ldPWZ1bmN0aW9uKGksbyl7dmFyIGE9YXJndW1lbnRzLmxlbmd0aCYmKHJ8fFwiYm9vbGVhblwiIT10eXBlb2YgaSkscz1yfHwoaT09PSEwfHxvPT09ITA/XCJtYXJnaW5cIjpcImJvcmRlclwiKTtyZXR1cm4geC5hY2Nlc3ModGhpcyxmdW5jdGlvbihuLHIsaSl7dmFyIG87cmV0dXJuIHguaXNXaW5kb3cobik/bi5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbXCJjbGllbnRcIitlXTo5PT09bi5ub2RlVHlwZT8obz1uLmRvY3VtZW50RWxlbWVudCxNYXRoLm1heChuLmJvZHlbXCJzY3JvbGxcIitlXSxvW1wic2Nyb2xsXCIrZV0sbi5ib2R5W1wib2Zmc2V0XCIrZV0sb1tcIm9mZnNldFwiK2VdLG9bXCJjbGllbnRcIitlXSkpOmk9PT10P3guY3NzKG4scixzKTp4LnN0eWxlKG4scixpLHMpfSxuLGE/aTp0LGEsbnVsbCl9fSl9KSx4LmZuLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZW5ndGh9LHguZm4uYW5kU2VsZj14LmZuLmFkZEJhY2ssXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZSYmbW9kdWxlJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9eDooZS5qUXVlcnk9ZS4kPXgsXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kJiZkZWZpbmUoXCJqcXVlcnlcIixbXSxmdW5jdGlvbigpe3JldHVybiB4fSkpfSkod2luZG93KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyByZXNvdXJjZXMvYXNzZXRzL2pzL3ZlbmRvci9qcXVlcnkuanMiXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTs7QUFBQTs7QUFBQTs7QUFBQTtBQUNBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBQ0E7O0FBQUE7O0FBQUE7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* mousetrap v1.5.3 craig.is/killing/mice */\n(function(C,r,g){function t(a,b,h){a.addEventListener?a.addEventListener(b,h,!1):a.attachEvent(\"on\"+b,h)}function x(a){if(\"keypress\"==a.type){var b=String.fromCharCode(a.which);a.shiftKey||(b=b.toLowerCase());return b}return l[a.which]?l[a.which]:p[a.which]?p[a.which]:String.fromCharCode(a.which).toLowerCase()}function D(a){var b=[];a.shiftKey&&b.push(\"shift\");a.altKey&&b.push(\"alt\");a.ctrlKey&&b.push(\"ctrl\");a.metaKey&&b.push(\"meta\");return b}function u(a){return\"shift\"==a||\"ctrl\"==a||\"alt\"==a||\n\"meta\"==a}function y(a,b){var h,c,e,g=[];h=a;\"+\"===h?h=[\"+\"]:(h=h.replace(/\\+{2}/g,\"+plus\"),h=h.split(\"+\"));for(e=0;e<h.length;++e)c=h[e],z[c]&&(c=z[c]),b&&\"keypress\"!=b&&A[c]&&(c=A[c],g.push(\"shift\")),u(c)&&g.push(c);h=c;e=b;if(!e){if(!k){k={};for(var m in l)95<m&&112>m||l.hasOwnProperty(m)&&(k[l[m]]=m)}e=k[h]?\"keydown\":\"keypress\"}\"keypress\"==e&&g.length&&(e=\"keydown\");return{key:c,modifiers:g,action:e}}function B(a,b){return null===a||a===r?!1:a===b?!0:B(a.parentNode,b)}function c(a){function b(a){a=\na||{};var b=!1,n;for(n in q)a[n]?b=!0:q[n]=0;b||(v=!1)}function h(a,b,n,f,c,h){var g,e,l=[],m=n.type;if(!d._callbacks[a])return[];\"keyup\"==m&&u(a)&&(b=[a]);for(g=0;g<d._callbacks[a].length;++g)if(e=d._callbacks[a][g],(f||!e.seq||q[e.seq]==e.level)&&m==e.action){var k;(k=\"keypress\"==m&&!n.metaKey&&!n.ctrlKey)||(k=e.modifiers,k=b.sort().join(\",\")===k.sort().join(\",\"));k&&(k=f&&e.seq==f&&e.level==h,(!f&&e.combo==c||k)&&d._callbacks[a].splice(g,1),l.push(e))}return l}function g(a,b,n,f){d.stopCallback(b,\nb.target||b.srcElement,n,f)||!1!==a(b,n)||(b.preventDefault?b.preventDefault():b.returnValue=!1,b.stopPropagation?b.stopPropagation():b.cancelBubble=!0)}function e(a){\"number\"!==typeof a.which&&(a.which=a.keyCode);var b=x(a);b&&(\"keyup\"==a.type&&w===b?w=!1:d.handleKey(b,D(a),a))}function l(a,c,n,f){function e(c){return function(){v=c;++q[a];clearTimeout(k);k=setTimeout(b,1E3)}}function h(c){g(n,c,a);\"keyup\"!==f&&(w=x(c));setTimeout(b,10)}for(var d=q[a]=0;d<c.length;++d){var p=d+1===c.length?h:e(f||\ny(c[d+1]).action);m(c[d],p,f,a,d)}}function m(a,b,c,f,e){d._directMap[a+\":\"+c]=b;a=a.replace(/\\s+/g,\" \");var g=a.split(\" \");1<g.length?l(a,g,b,c):(c=y(a,c),d._callbacks[c.key]=d._callbacks[c.key]||[],h(c.key,c.modifiers,{type:c.action},f,a,e),d._callbacks[c.key][f?\"unshift\":\"push\"]({callback:b,modifiers:c.modifiers,action:c.action,seq:f,level:e,combo:a}))}var d=this;a=a||r;if(!(d instanceof c))return new c(a);d.target=a;d._callbacks={};d._directMap={};var q={},k,w=!1,p=!1,v=!1;d._handleKey=function(a,\nc,e){var f=h(a,c,e),d;c={};var k=0,l=!1;for(d=0;d<f.length;++d)f[d].seq&&(k=Math.max(k,f[d].level));for(d=0;d<f.length;++d)f[d].seq?f[d].level==k&&(l=!0,c[f[d].seq]=1,g(f[d].callback,e,f[d].combo,f[d].seq)):l||g(f[d].callback,e,f[d].combo);f=\"keypress\"==e.type&&p;e.type!=v||u(a)||f||b(c);p=l&&\"keydown\"==e.type};d._bindMultiple=function(a,b,c){for(var d=0;d<a.length;++d)m(a[d],b,c)};t(a,\"keypress\",e);t(a,\"keydown\",e);t(a,\"keyup\",e)}var l={8:\"backspace\",9:\"tab\",13:\"enter\",16:\"shift\",17:\"ctrl\",18:\"alt\",\n20:\"capslock\",27:\"esc\",32:\"space\",33:\"pageup\",34:\"pagedown\",35:\"end\",36:\"home\",37:\"left\",38:\"up\",39:\"right\",40:\"down\",45:\"ins\",46:\"del\",91:\"meta\",93:\"meta\",224:\"meta\"},p={106:\"*\",107:\"+\",109:\"-\",110:\".\",111:\"/\",186:\";\",187:\"=\",188:\",\",189:\"-\",190:\".\",191:\"/\",192:\"`\",219:\"[\",220:\"\\\\\",221:\"]\",222:\"'\"},A={\"~\":\"`\",\"!\":\"1\",\"@\":\"2\",\"#\":\"3\",$:\"4\",\"%\":\"5\",\"^\":\"6\",\"&\":\"7\",\"*\":\"8\",\"(\":\"9\",\")\":\"0\",_:\"-\",\"+\":\"=\",\":\":\";\",'\"':\"'\",\"<\":\",\",\">\":\".\",\"?\":\"/\",\"|\":\"\\\\\"},z={option:\"alt\",command:\"meta\",\"return\":\"enter\",\nescape:\"esc\",plus:\"+\",mod:/Mac|iPod|iPhone|iPad/.test(navigator.platform)?\"meta\":\"ctrl\"},k;for(g=1;20>g;++g)l[111+g]=\"f\"+g;for(g=0;9>=g;++g)l[g+96]=g;c.prototype.bind=function(a,b,c){a=a instanceof Array?a:[a];this._bindMultiple.call(this,a,b,c);return this};c.prototype.unbind=function(a,b){return this.bind.call(this,a,function(){},b)};c.prototype.trigger=function(a,b){if(this._directMap[a+\":\"+b])this._directMap[a+\":\"+b]({},a);return this};c.prototype.reset=function(){this._callbacks={};this._directMap=\n{};return this};c.prototype.stopCallback=function(a,b){return-1<(\" \"+b.className+\" \").indexOf(\" mousetrap \")||B(b,this.target)?!1:\"INPUT\"==b.tagName||\"SELECT\"==b.tagName||\"TEXTAREA\"==b.tagName||b.isContentEditable};c.prototype.handleKey=function(){return this._handleKey.apply(this,arguments)};c.init=function(){var a=c(r),b;for(b in a)\"_\"!==b.charAt(0)&&(c[b]=function(b){return function(){return a[b].apply(a,arguments)}}(b))};c.init();C.Mousetrap=c;\"undefined\"!==typeof module&&module.exports&&(module.exports=\nc);\"function\"===\"function\"&&__webpack_require__(1)&&!(__WEBPACK_AMD_DEFINE_RESULT__ = function(){return c}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))})(window,document);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9yZXNvdXJjZXMvYXNzZXRzL2pzL3ZlbmRvci9tb3VzZXRyYXAuanM/ODFjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBtb3VzZXRyYXAgdjEuNS4zIGNyYWlnLmlzL2tpbGxpbmcvbWljZSAqL1xuKGZ1bmN0aW9uKEMscixnKXtmdW5jdGlvbiB0KGEsYixoKXthLmFkZEV2ZW50TGlzdGVuZXI/YS5hZGRFdmVudExpc3RlbmVyKGIsaCwhMSk6YS5hdHRhY2hFdmVudChcIm9uXCIrYixoKX1mdW5jdGlvbiB4KGEpe2lmKFwia2V5cHJlc3NcIj09YS50eXBlKXt2YXIgYj1TdHJpbmcuZnJvbUNoYXJDb2RlKGEud2hpY2gpO2Euc2hpZnRLZXl8fChiPWIudG9Mb3dlckNhc2UoKSk7cmV0dXJuIGJ9cmV0dXJuIGxbYS53aGljaF0/bFthLndoaWNoXTpwW2Eud2hpY2hdP3BbYS53aGljaF06U3RyaW5nLmZyb21DaGFyQ29kZShhLndoaWNoKS50b0xvd2VyQ2FzZSgpfWZ1bmN0aW9uIEQoYSl7dmFyIGI9W107YS5zaGlmdEtleSYmYi5wdXNoKFwic2hpZnRcIik7YS5hbHRLZXkmJmIucHVzaChcImFsdFwiKTthLmN0cmxLZXkmJmIucHVzaChcImN0cmxcIik7YS5tZXRhS2V5JiZiLnB1c2goXCJtZXRhXCIpO3JldHVybiBifWZ1bmN0aW9uIHUoYSl7cmV0dXJuXCJzaGlmdFwiPT1hfHxcImN0cmxcIj09YXx8XCJhbHRcIj09YXx8XG5cIm1ldGFcIj09YX1mdW5jdGlvbiB5KGEsYil7dmFyIGgsYyxlLGc9W107aD1hO1wiK1wiPT09aD9oPVtcIitcIl06KGg9aC5yZXBsYWNlKC9cXCt7Mn0vZyxcIitwbHVzXCIpLGg9aC5zcGxpdChcIitcIikpO2ZvcihlPTA7ZTxoLmxlbmd0aDsrK2UpYz1oW2VdLHpbY10mJihjPXpbY10pLGImJlwia2V5cHJlc3NcIiE9YiYmQVtjXSYmKGM9QVtjXSxnLnB1c2goXCJzaGlmdFwiKSksdShjKSYmZy5wdXNoKGMpO2g9YztlPWI7aWYoIWUpe2lmKCFrKXtrPXt9O2Zvcih2YXIgbSBpbiBsKTk1PG0mJjExMj5tfHxsLmhhc093blByb3BlcnR5KG0pJiYoa1tsW21dXT1tKX1lPWtbaF0/XCJrZXlkb3duXCI6XCJrZXlwcmVzc1wifVwia2V5cHJlc3NcIj09ZSYmZy5sZW5ndGgmJihlPVwia2V5ZG93blwiKTtyZXR1cm57a2V5OmMsbW9kaWZpZXJzOmcsYWN0aW9uOmV9fWZ1bmN0aW9uIEIoYSxiKXtyZXR1cm4gbnVsbD09PWF8fGE9PT1yPyExOmE9PT1iPyEwOkIoYS5wYXJlbnROb2RlLGIpfWZ1bmN0aW9uIGMoYSl7ZnVuY3Rpb24gYihhKXthPVxuYXx8e307dmFyIGI9ITEsbjtmb3IobiBpbiBxKWFbbl0/Yj0hMDpxW25dPTA7Ynx8KHY9ITEpfWZ1bmN0aW9uIGgoYSxiLG4sZixjLGgpe3ZhciBnLGUsbD1bXSxtPW4udHlwZTtpZighZC5fY2FsbGJhY2tzW2FdKXJldHVybltdO1wia2V5dXBcIj09bSYmdShhKSYmKGI9W2FdKTtmb3IoZz0wO2c8ZC5fY2FsbGJhY2tzW2FdLmxlbmd0aDsrK2cpaWYoZT1kLl9jYWxsYmFja3NbYV1bZ10sKGZ8fCFlLnNlcXx8cVtlLnNlcV09PWUubGV2ZWwpJiZtPT1lLmFjdGlvbil7dmFyIGs7KGs9XCJrZXlwcmVzc1wiPT1tJiYhbi5tZXRhS2V5JiYhbi5jdHJsS2V5KXx8KGs9ZS5tb2RpZmllcnMsaz1iLnNvcnQoKS5qb2luKFwiLFwiKT09PWsuc29ydCgpLmpvaW4oXCIsXCIpKTtrJiYoaz1mJiZlLnNlcT09ZiYmZS5sZXZlbD09aCwoIWYmJmUuY29tYm89PWN8fGspJiZkLl9jYWxsYmFja3NbYV0uc3BsaWNlKGcsMSksbC5wdXNoKGUpKX1yZXR1cm4gbH1mdW5jdGlvbiBnKGEsYixuLGYpe2Quc3RvcENhbGxiYWNrKGIsXG5iLnRhcmdldHx8Yi5zcmNFbGVtZW50LG4sZil8fCExIT09YShiLG4pfHwoYi5wcmV2ZW50RGVmYXVsdD9iLnByZXZlbnREZWZhdWx0KCk6Yi5yZXR1cm5WYWx1ZT0hMSxiLnN0b3BQcm9wYWdhdGlvbj9iLnN0b3BQcm9wYWdhdGlvbigpOmIuY2FuY2VsQnViYmxlPSEwKX1mdW5jdGlvbiBlKGEpe1wibnVtYmVyXCIhPT10eXBlb2YgYS53aGljaCYmKGEud2hpY2g9YS5rZXlDb2RlKTt2YXIgYj14KGEpO2ImJihcImtleXVwXCI9PWEudHlwZSYmdz09PWI/dz0hMTpkLmhhbmRsZUtleShiLEQoYSksYSkpfWZ1bmN0aW9uIGwoYSxjLG4sZil7ZnVuY3Rpb24gZShjKXtyZXR1cm4gZnVuY3Rpb24oKXt2PWM7KytxW2FdO2NsZWFyVGltZW91dChrKTtrPXNldFRpbWVvdXQoYiwxRTMpfX1mdW5jdGlvbiBoKGMpe2cobixjLGEpO1wia2V5dXBcIiE9PWYmJih3PXgoYykpO3NldFRpbWVvdXQoYiwxMCl9Zm9yKHZhciBkPXFbYV09MDtkPGMubGVuZ3RoOysrZCl7dmFyIHA9ZCsxPT09Yy5sZW5ndGg/aDplKGZ8fFxueShjW2QrMV0pLmFjdGlvbik7bShjW2RdLHAsZixhLGQpfX1mdW5jdGlvbiBtKGEsYixjLGYsZSl7ZC5fZGlyZWN0TWFwW2ErXCI6XCIrY109YjthPWEucmVwbGFjZSgvXFxzKy9nLFwiIFwiKTt2YXIgZz1hLnNwbGl0KFwiIFwiKTsxPGcubGVuZ3RoP2woYSxnLGIsYyk6KGM9eShhLGMpLGQuX2NhbGxiYWNrc1tjLmtleV09ZC5fY2FsbGJhY2tzW2Mua2V5XXx8W10saChjLmtleSxjLm1vZGlmaWVycyx7dHlwZTpjLmFjdGlvbn0sZixhLGUpLGQuX2NhbGxiYWNrc1tjLmtleV1bZj9cInVuc2hpZnRcIjpcInB1c2hcIl0oe2NhbGxiYWNrOmIsbW9kaWZpZXJzOmMubW9kaWZpZXJzLGFjdGlvbjpjLmFjdGlvbixzZXE6ZixsZXZlbDplLGNvbWJvOmF9KSl9dmFyIGQ9dGhpczthPWF8fHI7aWYoIShkIGluc3RhbmNlb2YgYykpcmV0dXJuIG5ldyBjKGEpO2QudGFyZ2V0PWE7ZC5fY2FsbGJhY2tzPXt9O2QuX2RpcmVjdE1hcD17fTt2YXIgcT17fSxrLHc9ITEscD0hMSx2PSExO2QuX2hhbmRsZUtleT1mdW5jdGlvbihhLFxuYyxlKXt2YXIgZj1oKGEsYyxlKSxkO2M9e307dmFyIGs9MCxsPSExO2ZvcihkPTA7ZDxmLmxlbmd0aDsrK2QpZltkXS5zZXEmJihrPU1hdGgubWF4KGssZltkXS5sZXZlbCkpO2ZvcihkPTA7ZDxmLmxlbmd0aDsrK2QpZltkXS5zZXE/ZltkXS5sZXZlbD09ayYmKGw9ITAsY1tmW2RdLnNlcV09MSxnKGZbZF0uY2FsbGJhY2ssZSxmW2RdLmNvbWJvLGZbZF0uc2VxKSk6bHx8ZyhmW2RdLmNhbGxiYWNrLGUsZltkXS5jb21ibyk7Zj1cImtleXByZXNzXCI9PWUudHlwZSYmcDtlLnR5cGUhPXZ8fHUoYSl8fGZ8fGIoYyk7cD1sJiZcImtleWRvd25cIj09ZS50eXBlfTtkLl9iaW5kTXVsdGlwbGU9ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD0wO2Q8YS5sZW5ndGg7KytkKW0oYVtkXSxiLGMpfTt0KGEsXCJrZXlwcmVzc1wiLGUpO3QoYSxcImtleWRvd25cIixlKTt0KGEsXCJrZXl1cFwiLGUpfXZhciBsPXs4OlwiYmFja3NwYWNlXCIsOTpcInRhYlwiLDEzOlwiZW50ZXJcIiwxNjpcInNoaWZ0XCIsMTc6XCJjdHJsXCIsMTg6XCJhbHRcIixcbjIwOlwiY2Fwc2xvY2tcIiwyNzpcImVzY1wiLDMyOlwic3BhY2VcIiwzMzpcInBhZ2V1cFwiLDM0OlwicGFnZWRvd25cIiwzNTpcImVuZFwiLDM2OlwiaG9tZVwiLDM3OlwibGVmdFwiLDM4OlwidXBcIiwzOTpcInJpZ2h0XCIsNDA6XCJkb3duXCIsNDU6XCJpbnNcIiw0NjpcImRlbFwiLDkxOlwibWV0YVwiLDkzOlwibWV0YVwiLDIyNDpcIm1ldGFcIn0scD17MTA2OlwiKlwiLDEwNzpcIitcIiwxMDk6XCItXCIsMTEwOlwiLlwiLDExMTpcIi9cIiwxODY6XCI7XCIsMTg3OlwiPVwiLDE4ODpcIixcIiwxODk6XCItXCIsMTkwOlwiLlwiLDE5MTpcIi9cIiwxOTI6XCJgXCIsMjE5OlwiW1wiLDIyMDpcIlxcXFxcIiwyMjE6XCJdXCIsMjIyOlwiJ1wifSxBPXtcIn5cIjpcImBcIixcIiFcIjpcIjFcIixcIkBcIjpcIjJcIixcIiNcIjpcIjNcIiwkOlwiNFwiLFwiJVwiOlwiNVwiLFwiXlwiOlwiNlwiLFwiJlwiOlwiN1wiLFwiKlwiOlwiOFwiLFwiKFwiOlwiOVwiLFwiKVwiOlwiMFwiLF86XCItXCIsXCIrXCI6XCI9XCIsXCI6XCI6XCI7XCIsJ1wiJzpcIidcIixcIjxcIjpcIixcIixcIj5cIjpcIi5cIixcIj9cIjpcIi9cIixcInxcIjpcIlxcXFxcIn0sej17b3B0aW9uOlwiYWx0XCIsY29tbWFuZDpcIm1ldGFcIixcInJldHVyblwiOlwiZW50ZXJcIixcbmVzY2FwZTpcImVzY1wiLHBsdXM6XCIrXCIsbW9kOi9NYWN8aVBvZHxpUGhvbmV8aVBhZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pP1wibWV0YVwiOlwiY3RybFwifSxrO2ZvcihnPTE7MjA+ZzsrK2cpbFsxMTErZ109XCJmXCIrZztmb3IoZz0wOzk+PWc7KytnKWxbZys5Nl09ZztjLnByb3RvdHlwZS5iaW5kPWZ1bmN0aW9uKGEsYixjKXthPWEgaW5zdGFuY2VvZiBBcnJheT9hOlthXTt0aGlzLl9iaW5kTXVsdGlwbGUuY2FsbCh0aGlzLGEsYixjKTtyZXR1cm4gdGhpc307Yy5wcm90b3R5cGUudW5iaW5kPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuYmluZC5jYWxsKHRoaXMsYSxmdW5jdGlvbigpe30sYil9O2MucHJvdG90eXBlLnRyaWdnZXI9ZnVuY3Rpb24oYSxiKXtpZih0aGlzLl9kaXJlY3RNYXBbYStcIjpcIitiXSl0aGlzLl9kaXJlY3RNYXBbYStcIjpcIitiXSh7fSxhKTtyZXR1cm4gdGhpc307Yy5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLl9jYWxsYmFja3M9e307dGhpcy5fZGlyZWN0TWFwPVxue307cmV0dXJuIHRoaXN9O2MucHJvdG90eXBlLnN0b3BDYWxsYmFjaz1mdW5jdGlvbihhLGIpe3JldHVybi0xPChcIiBcIitiLmNsYXNzTmFtZStcIiBcIikuaW5kZXhPZihcIiBtb3VzZXRyYXAgXCIpfHxCKGIsdGhpcy50YXJnZXQpPyExOlwiSU5QVVRcIj09Yi50YWdOYW1lfHxcIlNFTEVDVFwiPT1iLnRhZ05hbWV8fFwiVEVYVEFSRUFcIj09Yi50YWdOYW1lfHxiLmlzQ29udGVudEVkaXRhYmxlfTtjLnByb3RvdHlwZS5oYW5kbGVLZXk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFuZGxlS2V5LmFwcGx5KHRoaXMsYXJndW1lbnRzKX07Yy5pbml0PWZ1bmN0aW9uKCl7dmFyIGE9YyhyKSxiO2ZvcihiIGluIGEpXCJfXCIhPT1iLmNoYXJBdCgwKSYmKGNbYl09ZnVuY3Rpb24oYil7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGFbYl0uYXBwbHkoYSxhcmd1bWVudHMpfX0oYikpfTtjLmluaXQoKTtDLk1vdXNldHJhcD1jO1widW5kZWZpbmVkXCIhPT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cyYmKG1vZHVsZS5leHBvcnRzPVxuYyk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZCYmZGVmaW5lKGZ1bmN0aW9uKCl7cmV0dXJuIGN9KX0pKHdpbmRvdyxkb2N1bWVudCk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHJlc291cmNlcy9hc3NldHMvanMvdmVuZG9yL21vdXNldHJhcC5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 9 */
/***/ function(module, exports) {

eval("/* http://prismjs.com/download.html?themes=prism&languages=markup+twig+css+clike+javascript+php+php-extras+scss+bash+sql+apacheconf+git+handlebars&plugins=line-numbers */\nself=\"undefined\"!=typeof window?window:\"undefined\"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{};var Prism=function(){var e=/\\blang(?:uage)?-(?!\\*)(\\w+)\\b/i,t=self.Prism={util:{encode:function(e){return e instanceof n?new n(e.type,t.util.encode(e.content),e.alias):\"Array\"===t.util.type(e)?e.map(t.util.encode):e.replace(/&/g,\"&amp;\").replace(/</g,\"&lt;\").replace(/\\u00a0/g,\" \")},type:function(e){return Object.prototype.toString.call(e).match(/\\[object (\\w+)\\]/)[1]},clone:function(e){var n=t.util.type(e);switch(n){case\"Object\":var a={};for(var r in e)e.hasOwnProperty(r)&&(a[r]=t.util.clone(e[r]));return a;case\"Array\":return e.map(function(e){return t.util.clone(e)})}return e}},languages:{extend:function(e,n){var a=t.util.clone(t.languages[e]);for(var r in n)a[r]=n[r];return a},insertBefore:function(e,n,a,r){r=r||t.languages;var i=r[e];if(2==arguments.length){a=arguments[1];for(var l in a)a.hasOwnProperty(l)&&(i[l]=a[l]);return i}var o={};for(var s in i)if(i.hasOwnProperty(s)){if(s==n)for(var l in a)a.hasOwnProperty(l)&&(o[l]=a[l]);o[s]=i[s]}return t.languages.DFS(t.languages,function(t,n){n===r[e]&&t!=e&&(this[t]=o)}),r[e]=o},DFS:function(e,n,a){for(var r in e)e.hasOwnProperty(r)&&(n.call(e,r,e[r],a||r),\"Object\"===t.util.type(e[r])?t.languages.DFS(e[r],n):\"Array\"===t.util.type(e[r])&&t.languages.DFS(e[r],n,r))}},highlightAll:function(e,n){for(var a,r=document.querySelectorAll('pre code'),i=0;a=r[i++];)t.highlightElement(a,e===!0,n)},highlightElement:function(a,r,i){for(var l,o,s=a;s&&!e.test(s.className);)s=s.parentNode;if(s&&(l=(s.className.match(e)||[,\"\"])[1],o=t.languages[l]),o){a.className=a.className.replace(e,\"\").replace(/\\s+/g,\" \")+\" language-\"+l,s=a.parentNode,/pre/i.test(s.nodeName)&&(s.className=s.className.replace(e,\"\").replace(/\\s+/g,\" \")+\" language-\"+l);var g=a.textContent;if(g){g=g.replace(/^(?:\\r?\\n|\\r)/,\"\");var u={element:a,language:l,grammar:o,code:g};if(t.hooks.run(\"before-highlight\",u),r&&self.Worker){var c=new Worker(t.filename);c.onmessage=function(e){u.highlightedCode=n.stringify(JSON.parse(e.data),l),t.hooks.run(\"before-insert\",u),u.element.innerHTML=u.highlightedCode,i&&i.call(u.element),t.hooks.run(\"after-highlight\",u)},c.postMessage(JSON.stringify({language:u.language,code:u.code}))}else u.highlightedCode=t.highlight(u.code,u.grammar,u.language),t.hooks.run(\"before-insert\",u),u.element.innerHTML=u.highlightedCode,i&&i.call(a),t.hooks.run(\"after-highlight\",u)}}},highlight:function(e,a,r){var i=t.tokenize(e,a);return n.stringify(t.util.encode(i),r)},tokenize:function(e,n){var a=t.Token,r=[e],i=n.rest;if(i){for(var l in i)n[l]=i[l];delete n.rest}e:for(var l in n)if(n.hasOwnProperty(l)&&n[l]){var o=n[l];o=\"Array\"===t.util.type(o)?o:[o];for(var s=0;s<o.length;++s){var g=o[s],u=g.inside,c=!!g.lookbehind,f=0,h=g.alias;g=g.pattern||g;for(var p=0;p<r.length;p++){var d=r[p];if(r.length>e.length)break e;if(!(d instanceof a)){g.lastIndex=0;var m=g.exec(d);if(m){c&&(f=m[1].length);var y=m.index-1+f,m=m[0].slice(f),v=m.length,k=y+v,b=d.slice(0,y+1),w=d.slice(k+1),O=[p,1];b&&O.push(b);var N=new a(l,u?t.tokenize(m,u):m,h);O.push(N),w&&O.push(w),Array.prototype.splice.apply(r,O)}}}}}return r},hooks:{all:{},add:function(e,n){var a=t.hooks.all;a[e]=a[e]||[],a[e].push(n)},run:function(e,n){var a=t.hooks.all[e];if(a&&a.length)for(var r,i=0;r=a[i++];)r(n)}}},n=t.Token=function(e,t,n){this.type=e,this.content=t,this.alias=n};if(n.stringify=function(e,a,r){if(\"string\"==typeof e)return e;if(\"[object Array]\"==Object.prototype.toString.call(e))return e.map(function(t){return n.stringify(t,a,e)}).join(\"\");var i={type:e.type,content:n.stringify(e.content,a,r),tag:\"span\",classes:[\"token\",e.type],attributes:{},language:a,parent:r};if(\"comment\"==i.type&&(i.attributes.spellcheck=\"true\"),e.alias){var l=\"Array\"===t.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(i.classes,l)}t.hooks.run(\"wrap\",i);var o=\"\";for(var s in i.attributes)o+=s+'=\"'+(i.attributes[s]||\"\")+'\"';return\"<\"+i.tag+' class=\"'+i.classes.join(\" \")+'\" '+o+\">\"+i.content+\"</\"+i.tag+\">\"},!self.document)return self.addEventListener?(self.addEventListener(\"message\",function(e){var n=JSON.parse(e.data),a=n.language,r=n.code;self.postMessage(JSON.stringify(t.util.encode(t.tokenize(r,t.languages[a])))),self.close()},!1),self.Prism):self.Prism;var a=document.getElementsByTagName(\"script\");return a=a[a.length-1],a&&(t.filename=a.src,document.addEventListener&&!a.hasAttribute(\"data-manual\")&&document.addEventListener(\"DOMContentLoaded\",t.highlightAll)),self.Prism}();\"undefined\"!=typeof module&&module.exports&&(module.exports=Prism);;\nPrism.languages.markup={comment:/<!--[\\w\\W]*?-->/g,prolog:/<\\?.+?\\?>/,doctype:/<!DOCTYPE.+?>/,cdata:/<!\\[CDATA\\[[\\w\\W]*?]]>/i,tag:{pattern:/<\\/?[\\w:-]+\\s*(?:\\s+[\\w:-]+(?:=(?:(\"|')(\\\\?[\\w\\W])*?\\1|[^\\s'\">=]+))?\\s*)*\\/?>/gi,inside:{tag:{pattern:/^<\\/?[\\w:-]+/i,inside:{punctuation:/^<\\/?/,namespace:/^[\\w-]+?:/}},\"attr-value\":{pattern:/=(?:('|\")[\\w\\W]*?(\\1)|[^\\s>]+)/gi,inside:{punctuation:/=|>|\"/g}},punctuation:/\\/?>/g,\"attr-name\":{pattern:/[\\w:-]+/g,inside:{namespace:/^[\\w-]+?:/}}}},entity:/&#?[\\da-z]{1,8};/gi},Prism.hooks.add(\"wrap\",function(t){\"entity\"===t.type&&(t.attributes.title=t.content.replace(/&amp;/,\"&\"))});;\nPrism.languages.twig={comment:/\\{#[\\s\\S]*?#\\}/g,tag:{pattern:/(\\{\\{[\\s\\S]*?\\}\\}|\\{%[\\s\\S]*?%\\})/g,inside:{ld:{pattern:/^(\\{\\{\\-?|\\{%\\-?\\s*\\w+)/,inside:{punctuation:/^(\\{\\{|\\{%)\\-?/,keyword:/\\w+/}},rd:{pattern:/\\-?(%\\}|\\}\\})$/,inside:{punctuation:/.*/}},string:{pattern:/(\"|')(\\\\?.)*?\\1/g,inside:{punctuation:/^('|\")|('|\")$/g}},keyword:/\\b(if)\\b/g,\"boolean\":/\\b(true|false|null)\\b/g,number:/\\b-?(0x[\\dA-Fa-f]+|\\d*\\.?\\d+([Ee]-?\\d+)?)\\b/g,operator:/==|=|!=|<|>|>=|<=|\\+|\\-|~|\\*|\\/|\\/\\/|%|\\*\\*|\\|/g,\"space-operator\":{pattern:/(\\s)(\\b(not|b\\-and|b\\-xor|b\\-or|and|or|in|matches|starts with|ends with|is)\\b|\\?|:|\\?:)(?=\\s)/g,lookbehind:!0,inside:{operator:/.*/}},property:/\\b[a-zA-Z_][a-zA-Z0-9_]*\\b/g,punctuation:/\\(|\\)|\\[\\]|\\[|\\]|\\{|\\}|:|\\.|,/g}},other:{pattern:/[\\s\\S]*/,inside:Prism.languages.markup}};;\nPrism.languages.css={comment:/\\/\\*[\\w\\W]*?\\*\\//g,atrule:{pattern:/@[\\w-]+?.*?(;|(?=\\s*\\{))/gi,inside:{punctuation:/[;:]/g}},url:/url\\((?:([\"'])(\\\\\\n|\\\\?.)*?\\1|.*?)\\)/gi,selector:/[^\\{\\}\\s][^\\{\\};]*(?=\\s*\\{)/g,string:/(\"|')(\\\\\\n|\\\\?.)*?\\1/g,property:/(\\b|\\B)[\\w-]+(?=\\s*:)/gi,important:/\\B!important\\b/gi,punctuation:/[\\{\\};:]/g,\"function\":/[-a-z0-9]+(?=\\()/gi},Prism.languages.markup&&(Prism.languages.insertBefore(\"markup\",\"tag\",{style:{pattern:/<style[\\w\\W]*?>[\\w\\W]*?<\\/style>/gi,inside:{tag:{pattern:/<style[\\w\\W]*?>|<\\/style>/gi,inside:Prism.languages.markup.tag.inside},rest:Prism.languages.css},alias:\"language-css\"}}),Prism.languages.insertBefore(\"inside\",\"attr-value\",{\"style-attr\":{pattern:/\\s*style=(\"|').+?\\1/gi,inside:{\"attr-name\":{pattern:/^\\s*style/gi,inside:Prism.languages.markup.tag.inside},punctuation:/^\\s*=\\s*['\"]|['\"]\\s*$/,\"attr-value\":{pattern:/.+/gi,inside:Prism.languages.css}},alias:\"language-css\"}},Prism.languages.markup.tag));;\nPrism.languages.clike={comment:[{pattern:/(^|[^\\\\])\\/\\*[\\w\\W]*?\\*\\//g,lookbehind:!0},{pattern:/(^|[^\\\\:])\\/\\/.*?(\\r?\\n|$)/g,lookbehind:!0}],string:/(\"|')(\\\\\\n|\\\\?.)*?\\1/g,\"class-name\":{pattern:/((?:(?:class|interface|extends|implements|trait|instanceof|new)\\s+)|(?:catch\\s+\\())[a-z0-9_\\.\\\\]+/gi,lookbehind:!0,inside:{punctuation:/(\\.|\\\\)/}},keyword:/\\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/g,\"boolean\":/\\b(true|false)\\b/g,\"function\":{pattern:/[a-z0-9_]+\\(/gi,inside:{punctuation:/\\(/}},number:/\\b-?(0x[\\dA-Fa-f]+|\\d*\\.?\\d+([Ee]-?\\d+)?)\\b/g,operator:/[-+]{1,2}|!|<=?|>=?|={1,3}|&{1,2}|\\|?\\||\\?|\\*|\\/|~|\\^|%/g,ignore:/&(lt|gt|amp);/gi,punctuation:/[{}[\\];(),.:]/g};;\nPrism.languages.javascript=Prism.languages.extend(\"clike\",{keyword:/\\b(break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|get|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|set|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\\b/g,number:/\\b-?(0x[\\dA-Fa-f]+|\\d*\\.?\\d+([Ee][+-]?\\d+)?|NaN|-?Infinity)\\b/g,\"function\":/(?!\\d)[a-z0-9_$]+(?=\\()/gi}),Prism.languages.insertBefore(\"javascript\",\"keyword\",{regex:{pattern:/(^|[^/])\\/(?!\\/)(\\[.+?]|\\\\.|[^/\\r\\n])+\\/[gim]{0,3}(?=\\s*($|[\\r\\n,.;})]))/g,lookbehind:!0}}),Prism.languages.markup&&Prism.languages.insertBefore(\"markup\",\"tag\",{script:{pattern:/<script[\\w\\W]*?>[\\w\\W]*?<\\/script>/gi,inside:{tag:{pattern:/<script[\\w\\W]*?>|<\\/script>/gi,inside:Prism.languages.markup.tag.inside},rest:Prism.languages.javascript},alias:\"language-javascript\"}});;\nPrism.languages.php=Prism.languages.extend(\"clike\",{keyword:/\\b(and|or|xor|array|as|break|case|cfunction|class|const|continue|declare|default|die|do|else|elseif|enddeclare|endfor|endforeach|endif|endswitch|endwhile|extends|for|foreach|function|include|include_once|global|if|new|return|static|switch|use|require|require_once|var|while|abstract|interface|public|implements|private|protected|parent|throw|null|echo|print|trait|namespace|final|yield|goto|instanceof|finally|try|catch)\\b/gi,constant:/\\b[A-Z0-9_]{2,}\\b/g,comment:{pattern:/(^|[^\\\\])(\\/\\*[\\w\\W]*?\\*\\/|(^|[^:])(\\/\\/|#).*?(\\r?\\n|$))/g,lookbehind:!0}}),Prism.languages.insertBefore(\"php\",\"keyword\",{delimiter:/(\\?>|<\\?php|<\\?)/gi,variable:/(\\$\\w+)\\b/gi,\"package\":{pattern:/(\\\\|namespace\\s+|use\\s+)[\\w\\\\]+/g,lookbehind:!0,inside:{punctuation:/\\\\/}}}),Prism.languages.insertBefore(\"php\",\"operator\",{property:{pattern:/(->)[\\w]+/g,lookbehind:!0}}),Prism.languages.markup&&(Prism.hooks.add(\"before-highlight\",function(e){\"php\"===e.language&&(e.tokenStack=[],e.backupCode=e.code,e.code=e.code.replace(/(?:<\\?php|<\\?)[\\w\\W]*?(?:\\?>)/gi,function(n){return e.tokenStack.push(n),\"{{{PHP\"+e.tokenStack.length+\"}}}\"}))}),Prism.hooks.add(\"before-insert\",function(e){\"php\"===e.language&&(e.code=e.backupCode,delete e.backupCode)}),Prism.hooks.add(\"after-highlight\",function(e){if(\"php\"===e.language){for(var n,a=0;n=e.tokenStack[a];a++)e.highlightedCode=e.highlightedCode.replace(\"{{{PHP\"+(a+1)+\"}}}\",Prism.highlight(n,e.grammar,\"php\"));e.element.innerHTML=e.highlightedCode}}),Prism.hooks.add(\"wrap\",function(e){\"php\"===e.language&&\"markup\"===e.type&&(e.content=e.content.replace(/(\\{\\{\\{PHP[0-9]+\\}\\}\\})/g,'<span class=\"token php\">$1</span>'))}),Prism.languages.insertBefore(\"php\",\"comment\",{markup:{pattern:/<[^?]\\/?(.*?)>/g,inside:Prism.languages.markup},php:/\\{\\{\\{PHP[0-9]+\\}\\}\\}/g}));;\nPrism.languages.insertBefore(\"php\",\"variable\",{\"this\":/\\$this/g,global:/\\$_?(GLOBALS|SERVER|GET|POST|FILES|REQUEST|SESSION|ENV|COOKIE|HTTP_RAW_POST_DATA|argc|argv|php_errormsg|http_response_header)/g,scope:{pattern:/\\b[\\w\\\\]+::/g,inside:{keyword:/(static|self|parent)/,punctuation:/(::|\\\\)/}}});;\nPrism.languages.scss=Prism.languages.extend(\"css\",{comment:{pattern:/(^|[^\\\\])(\\/\\*[\\w\\W]*?\\*\\/|\\/\\/.*?(\\r?\\n|$))/g,lookbehind:!0},atrule:/@[\\w-]+(?=\\s+(\\(|\\{|;))/gi,url:/([-a-z]+-)*url(?=\\()/gi,selector:/([^@;\\{\\}\\(\\)]?([^@;\\{\\}\\(\\)]|&|#\\{\\$[-_\\w]+\\})+)(?=\\s*\\{(\\}|\\s|[^\\}]+(:|\\{)[^\\}]+))/gm}),Prism.languages.insertBefore(\"scss\",\"atrule\",{keyword:/@(if|else if|else|for|each|while|import|extend|debug|warn|mixin|include|function|return|content)|(?=@for\\s+\\$[-_\\w]+\\s)+from/i}),Prism.languages.insertBefore(\"scss\",\"property\",{variable:/((\\$[-_\\w]+)|(#\\{\\$[-_\\w]+\\}))/i}),Prism.languages.insertBefore(\"scss\",\"function\",{placeholder:/%[-_\\w]+/i,statement:/\\B!(default|optional)\\b/gi,\"boolean\":/\\b(true|false)\\b/g,\"null\":/\\b(null)\\b/g,operator:/\\s+([-+]{1,2}|={1,2}|!=|\\|?\\||\\?|\\*|\\/|%)\\s+/g});;\nPrism.languages.bash=Prism.languages.extend(\"clike\",{comment:{pattern:/(^|[^\"{\\\\])(#.*?(\\r?\\n|$))/g,lookbehind:!0},string:{pattern:/(\"|')(\\\\?[\\s\\S])*?\\1/g,inside:{property:/\\$([a-zA-Z0-9_#\\?\\-\\*!@]+|\\{[^\\}]+\\})/g}},keyword:/\\b(if|then|else|elif|fi|for|break|continue|while|in|case|function|select|do|done|until|echo|exit|return|set|declare)\\b/g}),Prism.languages.insertBefore(\"bash\",\"keyword\",{property:/\\$([a-zA-Z0-9_#\\?\\-\\*!@]+|\\{[^}]+\\})/g}),Prism.languages.insertBefore(\"bash\",\"comment\",{important:/(^#!\\s*\\/bin\\/bash)|(^#!\\s*\\/bin\\/sh)/g});;\nPrism.languages.sql={comment:{pattern:/(^|[^\\\\])(\\/\\*[\\w\\W]*?\\*\\/|((--)|(\\/\\/)|#).*?(\\r?\\n|$))/g,lookbehind:!0},string:{pattern:/(^|[^@])(\"|')(\\\\?[\\s\\S])*?\\2/g,lookbehind:!0},variable:/@[\\w.$]+|@(\"|'|`)(\\\\?[\\s\\S])+?\\1/g,\"function\":/\\b(?:COUNT|SUM|AVG|MIN|MAX|FIRST|LAST|UCASE|LCASE|MID|LEN|ROUND|NOW|FORMAT)(?=\\s*\\()/gi,keyword:/\\b(?:ACTION|ADD|AFTER|ALGORITHM|ALTER|ANALYZE|APPLY|AS|ASC|AUTHORIZATION|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADE|CASCADED|CASE|CHAIN|CHAR VARYING|CHARACTER VARYING|CHECK|CHECKPOINT|CLOSE|CLUSTERED|COALESCE|COLUMN|COLUMNS|COMMENT|COMMIT|COMMITTED|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS|CONTAINSTABLE|CONTINUE|CONVERT|CREATE|CROSS|CURRENT|CURRENT_DATE|CURRENT_TIME|CURRENT_TIMESTAMP|CURRENT_USER|CURSOR|DATA|DATABASE|DATABASES|DATETIME|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DOUBLE PRECISION|DROP|DUMMY|DUMP|DUMPFILE|DUPLICATE KEY|ELSE|ENABLE|ENCLOSED BY|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPE|ESCAPED BY|EXCEPT|EXEC|EXECUTE|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR|FOR EACH ROW|FORCE|FOREIGN|FREETEXT|FREETEXTTABLE|FROM|FULL|FUNCTION|GEOMETRY|GEOMETRYCOLLECTION|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|IDENTITY|IDENTITY_INSERT|IDENTITYCOL|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTO|INVOKER|ISOLATION LEVEL|JOIN|KEY|KEYS|KILL|LANGUAGE SQL|LAST|LEFT|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONGBLOB|LONGTEXT|MATCH|MATCHED|MEDIUMBLOB|MEDIUMINT|MEDIUMTEXT|MERGE|MIDDLEINT|MODIFIES SQL DATA|MODIFY|MULTILINESTRING|MULTIPOINT|MULTIPOLYGON|NATIONAL|NATIONAL CHAR VARYING|NATIONAL CHARACTER|NATIONAL CHARACTER VARYING|NATIONAL VARCHAR|NATURAL|NCHAR|NCHAR VARCHAR|NEXT|NO|NO SQL|NOCHECK|NOCYCLE|NONCLUSTERED|NULLIF|NUMERIC|OF|OFF|OFFSETS|ON|OPEN|OPENDATASOURCE|OPENQUERY|OPENROWSET|OPTIMIZE|OPTION|OPTIONALLY|ORDER|OUT|OUTER|OUTFILE|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREV|PRIMARY|PRINT|PRIVILEGES|PROC|PROCEDURE|PUBLIC|PURGE|QUICK|RAISERROR|READ|READS SQL DATA|READTEXT|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEATABLE|REPLICATION|REQUIRE|RESTORE|RESTRICT|RETURN|RETURNS|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROWCOUNT|ROWGUIDCOL|ROWS?|RTREE|RULE|SAVE|SAVEPOINT|SCHEMA|SELECT|SERIAL|SERIALIZABLE|SESSION|SESSION_USER|SET|SETUSER|SHARE MODE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|START|STARTING BY|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLE|TABLES|TABLESPACE|TEMP(?:ORARY)?|TEMPTABLE|TERMINATED BY|TEXT|TEXTSIZE|THEN|TIMESTAMP|TINYBLOB|TINYINT|TINYTEXT|TO|TOP|TRAN|TRANSACTION|TRANSACTIONS|TRIGGER|TRUNCATE|TSEQUAL|TYPE|TYPES|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNPIVOT|UPDATE|UPDATETEXT|USAGE|USE|USER|USING|VALUE|VALUES|VARBINARY|VARCHAR|VARCHARACTER|VARYING|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH|WITH ROLLUP|WITHIN|WORK|WRITE|WRITETEXT)\\b/gi,\"boolean\":/\\b(?:TRUE|FALSE|NULL)\\b/gi,number:/\\b-?(0x)?\\d*\\.?[\\da-f]+\\b/g,operator:/\\b(?:ALL|AND|ANY|BETWEEN|EXISTS|IN|LIKE|NOT|OR|IS|UNIQUE|CHARACTER SET|COLLATE|DIV|OFFSET|REGEXP|RLIKE|SOUNDS LIKE|XOR)\\b|[-+]{1}|!|[=<>]{1,2}|(&){1,2}|\\|?\\||\\?|\\*|\\//gi,punctuation:/[;[\\]()`,.]/g};;\nPrism.languages.apacheconf={comment:/#.*/g,\"directive-inline\":{pattern:/^\\s*\\b(AcceptFilter|AcceptPathInfo|AccessFileName|Action|AddAlt|AddAltByEncoding|AddAltByType|AddCharset|AddDefaultCharset|AddDescription|AddEncoding|AddHandler|AddIcon|AddIconByEncoding|AddIconByType|AddInputFilter|AddLanguage|AddModuleInfo|AddOutputFilter|AddOutputFilterByType|AddType|Alias|AliasMatch|Allow|AllowCONNECT|AllowEncodedSlashes|AllowMethods|AllowOverride|AllowOverrideList|Anonymous|Anonymous_LogEmail|Anonymous_MustGiveEmail|Anonymous_NoUserID|Anonymous_VerifyEmail|AsyncRequestWorkerFactor|AuthBasicAuthoritative|AuthBasicFake|AuthBasicProvider|AuthBasicUseDigestAlgorithm|AuthDBDUserPWQuery|AuthDBDUserRealmQuery|AuthDBMGroupFile|AuthDBMType|AuthDBMUserFile|AuthDigestAlgorithm|AuthDigestDomain|AuthDigestNonceLifetime|AuthDigestProvider|AuthDigestQop|AuthDigestShmemSize|AuthFormAuthoritative|AuthFormBody|AuthFormDisableNoStore|AuthFormFakeBasicAuth|AuthFormLocation|AuthFormLoginRequiredLocation|AuthFormLoginSuccessLocation|AuthFormLogoutLocation|AuthFormMethod|AuthFormMimetype|AuthFormPassword|AuthFormProvider|AuthFormSitePassphrase|AuthFormSize|AuthFormUsername|AuthGroupFile|AuthLDAPAuthorizePrefix|AuthLDAPBindAuthoritative|AuthLDAPBindDN|AuthLDAPBindPassword|AuthLDAPCharsetConfig|AuthLDAPCompareAsUser|AuthLDAPCompareDNOnServer|AuthLDAPDereferenceAliases|AuthLDAPGroupAttribute|AuthLDAPGroupAttributeIsDN|AuthLDAPInitialBindAsUser|AuthLDAPInitialBindPattern|AuthLDAPMaxSubGroupDepth|AuthLDAPRemoteUserAttribute|AuthLDAPRemoteUserIsDN|AuthLDAPSearchAsUser|AuthLDAPSubGroupAttribute|AuthLDAPSubGroupClass|AuthLDAPUrl|AuthMerging|AuthName|AuthnCacheContext|AuthnCacheEnable|AuthnCacheProvideFor|AuthnCacheSOCache|AuthnCacheTimeout|AuthnzFcgiCheckAuthnProvider|AuthnzFcgiDefineProvider|AuthType|AuthUserFile|AuthzDBDLoginToReferer|AuthzDBDQuery|AuthzDBDRedirectQuery|AuthzDBMType|AuthzSendForbiddenOnFailure|BalancerGrowth|BalancerInherit|BalancerMember|BalancerPersist|BrowserMatch|BrowserMatchNoCase|BufferedLogs|BufferSize|CacheDefaultExpire|CacheDetailHeader|CacheDirLength|CacheDirLevels|CacheDisable|CacheEnable|CacheFile|CacheHeader|CacheIgnoreCacheControl|CacheIgnoreHeaders|CacheIgnoreNoLastMod|CacheIgnoreQueryString|CacheIgnoreURLSessionIdentifiers|CacheKeyBaseURL|CacheLastModifiedFactor|CacheLock|CacheLockMaxAge|CacheLockPath|CacheMaxExpire|CacheMaxFileSize|CacheMinExpire|CacheMinFileSize|CacheNegotiatedDocs|CacheQuickHandler|CacheReadSize|CacheReadTime|CacheRoot|CacheSocache|CacheSocacheMaxSize|CacheSocacheMaxTime|CacheSocacheMinTime|CacheSocacheReadSize|CacheSocacheReadTime|CacheStaleOnError|CacheStoreExpired|CacheStoreNoStore|CacheStorePrivate|CGIDScriptTimeout|CGIMapExtension|CharsetDefault|CharsetOptions|CharsetSourceEnc|CheckCaseOnly|CheckSpelling|ChrootDir|ContentDigest|CookieDomain|CookieExpires|CookieName|CookieStyle|CookieTracking|CoreDumpDirectory|CustomLog|Dav|DavDepthInfinity|DavGenericLockDB|DavLockDB|DavMinTimeout|DBDExptime|DBDInitSQL|DBDKeep|DBDMax|DBDMin|DBDParams|DBDPersist|DBDPrepareSQL|DBDriver|DefaultIcon|DefaultLanguage|DefaultRuntimeDir|DefaultType|Define|DeflateBufferSize|DeflateCompressionLevel|DeflateFilterNote|DeflateInflateLimitRequestBody|DeflateInflateRatioBurst|DeflateInflateRatioLimit|DeflateMemLevel|DeflateWindowSize|Deny|DirectoryCheckHandler|DirectoryIndex|DirectoryIndexRedirect|DirectorySlash|DocumentRoot|DTracePrivileges|DumpIOInput|DumpIOOutput|EnableExceptionHook|EnableMMAP|EnableSendfile|Error|ErrorDocument|ErrorLog|ErrorLogFormat|Example|ExpiresActive|ExpiresByType|ExpiresDefault|ExtendedStatus|ExtFilterDefine|ExtFilterOptions|FallbackResource|FileETag|FilterChain|FilterDeclare|FilterProtocol|FilterProvider|FilterTrace|ForceLanguagePriority|ForceType|ForensicLog|GprofDir|GracefulShutdownTimeout|Group|Header|HeaderName|HeartbeatAddress|HeartbeatListen|HeartbeatMaxServers|HeartbeatStorage|HeartbeatStorage|HostnameLookups|IdentityCheck|IdentityCheckTimeout|ImapBase|ImapDefault|ImapMenu|Include|IncludeOptional|IndexHeadInsert|IndexIgnore|IndexIgnoreReset|IndexOptions|IndexOrderDefault|IndexStyleSheet|InputSed|ISAPIAppendLogToErrors|ISAPIAppendLogToQuery|ISAPICacheFile|ISAPIFakeAsync|ISAPILogNotSupported|ISAPIReadAheadBuffer|KeepAlive|KeepAliveTimeout|KeptBodySize|LanguagePriority|LDAPCacheEntries|LDAPCacheTTL|LDAPConnectionPoolTTL|LDAPConnectionTimeout|LDAPLibraryDebug|LDAPOpCacheEntries|LDAPOpCacheTTL|LDAPReferralHopLimit|LDAPReferrals|LDAPRetries|LDAPRetryDelay|LDAPSharedCacheFile|LDAPSharedCacheSize|LDAPTimeout|LDAPTrustedClientCert|LDAPTrustedGlobalCert|LDAPTrustedMode|LDAPVerifyServerCert|LimitInternalRecursion|LimitRequestBody|LimitRequestFields|LimitRequestFieldSize|LimitRequestLine|LimitXMLRequestBody|Listen|ListenBackLog|LoadFile|LoadModule|LogFormat|LogLevel|LogMessage|LuaAuthzProvider|LuaCodeCache|LuaHookAccessChecker|LuaHookAuthChecker|LuaHookCheckUserID|LuaHookFixups|LuaHookInsertFilter|LuaHookLog|LuaHookMapToStorage|LuaHookTranslateName|LuaHookTypeChecker|LuaInherit|LuaInputFilter|LuaMapHandler|LuaOutputFilter|LuaPackageCPath|LuaPackagePath|LuaQuickHandler|LuaRoot|LuaScope|MaxConnectionsPerChild|MaxKeepAliveRequests|MaxMemFree|MaxRangeOverlaps|MaxRangeReversals|MaxRanges|MaxRequestWorkers|MaxSpareServers|MaxSpareThreads|MaxThreads|MergeTrailers|MetaDir|MetaFiles|MetaSuffix|MimeMagicFile|MinSpareServers|MinSpareThreads|MMapFile|ModemStandard|ModMimeUsePathInfo|MultiviewsMatch|Mutex|NameVirtualHost|NoProxy|NWSSLTrustedCerts|NWSSLUpgradeable|Options|Order|OutputSed|PassEnv|PidFile|PrivilegesMode|Protocol|ProtocolEcho|ProxyAddHeaders|ProxyBadHeader|ProxyBlock|ProxyDomain|ProxyErrorOverride|ProxyExpressDBMFile|ProxyExpressDBMType|ProxyExpressEnable|ProxyFtpDirCharset|ProxyFtpEscapeWildcards|ProxyFtpListOnWildcard|ProxyHTMLBufSize|ProxyHTMLCharsetOut|ProxyHTMLDocType|ProxyHTMLEnable|ProxyHTMLEvents|ProxyHTMLExtended|ProxyHTMLFixups|ProxyHTMLInterp|ProxyHTMLLinks|ProxyHTMLMeta|ProxyHTMLStripComments|ProxyHTMLURLMap|ProxyIOBufferSize|ProxyMaxForwards|ProxyPass|ProxyPassInherit|ProxyPassInterpolateEnv|ProxyPassMatch|ProxyPassReverse|ProxyPassReverseCookieDomain|ProxyPassReverseCookiePath|ProxyPreserveHost|ProxyReceiveBufferSize|ProxyRemote|ProxyRemoteMatch|ProxyRequests|ProxySCGIInternalRedirect|ProxySCGISendfile|ProxySet|ProxySourceAddress|ProxyStatus|ProxyTimeout|ProxyVia|ReadmeName|ReceiveBufferSize|Redirect|RedirectMatch|RedirectPermanent|RedirectTemp|ReflectorHeader|RemoteIPHeader|RemoteIPInternalProxy|RemoteIPInternalProxyList|RemoteIPProxiesHeader|RemoteIPTrustedProxy|RemoteIPTrustedProxyList|RemoveCharset|RemoveEncoding|RemoveHandler|RemoveInputFilter|RemoveLanguage|RemoveOutputFilter|RemoveType|RequestHeader|RequestReadTimeout|Require|RewriteBase|RewriteCond|RewriteEngine|RewriteMap|RewriteOptions|RewriteRule|RLimitCPU|RLimitMEM|RLimitNPROC|Satisfy|ScoreBoardFile|Script|ScriptAlias|ScriptAliasMatch|ScriptInterpreterSource|ScriptLog|ScriptLogBuffer|ScriptLogLength|ScriptSock|SecureListen|SeeRequestTail|SendBufferSize|ServerAdmin|ServerAlias|ServerLimit|ServerName|ServerPath|ServerRoot|ServerSignature|ServerTokens|Session|SessionCookieName|SessionCookieName2|SessionCookieRemove|SessionCryptoCipher|SessionCryptoDriver|SessionCryptoPassphrase|SessionCryptoPassphraseFile|SessionDBDCookieName|SessionDBDCookieName2|SessionDBDCookieRemove|SessionDBDDeleteLabel|SessionDBDInsertLabel|SessionDBDPerUser|SessionDBDSelectLabel|SessionDBDUpdateLabel|SessionEnv|SessionExclude|SessionHeader|SessionInclude|SessionMaxAge|SetEnv|SetEnvIf|SetEnvIfExpr|SetEnvIfNoCase|SetHandler|SetInputFilter|SetOutputFilter|SSIEndTag|SSIErrorMsg|SSIETag|SSILastModified|SSILegacyExprParser|SSIStartTag|SSITimeFormat|SSIUndefinedEcho|SSLCACertificateFile|SSLCACertificatePath|SSLCADNRequestFile|SSLCADNRequestPath|SSLCARevocationCheck|SSLCARevocationFile|SSLCARevocationPath|SSLCertificateChainFile|SSLCertificateFile|SSLCertificateKeyFile|SSLCipherSuite|SSLCompression|SSLCryptoDevice|SSLEngine|SSLFIPS|SSLHonorCipherOrder|SSLInsecureRenegotiation|SSLOCSPDefaultResponder|SSLOCSPEnable|SSLOCSPOverrideResponder|SSLOCSPResponderTimeout|SSLOCSPResponseMaxAge|SSLOCSPResponseTimeSkew|SSLOCSPUseRequestNonce|SSLOpenSSLConfCmd|SSLOptions|SSLPassPhraseDialog|SSLProtocol|SSLProxyCACertificateFile|SSLProxyCACertificatePath|SSLProxyCARevocationCheck|SSLProxyCARevocationFile|SSLProxyCARevocationPath|SSLProxyCheckPeerCN|SSLProxyCheckPeerExpire|SSLProxyCheckPeerName|SSLProxyCipherSuite|SSLProxyEngine|SSLProxyMachineCertificateChainFile|SSLProxyMachineCertificateFile|SSLProxyMachineCertificatePath|SSLProxyProtocol|SSLProxyVerify|SSLProxyVerifyDepth|SSLRandomSeed|SSLRenegBufferSize|SSLRequire|SSLRequireSSL|SSLSessionCache|SSLSessionCacheTimeout|SSLSessionTicketKeyFile|SSLSRPUnknownUserSeed|SSLSRPVerifierFile|SSLStaplingCache|SSLStaplingErrorCacheTimeout|SSLStaplingFakeTryLater|SSLStaplingForceURL|SSLStaplingResponderTimeout|SSLStaplingResponseMaxAge|SSLStaplingResponseTimeSkew|SSLStaplingReturnResponderErrors|SSLStaplingStandardCacheTimeout|SSLStrictSNIVHostCheck|SSLUserName|SSLUseStapling|SSLVerifyClient|SSLVerifyDepth|StartServers|StartThreads|Substitute|Suexec|SuexecUserGroup|ThreadLimit|ThreadsPerChild|ThreadStackSize|TimeOut|TraceEnable|TransferLog|TypesConfig|UnDefine|UndefMacro|UnsetEnv|Use|UseCanonicalName|UseCanonicalPhysicalPort|User|UserDir|VHostCGIMode|VHostCGIPrivs|VHostGroup|VHostPrivs|VHostSecure|VHostUser|VirtualDocumentRoot|VirtualDocumentRootIP|VirtualScriptAlias|VirtualScriptAliasIP|WatchdogInterval|XBitHack|xml2EncAlias|xml2EncDefault|xml2StartParse)\\b/gim,alias:\"property\"},\"directive-block\":{pattern:/<\\/?\\b(AuthnProviderAlias|AuthzProviderAlias|Directory|DirectoryMatch|Else|ElseIf|Files|FilesMatch|If|IfDefine|IfModule|IfVersion|Limit|LimitExcept|Location|LocationMatch|Macro|Proxy|RequireAll|RequireAny|RequireNone|VirtualHost)\\b *.*>/gi,inside:{\"directive-block\":{pattern:/^<\\/?\\w+/,inside:{punctuation:/^<\\/?/},alias:\"tag\"},\"directive-block-parameter\":{pattern:/.*[^>]/,inside:{punctuation:/:/,string:{pattern:/(\"|').*\\1/g,inside:{variable:/(\\$|%)\\{?(\\w\\.?(\\+|\\-|:)?)+\\}?/g}}},alias:\"attr-value\"},punctuation:/>/},alias:\"tag\"},\"directive-flags\":{pattern:/\\[(\\w,?)+\\]/g,alias:\"keyword\"},string:{pattern:/(\"|').*\\1/g,inside:{variable:/(\\$|%)\\{?(\\w\\.?(\\+|\\-|:)?)+\\}?/g}},variable:/(\\$|%)\\{?(\\w\\.?(\\+|\\-|:)?)+\\}?/g,regex:/\\^?.*\\$|\\^.*\\$?/g};;\nPrism.languages.git={comment:/^#.*$/m,string:/(\"|')(\\\\?.)*?\\1/gm,command:{pattern:/^.*\\$ git .*$/m,inside:{parameter:/\\s(--|-)\\w+/m}},coord:/^@@.*@@$/m,deleted:/^-(?!-).+$/m,inserted:/^\\+(?!\\+).+$/m,commit_sha1:/^commit \\w{40}$/m};;\n!function(e){var a=/\\{\\{\\{[\\w\\W]+?\\}\\}\\}|\\{\\{[\\w\\W]+?\\}\\}/g;e.languages.handlebars=e.languages.extend(\"markup\",{handlebars:{pattern:a,inside:{delimiter:{pattern:/^\\{\\{\\{?|\\}\\}\\}?$/gi,alias:\"punctuation\"},string:/([\"'])(\\\\?.)+?\\1/g,number:/\\b-?(0x[\\dA-Fa-f]+|\\d*\\.?\\d+([Ee]-?\\d+)?)\\b/g,\"boolean\":/\\b(true|false)\\b/g,block:{pattern:/^(\\s*~?\\s*)[#\\/]\\w+/gi,lookbehind:!0,alias:\"keyword\"},brackets:{pattern:/\\[[^\\]]+\\]/,inside:{punctuation:/\\[|\\]/g,variable:/[\\w\\W]+/g}},punctuation:/[!\"#%&'()*+,.\\/;<=>@\\[\\\\\\]^`{|}~]/g,variable:/[^!\"#%&'()*+,.\\/;<=>@\\[\\\\\\]^`{|}~]+/g}}}),e.languages.insertBefore(\"handlebars\",\"tag\",{\"handlebars-comment\":{pattern:/\\{\\{![\\w\\W]*?\\}\\}/g,alias:[\"handlebars\",\"comment\"]}}),e.hooks.add(\"before-highlight\",function(e){\"handlebars\"===e.language&&(e.tokenStack=[],e.backupCode=e.code,e.code=e.code.replace(a,function(a){return e.tokenStack.push(a),\"___HANDLEBARS\"+e.tokenStack.length+\"___\"}))}),e.hooks.add(\"before-insert\",function(e){\"handlebars\"===e.language&&(e.code=e.backupCode,delete e.backupCode)}),e.hooks.add(\"after-highlight\",function(a){if(\"handlebars\"===a.language){for(var n,t=0;n=a.tokenStack[t];t++)a.highlightedCode=a.highlightedCode.replace(\"___HANDLEBARS\"+(t+1)+\"___\",e.highlight(n,a.grammar,\"handlebars\"));a.element.innerHTML=a.highlightedCode}})}(Prism);;\nPrism.hooks.add(\"after-highlight\",function(e){var n=e.element.parentNode;if(n&&/pre/i.test(n.nodeName)&&-1!==n.className.indexOf(\"line-numbers\")){var t,a=1+e.code.split(\"\\n\").length;lines=new Array(a),lines=lines.join(\"<span></span>\"),t=document.createElement(\"span\"),t.className=\"line-numbers-rows\",t.innerHTML=lines,n.hasAttribute(\"data-start\")&&(n.style.counterReset=\"linenumber \"+(parseInt(n.getAttribute(\"data-start\"),10)-1)),e.element.appendChild(t)}});;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9yZXNvdXJjZXMvYXNzZXRzL2pzL3ZlbmRvci9wcmlzbS5qcz82MTA1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGh0dHA6Ly9wcmlzbWpzLmNvbS9kb3dubG9hZC5odG1sP3RoZW1lcz1wcmlzbSZsYW5ndWFnZXM9bWFya3VwK3R3aWcrY3NzK2NsaWtlK2phdmFzY3JpcHQrcGhwK3BocC1leHRyYXMrc2NzcytiYXNoK3NxbCthcGFjaGVjb25mK2dpdCtoYW5kbGViYXJzJnBsdWdpbnM9bGluZS1udW1iZXJzICovXG5zZWxmPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSYmc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlP3NlbGY6e307dmFyIFByaXNtPWZ1bmN0aW9uKCl7dmFyIGU9L1xcYmxhbmcoPzp1YWdlKT8tKD8hXFwqKShcXHcrKVxcYi9pLHQ9c2VsZi5QcmlzbT17dXRpbDp7ZW5jb2RlOmZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2Ygbj9uZXcgbihlLnR5cGUsdC51dGlsLmVuY29kZShlLmNvbnRlbnQpLGUuYWxpYXMpOlwiQXJyYXlcIj09PXQudXRpbC50eXBlKGUpP2UubWFwKHQudXRpbC5lbmNvZGUpOmUucmVwbGFjZSgvJi9nLFwiJmFtcDtcIikucmVwbGFjZSgvPC9nLFwiJmx0O1wiKS5yZXBsYWNlKC9cXHUwMGEwL2csXCIgXCIpfSx0eXBlOmZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkubWF0Y2goL1xcW29iamVjdCAoXFx3KylcXF0vKVsxXX0sY2xvbmU6ZnVuY3Rpb24oZSl7dmFyIG49dC51dGlsLnR5cGUoZSk7c3dpdGNoKG4pe2Nhc2VcIk9iamVjdFwiOnZhciBhPXt9O2Zvcih2YXIgciBpbiBlKWUuaGFzT3duUHJvcGVydHkocikmJihhW3JdPXQudXRpbC5jbG9uZShlW3JdKSk7cmV0dXJuIGE7Y2FzZVwiQXJyYXlcIjpyZXR1cm4gZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHQudXRpbC5jbG9uZShlKX0pfXJldHVybiBlfX0sbGFuZ3VhZ2VzOntleHRlbmQ6ZnVuY3Rpb24oZSxuKXt2YXIgYT10LnV0aWwuY2xvbmUodC5sYW5ndWFnZXNbZV0pO2Zvcih2YXIgciBpbiBuKWFbcl09bltyXTtyZXR1cm4gYX0saW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKGUsbixhLHIpe3I9cnx8dC5sYW5ndWFnZXM7dmFyIGk9cltlXTtpZigyPT1hcmd1bWVudHMubGVuZ3RoKXthPWFyZ3VtZW50c1sxXTtmb3IodmFyIGwgaW4gYSlhLmhhc093blByb3BlcnR5KGwpJiYoaVtsXT1hW2xdKTtyZXR1cm4gaX12YXIgbz17fTtmb3IodmFyIHMgaW4gaSlpZihpLmhhc093blByb3BlcnR5KHMpKXtpZihzPT1uKWZvcih2YXIgbCBpbiBhKWEuaGFzT3duUHJvcGVydHkobCkmJihvW2xdPWFbbF0pO29bc109aVtzXX1yZXR1cm4gdC5sYW5ndWFnZXMuREZTKHQubGFuZ3VhZ2VzLGZ1bmN0aW9uKHQsbil7bj09PXJbZV0mJnQhPWUmJih0aGlzW3RdPW8pfSkscltlXT1vfSxERlM6ZnVuY3Rpb24oZSxuLGEpe2Zvcih2YXIgciBpbiBlKWUuaGFzT3duUHJvcGVydHkocikmJihuLmNhbGwoZSxyLGVbcl0sYXx8ciksXCJPYmplY3RcIj09PXQudXRpbC50eXBlKGVbcl0pP3QubGFuZ3VhZ2VzLkRGUyhlW3JdLG4pOlwiQXJyYXlcIj09PXQudXRpbC50eXBlKGVbcl0pJiZ0Lmxhbmd1YWdlcy5ERlMoZVtyXSxuLHIpKX19LGhpZ2hsaWdodEFsbDpmdW5jdGlvbihlLG4pe2Zvcih2YXIgYSxyPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3ByZSBjb2RlJyksaT0wO2E9cltpKytdOyl0LmhpZ2hsaWdodEVsZW1lbnQoYSxlPT09ITAsbil9LGhpZ2hsaWdodEVsZW1lbnQ6ZnVuY3Rpb24oYSxyLGkpe2Zvcih2YXIgbCxvLHM9YTtzJiYhZS50ZXN0KHMuY2xhc3NOYW1lKTspcz1zLnBhcmVudE5vZGU7aWYocyYmKGw9KHMuY2xhc3NOYW1lLm1hdGNoKGUpfHxbLFwiXCJdKVsxXSxvPXQubGFuZ3VhZ2VzW2xdKSxvKXthLmNsYXNzTmFtZT1hLmNsYXNzTmFtZS5yZXBsYWNlKGUsXCJcIikucmVwbGFjZSgvXFxzKy9nLFwiIFwiKStcIiBsYW5ndWFnZS1cIitsLHM9YS5wYXJlbnROb2RlLC9wcmUvaS50ZXN0KHMubm9kZU5hbWUpJiYocy5jbGFzc05hbWU9cy5jbGFzc05hbWUucmVwbGFjZShlLFwiXCIpLnJlcGxhY2UoL1xccysvZyxcIiBcIikrXCIgbGFuZ3VhZ2UtXCIrbCk7dmFyIGc9YS50ZXh0Q29udGVudDtpZihnKXtnPWcucmVwbGFjZSgvXig/Olxccj9cXG58XFxyKS8sXCJcIik7dmFyIHU9e2VsZW1lbnQ6YSxsYW5ndWFnZTpsLGdyYW1tYXI6byxjb2RlOmd9O2lmKHQuaG9va3MucnVuKFwiYmVmb3JlLWhpZ2hsaWdodFwiLHUpLHImJnNlbGYuV29ya2VyKXt2YXIgYz1uZXcgV29ya2VyKHQuZmlsZW5hbWUpO2Mub25tZXNzYWdlPWZ1bmN0aW9uKGUpe3UuaGlnaGxpZ2h0ZWRDb2RlPW4uc3RyaW5naWZ5KEpTT04ucGFyc2UoZS5kYXRhKSxsKSx0Lmhvb2tzLnJ1bihcImJlZm9yZS1pbnNlcnRcIix1KSx1LmVsZW1lbnQuaW5uZXJIVE1MPXUuaGlnaGxpZ2h0ZWRDb2RlLGkmJmkuY2FsbCh1LmVsZW1lbnQpLHQuaG9va3MucnVuKFwiYWZ0ZXItaGlnaGxpZ2h0XCIsdSl9LGMucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe2xhbmd1YWdlOnUubGFuZ3VhZ2UsY29kZTp1LmNvZGV9KSl9ZWxzZSB1LmhpZ2hsaWdodGVkQ29kZT10LmhpZ2hsaWdodCh1LmNvZGUsdS5ncmFtbWFyLHUubGFuZ3VhZ2UpLHQuaG9va3MucnVuKFwiYmVmb3JlLWluc2VydFwiLHUpLHUuZWxlbWVudC5pbm5lckhUTUw9dS5oaWdobGlnaHRlZENvZGUsaSYmaS5jYWxsKGEpLHQuaG9va3MucnVuKFwiYWZ0ZXItaGlnaGxpZ2h0XCIsdSl9fX0saGlnaGxpZ2h0OmZ1bmN0aW9uKGUsYSxyKXt2YXIgaT10LnRva2VuaXplKGUsYSk7cmV0dXJuIG4uc3RyaW5naWZ5KHQudXRpbC5lbmNvZGUoaSkscil9LHRva2VuaXplOmZ1bmN0aW9uKGUsbil7dmFyIGE9dC5Ub2tlbixyPVtlXSxpPW4ucmVzdDtpZihpKXtmb3IodmFyIGwgaW4gaSluW2xdPWlbbF07ZGVsZXRlIG4ucmVzdH1lOmZvcih2YXIgbCBpbiBuKWlmKG4uaGFzT3duUHJvcGVydHkobCkmJm5bbF0pe3ZhciBvPW5bbF07bz1cIkFycmF5XCI9PT10LnV0aWwudHlwZShvKT9vOltvXTtmb3IodmFyIHM9MDtzPG8ubGVuZ3RoOysrcyl7dmFyIGc9b1tzXSx1PWcuaW5zaWRlLGM9ISFnLmxvb2tiZWhpbmQsZj0wLGg9Zy5hbGlhcztnPWcucGF0dGVybnx8Zztmb3IodmFyIHA9MDtwPHIubGVuZ3RoO3ArKyl7dmFyIGQ9cltwXTtpZihyLmxlbmd0aD5lLmxlbmd0aClicmVhayBlO2lmKCEoZCBpbnN0YW5jZW9mIGEpKXtnLmxhc3RJbmRleD0wO3ZhciBtPWcuZXhlYyhkKTtpZihtKXtjJiYoZj1tWzFdLmxlbmd0aCk7dmFyIHk9bS5pbmRleC0xK2YsbT1tWzBdLnNsaWNlKGYpLHY9bS5sZW5ndGgsaz15K3YsYj1kLnNsaWNlKDAseSsxKSx3PWQuc2xpY2UoaysxKSxPPVtwLDFdO2ImJk8ucHVzaChiKTt2YXIgTj1uZXcgYShsLHU/dC50b2tlbml6ZShtLHUpOm0saCk7Ty5wdXNoKE4pLHcmJk8ucHVzaCh3KSxBcnJheS5wcm90b3R5cGUuc3BsaWNlLmFwcGx5KHIsTyl9fX19fXJldHVybiByfSxob29rczp7YWxsOnt9LGFkZDpmdW5jdGlvbihlLG4pe3ZhciBhPXQuaG9va3MuYWxsO2FbZV09YVtlXXx8W10sYVtlXS5wdXNoKG4pfSxydW46ZnVuY3Rpb24oZSxuKXt2YXIgYT10Lmhvb2tzLmFsbFtlXTtpZihhJiZhLmxlbmd0aClmb3IodmFyIHIsaT0wO3I9YVtpKytdOylyKG4pfX19LG49dC5Ub2tlbj1mdW5jdGlvbihlLHQsbil7dGhpcy50eXBlPWUsdGhpcy5jb250ZW50PXQsdGhpcy5hbGlhcz1ufTtpZihuLnN0cmluZ2lmeT1mdW5jdGlvbihlLGEscil7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpcmV0dXJuIGU7aWYoXCJbb2JqZWN0IEFycmF5XVwiPT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkpcmV0dXJuIGUubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBuLnN0cmluZ2lmeSh0LGEsZSl9KS5qb2luKFwiXCIpO3ZhciBpPXt0eXBlOmUudHlwZSxjb250ZW50Om4uc3RyaW5naWZ5KGUuY29udGVudCxhLHIpLHRhZzpcInNwYW5cIixjbGFzc2VzOltcInRva2VuXCIsZS50eXBlXSxhdHRyaWJ1dGVzOnt9LGxhbmd1YWdlOmEscGFyZW50OnJ9O2lmKFwiY29tbWVudFwiPT1pLnR5cGUmJihpLmF0dHJpYnV0ZXMuc3BlbGxjaGVjaz1cInRydWVcIiksZS5hbGlhcyl7dmFyIGw9XCJBcnJheVwiPT09dC51dGlsLnR5cGUoZS5hbGlhcyk/ZS5hbGlhczpbZS5hbGlhc107QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoaS5jbGFzc2VzLGwpfXQuaG9va3MucnVuKFwid3JhcFwiLGkpO3ZhciBvPVwiXCI7Zm9yKHZhciBzIGluIGkuYXR0cmlidXRlcylvKz1zKyc9XCInKyhpLmF0dHJpYnV0ZXNbc118fFwiXCIpKydcIic7cmV0dXJuXCI8XCIraS50YWcrJyBjbGFzcz1cIicraS5jbGFzc2VzLmpvaW4oXCIgXCIpKydcIiAnK28rXCI+XCIraS5jb250ZW50K1wiPC9cIitpLnRhZytcIj5cIn0sIXNlbGYuZG9jdW1lbnQpcmV0dXJuIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcj8oc2VsZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLGZ1bmN0aW9uKGUpe3ZhciBuPUpTT04ucGFyc2UoZS5kYXRhKSxhPW4ubGFuZ3VhZ2Uscj1uLmNvZGU7c2VsZi5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeSh0LnV0aWwuZW5jb2RlKHQudG9rZW5pemUocix0Lmxhbmd1YWdlc1thXSkpKSksc2VsZi5jbG9zZSgpfSwhMSksc2VsZi5QcmlzbSk6c2VsZi5QcmlzbTt2YXIgYT1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtyZXR1cm4gYT1hW2EubGVuZ3RoLTFdLGEmJih0LmZpbGVuYW1lPWEuc3JjLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXImJiFhLmhhc0F0dHJpYnV0ZShcImRhdGEtbWFudWFsXCIpJiZkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLHQuaGlnaGxpZ2h0QWxsKSksc2VsZi5QcmlzbX0oKTtcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cyYmKG1vZHVsZS5leHBvcnRzPVByaXNtKTs7XG5QcmlzbS5sYW5ndWFnZXMubWFya3VwPXtjb21tZW50Oi88IS0tW1xcd1xcV10qPy0tPi9nLHByb2xvZzovPFxcPy4rP1xcPz4vLGRvY3R5cGU6LzwhRE9DVFlQRS4rPz4vLGNkYXRhOi88IVxcW0NEQVRBXFxbW1xcd1xcV10qP11dPi9pLHRhZzp7cGF0dGVybjovPFxcLz9bXFx3Oi1dK1xccyooPzpcXHMrW1xcdzotXSsoPzo9KD86KFwifCcpKFxcXFw/W1xcd1xcV10pKj9cXDF8W15cXHMnXCI+PV0rKSk/XFxzKikqXFwvPz4vZ2ksaW5zaWRlOnt0YWc6e3BhdHRlcm46L148XFwvP1tcXHc6LV0rL2ksaW5zaWRlOntwdW5jdHVhdGlvbjovXjxcXC8/LyxuYW1lc3BhY2U6L15bXFx3LV0rPzovfX0sXCJhdHRyLXZhbHVlXCI6e3BhdHRlcm46Lz0oPzooJ3xcIilbXFx3XFxXXSo/KFxcMSl8W15cXHM+XSspL2dpLGluc2lkZTp7cHVuY3R1YXRpb246Lz18PnxcIi9nfX0scHVuY3R1YXRpb246L1xcLz8+L2csXCJhdHRyLW5hbWVcIjp7cGF0dGVybjovW1xcdzotXSsvZyxpbnNpZGU6e25hbWVzcGFjZTovXltcXHctXSs/Oi99fX19LGVudGl0eTovJiM/W1xcZGEtel17MSw4fTsvZ2l9LFByaXNtLmhvb2tzLmFkZChcIndyYXBcIixmdW5jdGlvbih0KXtcImVudGl0eVwiPT09dC50eXBlJiYodC5hdHRyaWJ1dGVzLnRpdGxlPXQuY29udGVudC5yZXBsYWNlKC8mYW1wOy8sXCImXCIpKX0pOztcblByaXNtLmxhbmd1YWdlcy50d2lnPXtjb21tZW50Oi9cXHsjW1xcc1xcU10qPyNcXH0vZyx0YWc6e3BhdHRlcm46LyhcXHtcXHtbXFxzXFxTXSo/XFx9XFx9fFxceyVbXFxzXFxTXSo/JVxcfSkvZyxpbnNpZGU6e2xkOntwYXR0ZXJuOi9eKFxce1xce1xcLT98XFx7JVxcLT9cXHMqXFx3KykvLGluc2lkZTp7cHVuY3R1YXRpb246L14oXFx7XFx7fFxceyUpXFwtPy8sa2V5d29yZDovXFx3Ky99fSxyZDp7cGF0dGVybjovXFwtPyglXFx9fFxcfVxcfSkkLyxpbnNpZGU6e3B1bmN0dWF0aW9uOi8uKi99fSxzdHJpbmc6e3BhdHRlcm46LyhcInwnKShcXFxcPy4pKj9cXDEvZyxpbnNpZGU6e3B1bmN0dWF0aW9uOi9eKCd8XCIpfCgnfFwiKSQvZ319LGtleXdvcmQ6L1xcYihpZilcXGIvZyxcImJvb2xlYW5cIjovXFxiKHRydWV8ZmFsc2V8bnVsbClcXGIvZyxudW1iZXI6L1xcYi0/KDB4W1xcZEEtRmEtZl0rfFxcZCpcXC4/XFxkKyhbRWVdLT9cXGQrKT8pXFxiL2csb3BlcmF0b3I6Lz09fD18IT18PHw+fD49fDw9fFxcK3xcXC18fnxcXCp8XFwvfFxcL1xcL3wlfFxcKlxcKnxcXHwvZyxcInNwYWNlLW9wZXJhdG9yXCI6e3BhdHRlcm46LyhcXHMpKFxcYihub3R8YlxcLWFuZHxiXFwteG9yfGJcXC1vcnxhbmR8b3J8aW58bWF0Y2hlc3xzdGFydHMgd2l0aHxlbmRzIHdpdGh8aXMpXFxifFxcP3w6fFxcPzopKD89XFxzKS9nLGxvb2tiZWhpbmQ6ITAsaW5zaWRlOntvcGVyYXRvcjovLiovfX0scHJvcGVydHk6L1xcYlthLXpBLVpfXVthLXpBLVowLTlfXSpcXGIvZyxwdW5jdHVhdGlvbjovXFwofFxcKXxcXFtcXF18XFxbfFxcXXxcXHt8XFx9fDp8XFwufCwvZ319LG90aGVyOntwYXR0ZXJuOi9bXFxzXFxTXSovLGluc2lkZTpQcmlzbS5sYW5ndWFnZXMubWFya3VwfX07O1xuUHJpc20ubGFuZ3VhZ2VzLmNzcz17Y29tbWVudDovXFwvXFwqW1xcd1xcV10qP1xcKlxcLy9nLGF0cnVsZTp7cGF0dGVybjovQFtcXHctXSs/Lio/KDt8KD89XFxzKlxceykpL2dpLGluc2lkZTp7cHVuY3R1YXRpb246L1s7Ol0vZ319LHVybDovdXJsXFwoKD86KFtcIiddKShcXFxcXFxufFxcXFw/LikqP1xcMXwuKj8pXFwpL2dpLHNlbGVjdG9yOi9bXlxce1xcfVxcc11bXlxce1xcfTtdKig/PVxccypcXHspL2csc3RyaW5nOi8oXCJ8JykoXFxcXFxcbnxcXFxcPy4pKj9cXDEvZyxwcm9wZXJ0eTovKFxcYnxcXEIpW1xcdy1dKyg/PVxccyo6KS9naSxpbXBvcnRhbnQ6L1xcQiFpbXBvcnRhbnRcXGIvZ2kscHVuY3R1YXRpb246L1tcXHtcXH07Ol0vZyxcImZ1bmN0aW9uXCI6L1stYS16MC05XSsoPz1cXCgpL2dpfSxQcmlzbS5sYW5ndWFnZXMubWFya3VwJiYoUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZShcIm1hcmt1cFwiLFwidGFnXCIse3N0eWxlOntwYXR0ZXJuOi88c3R5bGVbXFx3XFxXXSo/PltcXHdcXFddKj88XFwvc3R5bGU+L2dpLGluc2lkZTp7dGFnOntwYXR0ZXJuOi88c3R5bGVbXFx3XFxXXSo/Pnw8XFwvc3R5bGU+L2dpLGluc2lkZTpQcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZy5pbnNpZGV9LHJlc3Q6UHJpc20ubGFuZ3VhZ2VzLmNzc30sYWxpYXM6XCJsYW5ndWFnZS1jc3NcIn19KSxQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKFwiaW5zaWRlXCIsXCJhdHRyLXZhbHVlXCIse1wic3R5bGUtYXR0clwiOntwYXR0ZXJuOi9cXHMqc3R5bGU9KFwifCcpLis/XFwxL2dpLGluc2lkZTp7XCJhdHRyLW5hbWVcIjp7cGF0dGVybjovXlxccypzdHlsZS9naSxpbnNpZGU6UHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuaW5zaWRlfSxwdW5jdHVhdGlvbjovXlxccyo9XFxzKlsnXCJdfFsnXCJdXFxzKiQvLFwiYXR0ci12YWx1ZVwiOntwYXR0ZXJuOi8uKy9naSxpbnNpZGU6UHJpc20ubGFuZ3VhZ2VzLmNzc319LGFsaWFzOlwibGFuZ3VhZ2UtY3NzXCJ9fSxQcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZykpOztcblByaXNtLmxhbmd1YWdlcy5jbGlrZT17Y29tbWVudDpbe3BhdHRlcm46LyhefFteXFxcXF0pXFwvXFwqW1xcd1xcV10qP1xcKlxcLy9nLGxvb2tiZWhpbmQ6ITB9LHtwYXR0ZXJuOi8oXnxbXlxcXFw6XSlcXC9cXC8uKj8oXFxyP1xcbnwkKS9nLGxvb2tiZWhpbmQ6ITB9XSxzdHJpbmc6LyhcInwnKShcXFxcXFxufFxcXFw/LikqP1xcMS9nLFwiY2xhc3MtbmFtZVwiOntwYXR0ZXJuOi8oKD86KD86Y2xhc3N8aW50ZXJmYWNlfGV4dGVuZHN8aW1wbGVtZW50c3x0cmFpdHxpbnN0YW5jZW9mfG5ldylcXHMrKXwoPzpjYXRjaFxccytcXCgpKVthLXowLTlfXFwuXFxcXF0rL2dpLGxvb2tiZWhpbmQ6ITAsaW5zaWRlOntwdW5jdHVhdGlvbjovKFxcLnxcXFxcKS99fSxrZXl3b3JkOi9cXGIoaWZ8ZWxzZXx3aGlsZXxkb3xmb3J8cmV0dXJufGlufGluc3RhbmNlb2Z8ZnVuY3Rpb258bmV3fHRyeXx0aHJvd3xjYXRjaHxmaW5hbGx5fG51bGx8YnJlYWt8Y29udGludWUpXFxiL2csXCJib29sZWFuXCI6L1xcYih0cnVlfGZhbHNlKVxcYi9nLFwiZnVuY3Rpb25cIjp7cGF0dGVybjovW2EtejAtOV9dK1xcKC9naSxpbnNpZGU6e3B1bmN0dWF0aW9uOi9cXCgvfX0sbnVtYmVyOi9cXGItPygweFtcXGRBLUZhLWZdK3xcXGQqXFwuP1xcZCsoW0VlXS0/XFxkKyk/KVxcYi9nLG9wZXJhdG9yOi9bLStdezEsMn18IXw8PT98Pj0/fD17MSwzfXwmezEsMn18XFx8P1xcfHxcXD98XFwqfFxcL3x+fFxcXnwlL2csaWdub3JlOi8mKGx0fGd0fGFtcCk7L2dpLHB1bmN0dWF0aW9uOi9be31bXFxdOygpLC46XS9nfTs7XG5QcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdD1QcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKFwiY2xpa2VcIix7a2V5d29yZDovXFxiKGJyZWFrfGNhc2V8Y2F0Y2h8Y2xhc3N8Y29uc3R8Y29udGludWV8ZGVidWdnZXJ8ZGVmYXVsdHxkZWxldGV8ZG98ZWxzZXxlbnVtfGV4cG9ydHxleHRlbmRzfGZhbHNlfGZpbmFsbHl8Zm9yfGZ1bmN0aW9ufGdldHxpZnxpbXBsZW1lbnRzfGltcG9ydHxpbnxpbnN0YW5jZW9mfGludGVyZmFjZXxsZXR8bmV3fG51bGx8cGFja2FnZXxwcml2YXRlfHByb3RlY3RlZHxwdWJsaWN8cmV0dXJufHNldHxzdGF0aWN8c3VwZXJ8c3dpdGNofHRoaXN8dGhyb3d8dHJ1ZXx0cnl8dHlwZW9mfHZhcnx2b2lkfHdoaWxlfHdpdGh8eWllbGQpXFxiL2csbnVtYmVyOi9cXGItPygweFtcXGRBLUZhLWZdK3xcXGQqXFwuP1xcZCsoW0VlXVsrLV0/XFxkKyk/fE5hTnwtP0luZmluaXR5KVxcYi9nLFwiZnVuY3Rpb25cIjovKD8hXFxkKVthLXowLTlfJF0rKD89XFwoKS9naX0pLFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoXCJqYXZhc2NyaXB0XCIsXCJrZXl3b3JkXCIse3JlZ2V4OntwYXR0ZXJuOi8oXnxbXi9dKVxcLyg/IVxcLykoXFxbLis/XXxcXFxcLnxbXi9cXHJcXG5dKStcXC9bZ2ltXXswLDN9KD89XFxzKigkfFtcXHJcXG4sLjt9KV0pKS9nLGxvb2tiZWhpbmQ6ITB9fSksUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cCYmUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZShcIm1hcmt1cFwiLFwidGFnXCIse3NjcmlwdDp7cGF0dGVybjovPHNjcmlwdFtcXHdcXFddKj8+W1xcd1xcV10qPzxcXC9zY3JpcHQ+L2dpLGluc2lkZTp7dGFnOntwYXR0ZXJuOi88c2NyaXB0W1xcd1xcV10qPz58PFxcL3NjcmlwdD4vZ2ksaW5zaWRlOlByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLmluc2lkZX0scmVzdDpQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdH0sYWxpYXM6XCJsYW5ndWFnZS1qYXZhc2NyaXB0XCJ9fSk7O1xuUHJpc20ubGFuZ3VhZ2VzLnBocD1QcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKFwiY2xpa2VcIix7a2V5d29yZDovXFxiKGFuZHxvcnx4b3J8YXJyYXl8YXN8YnJlYWt8Y2FzZXxjZnVuY3Rpb258Y2xhc3N8Y29uc3R8Y29udGludWV8ZGVjbGFyZXxkZWZhdWx0fGRpZXxkb3xlbHNlfGVsc2VpZnxlbmRkZWNsYXJlfGVuZGZvcnxlbmRmb3JlYWNofGVuZGlmfGVuZHN3aXRjaHxlbmR3aGlsZXxleHRlbmRzfGZvcnxmb3JlYWNofGZ1bmN0aW9ufGluY2x1ZGV8aW5jbHVkZV9vbmNlfGdsb2JhbHxpZnxuZXd8cmV0dXJufHN0YXRpY3xzd2l0Y2h8dXNlfHJlcXVpcmV8cmVxdWlyZV9vbmNlfHZhcnx3aGlsZXxhYnN0cmFjdHxpbnRlcmZhY2V8cHVibGljfGltcGxlbWVudHN8cHJpdmF0ZXxwcm90ZWN0ZWR8cGFyZW50fHRocm93fG51bGx8ZWNob3xwcmludHx0cmFpdHxuYW1lc3BhY2V8ZmluYWx8eWllbGR8Z290b3xpbnN0YW5jZW9mfGZpbmFsbHl8dHJ5fGNhdGNoKVxcYi9naSxjb25zdGFudDovXFxiW0EtWjAtOV9dezIsfVxcYi9nLGNvbW1lbnQ6e3BhdHRlcm46LyhefFteXFxcXF0pKFxcL1xcKltcXHdcXFddKj9cXCpcXC98KF58W146XSkoXFwvXFwvfCMpLio/KFxccj9cXG58JCkpL2csbG9va2JlaGluZDohMH19KSxQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKFwicGhwXCIsXCJrZXl3b3JkXCIse2RlbGltaXRlcjovKFxcPz58PFxcP3BocHw8XFw/KS9naSx2YXJpYWJsZTovKFxcJFxcdyspXFxiL2dpLFwicGFja2FnZVwiOntwYXR0ZXJuOi8oXFxcXHxuYW1lc3BhY2VcXHMrfHVzZVxccyspW1xcd1xcXFxdKy9nLGxvb2tiZWhpbmQ6ITAsaW5zaWRlOntwdW5jdHVhdGlvbjovXFxcXC99fX0pLFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoXCJwaHBcIixcIm9wZXJhdG9yXCIse3Byb3BlcnR5OntwYXR0ZXJuOi8oLT4pW1xcd10rL2csbG9va2JlaGluZDohMH19KSxQcmlzbS5sYW5ndWFnZXMubWFya3VwJiYoUHJpc20uaG9va3MuYWRkKFwiYmVmb3JlLWhpZ2hsaWdodFwiLGZ1bmN0aW9uKGUpe1wicGhwXCI9PT1lLmxhbmd1YWdlJiYoZS50b2tlblN0YWNrPVtdLGUuYmFja3VwQ29kZT1lLmNvZGUsZS5jb2RlPWUuY29kZS5yZXBsYWNlKC8oPzo8XFw/cGhwfDxcXD8pW1xcd1xcV10qPyg/OlxcPz4pL2dpLGZ1bmN0aW9uKG4pe3JldHVybiBlLnRva2VuU3RhY2sucHVzaChuKSxcInt7e1BIUFwiK2UudG9rZW5TdGFjay5sZW5ndGgrXCJ9fX1cIn0pKX0pLFByaXNtLmhvb2tzLmFkZChcImJlZm9yZS1pbnNlcnRcIixmdW5jdGlvbihlKXtcInBocFwiPT09ZS5sYW5ndWFnZSYmKGUuY29kZT1lLmJhY2t1cENvZGUsZGVsZXRlIGUuYmFja3VwQ29kZSl9KSxQcmlzbS5ob29rcy5hZGQoXCJhZnRlci1oaWdobGlnaHRcIixmdW5jdGlvbihlKXtpZihcInBocFwiPT09ZS5sYW5ndWFnZSl7Zm9yKHZhciBuLGE9MDtuPWUudG9rZW5TdGFja1thXTthKyspZS5oaWdobGlnaHRlZENvZGU9ZS5oaWdobGlnaHRlZENvZGUucmVwbGFjZShcInt7e1BIUFwiKyhhKzEpK1wifX19XCIsUHJpc20uaGlnaGxpZ2h0KG4sZS5ncmFtbWFyLFwicGhwXCIpKTtlLmVsZW1lbnQuaW5uZXJIVE1MPWUuaGlnaGxpZ2h0ZWRDb2RlfX0pLFByaXNtLmhvb2tzLmFkZChcIndyYXBcIixmdW5jdGlvbihlKXtcInBocFwiPT09ZS5sYW5ndWFnZSYmXCJtYXJrdXBcIj09PWUudHlwZSYmKGUuY29udGVudD1lLmNvbnRlbnQucmVwbGFjZSgvKFxce1xce1xce1BIUFswLTldK1xcfVxcfVxcfSkvZywnPHNwYW4gY2xhc3M9XCJ0b2tlbiBwaHBcIj4kMTwvc3Bhbj4nKSl9KSxQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKFwicGhwXCIsXCJjb21tZW50XCIse21hcmt1cDp7cGF0dGVybjovPFteP11cXC8/KC4qPyk+L2csaW5zaWRlOlByaXNtLmxhbmd1YWdlcy5tYXJrdXB9LHBocDovXFx7XFx7XFx7UEhQWzAtOV0rXFx9XFx9XFx9L2d9KSk7O1xuUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZShcInBocFwiLFwidmFyaWFibGVcIix7XCJ0aGlzXCI6L1xcJHRoaXMvZyxnbG9iYWw6L1xcJF8/KEdMT0JBTFN8U0VSVkVSfEdFVHxQT1NUfEZJTEVTfFJFUVVFU1R8U0VTU0lPTnxFTlZ8Q09PS0lFfEhUVFBfUkFXX1BPU1RfREFUQXxhcmdjfGFyZ3Z8cGhwX2Vycm9ybXNnfGh0dHBfcmVzcG9uc2VfaGVhZGVyKS9nLHNjb3BlOntwYXR0ZXJuOi9cXGJbXFx3XFxcXF0rOjovZyxpbnNpZGU6e2tleXdvcmQ6LyhzdGF0aWN8c2VsZnxwYXJlbnQpLyxwdW5jdHVhdGlvbjovKDo6fFxcXFwpL319fSk7O1xuUHJpc20ubGFuZ3VhZ2VzLnNjc3M9UHJpc20ubGFuZ3VhZ2VzLmV4dGVuZChcImNzc1wiLHtjb21tZW50OntwYXR0ZXJuOi8oXnxbXlxcXFxdKShcXC9cXCpbXFx3XFxXXSo/XFwqXFwvfFxcL1xcLy4qPyhcXHI/XFxufCQpKS9nLGxvb2tiZWhpbmQ6ITB9LGF0cnVsZTovQFtcXHctXSsoPz1cXHMrKFxcKHxcXHt8OykpL2dpLHVybDovKFstYS16XSstKSp1cmwoPz1cXCgpL2dpLHNlbGVjdG9yOi8oW15AO1xce1xcfVxcKFxcKV0/KFteQDtcXHtcXH1cXChcXCldfCZ8I1xce1xcJFstX1xcd10rXFx9KSspKD89XFxzKlxceyhcXH18XFxzfFteXFx9XSsoOnxcXHspW15cXH1dKykpL2dtfSksUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZShcInNjc3NcIixcImF0cnVsZVwiLHtrZXl3b3JkOi9AKGlmfGVsc2UgaWZ8ZWxzZXxmb3J8ZWFjaHx3aGlsZXxpbXBvcnR8ZXh0ZW5kfGRlYnVnfHdhcm58bWl4aW58aW5jbHVkZXxmdW5jdGlvbnxyZXR1cm58Y29udGVudCl8KD89QGZvclxccytcXCRbLV9cXHddK1xccykrZnJvbS9pfSksUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZShcInNjc3NcIixcInByb3BlcnR5XCIse3ZhcmlhYmxlOi8oKFxcJFstX1xcd10rKXwoI1xce1xcJFstX1xcd10rXFx9KSkvaX0pLFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoXCJzY3NzXCIsXCJmdW5jdGlvblwiLHtwbGFjZWhvbGRlcjovJVstX1xcd10rL2ksc3RhdGVtZW50Oi9cXEIhKGRlZmF1bHR8b3B0aW9uYWwpXFxiL2dpLFwiYm9vbGVhblwiOi9cXGIodHJ1ZXxmYWxzZSlcXGIvZyxcIm51bGxcIjovXFxiKG51bGwpXFxiL2csb3BlcmF0b3I6L1xccysoWy0rXXsxLDJ9fD17MSwyfXwhPXxcXHw/XFx8fFxcP3xcXCp8XFwvfCUpXFxzKy9nfSk7O1xuUHJpc20ubGFuZ3VhZ2VzLmJhc2g9UHJpc20ubGFuZ3VhZ2VzLmV4dGVuZChcImNsaWtlXCIse2NvbW1lbnQ6e3BhdHRlcm46LyhefFteXCJ7XFxcXF0pKCMuKj8oXFxyP1xcbnwkKSkvZyxsb29rYmVoaW5kOiEwfSxzdHJpbmc6e3BhdHRlcm46LyhcInwnKShcXFxcP1tcXHNcXFNdKSo/XFwxL2csaW5zaWRlOntwcm9wZXJ0eTovXFwkKFthLXpBLVowLTlfI1xcP1xcLVxcKiFAXSt8XFx7W15cXH1dK1xcfSkvZ319LGtleXdvcmQ6L1xcYihpZnx0aGVufGVsc2V8ZWxpZnxmaXxmb3J8YnJlYWt8Y29udGludWV8d2hpbGV8aW58Y2FzZXxmdW5jdGlvbnxzZWxlY3R8ZG98ZG9uZXx1bnRpbHxlY2hvfGV4aXR8cmV0dXJufHNldHxkZWNsYXJlKVxcYi9nfSksUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZShcImJhc2hcIixcImtleXdvcmRcIix7cHJvcGVydHk6L1xcJChbYS16QS1aMC05XyNcXD9cXC1cXCohQF0rfFxce1tefV0rXFx9KS9nfSksUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZShcImJhc2hcIixcImNvbW1lbnRcIix7aW1wb3J0YW50Oi8oXiMhXFxzKlxcL2JpblxcL2Jhc2gpfCheIyFcXHMqXFwvYmluXFwvc2gpL2d9KTs7XG5QcmlzbS5sYW5ndWFnZXMuc3FsPXtjb21tZW50OntwYXR0ZXJuOi8oXnxbXlxcXFxdKShcXC9cXCpbXFx3XFxXXSo/XFwqXFwvfCgoLS0pfChcXC9cXC8pfCMpLio/KFxccj9cXG58JCkpL2csbG9va2JlaGluZDohMH0sc3RyaW5nOntwYXR0ZXJuOi8oXnxbXkBdKShcInwnKShcXFxcP1tcXHNcXFNdKSo/XFwyL2csbG9va2JlaGluZDohMH0sdmFyaWFibGU6L0BbXFx3LiRdK3xAKFwifCd8YCkoXFxcXD9bXFxzXFxTXSkrP1xcMS9nLFwiZnVuY3Rpb25cIjovXFxiKD86Q09VTlR8U1VNfEFWR3xNSU58TUFYfEZJUlNUfExBU1R8VUNBU0V8TENBU0V8TUlEfExFTnxST1VORHxOT1d8Rk9STUFUKSg/PVxccypcXCgpL2dpLGtleXdvcmQ6L1xcYig/OkFDVElPTnxBRER8QUZURVJ8QUxHT1JJVEhNfEFMVEVSfEFOQUxZWkV8QVBQTFl8QVN8QVNDfEFVVEhPUklaQVRJT058QkFDS1VQfEJEQnxCRUdJTnxCRVJLRUxFWURCfEJJR0lOVHxCSU5BUll8QklUfEJMT0J8Qk9PTHxCT09MRUFOfEJSRUFLfEJST1dTRXxCVFJFRXxCVUxLfEJZfENBTEx8Q0FTQ0FERXxDQVNDQURFRHxDQVNFfENIQUlOfENIQVIgVkFSWUlOR3xDSEFSQUNURVIgVkFSWUlOR3xDSEVDS3xDSEVDS1BPSU5UfENMT1NFfENMVVNURVJFRHxDT0FMRVNDRXxDT0xVTU58Q09MVU1OU3xDT01NRU5UfENPTU1JVHxDT01NSVRURUR8Q09NUFVURXxDT05ORUNUfENPTlNJU1RFTlR8Q09OU1RSQUlOVHxDT05UQUlOU3xDT05UQUlOU1RBQkxFfENPTlRJTlVFfENPTlZFUlR8Q1JFQVRFfENST1NTfENVUlJFTlR8Q1VSUkVOVF9EQVRFfENVUlJFTlRfVElNRXxDVVJSRU5UX1RJTUVTVEFNUHxDVVJSRU5UX1VTRVJ8Q1VSU09SfERBVEF8REFUQUJBU0V8REFUQUJBU0VTfERBVEVUSU1FfERCQ0N8REVBTExPQ0FURXxERUN8REVDSU1BTHxERUNMQVJFfERFRkFVTFR8REVGSU5FUnxERUxBWUVEfERFTEVURXxERU5ZfERFU0N8REVTQ1JJQkV8REVURVJNSU5JU1RJQ3xESVNBQkxFfERJU0NBUkR8RElTS3xESVNUSU5DVHxESVNUSU5DVFJPV3xESVNUUklCVVRFRHxET3xET1VCTEV8RE9VQkxFIFBSRUNJU0lPTnxEUk9QfERVTU1ZfERVTVB8RFVNUEZJTEV8RFVQTElDQVRFIEtFWXxFTFNFfEVOQUJMRXxFTkNMT1NFRCBCWXxFTkR8RU5HSU5FfEVOVU18RVJSTFZMfEVSUk9SU3xFU0NBUEV8RVNDQVBFRCBCWXxFWENFUFR8RVhFQ3xFWEVDVVRFfEVYSVR8RVhQTEFJTnxFWFRFTkRFRHxGRVRDSHxGSUVMRFN8RklMRXxGSUxMRkFDVE9SfEZJUlNUfEZJWEVEfEZMT0FUfEZPTExPV0lOR3xGT1J8Rk9SIEVBQ0ggUk9XfEZPUkNFfEZPUkVJR058RlJFRVRFWFR8RlJFRVRFWFRUQUJMRXxGUk9NfEZVTEx8RlVOQ1RJT058R0VPTUVUUll8R0VPTUVUUllDT0xMRUNUSU9OfEdMT0JBTHxHT1RPfEdSQU5UfEdST1VQfEhBTkRMRVJ8SEFTSHxIQVZJTkd8SE9MRExPQ0t8SURFTlRJVFl8SURFTlRJVFlfSU5TRVJUfElERU5USVRZQ09MfElGfElHTk9SRXxJTVBPUlR8SU5ERVh8SU5GSUxFfElOTkVSfElOTk9EQnxJTk9VVHxJTlNFUlR8SU5UfElOVEVHRVJ8SU5URVJTRUNUfElOVE98SU5WT0tFUnxJU09MQVRJT04gTEVWRUx8Sk9JTnxLRVl8S0VZU3xLSUxMfExBTkdVQUdFIFNRTHxMQVNUfExFRlR8TElNSVR8TElORU5PfExJTkVTfExJTkVTVFJJTkd8TE9BRHxMT0NBTHxMT0NLfExPTkdCTE9CfExPTkdURVhUfE1BVENIfE1BVENIRUR8TUVESVVNQkxPQnxNRURJVU1JTlR8TUVESVVNVEVYVHxNRVJHRXxNSURETEVJTlR8TU9ESUZJRVMgU1FMIERBVEF8TU9ESUZZfE1VTFRJTElORVNUUklOR3xNVUxUSVBPSU5UfE1VTFRJUE9MWUdPTnxOQVRJT05BTHxOQVRJT05BTCBDSEFSIFZBUllJTkd8TkFUSU9OQUwgQ0hBUkFDVEVSfE5BVElPTkFMIENIQVJBQ1RFUiBWQVJZSU5HfE5BVElPTkFMIFZBUkNIQVJ8TkFUVVJBTHxOQ0hBUnxOQ0hBUiBWQVJDSEFSfE5FWFR8Tk98Tk8gU1FMfE5PQ0hFQ0t8Tk9DWUNMRXxOT05DTFVTVEVSRUR8TlVMTElGfE5VTUVSSUN8T0Z8T0ZGfE9GRlNFVFN8T058T1BFTnxPUEVOREFUQVNPVVJDRXxPUEVOUVVFUll8T1BFTlJPV1NFVHxPUFRJTUlaRXxPUFRJT058T1BUSU9OQUxMWXxPUkRFUnxPVVR8T1VURVJ8T1VURklMRXxPVkVSfFBBUlRJQUx8UEFSVElUSU9OfFBFUkNFTlR8UElWT1R8UExBTnxQT0lOVHxQT0xZR09OfFBSRUNFRElOR3xQUkVDSVNJT058UFJFVnxQUklNQVJZfFBSSU5UfFBSSVZJTEVHRVN8UFJPQ3xQUk9DRURVUkV8UFVCTElDfFBVUkdFfFFVSUNLfFJBSVNFUlJPUnxSRUFEfFJFQURTIFNRTCBEQVRBfFJFQURURVhUfFJFQUx8UkVDT05GSUdVUkV8UkVGRVJFTkNFU3xSRUxFQVNFfFJFTkFNRXxSRVBFQVRBQkxFfFJFUExJQ0FUSU9OfFJFUVVJUkV8UkVTVE9SRXxSRVNUUklDVHxSRVRVUk58UkVUVVJOU3xSRVZPS0V8UklHSFR8Uk9MTEJBQ0t8Uk9VVElORXxST1dDT1VOVHxST1dHVUlEQ09MfFJPV1M/fFJUUkVFfFJVTEV8U0FWRXxTQVZFUE9JTlR8U0NIRU1BfFNFTEVDVHxTRVJJQUx8U0VSSUFMSVpBQkxFfFNFU1NJT058U0VTU0lPTl9VU0VSfFNFVHxTRVRVU0VSfFNIQVJFIE1PREV8U0hPV3xTSFVURE9XTnxTSU1QTEV8U01BTExJTlR8U05BUFNIT1R8U09NRXxTT05BTUV8U1RBUlR8U1RBUlRJTkcgQll8U1RBVElTVElDU3xTVEFUVVN8U1RSSVBFRHxTWVNURU1fVVNFUnxUQUJMRXxUQUJMRVN8VEFCTEVTUEFDRXxURU1QKD86T1JBUlkpP3xURU1QVEFCTEV8VEVSTUlOQVRFRCBCWXxURVhUfFRFWFRTSVpFfFRIRU58VElNRVNUQU1QfFRJTllCTE9CfFRJTllJTlR8VElOWVRFWFR8VE98VE9QfFRSQU58VFJBTlNBQ1RJT058VFJBTlNBQ1RJT05TfFRSSUdHRVJ8VFJVTkNBVEV8VFNFUVVBTHxUWVBFfFRZUEVTfFVOQk9VTkRFRHxVTkNPTU1JVFRFRHxVTkRFRklORUR8VU5JT058VU5QSVZPVHxVUERBVEV8VVBEQVRFVEVYVHxVU0FHRXxVU0V8VVNFUnxVU0lOR3xWQUxVRXxWQUxVRVN8VkFSQklOQVJZfFZBUkNIQVJ8VkFSQ0hBUkFDVEVSfFZBUllJTkd8VklFV3xXQUlURk9SfFdBUk5JTkdTfFdIRU58V0hFUkV8V0hJTEV8V0lUSHxXSVRIIFJPTExVUHxXSVRISU58V09SS3xXUklURXxXUklURVRFWFQpXFxiL2dpLFwiYm9vbGVhblwiOi9cXGIoPzpUUlVFfEZBTFNFfE5VTEwpXFxiL2dpLG51bWJlcjovXFxiLT8oMHgpP1xcZCpcXC4/W1xcZGEtZl0rXFxiL2csb3BlcmF0b3I6L1xcYig/OkFMTHxBTkR8QU5ZfEJFVFdFRU58RVhJU1RTfElOfExJS0V8Tk9UfE9SfElTfFVOSVFVRXxDSEFSQUNURVIgU0VUfENPTExBVEV8RElWfE9GRlNFVHxSRUdFWFB8UkxJS0V8U09VTkRTIExJS0V8WE9SKVxcYnxbLStdezF9fCF8Wz08Pl17MSwyfXwoJil7MSwyfXxcXHw/XFx8fFxcP3xcXCp8XFwvL2dpLHB1bmN0dWF0aW9uOi9bO1tcXF0oKWAsLl0vZ307O1xuUHJpc20ubGFuZ3VhZ2VzLmFwYWNoZWNvbmY9e2NvbW1lbnQ6LyMuKi9nLFwiZGlyZWN0aXZlLWlubGluZVwiOntwYXR0ZXJuOi9eXFxzKlxcYihBY2NlcHRGaWx0ZXJ8QWNjZXB0UGF0aEluZm98QWNjZXNzRmlsZU5hbWV8QWN0aW9ufEFkZEFsdHxBZGRBbHRCeUVuY29kaW5nfEFkZEFsdEJ5VHlwZXxBZGRDaGFyc2V0fEFkZERlZmF1bHRDaGFyc2V0fEFkZERlc2NyaXB0aW9ufEFkZEVuY29kaW5nfEFkZEhhbmRsZXJ8QWRkSWNvbnxBZGRJY29uQnlFbmNvZGluZ3xBZGRJY29uQnlUeXBlfEFkZElucHV0RmlsdGVyfEFkZExhbmd1YWdlfEFkZE1vZHVsZUluZm98QWRkT3V0cHV0RmlsdGVyfEFkZE91dHB1dEZpbHRlckJ5VHlwZXxBZGRUeXBlfEFsaWFzfEFsaWFzTWF0Y2h8QWxsb3d8QWxsb3dDT05ORUNUfEFsbG93RW5jb2RlZFNsYXNoZXN8QWxsb3dNZXRob2RzfEFsbG93T3ZlcnJpZGV8QWxsb3dPdmVycmlkZUxpc3R8QW5vbnltb3VzfEFub255bW91c19Mb2dFbWFpbHxBbm9ueW1vdXNfTXVzdEdpdmVFbWFpbHxBbm9ueW1vdXNfTm9Vc2VySUR8QW5vbnltb3VzX1ZlcmlmeUVtYWlsfEFzeW5jUmVxdWVzdFdvcmtlckZhY3RvcnxBdXRoQmFzaWNBdXRob3JpdGF0aXZlfEF1dGhCYXNpY0Zha2V8QXV0aEJhc2ljUHJvdmlkZXJ8QXV0aEJhc2ljVXNlRGlnZXN0QWxnb3JpdGhtfEF1dGhEQkRVc2VyUFdRdWVyeXxBdXRoREJEVXNlclJlYWxtUXVlcnl8QXV0aERCTUdyb3VwRmlsZXxBdXRoREJNVHlwZXxBdXRoREJNVXNlckZpbGV8QXV0aERpZ2VzdEFsZ29yaXRobXxBdXRoRGlnZXN0RG9tYWlufEF1dGhEaWdlc3ROb25jZUxpZmV0aW1lfEF1dGhEaWdlc3RQcm92aWRlcnxBdXRoRGlnZXN0UW9wfEF1dGhEaWdlc3RTaG1lbVNpemV8QXV0aEZvcm1BdXRob3JpdGF0aXZlfEF1dGhGb3JtQm9keXxBdXRoRm9ybURpc2FibGVOb1N0b3JlfEF1dGhGb3JtRmFrZUJhc2ljQXV0aHxBdXRoRm9ybUxvY2F0aW9ufEF1dGhGb3JtTG9naW5SZXF1aXJlZExvY2F0aW9ufEF1dGhGb3JtTG9naW5TdWNjZXNzTG9jYXRpb258QXV0aEZvcm1Mb2dvdXRMb2NhdGlvbnxBdXRoRm9ybU1ldGhvZHxBdXRoRm9ybU1pbWV0eXBlfEF1dGhGb3JtUGFzc3dvcmR8QXV0aEZvcm1Qcm92aWRlcnxBdXRoRm9ybVNpdGVQYXNzcGhyYXNlfEF1dGhGb3JtU2l6ZXxBdXRoRm9ybVVzZXJuYW1lfEF1dGhHcm91cEZpbGV8QXV0aExEQVBBdXRob3JpemVQcmVmaXh8QXV0aExEQVBCaW5kQXV0aG9yaXRhdGl2ZXxBdXRoTERBUEJpbmRETnxBdXRoTERBUEJpbmRQYXNzd29yZHxBdXRoTERBUENoYXJzZXRDb25maWd8QXV0aExEQVBDb21wYXJlQXNVc2VyfEF1dGhMREFQQ29tcGFyZUROT25TZXJ2ZXJ8QXV0aExEQVBEZXJlZmVyZW5jZUFsaWFzZXN8QXV0aExEQVBHcm91cEF0dHJpYnV0ZXxBdXRoTERBUEdyb3VwQXR0cmlidXRlSXNETnxBdXRoTERBUEluaXRpYWxCaW5kQXNVc2VyfEF1dGhMREFQSW5pdGlhbEJpbmRQYXR0ZXJufEF1dGhMREFQTWF4U3ViR3JvdXBEZXB0aHxBdXRoTERBUFJlbW90ZVVzZXJBdHRyaWJ1dGV8QXV0aExEQVBSZW1vdGVVc2VySXNETnxBdXRoTERBUFNlYXJjaEFzVXNlcnxBdXRoTERBUFN1Ykdyb3VwQXR0cmlidXRlfEF1dGhMREFQU3ViR3JvdXBDbGFzc3xBdXRoTERBUFVybHxBdXRoTWVyZ2luZ3xBdXRoTmFtZXxBdXRobkNhY2hlQ29udGV4dHxBdXRobkNhY2hlRW5hYmxlfEF1dGhuQ2FjaGVQcm92aWRlRm9yfEF1dGhuQ2FjaGVTT0NhY2hlfEF1dGhuQ2FjaGVUaW1lb3V0fEF1dGhuekZjZ2lDaGVja0F1dGhuUHJvdmlkZXJ8QXV0aG56RmNnaURlZmluZVByb3ZpZGVyfEF1dGhUeXBlfEF1dGhVc2VyRmlsZXxBdXRoekRCRExvZ2luVG9SZWZlcmVyfEF1dGh6REJEUXVlcnl8QXV0aHpEQkRSZWRpcmVjdFF1ZXJ5fEF1dGh6REJNVHlwZXxBdXRoelNlbmRGb3JiaWRkZW5PbkZhaWx1cmV8QmFsYW5jZXJHcm93dGh8QmFsYW5jZXJJbmhlcml0fEJhbGFuY2VyTWVtYmVyfEJhbGFuY2VyUGVyc2lzdHxCcm93c2VyTWF0Y2h8QnJvd3Nlck1hdGNoTm9DYXNlfEJ1ZmZlcmVkTG9nc3xCdWZmZXJTaXplfENhY2hlRGVmYXVsdEV4cGlyZXxDYWNoZURldGFpbEhlYWRlcnxDYWNoZURpckxlbmd0aHxDYWNoZURpckxldmVsc3xDYWNoZURpc2FibGV8Q2FjaGVFbmFibGV8Q2FjaGVGaWxlfENhY2hlSGVhZGVyfENhY2hlSWdub3JlQ2FjaGVDb250cm9sfENhY2hlSWdub3JlSGVhZGVyc3xDYWNoZUlnbm9yZU5vTGFzdE1vZHxDYWNoZUlnbm9yZVF1ZXJ5U3RyaW5nfENhY2hlSWdub3JlVVJMU2Vzc2lvbklkZW50aWZpZXJzfENhY2hlS2V5QmFzZVVSTHxDYWNoZUxhc3RNb2RpZmllZEZhY3RvcnxDYWNoZUxvY2t8Q2FjaGVMb2NrTWF4QWdlfENhY2hlTG9ja1BhdGh8Q2FjaGVNYXhFeHBpcmV8Q2FjaGVNYXhGaWxlU2l6ZXxDYWNoZU1pbkV4cGlyZXxDYWNoZU1pbkZpbGVTaXplfENhY2hlTmVnb3RpYXRlZERvY3N8Q2FjaGVRdWlja0hhbmRsZXJ8Q2FjaGVSZWFkU2l6ZXxDYWNoZVJlYWRUaW1lfENhY2hlUm9vdHxDYWNoZVNvY2FjaGV8Q2FjaGVTb2NhY2hlTWF4U2l6ZXxDYWNoZVNvY2FjaGVNYXhUaW1lfENhY2hlU29jYWNoZU1pblRpbWV8Q2FjaGVTb2NhY2hlUmVhZFNpemV8Q2FjaGVTb2NhY2hlUmVhZFRpbWV8Q2FjaGVTdGFsZU9uRXJyb3J8Q2FjaGVTdG9yZUV4cGlyZWR8Q2FjaGVTdG9yZU5vU3RvcmV8Q2FjaGVTdG9yZVByaXZhdGV8Q0dJRFNjcmlwdFRpbWVvdXR8Q0dJTWFwRXh0ZW5zaW9ufENoYXJzZXREZWZhdWx0fENoYXJzZXRPcHRpb25zfENoYXJzZXRTb3VyY2VFbmN8Q2hlY2tDYXNlT25seXxDaGVja1NwZWxsaW5nfENocm9vdERpcnxDb250ZW50RGlnZXN0fENvb2tpZURvbWFpbnxDb29raWVFeHBpcmVzfENvb2tpZU5hbWV8Q29va2llU3R5bGV8Q29va2llVHJhY2tpbmd8Q29yZUR1bXBEaXJlY3Rvcnl8Q3VzdG9tTG9nfERhdnxEYXZEZXB0aEluZmluaXR5fERhdkdlbmVyaWNMb2NrREJ8RGF2TG9ja0RCfERhdk1pblRpbWVvdXR8REJERXhwdGltZXxEQkRJbml0U1FMfERCREtlZXB8REJETWF4fERCRE1pbnxEQkRQYXJhbXN8REJEUGVyc2lzdHxEQkRQcmVwYXJlU1FMfERCRHJpdmVyfERlZmF1bHRJY29ufERlZmF1bHRMYW5ndWFnZXxEZWZhdWx0UnVudGltZURpcnxEZWZhdWx0VHlwZXxEZWZpbmV8RGVmbGF0ZUJ1ZmZlclNpemV8RGVmbGF0ZUNvbXByZXNzaW9uTGV2ZWx8RGVmbGF0ZUZpbHRlck5vdGV8RGVmbGF0ZUluZmxhdGVMaW1pdFJlcXVlc3RCb2R5fERlZmxhdGVJbmZsYXRlUmF0aW9CdXJzdHxEZWZsYXRlSW5mbGF0ZVJhdGlvTGltaXR8RGVmbGF0ZU1lbUxldmVsfERlZmxhdGVXaW5kb3dTaXplfERlbnl8RGlyZWN0b3J5Q2hlY2tIYW5kbGVyfERpcmVjdG9yeUluZGV4fERpcmVjdG9yeUluZGV4UmVkaXJlY3R8RGlyZWN0b3J5U2xhc2h8RG9jdW1lbnRSb290fERUcmFjZVByaXZpbGVnZXN8RHVtcElPSW5wdXR8RHVtcElPT3V0cHV0fEVuYWJsZUV4Y2VwdGlvbkhvb2t8RW5hYmxlTU1BUHxFbmFibGVTZW5kZmlsZXxFcnJvcnxFcnJvckRvY3VtZW50fEVycm9yTG9nfEVycm9yTG9nRm9ybWF0fEV4YW1wbGV8RXhwaXJlc0FjdGl2ZXxFeHBpcmVzQnlUeXBlfEV4cGlyZXNEZWZhdWx0fEV4dGVuZGVkU3RhdHVzfEV4dEZpbHRlckRlZmluZXxFeHRGaWx0ZXJPcHRpb25zfEZhbGxiYWNrUmVzb3VyY2V8RmlsZUVUYWd8RmlsdGVyQ2hhaW58RmlsdGVyRGVjbGFyZXxGaWx0ZXJQcm90b2NvbHxGaWx0ZXJQcm92aWRlcnxGaWx0ZXJUcmFjZXxGb3JjZUxhbmd1YWdlUHJpb3JpdHl8Rm9yY2VUeXBlfEZvcmVuc2ljTG9nfEdwcm9mRGlyfEdyYWNlZnVsU2h1dGRvd25UaW1lb3V0fEdyb3VwfEhlYWRlcnxIZWFkZXJOYW1lfEhlYXJ0YmVhdEFkZHJlc3N8SGVhcnRiZWF0TGlzdGVufEhlYXJ0YmVhdE1heFNlcnZlcnN8SGVhcnRiZWF0U3RvcmFnZXxIZWFydGJlYXRTdG9yYWdlfEhvc3RuYW1lTG9va3Vwc3xJZGVudGl0eUNoZWNrfElkZW50aXR5Q2hlY2tUaW1lb3V0fEltYXBCYXNlfEltYXBEZWZhdWx0fEltYXBNZW51fEluY2x1ZGV8SW5jbHVkZU9wdGlvbmFsfEluZGV4SGVhZEluc2VydHxJbmRleElnbm9yZXxJbmRleElnbm9yZVJlc2V0fEluZGV4T3B0aW9uc3xJbmRleE9yZGVyRGVmYXVsdHxJbmRleFN0eWxlU2hlZXR8SW5wdXRTZWR8SVNBUElBcHBlbmRMb2dUb0Vycm9yc3xJU0FQSUFwcGVuZExvZ1RvUXVlcnl8SVNBUElDYWNoZUZpbGV8SVNBUElGYWtlQXN5bmN8SVNBUElMb2dOb3RTdXBwb3J0ZWR8SVNBUElSZWFkQWhlYWRCdWZmZXJ8S2VlcEFsaXZlfEtlZXBBbGl2ZVRpbWVvdXR8S2VwdEJvZHlTaXplfExhbmd1YWdlUHJpb3JpdHl8TERBUENhY2hlRW50cmllc3xMREFQQ2FjaGVUVEx8TERBUENvbm5lY3Rpb25Qb29sVFRMfExEQVBDb25uZWN0aW9uVGltZW91dHxMREFQTGlicmFyeURlYnVnfExEQVBPcENhY2hlRW50cmllc3xMREFQT3BDYWNoZVRUTHxMREFQUmVmZXJyYWxIb3BMaW1pdHxMREFQUmVmZXJyYWxzfExEQVBSZXRyaWVzfExEQVBSZXRyeURlbGF5fExEQVBTaGFyZWRDYWNoZUZpbGV8TERBUFNoYXJlZENhY2hlU2l6ZXxMREFQVGltZW91dHxMREFQVHJ1c3RlZENsaWVudENlcnR8TERBUFRydXN0ZWRHbG9iYWxDZXJ0fExEQVBUcnVzdGVkTW9kZXxMREFQVmVyaWZ5U2VydmVyQ2VydHxMaW1pdEludGVybmFsUmVjdXJzaW9ufExpbWl0UmVxdWVzdEJvZHl8TGltaXRSZXF1ZXN0RmllbGRzfExpbWl0UmVxdWVzdEZpZWxkU2l6ZXxMaW1pdFJlcXVlc3RMaW5lfExpbWl0WE1MUmVxdWVzdEJvZHl8TGlzdGVufExpc3RlbkJhY2tMb2d8TG9hZEZpbGV8TG9hZE1vZHVsZXxMb2dGb3JtYXR8TG9nTGV2ZWx8TG9nTWVzc2FnZXxMdWFBdXRoelByb3ZpZGVyfEx1YUNvZGVDYWNoZXxMdWFIb29rQWNjZXNzQ2hlY2tlcnxMdWFIb29rQXV0aENoZWNrZXJ8THVhSG9va0NoZWNrVXNlcklEfEx1YUhvb2tGaXh1cHN8THVhSG9va0luc2VydEZpbHRlcnxMdWFIb29rTG9nfEx1YUhvb2tNYXBUb1N0b3JhZ2V8THVhSG9va1RyYW5zbGF0ZU5hbWV8THVhSG9va1R5cGVDaGVja2VyfEx1YUluaGVyaXR8THVhSW5wdXRGaWx0ZXJ8THVhTWFwSGFuZGxlcnxMdWFPdXRwdXRGaWx0ZXJ8THVhUGFja2FnZUNQYXRofEx1YVBhY2thZ2VQYXRofEx1YVF1aWNrSGFuZGxlcnxMdWFSb290fEx1YVNjb3BlfE1heENvbm5lY3Rpb25zUGVyQ2hpbGR8TWF4S2VlcEFsaXZlUmVxdWVzdHN8TWF4TWVtRnJlZXxNYXhSYW5nZU92ZXJsYXBzfE1heFJhbmdlUmV2ZXJzYWxzfE1heFJhbmdlc3xNYXhSZXF1ZXN0V29ya2Vyc3xNYXhTcGFyZVNlcnZlcnN8TWF4U3BhcmVUaHJlYWRzfE1heFRocmVhZHN8TWVyZ2VUcmFpbGVyc3xNZXRhRGlyfE1ldGFGaWxlc3xNZXRhU3VmZml4fE1pbWVNYWdpY0ZpbGV8TWluU3BhcmVTZXJ2ZXJzfE1pblNwYXJlVGhyZWFkc3xNTWFwRmlsZXxNb2RlbVN0YW5kYXJkfE1vZE1pbWVVc2VQYXRoSW5mb3xNdWx0aXZpZXdzTWF0Y2h8TXV0ZXh8TmFtZVZpcnR1YWxIb3N0fE5vUHJveHl8TldTU0xUcnVzdGVkQ2VydHN8TldTU0xVcGdyYWRlYWJsZXxPcHRpb25zfE9yZGVyfE91dHB1dFNlZHxQYXNzRW52fFBpZEZpbGV8UHJpdmlsZWdlc01vZGV8UHJvdG9jb2x8UHJvdG9jb2xFY2hvfFByb3h5QWRkSGVhZGVyc3xQcm94eUJhZEhlYWRlcnxQcm94eUJsb2NrfFByb3h5RG9tYWlufFByb3h5RXJyb3JPdmVycmlkZXxQcm94eUV4cHJlc3NEQk1GaWxlfFByb3h5RXhwcmVzc0RCTVR5cGV8UHJveHlFeHByZXNzRW5hYmxlfFByb3h5RnRwRGlyQ2hhcnNldHxQcm94eUZ0cEVzY2FwZVdpbGRjYXJkc3xQcm94eUZ0cExpc3RPbldpbGRjYXJkfFByb3h5SFRNTEJ1ZlNpemV8UHJveHlIVE1MQ2hhcnNldE91dHxQcm94eUhUTUxEb2NUeXBlfFByb3h5SFRNTEVuYWJsZXxQcm94eUhUTUxFdmVudHN8UHJveHlIVE1MRXh0ZW5kZWR8UHJveHlIVE1MRml4dXBzfFByb3h5SFRNTEludGVycHxQcm94eUhUTUxMaW5rc3xQcm94eUhUTUxNZXRhfFByb3h5SFRNTFN0cmlwQ29tbWVudHN8UHJveHlIVE1MVVJMTWFwfFByb3h5SU9CdWZmZXJTaXplfFByb3h5TWF4Rm9yd2FyZHN8UHJveHlQYXNzfFByb3h5UGFzc0luaGVyaXR8UHJveHlQYXNzSW50ZXJwb2xhdGVFbnZ8UHJveHlQYXNzTWF0Y2h8UHJveHlQYXNzUmV2ZXJzZXxQcm94eVBhc3NSZXZlcnNlQ29va2llRG9tYWlufFByb3h5UGFzc1JldmVyc2VDb29raWVQYXRofFByb3h5UHJlc2VydmVIb3N0fFByb3h5UmVjZWl2ZUJ1ZmZlclNpemV8UHJveHlSZW1vdGV8UHJveHlSZW1vdGVNYXRjaHxQcm94eVJlcXVlc3RzfFByb3h5U0NHSUludGVybmFsUmVkaXJlY3R8UHJveHlTQ0dJU2VuZGZpbGV8UHJveHlTZXR8UHJveHlTb3VyY2VBZGRyZXNzfFByb3h5U3RhdHVzfFByb3h5VGltZW91dHxQcm94eVZpYXxSZWFkbWVOYW1lfFJlY2VpdmVCdWZmZXJTaXplfFJlZGlyZWN0fFJlZGlyZWN0TWF0Y2h8UmVkaXJlY3RQZXJtYW5lbnR8UmVkaXJlY3RUZW1wfFJlZmxlY3RvckhlYWRlcnxSZW1vdGVJUEhlYWRlcnxSZW1vdGVJUEludGVybmFsUHJveHl8UmVtb3RlSVBJbnRlcm5hbFByb3h5TGlzdHxSZW1vdGVJUFByb3hpZXNIZWFkZXJ8UmVtb3RlSVBUcnVzdGVkUHJveHl8UmVtb3RlSVBUcnVzdGVkUHJveHlMaXN0fFJlbW92ZUNoYXJzZXR8UmVtb3ZlRW5jb2Rpbmd8UmVtb3ZlSGFuZGxlcnxSZW1vdmVJbnB1dEZpbHRlcnxSZW1vdmVMYW5ndWFnZXxSZW1vdmVPdXRwdXRGaWx0ZXJ8UmVtb3ZlVHlwZXxSZXF1ZXN0SGVhZGVyfFJlcXVlc3RSZWFkVGltZW91dHxSZXF1aXJlfFJld3JpdGVCYXNlfFJld3JpdGVDb25kfFJld3JpdGVFbmdpbmV8UmV3cml0ZU1hcHxSZXdyaXRlT3B0aW9uc3xSZXdyaXRlUnVsZXxSTGltaXRDUFV8UkxpbWl0TUVNfFJMaW1pdE5QUk9DfFNhdGlzZnl8U2NvcmVCb2FyZEZpbGV8U2NyaXB0fFNjcmlwdEFsaWFzfFNjcmlwdEFsaWFzTWF0Y2h8U2NyaXB0SW50ZXJwcmV0ZXJTb3VyY2V8U2NyaXB0TG9nfFNjcmlwdExvZ0J1ZmZlcnxTY3JpcHRMb2dMZW5ndGh8U2NyaXB0U29ja3xTZWN1cmVMaXN0ZW58U2VlUmVxdWVzdFRhaWx8U2VuZEJ1ZmZlclNpemV8U2VydmVyQWRtaW58U2VydmVyQWxpYXN8U2VydmVyTGltaXR8U2VydmVyTmFtZXxTZXJ2ZXJQYXRofFNlcnZlclJvb3R8U2VydmVyU2lnbmF0dXJlfFNlcnZlclRva2Vuc3xTZXNzaW9ufFNlc3Npb25Db29raWVOYW1lfFNlc3Npb25Db29raWVOYW1lMnxTZXNzaW9uQ29va2llUmVtb3ZlfFNlc3Npb25DcnlwdG9DaXBoZXJ8U2Vzc2lvbkNyeXB0b0RyaXZlcnxTZXNzaW9uQ3J5cHRvUGFzc3BocmFzZXxTZXNzaW9uQ3J5cHRvUGFzc3BocmFzZUZpbGV8U2Vzc2lvbkRCRENvb2tpZU5hbWV8U2Vzc2lvbkRCRENvb2tpZU5hbWUyfFNlc3Npb25EQkRDb29raWVSZW1vdmV8U2Vzc2lvbkRCRERlbGV0ZUxhYmVsfFNlc3Npb25EQkRJbnNlcnRMYWJlbHxTZXNzaW9uREJEUGVyVXNlcnxTZXNzaW9uREJEU2VsZWN0TGFiZWx8U2Vzc2lvbkRCRFVwZGF0ZUxhYmVsfFNlc3Npb25FbnZ8U2Vzc2lvbkV4Y2x1ZGV8U2Vzc2lvbkhlYWRlcnxTZXNzaW9uSW5jbHVkZXxTZXNzaW9uTWF4QWdlfFNldEVudnxTZXRFbnZJZnxTZXRFbnZJZkV4cHJ8U2V0RW52SWZOb0Nhc2V8U2V0SGFuZGxlcnxTZXRJbnB1dEZpbHRlcnxTZXRPdXRwdXRGaWx0ZXJ8U1NJRW5kVGFnfFNTSUVycm9yTXNnfFNTSUVUYWd8U1NJTGFzdE1vZGlmaWVkfFNTSUxlZ2FjeUV4cHJQYXJzZXJ8U1NJU3RhcnRUYWd8U1NJVGltZUZvcm1hdHxTU0lVbmRlZmluZWRFY2hvfFNTTENBQ2VydGlmaWNhdGVGaWxlfFNTTENBQ2VydGlmaWNhdGVQYXRofFNTTENBRE5SZXF1ZXN0RmlsZXxTU0xDQUROUmVxdWVzdFBhdGh8U1NMQ0FSZXZvY2F0aW9uQ2hlY2t8U1NMQ0FSZXZvY2F0aW9uRmlsZXxTU0xDQVJldm9jYXRpb25QYXRofFNTTENlcnRpZmljYXRlQ2hhaW5GaWxlfFNTTENlcnRpZmljYXRlRmlsZXxTU0xDZXJ0aWZpY2F0ZUtleUZpbGV8U1NMQ2lwaGVyU3VpdGV8U1NMQ29tcHJlc3Npb258U1NMQ3J5cHRvRGV2aWNlfFNTTEVuZ2luZXxTU0xGSVBTfFNTTEhvbm9yQ2lwaGVyT3JkZXJ8U1NMSW5zZWN1cmVSZW5lZ290aWF0aW9ufFNTTE9DU1BEZWZhdWx0UmVzcG9uZGVyfFNTTE9DU1BFbmFibGV8U1NMT0NTUE92ZXJyaWRlUmVzcG9uZGVyfFNTTE9DU1BSZXNwb25kZXJUaW1lb3V0fFNTTE9DU1BSZXNwb25zZU1heEFnZXxTU0xPQ1NQUmVzcG9uc2VUaW1lU2tld3xTU0xPQ1NQVXNlUmVxdWVzdE5vbmNlfFNTTE9wZW5TU0xDb25mQ21kfFNTTE9wdGlvbnN8U1NMUGFzc1BocmFzZURpYWxvZ3xTU0xQcm90b2NvbHxTU0xQcm94eUNBQ2VydGlmaWNhdGVGaWxlfFNTTFByb3h5Q0FDZXJ0aWZpY2F0ZVBhdGh8U1NMUHJveHlDQVJldm9jYXRpb25DaGVja3xTU0xQcm94eUNBUmV2b2NhdGlvbkZpbGV8U1NMUHJveHlDQVJldm9jYXRpb25QYXRofFNTTFByb3h5Q2hlY2tQZWVyQ058U1NMUHJveHlDaGVja1BlZXJFeHBpcmV8U1NMUHJveHlDaGVja1BlZXJOYW1lfFNTTFByb3h5Q2lwaGVyU3VpdGV8U1NMUHJveHlFbmdpbmV8U1NMUHJveHlNYWNoaW5lQ2VydGlmaWNhdGVDaGFpbkZpbGV8U1NMUHJveHlNYWNoaW5lQ2VydGlmaWNhdGVGaWxlfFNTTFByb3h5TWFjaGluZUNlcnRpZmljYXRlUGF0aHxTU0xQcm94eVByb3RvY29sfFNTTFByb3h5VmVyaWZ5fFNTTFByb3h5VmVyaWZ5RGVwdGh8U1NMUmFuZG9tU2VlZHxTU0xSZW5lZ0J1ZmZlclNpemV8U1NMUmVxdWlyZXxTU0xSZXF1aXJlU1NMfFNTTFNlc3Npb25DYWNoZXxTU0xTZXNzaW9uQ2FjaGVUaW1lb3V0fFNTTFNlc3Npb25UaWNrZXRLZXlGaWxlfFNTTFNSUFVua25vd25Vc2VyU2VlZHxTU0xTUlBWZXJpZmllckZpbGV8U1NMU3RhcGxpbmdDYWNoZXxTU0xTdGFwbGluZ0Vycm9yQ2FjaGVUaW1lb3V0fFNTTFN0YXBsaW5nRmFrZVRyeUxhdGVyfFNTTFN0YXBsaW5nRm9yY2VVUkx8U1NMU3RhcGxpbmdSZXNwb25kZXJUaW1lb3V0fFNTTFN0YXBsaW5nUmVzcG9uc2VNYXhBZ2V8U1NMU3RhcGxpbmdSZXNwb25zZVRpbWVTa2V3fFNTTFN0YXBsaW5nUmV0dXJuUmVzcG9uZGVyRXJyb3JzfFNTTFN0YXBsaW5nU3RhbmRhcmRDYWNoZVRpbWVvdXR8U1NMU3RyaWN0U05JVkhvc3RDaGVja3xTU0xVc2VyTmFtZXxTU0xVc2VTdGFwbGluZ3xTU0xWZXJpZnlDbGllbnR8U1NMVmVyaWZ5RGVwdGh8U3RhcnRTZXJ2ZXJzfFN0YXJ0VGhyZWFkc3xTdWJzdGl0dXRlfFN1ZXhlY3xTdWV4ZWNVc2VyR3JvdXB8VGhyZWFkTGltaXR8VGhyZWFkc1BlckNoaWxkfFRocmVhZFN0YWNrU2l6ZXxUaW1lT3V0fFRyYWNlRW5hYmxlfFRyYW5zZmVyTG9nfFR5cGVzQ29uZmlnfFVuRGVmaW5lfFVuZGVmTWFjcm98VW5zZXRFbnZ8VXNlfFVzZUNhbm9uaWNhbE5hbWV8VXNlQ2Fub25pY2FsUGh5c2ljYWxQb3J0fFVzZXJ8VXNlckRpcnxWSG9zdENHSU1vZGV8Vkhvc3RDR0lQcml2c3xWSG9zdEdyb3VwfFZIb3N0UHJpdnN8Vkhvc3RTZWN1cmV8Vkhvc3RVc2VyfFZpcnR1YWxEb2N1bWVudFJvb3R8VmlydHVhbERvY3VtZW50Um9vdElQfFZpcnR1YWxTY3JpcHRBbGlhc3xWaXJ0dWFsU2NyaXB0QWxpYXNJUHxXYXRjaGRvZ0ludGVydmFsfFhCaXRIYWNrfHhtbDJFbmNBbGlhc3x4bWwyRW5jRGVmYXVsdHx4bWwyU3RhcnRQYXJzZSlcXGIvZ2ltLGFsaWFzOlwicHJvcGVydHlcIn0sXCJkaXJlY3RpdmUtYmxvY2tcIjp7cGF0dGVybjovPFxcLz9cXGIoQXV0aG5Qcm92aWRlckFsaWFzfEF1dGh6UHJvdmlkZXJBbGlhc3xEaXJlY3Rvcnl8RGlyZWN0b3J5TWF0Y2h8RWxzZXxFbHNlSWZ8RmlsZXN8RmlsZXNNYXRjaHxJZnxJZkRlZmluZXxJZk1vZHVsZXxJZlZlcnNpb258TGltaXR8TGltaXRFeGNlcHR8TG9jYXRpb258TG9jYXRpb25NYXRjaHxNYWNyb3xQcm94eXxSZXF1aXJlQWxsfFJlcXVpcmVBbnl8UmVxdWlyZU5vbmV8VmlydHVhbEhvc3QpXFxiICouKj4vZ2ksaW5zaWRlOntcImRpcmVjdGl2ZS1ibG9ja1wiOntwYXR0ZXJuOi9ePFxcLz9cXHcrLyxpbnNpZGU6e3B1bmN0dWF0aW9uOi9ePFxcLz8vfSxhbGlhczpcInRhZ1wifSxcImRpcmVjdGl2ZS1ibG9jay1wYXJhbWV0ZXJcIjp7cGF0dGVybjovLipbXj5dLyxpbnNpZGU6e3B1bmN0dWF0aW9uOi86LyxzdHJpbmc6e3BhdHRlcm46LyhcInwnKS4qXFwxL2csaW5zaWRlOnt2YXJpYWJsZTovKFxcJHwlKVxcez8oXFx3XFwuPyhcXCt8XFwtfDopPykrXFx9Py9nfX19LGFsaWFzOlwiYXR0ci12YWx1ZVwifSxwdW5jdHVhdGlvbjovPi99LGFsaWFzOlwidGFnXCJ9LFwiZGlyZWN0aXZlLWZsYWdzXCI6e3BhdHRlcm46L1xcWyhcXHcsPykrXFxdL2csYWxpYXM6XCJrZXl3b3JkXCJ9LHN0cmluZzp7cGF0dGVybjovKFwifCcpLipcXDEvZyxpbnNpZGU6e3ZhcmlhYmxlOi8oXFwkfCUpXFx7PyhcXHdcXC4/KFxcK3xcXC18Oik/KStcXH0/L2d9fSx2YXJpYWJsZTovKFxcJHwlKVxcez8oXFx3XFwuPyhcXCt8XFwtfDopPykrXFx9Py9nLHJlZ2V4Oi9cXF4/LipcXCR8XFxeLipcXCQ/L2d9OztcblByaXNtLmxhbmd1YWdlcy5naXQ9e2NvbW1lbnQ6L14jLiokL20sc3RyaW5nOi8oXCJ8JykoXFxcXD8uKSo/XFwxL2dtLGNvbW1hbmQ6e3BhdHRlcm46L14uKlxcJCBnaXQgLiokL20saW5zaWRlOntwYXJhbWV0ZXI6L1xccygtLXwtKVxcdysvbX19LGNvb3JkOi9eQEAuKkBAJC9tLGRlbGV0ZWQ6L14tKD8hLSkuKyQvbSxpbnNlcnRlZDovXlxcKyg/IVxcKykuKyQvbSxjb21taXRfc2hhMTovXmNvbW1pdCBcXHd7NDB9JC9tfTs7XG4hZnVuY3Rpb24oZSl7dmFyIGE9L1xce1xce1xce1tcXHdcXFddKz9cXH1cXH1cXH18XFx7XFx7W1xcd1xcV10rP1xcfVxcfS9nO2UubGFuZ3VhZ2VzLmhhbmRsZWJhcnM9ZS5sYW5ndWFnZXMuZXh0ZW5kKFwibWFya3VwXCIse2hhbmRsZWJhcnM6e3BhdHRlcm46YSxpbnNpZGU6e2RlbGltaXRlcjp7cGF0dGVybjovXlxce1xce1xcez98XFx9XFx9XFx9PyQvZ2ksYWxpYXM6XCJwdW5jdHVhdGlvblwifSxzdHJpbmc6LyhbXCInXSkoXFxcXD8uKSs/XFwxL2csbnVtYmVyOi9cXGItPygweFtcXGRBLUZhLWZdK3xcXGQqXFwuP1xcZCsoW0VlXS0/XFxkKyk/KVxcYi9nLFwiYm9vbGVhblwiOi9cXGIodHJ1ZXxmYWxzZSlcXGIvZyxibG9jazp7cGF0dGVybjovXihcXHMqfj9cXHMqKVsjXFwvXVxcdysvZ2ksbG9va2JlaGluZDohMCxhbGlhczpcImtleXdvcmRcIn0sYnJhY2tldHM6e3BhdHRlcm46L1xcW1teXFxdXStcXF0vLGluc2lkZTp7cHVuY3R1YXRpb246L1xcW3xcXF0vZyx2YXJpYWJsZTovW1xcd1xcV10rL2d9fSxwdW5jdHVhdGlvbjovWyFcIiMlJicoKSorLC5cXC87PD0+QFxcW1xcXFxcXF1eYHt8fX5dL2csdmFyaWFibGU6L1teIVwiIyUmJygpKissLlxcLzs8PT5AXFxbXFxcXFxcXV5ge3x9fl0rL2d9fX0pLGUubGFuZ3VhZ2VzLmluc2VydEJlZm9yZShcImhhbmRsZWJhcnNcIixcInRhZ1wiLHtcImhhbmRsZWJhcnMtY29tbWVudFwiOntwYXR0ZXJuOi9cXHtcXHshW1xcd1xcV10qP1xcfVxcfS9nLGFsaWFzOltcImhhbmRsZWJhcnNcIixcImNvbW1lbnRcIl19fSksZS5ob29rcy5hZGQoXCJiZWZvcmUtaGlnaGxpZ2h0XCIsZnVuY3Rpb24oZSl7XCJoYW5kbGViYXJzXCI9PT1lLmxhbmd1YWdlJiYoZS50b2tlblN0YWNrPVtdLGUuYmFja3VwQ29kZT1lLmNvZGUsZS5jb2RlPWUuY29kZS5yZXBsYWNlKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGUudG9rZW5TdGFjay5wdXNoKGEpLFwiX19fSEFORExFQkFSU1wiK2UudG9rZW5TdGFjay5sZW5ndGgrXCJfX19cIn0pKX0pLGUuaG9va3MuYWRkKFwiYmVmb3JlLWluc2VydFwiLGZ1bmN0aW9uKGUpe1wiaGFuZGxlYmFyc1wiPT09ZS5sYW5ndWFnZSYmKGUuY29kZT1lLmJhY2t1cENvZGUsZGVsZXRlIGUuYmFja3VwQ29kZSl9KSxlLmhvb2tzLmFkZChcImFmdGVyLWhpZ2hsaWdodFwiLGZ1bmN0aW9uKGEpe2lmKFwiaGFuZGxlYmFyc1wiPT09YS5sYW5ndWFnZSl7Zm9yKHZhciBuLHQ9MDtuPWEudG9rZW5TdGFja1t0XTt0KyspYS5oaWdobGlnaHRlZENvZGU9YS5oaWdobGlnaHRlZENvZGUucmVwbGFjZShcIl9fX0hBTkRMRUJBUlNcIisodCsxKStcIl9fX1wiLGUuaGlnaGxpZ2h0KG4sYS5ncmFtbWFyLFwiaGFuZGxlYmFyc1wiKSk7YS5lbGVtZW50LmlubmVySFRNTD1hLmhpZ2hsaWdodGVkQ29kZX19KX0oUHJpc20pOztcblByaXNtLmhvb2tzLmFkZChcImFmdGVyLWhpZ2hsaWdodFwiLGZ1bmN0aW9uKGUpe3ZhciBuPWUuZWxlbWVudC5wYXJlbnROb2RlO2lmKG4mJi9wcmUvaS50ZXN0KG4ubm9kZU5hbWUpJiYtMSE9PW4uY2xhc3NOYW1lLmluZGV4T2YoXCJsaW5lLW51bWJlcnNcIikpe3ZhciB0LGE9MStlLmNvZGUuc3BsaXQoXCJcXG5cIikubGVuZ3RoO2xpbmVzPW5ldyBBcnJheShhKSxsaW5lcz1saW5lcy5qb2luKFwiPHNwYW4+PC9zcGFuPlwiKSx0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpLHQuY2xhc3NOYW1lPVwibGluZS1udW1iZXJzLXJvd3NcIix0LmlubmVySFRNTD1saW5lcyxuLmhhc0F0dHJpYnV0ZShcImRhdGEtc3RhcnRcIikmJihuLnN0eWxlLmNvdW50ZXJSZXNldD1cImxpbmVudW1iZXIgXCIrKHBhcnNlSW50KG4uZ2V0QXR0cmlidXRlKFwiZGF0YS1zdGFydFwiKSwxMCktMSkpLGUuZWxlbWVudC5hcHBlbmRDaGlsZCh0KX19KTs7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcmVzb3VyY2VzL2Fzc2V0cy9qcy92ZW5kb3IvcHJpc20uanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 10 */
/***/ function(module, exports) {

eval("/*\n* scotchPanels - v1.0.3 - 2014-09-25\n* https://github.com/scotch-io/scotch-panels\n* Copyright (c) 2014 Nicholas Cerminara <nick@scotch.io>\n*/\n// Start with Semicolon to block\n;(function($) {\n    // Enable Strict Mode\n    'use strict';\n    // Create Panels Array\n    var panels = [];\n    // Has done CSS3 browser support check?\n    var browserSupportTest = false;\n    var has3d = false;\n    var hasTransitions = false;\n    // Plugin Default Settings\n    var defaults = {\n        // General Config\n        containerSelector: 'body',\n        type: 'html', // html, iframe, video, image\n        // Styles\n        direction: 'top', // top, left, right, bottom\n        duration: 300, // ms\n        transition: 'ease', // linear, ease, ease-in, ease-out, ease-in-out, cubic-bezier(P1x,P1y,P2x,P2y)\n        // Browser Support\n        easingPluginTransition: 'easeInCirc',\n        useCSS: true,   // Consider not using if have Fixed Elements\n        useEasingPlugin: false, // http://gsgd.co.uk/sandbox/jquery/easing/ only for browser support\n        // Image Options\n        imageURL: false,\n        // Iframe Options\n        iframeURL: false,\n        // Video Options\n        autoPlayVideo: true,\n        youtubeID: false,\n        youTubeTheme: 'light',\n        // TranslateX Options\n        distanceX: '70%',\n        // TranslateY Options\n        forceMinHeight: false,\n        minHeight: '200px',\n        // Triggers\n        closeAfter: 0, // ms\n        startOpened: false,\n        startOpenedDelay: 0, // ms\n        // Event Helpers\n        clickSelector: false,\n        enableEscapeKey: true,\n        hoverSelector: false,\n        touchSelector: false,\n        // Callbacks\n        beforePanelOpen: function() {},\n        afterPanelOpen: function() {},\n        beforePanelClose: function() {},\n        afterPanelClose: function() {}\n    };\n    $.fn.scotchPanel = function(options) {\n        // Check to see if Default Options are Set\n        if (typeof options === 'undefined') {\n            options = {};\n        }\n        // Check to see if an element is even selected\n        if (this.length === 0) return this;\n        // Support selecting Panels\n        if (this.length > 1) {\n            // Loop through all selected scotch panels\n            this.each(function() {\n                // Add panel to array\n                panels.push($(this).scotchPanel(options));\n            });\n            // Public Functions Functionality for all at once\n            panels.open = function() {\n                for (var i = 0; i < panels.length; i++) {\n                    panels[i].open();\n                }\n            };\n            panels.close = function() {\n                for (var i = 0; i < panels.length; i++) {\n                    panels[i].close();\n                }\n            };\n            panels.toggle = function() {\n                for (var i = 0; i < panels.length; i++) {\n                    panels[i].toggle();\n                }\n            };\n            // Return the Scotch Panels\n            return panels;\n        }\n        // Create Current Scotch Panel Object\n        var panel = {};\n        panel = this;\n        /*=========================================\n        =            PRIVATE FUNCTIONS            =\n        =========================================*/\n        // Prep everything\n        var init = function() {\n            // Do CSS3 Check!\n            if (!browserSupportTest) {\n                browserSupportTest = true;\n                has3d = browserSupport.transition();\n                hasTransitions = browserSupport.translate3d();\n            }\n            // Check for HTML5 data attributes instead\n            for (var key in defaults) {\n                if (defaults.hasOwnProperty(key)) {\n                    if (panel.attr('data-'+key.toLowerCase())) {\n                        options[key] = panel.data(key.toLowerCase());\n                    }\n                }\n            }\n            // Merge Custom Plugin Settings with Default\n            panel.settings = $.extend({}, defaults, options);\n            // Start DOM and CSS Modifications\n            setup();\n        };\n        // DOM / CSS Changes / Make Things Happen\n        var setup = function() {\n            // Wrap the panel!\n            var container = $(panel.settings.containerSelector);\n            if (!container.hasClass('scotchified')) {\n                container.wrapInner('<div class=\"scotch-panel-wrapper\"><div class=\"scotch-panel-canvas\"></div></div>').addClass('scotchified');\n            }\n            // Scotch Panel Wrapper CSS\n            $('.scotch-panel-wrapper').css({\n                'position': 'relative',\n                'overflow': 'hidden',\n                'width': '100%'\n            });\n            // Scotch Panel Canvas CSS\n            $('.scotch-panel-canvas').css({\n                'position': 'relative',\n                'height': '100%',\n                'width': '100%'\n            });\n            // Do 3D Stuff separate\n            if (panel.settings.useCSS) {\n                $('.scotch-panel-canvas').css({\n                    '-moz-transform': 'translate3d(0, 0, 0)',\n                    '-ms-transform': 'translate3d(0, 0, 0)',\n                    '-o-transform': 'translate3d(0, 0, 0)',\n                    '-webkit-transform': 'translate3d(0, 0, 0)',\n                    'transform': 'translate3d(0, 0, 0)',\n                    '-moz-backface-visibility': 'hidden',\n                    '-ms-backface-visibility': 'hidden',\n                    '-o-backface-visibility': 'hidden',\n                    '-webkit-backface-visibility': 'hidden',\n                    'backface-visibility': 'hidden'\n                });\n            }\n            // Figure out which off canvas style is used (left, top, right)\n            if (panel.settings.direction == 'top') {\n                panel.height = panel.height();\n                panel.addClass('scotch-panel-top');\n                panel.css({\n                    'bottom': '100%',\n                    'left': '0',\n                    'width': '100%',\n                    'position': 'absolute',\n                    'z-index': '888888',\n                    'overflow': 'hidden'\n                });\n            }\n            if (panel.settings.direction == 'bottom') {\n                panel.height = panel.height();\n                panel.addClass('scotch-panel-bottom');\n                panel.css({\n                    'top': '100%',\n                    'left': '0',\n                    'width': '100%',\n                    'position': 'absolute',\n                    'z-index': '888888',\n                    'overflow': 'hidden'\n                });\n            }\n            if (panel.settings.direction == 'left') {\n                panel.addClass('scotch-panel-left');\n                panel.css({\n                    'top': '0',\n                    'left': '-' + panel.settings.distanceX,\n                    'width': panel.settings.distanceX,\n                    'height': '100%',\n                    'position': 'absolute',\n                    'z-index': '888888',\n                    'overflow': 'hidden'\n                });\n            }\n            if (panel.settings.direction == 'right') {\n                panel.addClass('scotch-panel-right');\n                panel.css({\n                    'top': '0',\n                    'right': '-' + panel.settings.distanceX,\n                    'width': panel.settings.distanceX,\n                    'height': '100%',\n                    'position': 'absolute',\n                    'z-index': '888888',\n                    'overflow': 'hidden'\n                });\n            }\n            panel.css({\n                '-moz-backface-visibility': 'hidden',\n                '-ms-backface-visibility': 'hidden',\n                '-o-backface-visibility': 'hidden',\n                '-webkit-backface-visibility': 'hidden',\n                'backface-visibility': 'hidden'\n            });\n            // Photo Logic\n            if (panel.settings.type == 'image' && panel.settings.imageURL) {\n                panel.css({\n                    '-o-background-size': 'cover',\n                    '-ms-background-size': 'cover',\n                    '-moz-background-size': 'cover',\n                    '-webkit-background-size': 'cover',\n                    'background-size': 'cover',\n                    'background-position': '50% 0',\n                    'background-repeat': 'no-repeat',\n                    'background-image': 'url('+panel.settings.imageURL+')'\n                });\n                // Update Panel Height if top or bottom\n                if (panel.settings.direction == 'top' || panel.settings.direction == 'bottom') {\n                    panel.css('min-height', panel.settings.minHeight);\n                    panel.height = $(panel).height();\n                }\n            }\n            // Iframe Logic\n            if (panel.settings.type == 'iframe' && panel.settings.iframeURL) {\n                panel.iframeIsLoaded = false;\n                panel.append('<iframe frameborder=\"0\" style=\"width: 100%; height: 100%; display: block; position: relative; min-height: '+panel.settings.minHeight+'\" allowfullscreen></iframe>');\n                // Update Panel Height if top or bottom\n                if (panel.settings.direction == 'top' || panel.settings.direction == 'bottom') {\n                    panel.height = $(panel).height();\n                }\n            }\n            // YouTube Logic\n            if (panel.settings.type == 'video' && panel.settings.youtubeID) {\n                panel.append('<div id=\"video-id-'+panel.settings.youtubeID+'\" style=\"min-height: '+panel.settings.minHeight+'; display: block !important;\"><iframe src=\"//www.youtube.com/embed/'+panel.settings.youtubeID+'?enablejsapi=1&theme='+panel.settings.youTubeTheme+'\" frameborder=\"0\" style=\"width: 100%; height: 100%; display: block; position: absolute; left: 0; top: 0;\" allowfullscreen></iframe></div>');\n                // Update Panel Height if top or bottom\n                if (panel.settings.direction == 'top' || panel.settings.direction == 'bottom') {\n                    panel.height = $(panel).height();\n                }\n            }\n            // Apply CSS3 Transitions if modern browser\n            if (has3d && hasTransitions) {\n                applyTransition(panel.settings.transition, panel.settings.duration);\n            }\n            // Open on Start?\n            if (panel.settings.startOpened) {\n                setTimeout(function(){\n                    panel.open();\n                }, panel.settings.startOpenedDelay);\n            }\n            // Close after X milliseconds?\n            if (panel.settings.closeAfter != 0) {\n                setTimeout(function(){\n                    panel.close();\n                }, panel.settings.closeAfter);\n            }\n        };\n        // Browser Support Object\n        var browserSupport = {\n            transition: function() {\n                // IE 7 + 8 Sucks\n                if (!window.getComputedStyle) {\n                    return false;\n                }\n                var b = document.body || document.documentElement,\n                    s = b.style,\n                    p = 'transition';\n                if (typeof s[p] == 'string') { return true; }\n                // Tests for vendor specific prop\n                var v = ['Moz', 'webkit', 'Webkit', 'Khtml', 'O', 'ms'];\n                p = p.charAt(0).toUpperCase() + p.substr(1);\n                for (var i=0; i<v.length; i++) {\n                    if (typeof s[v[i] + p] == 'string') { return true; }\n                }\n                return false;\n            },\n            translate3d: function() {\n                // IE 7 + 8 Sucks\n                if (!window.getComputedStyle) {\n                    return false;\n                }\n                var el, has3d;\n                el = document.createElement('p');\n                el.style['transform'] = 'matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)';\n                el.style['margin'] = '0';\n                document.body.insertBefore(el, document.body.lastChild);\n                has3d = window.getComputedStyle(el).getPropertyValue('transform');\n                if (has3d !== undefined) {\n                    return has3d !== 'none';\n                } else {\n                    return false;\n                }\n            }\n        };\n        // Toggle YouTube State (Play / Pause)\n        var toggleVideoState = function(element, state) {\n            var div = document.getElementById(element);\n            var iframe = div.getElementsByTagName('iframe')[0].contentWindow;\n            div.style.display = state == 'hide' ? 'none' : '';\n            var func = state == 'hide' ? 'pauseVideo' : 'playVideo';\n            iframe.postMessage('{\"event\":\"command\",\"func\":\"' + func + '\",\"args\":\"\"}','*');\n            div.style['display'] = 'block';\n        };\n        // Apply CSS Transitions\n        var applyTransition = function(transition, duration) {\n            panel.parents('.scotch-panel-canvas:first').css({\n                '-ms-transition': 'all '+duration+'ms '+transition,\n                '-moz-transition': 'all '+duration+'ms '+transition,\n                '-o-transition': 'all '+duration+'ms '+transition,\n                '-webkit-transition': 'all '+duration+'ms '+transition,\n                'transition': 'all '+duration+'ms '+transition\n            });\n        };\n        // Toggle Translate Y\n        var translateY = function(distanceY) {\n            // Auto adapt height if unknown and enabled\n            if (panel.settings.forceMinHeight) {\n                panel.parents('.scotch-panel-canvas:first').css('min-height', distanceY);\n            }\n            if (has3d && hasTransitions && panel.settings.useCSS) {\n                // Open/Close Before Callbacks (CSS)\n                if (panel.parents('.scotch-panel-canvas:first').hasClass('scotch-is-showing')) {\n                    panel.settings.beforePanelOpen();\n                } else {\n                    panel.settings.beforePanelClose();\n                }\n                panel.parents('.scotch-panel-canvas:first').css({\n                    '-ms-transform': 'translate3d(0, '+distanceY+'px, 0)',\n                    '-moz-transform': 'translate3d(0, '+distanceY+'px, 0)',\n                    '-o-transform': 'translate3d(0, '+distanceY+'px, 0)',\n                    '-webkit-transform': 'translate3d(0, '+distanceY+'px, 0)',\n                    'transform': 'translate3d(0, '+distanceY+'px, 0)'\n                });\n                setTimeout(function(){\n                    // Open/Close After Callbacks (CSS)\n                    if (panel.parents('.scotch-panel-canvas:first').hasClass('scotch-is-showing')) {\n                        panel.settings.afterPanelOpen();\n                    } else {\n                        panel.settings.afterPanelClose();\n                    }\n                }, panel.settings.duration);\n            } else {\n                // Open/Close Before Callbacks (JS)\n                if (panel.parents('.scotch-panel-canvas:first').hasClass('scotch-is-showing')) {\n                    panel.settings.beforePanelOpen();\n                } else {\n                    panel.settings.beforePanelClose();\n                }\n                if (panel.settings.useEasingPlugin) {\n                    panel.parents('.scotch-panel-canvas:first').animate({\n                        top: distanceY+'px'\n                    }, {\n                        duration: panel.settings.duration,\n                        easing: panel.settings.easingPluginTransition,\n                        complete: function() {\n                            // Open/Close After Callbacks (JS EASE)\n                            if (panel.parents('.scotch-panel-canvas:first').hasClass('scotch-is-showing')) {\n                                panel.settings.afterPanelOpen();\n                            } else {\n                                panel.settings.afterPanelClose();\n                            }\n                        }\n                    });\n                } else {\n                    panel.parents('.scotch-panel-canvas:first').animate({\n                        top: distanceY+'px'\n                    }, panel.settings.duration, function() {\n                        // Open/Close After Callbacks (JS NO EASE)\n                        if (panel.parents('.scotch-panel-canvas:first').hasClass('scotch-is-showing')) {\n                            panel.settings.afterPanelOpen();\n                        } else {\n                            panel.settings.afterPanelClose();\n                        }\n                    });\n                }\n            }\n        };\n        // Toggle Translate X\n        var translateX = function(distanceX) {\n            if (has3d && hasTransitions && panel.settings.useCSS) {\n                // Open/Close Before Callbacks (CSS)\n                if (panel.parents('.scotch-panel-canvas:first').hasClass('scotch-is-showing')) {\n                    panel.settings.beforePanelOpen();\n                } else {\n                    panel.settings.beforePanelClose();\n                }\n                panel.parents('.scotch-panel-canvas:first').css({\n                    '-ms-transform': 'translate3d('+distanceX+', 0, 0)',\n                    '-moz-transform': 'translate3d('+distanceX+', 0, 0)',\n                    '-o-transform': 'translate3d('+distanceX+', 0, 0)',\n                    '-webkit-transform': 'translate3d('+distanceX+', 0, 0)',\n                    'transform': 'translate3d('+distanceX+', 0, 0)'\n                });\n                setTimeout(function() {\n                    // Open/Close After Callbacks (CSS)\n                    if (panel.parents('.scotch-panel-canvas:first').hasClass('scotch-is-showing')) {\n                        panel.settings.afterPanelOpen();\n                    } else {\n                        panel.settings.afterPanelClose();\n                    }\n                }, panel.settings.duration);\n            } else {\n                // Open/Close Before Callbacks (JS)\n                if (panel.parents('.scotch-panel-canvas:first').hasClass('scotch-is-showing')) {\n                    panel.settings.beforePanelOpen();\n                } else {\n                    panel.settings.beforePanelClose();\n                }\n                if (panel.settings.useEasingPlugin) {\n                    panel.parents('.scotch-panel-canvas:first').animate({\n                        left: distanceX\n                    }, {\n                        duration: panel.settings.duration,\n                        easing: panel.settings.easingPluginTransition,\n                        complete: function() {\n                            // Open/Close After Callbacks (JS EASE)\n                            if (panel.parents('.scotch-panel-canvas:first').hasClass('scotch-is-showing')) {\n                                panel.settings.afterPanelOpen();\n                            } else {\n                                panel.settings.afterPanelClose();\n                            }\n                        }\n                    });\n                } else {\n                    panel.parents('.scotch-panel-canvas:first').animate({\n                        left: distanceX\n                    }, panel.settings.duration, function() {\n                        // Open/Close After Callbacks (JS NO EASE)\n                        if (panel.parents('.scotch-panel-canvas:first').hasClass('scotch-is-showing')) {\n                            panel.settings.afterPanelOpen();\n                        } else {\n                            panel.settings.afterPanelClose();\n                        }\n                    });\n                }\n            }\n        };\n        /*========================================\n        =            PUBLIC FUNCTIONS            =\n        ========================================*/\n        // Open the Scotch Panel\n        panel.open = function() {\n            panel.parents('.scotch-panel-canvas:first').addClass('scotch-is-showing');\n            // Load iframe if not loaded\n            if (panel.settings.type == 'iframe' && panel.settings.iframeURL && !panel.iframeIsLoaded) {\n                panel.iframeIsLoaded = true;\n                panel.find('iframe').attr('src', panel.settings.iframeURL);\n            }\n            // Play YouTube Video\n            if (panel.settings.type == 'video' && panel.settings.youtubeID && panel.settings.autoPlayVideo) {\n                toggleVideoState('video-id-'+panel.settings.youtubeID, '');\n            }\n            if (panel.settings.direction == 'top') {\n                translateY(panel.height);\n            }\n            if (panel.settings.direction == 'bottom') {\n                translateY('-' + panel.height);\n            }\n            if (panel.settings.direction == 'left') {\n                translateX(panel.settings.distanceX);\n            }\n            if (panel.settings.direction == 'right') {\n                translateX('-' + panel.settings.distanceX);\n            }\n        };\n        // Close ScotchPanel\n        panel.close = function() {\n            panel.parents('.scotch-panel-canvas:first').removeClass('scotch-is-showing');\n            // Pause YouTube Video (after close...)\n            setTimeout(function(){\n                if (panel.settings.type == 'video' && panel.settings.youtubeID && panel.settings.autoPlayVideo) {\n                    toggleVideoState('video-id-'+panel.settings.youtubeID, 'hide');\n                }\n            }, panel.settings.duration);\n            if (panel.settings.direction == 'top' || panel.settings.direction == 'bottom') {\n                translateY(0);\n            }\n            if (panel.settings.direction == 'left' || panel.settings.direction == 'right') {\n                translateX(0);\n            }\n        };\n        // Toggle ScotchPanel\n        panel.toggle = function() {\n            if (panel.parents('.scotch-panel-canvas:first').hasClass('scotch-is-showing')) {\n                panel.close();\n            } else {\n                panel.open();\n            }\n        };\n        /*=========================================\n        =            MAKE MAGIC HAPPEN            =\n        =========================================*/\n        init();\n        /*===============================\n        =            HELEPRS            =\n        ===============================*/\n        // Escape Key to Close\n        $(document).keyup(function(e) {\n            if (e.keyCode == 27 && panel.settings.enableEscapeKey) {\n                panel.close();\n            }\n        });\n        // Hover Helper\n        if (panel.settings.hoverSelector) {\n            $(panel.settings.hoverSelector).hover(function () {\n                panel.open();\n            },\n            function () {\n                panel.close();\n            });\n        }\n        // Click Helper\n        if (panel.settings.clickSelector) {\n            $(panel.settings.clickSelector).click(function () {\n                panel.toggle();\n                return false;\n            });\n        }\n        // Touch Helper\n        if (panel.settings.touchSelector) {\n            $(panel.settings.touchSelector).on('touchstart', function () {\n                panel.toggle();\n                return false;\n            });\n        }\n        // Return the Scotch Panel Object so Devs can do cool things with it\n        return panel;\n    };\n}(jQuery));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcmVzb3VyY2VzL2Fzc2V0cy9qcy92ZW5kb3Ivc2NvdGNoUGFuZWxzLmpzP2U5ZjEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiogc2NvdGNoUGFuZWxzIC0gdjEuMC4zIC0gMjAxNC0wOS0yNVxuKiBodHRwczovL2dpdGh1Yi5jb20vc2NvdGNoLWlvL3Njb3RjaC1wYW5lbHNcbiogQ29weXJpZ2h0IChjKSAyMDE0IE5pY2hvbGFzIENlcm1pbmFyYSA8bmlja0BzY290Y2guaW8+XG4qL1xuLy8gU3RhcnQgd2l0aCBTZW1pY29sb24gdG8gYmxvY2tcbjsoZnVuY3Rpb24oJCkge1xuICAgIC8vIEVuYWJsZSBTdHJpY3QgTW9kZVxuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBDcmVhdGUgUGFuZWxzIEFycmF5XG4gICAgdmFyIHBhbmVscyA9IFtdO1xuICAgIC8vIEhhcyBkb25lIENTUzMgYnJvd3NlciBzdXBwb3J0IGNoZWNrP1xuICAgIHZhciBicm93c2VyU3VwcG9ydFRlc3QgPSBmYWxzZTtcbiAgICB2YXIgaGFzM2QgPSBmYWxzZTtcbiAgICB2YXIgaGFzVHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICAvLyBQbHVnaW4gRGVmYXVsdCBTZXR0aW5nc1xuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgLy8gR2VuZXJhbCBDb25maWdcbiAgICAgICAgY29udGFpbmVyU2VsZWN0b3I6ICdib2R5JyxcbiAgICAgICAgdHlwZTogJ2h0bWwnLCAvLyBodG1sLCBpZnJhbWUsIHZpZGVvLCBpbWFnZVxuICAgICAgICAvLyBTdHlsZXNcbiAgICAgICAgZGlyZWN0aW9uOiAndG9wJywgLy8gdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tXG4gICAgICAgIGR1cmF0aW9uOiAzMDAsIC8vIG1zXG4gICAgICAgIHRyYW5zaXRpb246ICdlYXNlJywgLy8gbGluZWFyLCBlYXNlLCBlYXNlLWluLCBlYXNlLW91dCwgZWFzZS1pbi1vdXQsIGN1YmljLWJlemllcihQMXgsUDF5LFAyeCxQMnkpXG4gICAgICAgIC8vIEJyb3dzZXIgU3VwcG9ydFxuICAgICAgICBlYXNpbmdQbHVnaW5UcmFuc2l0aW9uOiAnZWFzZUluQ2lyYycsXG4gICAgICAgIHVzZUNTUzogdHJ1ZSwgICAvLyBDb25zaWRlciBub3QgdXNpbmcgaWYgaGF2ZSBGaXhlZCBFbGVtZW50c1xuICAgICAgICB1c2VFYXNpbmdQbHVnaW46IGZhbHNlLCAvLyBodHRwOi8vZ3NnZC5jby51ay9zYW5kYm94L2pxdWVyeS9lYXNpbmcvIG9ubHkgZm9yIGJyb3dzZXIgc3VwcG9ydFxuICAgICAgICAvLyBJbWFnZSBPcHRpb25zXG4gICAgICAgIGltYWdlVVJMOiBmYWxzZSxcbiAgICAgICAgLy8gSWZyYW1lIE9wdGlvbnNcbiAgICAgICAgaWZyYW1lVVJMOiBmYWxzZSxcbiAgICAgICAgLy8gVmlkZW8gT3B0aW9uc1xuICAgICAgICBhdXRvUGxheVZpZGVvOiB0cnVlLFxuICAgICAgICB5b3V0dWJlSUQ6IGZhbHNlLFxuICAgICAgICB5b3VUdWJlVGhlbWU6ICdsaWdodCcsXG4gICAgICAgIC8vIFRyYW5zbGF0ZVggT3B0aW9uc1xuICAgICAgICBkaXN0YW5jZVg6ICc3MCUnLFxuICAgICAgICAvLyBUcmFuc2xhdGVZIE9wdGlvbnNcbiAgICAgICAgZm9yY2VNaW5IZWlnaHQ6IGZhbHNlLFxuICAgICAgICBtaW5IZWlnaHQ6ICcyMDBweCcsXG4gICAgICAgIC8vIFRyaWdnZXJzXG4gICAgICAgIGNsb3NlQWZ0ZXI6IDAsIC8vIG1zXG4gICAgICAgIHN0YXJ0T3BlbmVkOiBmYWxzZSxcbiAgICAgICAgc3RhcnRPcGVuZWREZWxheTogMCwgLy8gbXNcbiAgICAgICAgLy8gRXZlbnQgSGVscGVyc1xuICAgICAgICBjbGlja1NlbGVjdG9yOiBmYWxzZSxcbiAgICAgICAgZW5hYmxlRXNjYXBlS2V5OiB0cnVlLFxuICAgICAgICBob3ZlclNlbGVjdG9yOiBmYWxzZSxcbiAgICAgICAgdG91Y2hTZWxlY3RvcjogZmFsc2UsXG4gICAgICAgIC8vIENhbGxiYWNrc1xuICAgICAgICBiZWZvcmVQYW5lbE9wZW46IGZ1bmN0aW9uKCkge30sXG4gICAgICAgIGFmdGVyUGFuZWxPcGVuOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICBiZWZvcmVQYW5lbENsb3NlOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICBhZnRlclBhbmVsQ2xvc2U6IGZ1bmN0aW9uKCkge31cbiAgICB9O1xuICAgICQuZm4uc2NvdGNoUGFuZWwgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiBEZWZhdWx0IE9wdGlvbnMgYXJlIFNldFxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIGFuIGVsZW1lbnQgaXMgZXZlbiBzZWxlY3RlZFxuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzO1xuICAgICAgICAvLyBTdXBwb3J0IHNlbGVjdGluZyBQYW5lbHNcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGFsbCBzZWxlY3RlZCBzY290Y2ggcGFuZWxzXG4gICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHBhbmVsIHRvIGFycmF5XG4gICAgICAgICAgICAgICAgcGFuZWxzLnB1c2goJCh0aGlzKS5zY290Y2hQYW5lbChvcHRpb25zKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFB1YmxpYyBGdW5jdGlvbnMgRnVuY3Rpb25hbGl0eSBmb3IgYWxsIGF0IG9uY2VcbiAgICAgICAgICAgIHBhbmVscy5vcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYW5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWxzW2ldLm9wZW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcGFuZWxzLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYW5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWxzW2ldLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBhbmVscy50b2dnbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhbmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwYW5lbHNbaV0udG9nZ2xlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgU2NvdGNoIFBhbmVsc1xuICAgICAgICAgICAgcmV0dXJuIHBhbmVscztcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgQ3VycmVudCBTY290Y2ggUGFuZWwgT2JqZWN0XG4gICAgICAgIHZhciBwYW5lbCA9IHt9O1xuICAgICAgICBwYW5lbCA9IHRoaXM7XG4gICAgICAgIC8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgPSAgICAgICAgICAgIFBSSVZBVEUgRlVOQ1RJT05TICAgICAgICAgICAgPVxuICAgICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4gICAgICAgIC8vIFByZXAgZXZlcnl0aGluZ1xuICAgICAgICB2YXIgaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gRG8gQ1NTMyBDaGVjayFcbiAgICAgICAgICAgIGlmICghYnJvd3NlclN1cHBvcnRUZXN0KSB7XG4gICAgICAgICAgICAgICAgYnJvd3NlclN1cHBvcnRUZXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBoYXMzZCA9IGJyb3dzZXJTdXBwb3J0LnRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgICAgICBoYXNUcmFuc2l0aW9ucyA9IGJyb3dzZXJTdXBwb3J0LnRyYW5zbGF0ZTNkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgSFRNTDUgZGF0YSBhdHRyaWJ1dGVzIGluc3RlYWRcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBkZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYW5lbC5hdHRyKCdkYXRhLScra2V5LnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zW2tleV0gPSBwYW5lbC5kYXRhKGtleS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1lcmdlIEN1c3RvbSBQbHVnaW4gU2V0dGluZ3Mgd2l0aCBEZWZhdWx0XG4gICAgICAgICAgICBwYW5lbC5zZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBTdGFydCBET00gYW5kIENTUyBNb2RpZmljYXRpb25zXG4gICAgICAgICAgICBzZXR1cCgpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBET00gLyBDU1MgQ2hhbmdlcyAvIE1ha2UgVGhpbmdzIEhhcHBlblxuICAgICAgICB2YXIgc2V0dXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFdyYXAgdGhlIHBhbmVsIVxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9ICQocGFuZWwuc2V0dGluZ3MuY29udGFpbmVyU2VsZWN0b3IpO1xuICAgICAgICAgICAgaWYgKCFjb250YWluZXIuaGFzQ2xhc3MoJ3Njb3RjaGlmaWVkJykpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIud3JhcElubmVyKCc8ZGl2IGNsYXNzPVwic2NvdGNoLXBhbmVsLXdyYXBwZXJcIj48ZGl2IGNsYXNzPVwic2NvdGNoLXBhbmVsLWNhbnZhc1wiPjwvZGl2PjwvZGl2PicpLmFkZENsYXNzKCdzY290Y2hpZmllZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2NvdGNoIFBhbmVsIFdyYXBwZXIgQ1NTXG4gICAgICAgICAgICAkKCcuc2NvdGNoLXBhbmVsLXdyYXBwZXInKS5jc3Moe1xuICAgICAgICAgICAgICAgICdwb3NpdGlvbic6ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAgICAgJ292ZXJmbG93JzogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgJ3dpZHRoJzogJzEwMCUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFNjb3RjaCBQYW5lbCBDYW52YXMgQ1NTXG4gICAgICAgICAgICAkKCcuc2NvdGNoLXBhbmVsLWNhbnZhcycpLmNzcyh7XG4gICAgICAgICAgICAgICAgJ3Bvc2l0aW9uJzogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgICAnaGVpZ2h0JzogJzEwMCUnLFxuICAgICAgICAgICAgICAgICd3aWR0aCc6ICcxMDAlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBEbyAzRCBTdHVmZiBzZXBhcmF0ZVxuICAgICAgICAgICAgaWYgKHBhbmVsLnNldHRpbmdzLnVzZUNTUykge1xuICAgICAgICAgICAgICAgICQoJy5zY290Y2gtcGFuZWwtY2FudmFzJykuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgJy1tb3otdHJhbnNmb3JtJzogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgICAgICAgICAgJy1tcy10cmFuc2Zvcm0nOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICAgICAgICAnLW8tdHJhbnNmb3JtJzogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgICAgICAgICAgJy13ZWJraXQtdHJhbnNmb3JtJzogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgICAgICAgICAgJ3RyYW5zZm9ybSc6ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICAgICAgICAgICAgICAgICctbW96LWJhY2tmYWNlLXZpc2liaWxpdHknOiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICAgICAgJy1tcy1iYWNrZmFjZS12aXNpYmlsaXR5JzogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgICctby1iYWNrZmFjZS12aXNpYmlsaXR5JzogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgICctd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHknOiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICAgICAgJ2JhY2tmYWNlLXZpc2liaWxpdHknOiAnaGlkZGVuJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmlndXJlIG91dCB3aGljaCBvZmYgY2FudmFzIHN0eWxlIGlzIHVzZWQgKGxlZnQsIHRvcCwgcmlnaHQpXG4gICAgICAgICAgICBpZiAocGFuZWwuc2V0dGluZ3MuZGlyZWN0aW9uID09ICd0b3AnKSB7XG4gICAgICAgICAgICAgICAgcGFuZWwuaGVpZ2h0ID0gcGFuZWwuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgcGFuZWwuYWRkQ2xhc3MoJ3Njb3RjaC1wYW5lbC10b3AnKTtcbiAgICAgICAgICAgICAgICBwYW5lbC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAnYm90dG9tJzogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICAnbGVmdCc6ICcwJyxcbiAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJzogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICAncG9zaXRpb24nOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgICAgICAnei1pbmRleCc6ICc4ODg4ODgnLFxuICAgICAgICAgICAgICAgICAgICAnb3ZlcmZsb3cnOiAnaGlkZGVuJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhbmVsLnNldHRpbmdzLmRpcmVjdGlvbiA9PSAnYm90dG9tJykge1xuICAgICAgICAgICAgICAgIHBhbmVsLmhlaWdodCA9IHBhbmVsLmhlaWdodCgpO1xuICAgICAgICAgICAgICAgIHBhbmVsLmFkZENsYXNzKCdzY290Y2gtcGFuZWwtYm90dG9tJyk7XG4gICAgICAgICAgICAgICAgcGFuZWwuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgJ3RvcCc6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2xlZnQnOiAnMCcsXG4gICAgICAgICAgICAgICAgICAgICd3aWR0aCc6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc2l0aW9uJzogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgJ3otaW5kZXgnOiAnODg4ODg4JyxcbiAgICAgICAgICAgICAgICAgICAgJ292ZXJmbG93JzogJ2hpZGRlbidcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYW5lbC5zZXR0aW5ncy5kaXJlY3Rpb24gPT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgICAgcGFuZWwuYWRkQ2xhc3MoJ3Njb3RjaC1wYW5lbC1sZWZ0Jyk7XG4gICAgICAgICAgICAgICAgcGFuZWwuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgJ3RvcCc6ICcwJyxcbiAgICAgICAgICAgICAgICAgICAgJ2xlZnQnOiAnLScgKyBwYW5lbC5zZXR0aW5ncy5kaXN0YW5jZVgsXG4gICAgICAgICAgICAgICAgICAgICd3aWR0aCc6IHBhbmVsLnNldHRpbmdzLmRpc3RhbmNlWCxcbiAgICAgICAgICAgICAgICAgICAgJ2hlaWdodCc6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc2l0aW9uJzogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgJ3otaW5kZXgnOiAnODg4ODg4JyxcbiAgICAgICAgICAgICAgICAgICAgJ292ZXJmbG93JzogJ2hpZGRlbidcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYW5lbC5zZXR0aW5ncy5kaXJlY3Rpb24gPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgIHBhbmVsLmFkZENsYXNzKCdzY290Y2gtcGFuZWwtcmlnaHQnKTtcbiAgICAgICAgICAgICAgICBwYW5lbC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAndG9wJzogJzAnLFxuICAgICAgICAgICAgICAgICAgICAncmlnaHQnOiAnLScgKyBwYW5lbC5zZXR0aW5ncy5kaXN0YW5jZVgsXG4gICAgICAgICAgICAgICAgICAgICd3aWR0aCc6IHBhbmVsLnNldHRpbmdzLmRpc3RhbmNlWCxcbiAgICAgICAgICAgICAgICAgICAgJ2hlaWdodCc6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc2l0aW9uJzogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgJ3otaW5kZXgnOiAnODg4ODg4JyxcbiAgICAgICAgICAgICAgICAgICAgJ292ZXJmbG93JzogJ2hpZGRlbidcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhbmVsLmNzcyh7XG4gICAgICAgICAgICAgICAgJy1tb3otYmFja2ZhY2UtdmlzaWJpbGl0eSc6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICctbXMtYmFja2ZhY2UtdmlzaWJpbGl0eSc6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICctby1iYWNrZmFjZS12aXNpYmlsaXR5JzogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgJy13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eSc6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICdiYWNrZmFjZS12aXNpYmlsaXR5JzogJ2hpZGRlbidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gUGhvdG8gTG9naWNcbiAgICAgICAgICAgIGlmIChwYW5lbC5zZXR0aW5ncy50eXBlID09ICdpbWFnZScgJiYgcGFuZWwuc2V0dGluZ3MuaW1hZ2VVUkwpIHtcbiAgICAgICAgICAgICAgICBwYW5lbC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAnLW8tYmFja2dyb3VuZC1zaXplJzogJ2NvdmVyJyxcbiAgICAgICAgICAgICAgICAgICAgJy1tcy1iYWNrZ3JvdW5kLXNpemUnOiAnY292ZXInLFxuICAgICAgICAgICAgICAgICAgICAnLW1vei1iYWNrZ3JvdW5kLXNpemUnOiAnY292ZXInLFxuICAgICAgICAgICAgICAgICAgICAnLXdlYmtpdC1iYWNrZ3JvdW5kLXNpemUnOiAnY292ZXInLFxuICAgICAgICAgICAgICAgICAgICAnYmFja2dyb3VuZC1zaXplJzogJ2NvdmVyJyxcbiAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmQtcG9zaXRpb24nOiAnNTAlIDAnLFxuICAgICAgICAgICAgICAgICAgICAnYmFja2dyb3VuZC1yZXBlYXQnOiAnbm8tcmVwZWF0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmQtaW1hZ2UnOiAndXJsKCcrcGFuZWwuc2V0dGluZ3MuaW1hZ2VVUkwrJyknXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIFBhbmVsIEhlaWdodCBpZiB0b3Agb3IgYm90dG9tXG4gICAgICAgICAgICAgICAgaWYgKHBhbmVsLnNldHRpbmdzLmRpcmVjdGlvbiA9PSAndG9wJyB8fCBwYW5lbC5zZXR0aW5ncy5kaXJlY3Rpb24gPT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWwuY3NzKCdtaW4taGVpZ2h0JywgcGFuZWwuc2V0dGluZ3MubWluSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWwuaGVpZ2h0ID0gJChwYW5lbCkuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWZyYW1lIExvZ2ljXG4gICAgICAgICAgICBpZiAocGFuZWwuc2V0dGluZ3MudHlwZSA9PSAnaWZyYW1lJyAmJiBwYW5lbC5zZXR0aW5ncy5pZnJhbWVVUkwpIHtcbiAgICAgICAgICAgICAgICBwYW5lbC5pZnJhbWVJc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHBhbmVsLmFwcGVuZCgnPGlmcmFtZSBmcmFtZWJvcmRlcj1cIjBcIiBzdHlsZT1cIndpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IGRpc3BsYXk6IGJsb2NrOyBwb3NpdGlvbjogcmVsYXRpdmU7IG1pbi1oZWlnaHQ6ICcrcGFuZWwuc2V0dGluZ3MubWluSGVpZ2h0KydcIiBhbGxvd2Z1bGxzY3JlZW4+PC9pZnJhbWU+Jyk7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIFBhbmVsIEhlaWdodCBpZiB0b3Agb3IgYm90dG9tXG4gICAgICAgICAgICAgICAgaWYgKHBhbmVsLnNldHRpbmdzLmRpcmVjdGlvbiA9PSAndG9wJyB8fCBwYW5lbC5zZXR0aW5ncy5kaXJlY3Rpb24gPT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWwuaGVpZ2h0ID0gJChwYW5lbCkuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gWW91VHViZSBMb2dpY1xuICAgICAgICAgICAgaWYgKHBhbmVsLnNldHRpbmdzLnR5cGUgPT0gJ3ZpZGVvJyAmJiBwYW5lbC5zZXR0aW5ncy55b3V0dWJlSUQpIHtcbiAgICAgICAgICAgICAgICBwYW5lbC5hcHBlbmQoJzxkaXYgaWQ9XCJ2aWRlby1pZC0nK3BhbmVsLnNldHRpbmdzLnlvdXR1YmVJRCsnXCIgc3R5bGU9XCJtaW4taGVpZ2h0OiAnK3BhbmVsLnNldHRpbmdzLm1pbkhlaWdodCsnOyBkaXNwbGF5OiBibG9jayAhaW1wb3J0YW50O1wiPjxpZnJhbWUgc3JjPVwiLy93d3cueW91dHViZS5jb20vZW1iZWQvJytwYW5lbC5zZXR0aW5ncy55b3V0dWJlSUQrJz9lbmFibGVqc2FwaT0xJnRoZW1lPScrcGFuZWwuc2V0dGluZ3MueW91VHViZVRoZW1lKydcIiBmcmFtZWJvcmRlcj1cIjBcIiBzdHlsZT1cIndpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IGRpc3BsYXk6IGJsb2NrOyBwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IDA7IHRvcDogMDtcIiBhbGxvd2Z1bGxzY3JlZW4+PC9pZnJhbWU+PC9kaXY+Jyk7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIFBhbmVsIEhlaWdodCBpZiB0b3Agb3IgYm90dG9tXG4gICAgICAgICAgICAgICAgaWYgKHBhbmVsLnNldHRpbmdzLmRpcmVjdGlvbiA9PSAndG9wJyB8fCBwYW5lbC5zZXR0aW5ncy5kaXJlY3Rpb24gPT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWwuaGVpZ2h0ID0gJChwYW5lbCkuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXBwbHkgQ1NTMyBUcmFuc2l0aW9ucyBpZiBtb2Rlcm4gYnJvd3NlclxuICAgICAgICAgICAgaWYgKGhhczNkICYmIGhhc1RyYW5zaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgYXBwbHlUcmFuc2l0aW9uKHBhbmVsLnNldHRpbmdzLnRyYW5zaXRpb24sIHBhbmVsLnNldHRpbmdzLmR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9wZW4gb24gU3RhcnQ/XG4gICAgICAgICAgICBpZiAocGFuZWwuc2V0dGluZ3Muc3RhcnRPcGVuZWQpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIHBhbmVsLm9wZW4oKTtcbiAgICAgICAgICAgICAgICB9LCBwYW5lbC5zZXR0aW5ncy5zdGFydE9wZW5lZERlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENsb3NlIGFmdGVyIFggbWlsbGlzZWNvbmRzP1xuICAgICAgICAgICAgaWYgKHBhbmVsLnNldHRpbmdzLmNsb3NlQWZ0ZXIgIT0gMCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWwuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9LCBwYW5lbC5zZXR0aW5ncy5jbG9zZUFmdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gQnJvd3NlciBTdXBwb3J0IE9iamVjdFxuICAgICAgICB2YXIgYnJvd3NlclN1cHBvcnQgPSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBJRSA3ICsgOCBTdWNrc1xuICAgICAgICAgICAgICAgIGlmICghd2luZG93LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYiA9IGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBzID0gYi5zdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgcCA9ICd0cmFuc2l0aW9uJztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNbcF0gPT0gJ3N0cmluZycpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgICAgICAgICAvLyBUZXN0cyBmb3IgdmVuZG9yIHNwZWNpZmljIHByb3BcbiAgICAgICAgICAgICAgICB2YXIgdiA9IFsnTW96JywgJ3dlYmtpdCcsICdXZWJraXQnLCAnS2h0bWwnLCAnTycsICdtcyddO1xuICAgICAgICAgICAgICAgIHAgPSBwLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcC5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzW3ZbaV0gKyBwXSA9PSAnc3RyaW5nJykgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhbnNsYXRlM2Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIElFIDcgKyA4IFN1Y2tzXG4gICAgICAgICAgICAgICAgaWYgKCF3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBlbCwgaGFzM2Q7XG4gICAgICAgICAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGVbJ3RyYW5zZm9ybSddID0gJ21hdHJpeDNkKDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpJztcbiAgICAgICAgICAgICAgICBlbC5zdHlsZVsnbWFyZ2luJ10gPSAnMCc7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5pbnNlcnRCZWZvcmUoZWwsIGRvY3VtZW50LmJvZHkubGFzdENoaWxkKTtcbiAgICAgICAgICAgICAgICBoYXMzZCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKCd0cmFuc2Zvcm0nKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzM2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzM2QgIT09ICdub25lJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBUb2dnbGUgWW91VHViZSBTdGF0ZSAoUGxheSAvIFBhdXNlKVxuICAgICAgICB2YXIgdG9nZ2xlVmlkZW9TdGF0ZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudCk7XG4gICAgICAgICAgICB2YXIgaWZyYW1lID0gZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpZnJhbWUnKVswXS5jb250ZW50V2luZG93O1xuICAgICAgICAgICAgZGl2LnN0eWxlLmRpc3BsYXkgPSBzdGF0ZSA9PSAnaGlkZScgPyAnbm9uZScgOiAnJztcbiAgICAgICAgICAgIHZhciBmdW5jID0gc3RhdGUgPT0gJ2hpZGUnID8gJ3BhdXNlVmlkZW8nIDogJ3BsYXlWaWRlbyc7XG4gICAgICAgICAgICBpZnJhbWUucG9zdE1lc3NhZ2UoJ3tcImV2ZW50XCI6XCJjb21tYW5kXCIsXCJmdW5jXCI6XCInICsgZnVuYyArICdcIixcImFyZ3NcIjpcIlwifScsJyonKTtcbiAgICAgICAgICAgIGRpdi5zdHlsZVsnZGlzcGxheSddID0gJ2Jsb2NrJztcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQXBwbHkgQ1NTIFRyYW5zaXRpb25zXG4gICAgICAgIHZhciBhcHBseVRyYW5zaXRpb24gPSBmdW5jdGlvbih0cmFuc2l0aW9uLCBkdXJhdGlvbikge1xuICAgICAgICAgICAgcGFuZWwucGFyZW50cygnLnNjb3RjaC1wYW5lbC1jYW52YXM6Zmlyc3QnKS5jc3Moe1xuICAgICAgICAgICAgICAgICctbXMtdHJhbnNpdGlvbic6ICdhbGwgJytkdXJhdGlvbisnbXMgJyt0cmFuc2l0aW9uLFxuICAgICAgICAgICAgICAgICctbW96LXRyYW5zaXRpb24nOiAnYWxsICcrZHVyYXRpb24rJ21zICcrdHJhbnNpdGlvbixcbiAgICAgICAgICAgICAgICAnLW8tdHJhbnNpdGlvbic6ICdhbGwgJytkdXJhdGlvbisnbXMgJyt0cmFuc2l0aW9uLFxuICAgICAgICAgICAgICAgICctd2Via2l0LXRyYW5zaXRpb24nOiAnYWxsICcrZHVyYXRpb24rJ21zICcrdHJhbnNpdGlvbixcbiAgICAgICAgICAgICAgICAndHJhbnNpdGlvbic6ICdhbGwgJytkdXJhdGlvbisnbXMgJyt0cmFuc2l0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVG9nZ2xlIFRyYW5zbGF0ZSBZXG4gICAgICAgIHZhciB0cmFuc2xhdGVZID0gZnVuY3Rpb24oZGlzdGFuY2VZKSB7XG4gICAgICAgICAgICAvLyBBdXRvIGFkYXB0IGhlaWdodCBpZiB1bmtub3duIGFuZCBlbmFibGVkXG4gICAgICAgICAgICBpZiAocGFuZWwuc2V0dGluZ3MuZm9yY2VNaW5IZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBwYW5lbC5wYXJlbnRzKCcuc2NvdGNoLXBhbmVsLWNhbnZhczpmaXJzdCcpLmNzcygnbWluLWhlaWdodCcsIGRpc3RhbmNlWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzM2QgJiYgaGFzVHJhbnNpdGlvbnMgJiYgcGFuZWwuc2V0dGluZ3MudXNlQ1NTKSB7XG4gICAgICAgICAgICAgICAgLy8gT3Blbi9DbG9zZSBCZWZvcmUgQ2FsbGJhY2tzIChDU1MpXG4gICAgICAgICAgICAgICAgaWYgKHBhbmVsLnBhcmVudHMoJy5zY290Y2gtcGFuZWwtY2FudmFzOmZpcnN0JykuaGFzQ2xhc3MoJ3Njb3RjaC1pcy1zaG93aW5nJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWwuc2V0dGluZ3MuYmVmb3JlUGFuZWxPcGVuKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWwuc2V0dGluZ3MuYmVmb3JlUGFuZWxDbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYW5lbC5wYXJlbnRzKCcuc2NvdGNoLXBhbmVsLWNhbnZhczpmaXJzdCcpLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICctbXMtdHJhbnNmb3JtJzogJ3RyYW5zbGF0ZTNkKDAsICcrZGlzdGFuY2VZKydweCwgMCknLFxuICAgICAgICAgICAgICAgICAgICAnLW1vei10cmFuc2Zvcm0nOiAndHJhbnNsYXRlM2QoMCwgJytkaXN0YW5jZVkrJ3B4LCAwKScsXG4gICAgICAgICAgICAgICAgICAgICctby10cmFuc2Zvcm0nOiAndHJhbnNsYXRlM2QoMCwgJytkaXN0YW5jZVkrJ3B4LCAwKScsXG4gICAgICAgICAgICAgICAgICAgICctd2Via2l0LXRyYW5zZm9ybSc6ICd0cmFuc2xhdGUzZCgwLCAnK2Rpc3RhbmNlWSsncHgsIDApJyxcbiAgICAgICAgICAgICAgICAgICAgJ3RyYW5zZm9ybSc6ICd0cmFuc2xhdGUzZCgwLCAnK2Rpc3RhbmNlWSsncHgsIDApJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3Blbi9DbG9zZSBBZnRlciBDYWxsYmFja3MgKENTUylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhbmVsLnBhcmVudHMoJy5zY290Y2gtcGFuZWwtY2FudmFzOmZpcnN0JykuaGFzQ2xhc3MoJ3Njb3RjaC1pcy1zaG93aW5nJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbmVsLnNldHRpbmdzLmFmdGVyUGFuZWxPcGVuKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYW5lbC5zZXR0aW5ncy5hZnRlclBhbmVsQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHBhbmVsLnNldHRpbmdzLmR1cmF0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3Blbi9DbG9zZSBCZWZvcmUgQ2FsbGJhY2tzIChKUylcbiAgICAgICAgICAgICAgICBpZiAocGFuZWwucGFyZW50cygnLnNjb3RjaC1wYW5lbC1jYW52YXM6Zmlyc3QnKS5oYXNDbGFzcygnc2NvdGNoLWlzLXNob3dpbmcnKSkge1xuICAgICAgICAgICAgICAgICAgICBwYW5lbC5zZXR0aW5ncy5iZWZvcmVQYW5lbE9wZW4oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYW5lbC5zZXR0aW5ncy5iZWZvcmVQYW5lbENsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYW5lbC5zZXR0aW5ncy51c2VFYXNpbmdQbHVnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWwucGFyZW50cygnLnNjb3RjaC1wYW5lbC1jYW52YXM6Zmlyc3QnKS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogZGlzdGFuY2VZKydweCdcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IHBhbmVsLnNldHRpbmdzLmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWFzaW5nOiBwYW5lbC5zZXR0aW5ncy5lYXNpbmdQbHVnaW5UcmFuc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZW4vQ2xvc2UgQWZ0ZXIgQ2FsbGJhY2tzIChKUyBFQVNFKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYW5lbC5wYXJlbnRzKCcuc2NvdGNoLXBhbmVsLWNhbnZhczpmaXJzdCcpLmhhc0NsYXNzKCdzY290Y2gtaXMtc2hvd2luZycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhbmVsLnNldHRpbmdzLmFmdGVyUGFuZWxPcGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFuZWwuc2V0dGluZ3MuYWZ0ZXJQYW5lbENsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYW5lbC5wYXJlbnRzKCcuc2NvdGNoLXBhbmVsLWNhbnZhczpmaXJzdCcpLmFuaW1hdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBkaXN0YW5jZVkrJ3B4J1xuICAgICAgICAgICAgICAgICAgICB9LCBwYW5lbC5zZXR0aW5ncy5kdXJhdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVuL0Nsb3NlIEFmdGVyIENhbGxiYWNrcyAoSlMgTk8gRUFTRSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYW5lbC5wYXJlbnRzKCcuc2NvdGNoLXBhbmVsLWNhbnZhczpmaXJzdCcpLmhhc0NsYXNzKCdzY290Y2gtaXMtc2hvd2luZycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFuZWwuc2V0dGluZ3MuYWZ0ZXJQYW5lbE9wZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFuZWwuc2V0dGluZ3MuYWZ0ZXJQYW5lbENsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gVG9nZ2xlIFRyYW5zbGF0ZSBYXG4gICAgICAgIHZhciB0cmFuc2xhdGVYID0gZnVuY3Rpb24oZGlzdGFuY2VYKSB7XG4gICAgICAgICAgICBpZiAoaGFzM2QgJiYgaGFzVHJhbnNpdGlvbnMgJiYgcGFuZWwuc2V0dGluZ3MudXNlQ1NTKSB7XG4gICAgICAgICAgICAgICAgLy8gT3Blbi9DbG9zZSBCZWZvcmUgQ2FsbGJhY2tzIChDU1MpXG4gICAgICAgICAgICAgICAgaWYgKHBhbmVsLnBhcmVudHMoJy5zY290Y2gtcGFuZWwtY2FudmFzOmZpcnN0JykuaGFzQ2xhc3MoJ3Njb3RjaC1pcy1zaG93aW5nJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWwuc2V0dGluZ3MuYmVmb3JlUGFuZWxPcGVuKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWwuc2V0dGluZ3MuYmVmb3JlUGFuZWxDbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYW5lbC5wYXJlbnRzKCcuc2NvdGNoLXBhbmVsLWNhbnZhczpmaXJzdCcpLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICctbXMtdHJhbnNmb3JtJzogJ3RyYW5zbGF0ZTNkKCcrZGlzdGFuY2VYKycsIDAsIDApJyxcbiAgICAgICAgICAgICAgICAgICAgJy1tb3otdHJhbnNmb3JtJzogJ3RyYW5zbGF0ZTNkKCcrZGlzdGFuY2VYKycsIDAsIDApJyxcbiAgICAgICAgICAgICAgICAgICAgJy1vLXRyYW5zZm9ybSc6ICd0cmFuc2xhdGUzZCgnK2Rpc3RhbmNlWCsnLCAwLCAwKScsXG4gICAgICAgICAgICAgICAgICAgICctd2Via2l0LXRyYW5zZm9ybSc6ICd0cmFuc2xhdGUzZCgnK2Rpc3RhbmNlWCsnLCAwLCAwKScsXG4gICAgICAgICAgICAgICAgICAgICd0cmFuc2Zvcm0nOiAndHJhbnNsYXRlM2QoJytkaXN0YW5jZVgrJywgMCwgMCknXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3Blbi9DbG9zZSBBZnRlciBDYWxsYmFja3MgKENTUylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhbmVsLnBhcmVudHMoJy5zY290Y2gtcGFuZWwtY2FudmFzOmZpcnN0JykuaGFzQ2xhc3MoJ3Njb3RjaC1pcy1zaG93aW5nJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbmVsLnNldHRpbmdzLmFmdGVyUGFuZWxPcGVuKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYW5lbC5zZXR0aW5ncy5hZnRlclBhbmVsQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHBhbmVsLnNldHRpbmdzLmR1cmF0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3Blbi9DbG9zZSBCZWZvcmUgQ2FsbGJhY2tzIChKUylcbiAgICAgICAgICAgICAgICBpZiAocGFuZWwucGFyZW50cygnLnNjb3RjaC1wYW5lbC1jYW52YXM6Zmlyc3QnKS5oYXNDbGFzcygnc2NvdGNoLWlzLXNob3dpbmcnKSkge1xuICAgICAgICAgICAgICAgICAgICBwYW5lbC5zZXR0aW5ncy5iZWZvcmVQYW5lbE9wZW4oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYW5lbC5zZXR0aW5ncy5iZWZvcmVQYW5lbENsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYW5lbC5zZXR0aW5ncy51c2VFYXNpbmdQbHVnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWwucGFyZW50cygnLnNjb3RjaC1wYW5lbC1jYW52YXM6Zmlyc3QnKS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGRpc3RhbmNlWFxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogcGFuZWwuc2V0dGluZ3MuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBlYXNpbmc6IHBhbmVsLnNldHRpbmdzLmVhc2luZ1BsdWdpblRyYW5zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3Blbi9DbG9zZSBBZnRlciBDYWxsYmFja3MgKEpTIEVBU0UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhbmVsLnBhcmVudHMoJy5zY290Y2gtcGFuZWwtY2FudmFzOmZpcnN0JykuaGFzQ2xhc3MoJ3Njb3RjaC1pcy1zaG93aW5nJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFuZWwuc2V0dGluZ3MuYWZ0ZXJQYW5lbE9wZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYW5lbC5zZXR0aW5ncy5hZnRlclBhbmVsQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhbmVsLnBhcmVudHMoJy5zY290Y2gtcGFuZWwtY2FudmFzOmZpcnN0JykuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBkaXN0YW5jZVhcbiAgICAgICAgICAgICAgICAgICAgfSwgcGFuZWwuc2V0dGluZ3MuZHVyYXRpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3Blbi9DbG9zZSBBZnRlciBDYWxsYmFja3MgKEpTIE5PIEVBU0UpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFuZWwucGFyZW50cygnLnNjb3RjaC1wYW5lbC1jYW52YXM6Zmlyc3QnKS5oYXNDbGFzcygnc2NvdGNoLWlzLXNob3dpbmcnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhbmVsLnNldHRpbmdzLmFmdGVyUGFuZWxPcGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhbmVsLnNldHRpbmdzLmFmdGVyUGFuZWxDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICA9ICAgICAgICAgICAgUFVCTElDIEZVTkNUSU9OUyAgICAgICAgICAgID1cbiAgICAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4gICAgICAgIC8vIE9wZW4gdGhlIFNjb3RjaCBQYW5lbFxuICAgICAgICBwYW5lbC5vcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBwYW5lbC5wYXJlbnRzKCcuc2NvdGNoLXBhbmVsLWNhbnZhczpmaXJzdCcpLmFkZENsYXNzKCdzY290Y2gtaXMtc2hvd2luZycpO1xuICAgICAgICAgICAgLy8gTG9hZCBpZnJhbWUgaWYgbm90IGxvYWRlZFxuICAgICAgICAgICAgaWYgKHBhbmVsLnNldHRpbmdzLnR5cGUgPT0gJ2lmcmFtZScgJiYgcGFuZWwuc2V0dGluZ3MuaWZyYW1lVVJMICYmICFwYW5lbC5pZnJhbWVJc0xvYWRlZCkge1xuICAgICAgICAgICAgICAgIHBhbmVsLmlmcmFtZUlzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwYW5lbC5maW5kKCdpZnJhbWUnKS5hdHRyKCdzcmMnLCBwYW5lbC5zZXR0aW5ncy5pZnJhbWVVUkwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGxheSBZb3VUdWJlIFZpZGVvXG4gICAgICAgICAgICBpZiAocGFuZWwuc2V0dGluZ3MudHlwZSA9PSAndmlkZW8nICYmIHBhbmVsLnNldHRpbmdzLnlvdXR1YmVJRCAmJiBwYW5lbC5zZXR0aW5ncy5hdXRvUGxheVZpZGVvKSB7XG4gICAgICAgICAgICAgICAgdG9nZ2xlVmlkZW9TdGF0ZSgndmlkZW8taWQtJytwYW5lbC5zZXR0aW5ncy55b3V0dWJlSUQsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYW5lbC5zZXR0aW5ncy5kaXJlY3Rpb24gPT0gJ3RvcCcpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVZKHBhbmVsLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFuZWwuc2V0dGluZ3MuZGlyZWN0aW9uID09ICdib3R0b20nKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWSgnLScgKyBwYW5lbC5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhbmVsLnNldHRpbmdzLmRpcmVjdGlvbiA9PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVYKHBhbmVsLnNldHRpbmdzLmRpc3RhbmNlWCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFuZWwuc2V0dGluZ3MuZGlyZWN0aW9uID09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVYKCctJyArIHBhbmVsLnNldHRpbmdzLmRpc3RhbmNlWCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIENsb3NlIFNjb3RjaFBhbmVsXG4gICAgICAgIHBhbmVsLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBwYW5lbC5wYXJlbnRzKCcuc2NvdGNoLXBhbmVsLWNhbnZhczpmaXJzdCcpLnJlbW92ZUNsYXNzKCdzY290Y2gtaXMtc2hvd2luZycpO1xuICAgICAgICAgICAgLy8gUGF1c2UgWW91VHViZSBWaWRlbyAoYWZ0ZXIgY2xvc2UuLi4pXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgaWYgKHBhbmVsLnNldHRpbmdzLnR5cGUgPT0gJ3ZpZGVvJyAmJiBwYW5lbC5zZXR0aW5ncy55b3V0dWJlSUQgJiYgcGFuZWwuc2V0dGluZ3MuYXV0b1BsYXlWaWRlbykge1xuICAgICAgICAgICAgICAgICAgICB0b2dnbGVWaWRlb1N0YXRlKCd2aWRlby1pZC0nK3BhbmVsLnNldHRpbmdzLnlvdXR1YmVJRCwgJ2hpZGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBwYW5lbC5zZXR0aW5ncy5kdXJhdGlvbik7XG4gICAgICAgICAgICBpZiAocGFuZWwuc2V0dGluZ3MuZGlyZWN0aW9uID09ICd0b3AnIHx8IHBhbmVsLnNldHRpbmdzLmRpcmVjdGlvbiA9PSAnYm90dG9tJykge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVkoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFuZWwuc2V0dGluZ3MuZGlyZWN0aW9uID09ICdsZWZ0JyB8fCBwYW5lbC5zZXR0aW5ncy5kaXJlY3Rpb24gPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVgoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRvZ2dsZSBTY290Y2hQYW5lbFxuICAgICAgICBwYW5lbC50b2dnbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChwYW5lbC5wYXJlbnRzKCcuc2NvdGNoLXBhbmVsLWNhbnZhczpmaXJzdCcpLmhhc0NsYXNzKCdzY290Y2gtaXMtc2hvd2luZycpKSB7XG4gICAgICAgICAgICAgICAgcGFuZWwuY2xvc2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFuZWwub3BlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgID0gICAgICAgICAgICBNQUtFIE1BR0lDIEhBUFBFTiAgICAgICAgICAgID1cbiAgICAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuICAgICAgICBpbml0KCk7XG4gICAgICAgIC8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICA9ICAgICAgICAgICAgSEVMRVBSUyAgICAgICAgICAgID1cbiAgICAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4gICAgICAgIC8vIEVzY2FwZSBLZXkgdG8gQ2xvc2VcbiAgICAgICAgJChkb2N1bWVudCkua2V5dXAoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAyNyAmJiBwYW5lbC5zZXR0aW5ncy5lbmFibGVFc2NhcGVLZXkpIHtcbiAgICAgICAgICAgICAgICBwYW5lbC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSG92ZXIgSGVscGVyXG4gICAgICAgIGlmIChwYW5lbC5zZXR0aW5ncy5ob3ZlclNlbGVjdG9yKSB7XG4gICAgICAgICAgICAkKHBhbmVsLnNldHRpbmdzLmhvdmVyU2VsZWN0b3IpLmhvdmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwYW5lbC5vcGVuKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHBhbmVsLmNsb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGljayBIZWxwZXJcbiAgICAgICAgaWYgKHBhbmVsLnNldHRpbmdzLmNsaWNrU2VsZWN0b3IpIHtcbiAgICAgICAgICAgICQocGFuZWwuc2V0dGluZ3MuY2xpY2tTZWxlY3RvcikuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHBhbmVsLnRvZ2dsZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRvdWNoIEhlbHBlclxuICAgICAgICBpZiAocGFuZWwuc2V0dGluZ3MudG91Y2hTZWxlY3Rvcikge1xuICAgICAgICAgICAgJChwYW5lbC5zZXR0aW5ncy50b3VjaFNlbGVjdG9yKS5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwYW5lbC50b2dnbGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gdGhlIFNjb3RjaCBQYW5lbCBPYmplY3Qgc28gRGV2cyBjYW4gZG8gY29vbCB0aGluZ3Mgd2l0aCBpdFxuICAgICAgICByZXR1cm4gcGFuZWw7XG4gICAgfTtcbn0oalF1ZXJ5KSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHJlc291cmNlcy9hc3NldHMvanMvdmVuZG9yL3Njb3RjaFBhbmVscy5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQU1BOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(setImmediate) {/*!\n * typeahead.js 0.10.5\n * https://github.com/twitter/typeahead.js\n * Copyright 2013-2014 Twitter, Inc. and other contributors; Licensed MIT\n */\n\n(function($) {\n    var _ = function() {\n        \"use strict\";\n        return {\n            isMsie: function() {\n                return /(msie|trident)/i.test(navigator.userAgent) ? navigator.userAgent.match(/(msie |rv:)(\\d+(.\\d+)?)/i)[2] : false;\n            },\n            isBlankString: function(str) {\n                return !str || /^\\s*$/.test(str);\n            },\n            escapeRegExChars: function(str) {\n                return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n            },\n            isString: function(obj) {\n                return typeof obj === \"string\";\n            },\n            isNumber: function(obj) {\n                return typeof obj === \"number\";\n            },\n            isArray: $.isArray,\n            isFunction: $.isFunction,\n            isObject: $.isPlainObject,\n            isUndefined: function(obj) {\n                return typeof obj === \"undefined\";\n            },\n            toStr: function toStr(s) {\n                return _.isUndefined(s) || s === null ? \"\" : s + \"\";\n            },\n            bind: $.proxy,\n            each: function(collection, cb) {\n                $.each(collection, reverseArgs);\n                function reverseArgs(index, value) {\n                    return cb(value, index);\n                }\n            },\n            map: $.map,\n            filter: $.grep,\n            every: function(obj, test) {\n                var result = true;\n                if (!obj) {\n                    return result;\n                }\n                $.each(obj, function(key, val) {\n                    if (!(result = test.call(null, val, key, obj))) {\n                        return false;\n                    }\n                });\n                return !!result;\n            },\n            some: function(obj, test) {\n                var result = false;\n                if (!obj) {\n                    return result;\n                }\n                $.each(obj, function(key, val) {\n                    if (result = test.call(null, val, key, obj)) {\n                        return false;\n                    }\n                });\n                return !!result;\n            },\n            mixin: $.extend,\n            getUniqueId: function() {\n                var counter = 0;\n                return function() {\n                    return counter++;\n                };\n            }(),\n            templatify: function templatify(obj) {\n                return $.isFunction(obj) ? obj : template;\n                function template() {\n                    return String(obj);\n                }\n            },\n            defer: function(fn) {\n                setTimeout(fn, 0);\n            },\n            debounce: function(func, wait, immediate) {\n                var timeout, result;\n                return function() {\n                    var context = this, args = arguments, later, callNow;\n                    later = function() {\n                        timeout = null;\n                        if (!immediate) {\n                            result = func.apply(context, args);\n                        }\n                    };\n                    callNow = immediate && !timeout;\n                    clearTimeout(timeout);\n                    timeout = setTimeout(later, wait);\n                    if (callNow) {\n                        result = func.apply(context, args);\n                    }\n                    return result;\n                };\n            },\n            throttle: function(func, wait) {\n                var context, args, timeout, result, previous, later;\n                previous = 0;\n                later = function() {\n                    previous = new Date();\n                    timeout = null;\n                    result = func.apply(context, args);\n                };\n                return function() {\n                    var now = new Date(), remaining = wait - (now - previous);\n                    context = this;\n                    args = arguments;\n                    if (remaining <= 0) {\n                        clearTimeout(timeout);\n                        timeout = null;\n                        previous = now;\n                        result = func.apply(context, args);\n                    } else if (!timeout) {\n                        timeout = setTimeout(later, remaining);\n                    }\n                    return result;\n                };\n            },\n            noop: function() {}\n        };\n    }();\n    var VERSION = \"0.10.5\";\n    var tokenizers = function() {\n        \"use strict\";\n        return {\n            nonword: nonword,\n            whitespace: whitespace,\n            obj: {\n                nonword: getObjTokenizer(nonword),\n                whitespace: getObjTokenizer(whitespace)\n            }\n        };\n        function whitespace(str) {\n            str = _.toStr(str);\n            return str ? str.split(/\\s+/) : [];\n        }\n        function nonword(str) {\n            str = _.toStr(str);\n            return str ? str.split(/\\W+/) : [];\n        }\n        function getObjTokenizer(tokenizer) {\n            return function setKey() {\n                var args = [].slice.call(arguments, 0);\n                return function tokenize(o) {\n                    var tokens = [];\n                    _.each(args, function(k) {\n                        tokens = tokens.concat(tokenizer(_.toStr(o[k])));\n                    });\n                    return tokens;\n                };\n            };\n        }\n    }();\n    var LruCache = function() {\n        \"use strict\";\n        function LruCache(maxSize) {\n            this.maxSize = _.isNumber(maxSize) ? maxSize : 100;\n            this.reset();\n            if (this.maxSize <= 0) {\n                this.set = this.get = $.noop;\n            }\n        }\n        _.mixin(LruCache.prototype, {\n            set: function set(key, val) {\n                var tailItem = this.list.tail, node;\n                if (this.size >= this.maxSize) {\n                    this.list.remove(tailItem);\n                    delete this.hash[tailItem.key];\n                }\n                if (node = this.hash[key]) {\n                    node.val = val;\n                    this.list.moveToFront(node);\n                } else {\n                    node = new Node(key, val);\n                    this.list.add(node);\n                    this.hash[key] = node;\n                    this.size++;\n                }\n            },\n            get: function get(key) {\n                var node = this.hash[key];\n                if (node) {\n                    this.list.moveToFront(node);\n                    return node.val;\n                }\n            },\n            reset: function reset() {\n                this.size = 0;\n                this.hash = {};\n                this.list = new List();\n            }\n        });\n        function List() {\n            this.head = this.tail = null;\n        }\n        _.mixin(List.prototype, {\n            add: function add(node) {\n                if (this.head) {\n                    node.next = this.head;\n                    this.head.prev = node;\n                }\n                this.head = node;\n                this.tail = this.tail || node;\n            },\n            remove: function remove(node) {\n                node.prev ? node.prev.next = node.next : this.head = node.next;\n                node.next ? node.next.prev = node.prev : this.tail = node.prev;\n            },\n            moveToFront: function(node) {\n                this.remove(node);\n                this.add(node);\n            }\n        });\n        function Node(key, val) {\n            this.key = key;\n            this.val = val;\n            this.prev = this.next = null;\n        }\n        return LruCache;\n    }();\n    var PersistentStorage = function() {\n        \"use strict\";\n        var ls, methods;\n        try {\n            ls = window.localStorage;\n            ls.setItem(\"~~~\", \"!\");\n            ls.removeItem(\"~~~\");\n        } catch (err) {\n            ls = null;\n        }\n        function PersistentStorage(namespace) {\n            this.prefix = [ \"__\", namespace, \"__\" ].join(\"\");\n            this.ttlKey = \"__ttl__\";\n            this.keyMatcher = new RegExp(\"^\" + _.escapeRegExChars(this.prefix));\n        }\n        if (ls && window.JSON) {\n            methods = {\n                _prefix: function(key) {\n                    return this.prefix + key;\n                },\n                _ttlKey: function(key) {\n                    return this._prefix(key) + this.ttlKey;\n                },\n                get: function(key) {\n                    if (this.isExpired(key)) {\n                        this.remove(key);\n                    }\n                    return decode(ls.getItem(this._prefix(key)));\n                },\n                set: function(key, val, ttl) {\n                    if (_.isNumber(ttl)) {\n                        ls.setItem(this._ttlKey(key), encode(now() + ttl));\n                    } else {\n                        ls.removeItem(this._ttlKey(key));\n                    }\n                    return ls.setItem(this._prefix(key), encode(val));\n                },\n                remove: function(key) {\n                    ls.removeItem(this._ttlKey(key));\n                    ls.removeItem(this._prefix(key));\n                    return this;\n                },\n                clear: function() {\n                    var this$1 = this;\n\n                    var i, key, keys = [], len = ls.length;\n                    for (i = 0; i < len; i++) {\n                        if ((key = ls.key(i)).match(this$1.keyMatcher)) {\n                            keys.push(key.replace(this$1.keyMatcher, \"\"));\n                        }\n                    }\n                    for (i = keys.length; i--; ) {\n                        this$1.remove(keys[i]);\n                    }\n                    return this;\n                },\n                isExpired: function(key) {\n                    var ttl = decode(ls.getItem(this._ttlKey(key)));\n                    return _.isNumber(ttl) && now() > ttl ? true : false;\n                }\n            };\n        } else {\n            methods = {\n                get: _.noop,\n                set: _.noop,\n                remove: _.noop,\n                clear: _.noop,\n                isExpired: _.noop\n            };\n        }\n        _.mixin(PersistentStorage.prototype, methods);\n        return PersistentStorage;\n        function now() {\n            return new Date().getTime();\n        }\n        function encode(val) {\n            return JSON.stringify(_.isUndefined(val) ? null : val);\n        }\n        function decode(val) {\n            return JSON.parse(val);\n        }\n    }();\n    var Transport = function() {\n        \"use strict\";\n        var pendingRequestsCount = 0, pendingRequests = {}, maxPendingRequests = 6, sharedCache = new LruCache(10);\n        function Transport(o) {\n            o = o || {};\n            this.cancelled = false;\n            this.lastUrl = null;\n            this._send = o.transport ? callbackToDeferred(o.transport) : $.ajax;\n            this._get = o.rateLimiter ? o.rateLimiter(this._get) : this._get;\n            this._cache = o.cache === false ? new LruCache(0) : sharedCache;\n        }\n        Transport.setMaxPendingRequests = function setMaxPendingRequests(num) {\n            maxPendingRequests = num;\n        };\n        Transport.resetCache = function resetCache() {\n            sharedCache.reset();\n        };\n        _.mixin(Transport.prototype, {\n            _get: function(url, o, cb) {\n                var that = this, jqXhr;\n                if (this.cancelled || url !== this.lastUrl) {\n                    return;\n                }\n                if (jqXhr = pendingRequests[url]) {\n                    jqXhr.done(done).fail(fail);\n                } else if (pendingRequestsCount < maxPendingRequests) {\n                    pendingRequestsCount++;\n                    pendingRequests[url] = this._send(url, o).done(done).fail(fail).always(always);\n                } else {\n                    this.onDeckRequestArgs = [].slice.call(arguments, 0);\n                }\n                function done(resp) {\n                    cb && cb(null, resp);\n                    that._cache.set(url, resp);\n                }\n                function fail() {\n                    cb && cb(true);\n                }\n                function always() {\n                    pendingRequestsCount--;\n                    delete pendingRequests[url];\n                    if (that.onDeckRequestArgs) {\n                        that._get.apply(that, that.onDeckRequestArgs);\n                        that.onDeckRequestArgs = null;\n                    }\n                }\n            },\n            get: function(url, o, cb) {\n                var resp;\n                if (_.isFunction(o)) {\n                    cb = o;\n                    o = {};\n                }\n                this.cancelled = false;\n                this.lastUrl = url;\n                if (resp = this._cache.get(url)) {\n                    _.defer(function() {\n                        cb && cb(null, resp);\n                    });\n                } else {\n                    this._get(url, o, cb);\n                }\n                return !!resp;\n            },\n            cancel: function() {\n                this.cancelled = true;\n            }\n        });\n        return Transport;\n        function callbackToDeferred(fn) {\n            return function customSendWrapper(url, o) {\n                var deferred = $.Deferred();\n                fn(url, o, onSuccess, onError);\n                return deferred;\n                function onSuccess(resp) {\n                    _.defer(function() {\n                        deferred.resolve(resp);\n                    });\n                }\n                function onError(err) {\n                    _.defer(function() {\n                        deferred.reject(err);\n                    });\n                }\n            };\n        }\n    }();\n    var SearchIndex = function() {\n        \"use strict\";\n        function SearchIndex(o) {\n            o = o || {};\n            if (!o.datumTokenizer || !o.queryTokenizer) {\n                $.error(\"datumTokenizer and queryTokenizer are both required\");\n            }\n            this.datumTokenizer = o.datumTokenizer;\n            this.queryTokenizer = o.queryTokenizer;\n            this.reset();\n        }\n        _.mixin(SearchIndex.prototype, {\n            bootstrap: function bootstrap(o) {\n                this.datums = o.datums;\n                this.trie = o.trie;\n            },\n            add: function(data) {\n                var that = this;\n                data = _.isArray(data) ? data : [ data ];\n                _.each(data, function(datum) {\n                    var id, tokens;\n                    id = that.datums.push(datum) - 1;\n                    tokens = normalizeTokens(that.datumTokenizer(datum));\n                    _.each(tokens, function(token) {\n                        var node, chars, ch;\n                        node = that.trie;\n                        chars = token.split(\"\");\n                        while (ch = chars.shift()) {\n                            node = node.children[ch] || (node.children[ch] = newNode());\n                            node.ids.push(id);\n                        }\n                    });\n                });\n            },\n            get: function get(query) {\n                var that = this, tokens, matches;\n                tokens = normalizeTokens(this.queryTokenizer(query));\n                _.each(tokens, function(token) {\n                    var node, chars, ch, ids;\n                    if (matches && matches.length === 0) {\n                        return false;\n                    }\n                    node = that.trie;\n                    chars = token.split(\"\");\n                    while (node && (ch = chars.shift())) {\n                        node = node.children[ch];\n                    }\n                    if (node && chars.length === 0) {\n                        ids = node.ids.slice(0);\n                        matches = matches ? getIntersection(matches, ids) : ids;\n                    } else {\n                        matches = [];\n                        return false;\n                    }\n                });\n                return matches ? _.map(unique(matches), function(id) {\n                    return that.datums[id];\n                }) : [];\n            },\n            reset: function reset() {\n                this.datums = [];\n                this.trie = newNode();\n            },\n            serialize: function serialize() {\n                return {\n                    datums: this.datums,\n                    trie: this.trie\n                };\n            }\n        });\n        return SearchIndex;\n        function normalizeTokens(tokens) {\n            tokens = _.filter(tokens, function(token) {\n                return !!token;\n            });\n            tokens = _.map(tokens, function(token) {\n                return token.toLowerCase();\n            });\n            return tokens;\n        }\n        function newNode() {\n            return {\n                ids: [],\n                children: {}\n            };\n        }\n        function unique(array) {\n            var seen = {}, uniques = [];\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (!seen[array[i]]) {\n                    seen[array[i]] = true;\n                    uniques.push(array[i]);\n                }\n            }\n            return uniques;\n        }\n        function getIntersection(arrayA, arrayB) {\n            var ai = 0, bi = 0, intersection = [];\n            arrayA = arrayA.sort(compare);\n            arrayB = arrayB.sort(compare);\n            var lenArrayA = arrayA.length, lenArrayB = arrayB.length;\n            while (ai < lenArrayA && bi < lenArrayB) {\n                if (arrayA[ai] < arrayB[bi]) {\n                    ai++;\n                } else if (arrayA[ai] > arrayB[bi]) {\n                    bi++;\n                } else {\n                    intersection.push(arrayA[ai]);\n                    ai++;\n                    bi++;\n                }\n            }\n            return intersection;\n            function compare(a, b) {\n                return a - b;\n            }\n        }\n    }();\n    var oParser = function() {\n        \"use strict\";\n        return {\n            local: getLocal,\n            prefetch: getPrefetch,\n            remote: getRemote\n        };\n        function getLocal(o) {\n            return o.local || null;\n        }\n        function getPrefetch(o) {\n            var prefetch, defaults;\n            defaults = {\n                url: null,\n                thumbprint: \"\",\n                ttl: 24 * 60 * 60 * 1e3,\n                filter: null,\n                ajax: {}\n            };\n            if (prefetch = o.prefetch || null) {\n                prefetch = _.isString(prefetch) ? {\n                    url: prefetch\n                } : prefetch;\n                prefetch = _.mixin(defaults, prefetch);\n                prefetch.thumbprint = VERSION + prefetch.thumbprint;\n                prefetch.ajax.type = prefetch.ajax.type || \"GET\";\n                prefetch.ajax.dataType = prefetch.ajax.dataType || \"json\";\n                !prefetch.url && $.error(\"prefetch requires url to be set\");\n            }\n            return prefetch;\n        }\n        function getRemote(o) {\n            var remote, defaults;\n            defaults = {\n                url: null,\n                cache: true,\n                wildcard: \"%QUERY\",\n                replace: null,\n                rateLimitBy: \"debounce\",\n                rateLimitWait: 300,\n                send: null,\n                filter: null,\n                ajax: {}\n            };\n            if (remote = o.remote || null) {\n                remote = _.isString(remote) ? {\n                    url: remote\n                } : remote;\n                remote = _.mixin(defaults, remote);\n                remote.rateLimiter = /^throttle$/i.test(remote.rateLimitBy) ? byThrottle(remote.rateLimitWait) : byDebounce(remote.rateLimitWait);\n                remote.ajax.type = remote.ajax.type || \"GET\";\n                remote.ajax.dataType = remote.ajax.dataType || \"json\";\n                delete remote.rateLimitBy;\n                delete remote.rateLimitWait;\n                !remote.url && $.error(\"remote requires url to be set\");\n            }\n            return remote;\n            function byDebounce(wait) {\n                return function(fn) {\n                    return _.debounce(fn, wait);\n                };\n            }\n            function byThrottle(wait) {\n                return function(fn) {\n                    return _.throttle(fn, wait);\n                };\n            }\n        }\n    }();\n    (function(root) {\n        \"use strict\";\n        var old, keys;\n        old = root.Bloodhound;\n        keys = {\n            data: \"data\",\n            protocol: \"protocol\",\n            thumbprint: \"thumbprint\"\n        };\n        root.Bloodhound = Bloodhound;\n        function Bloodhound(o) {\n            if (!o || !o.local && !o.prefetch && !o.remote) {\n                $.error(\"one of local, prefetch, or remote is required\");\n            }\n            this.limit = o.limit || 5;\n            this.sorter = getSorter(o.sorter);\n            this.dupDetector = o.dupDetector || ignoreDuplicates;\n            this.local = oParser.local(o);\n            this.prefetch = oParser.prefetch(o);\n            this.remote = oParser.remote(o);\n            this.cacheKey = this.prefetch ? this.prefetch.cacheKey || this.prefetch.url : null;\n            this.index = new SearchIndex({\n                datumTokenizer: o.datumTokenizer,\n                queryTokenizer: o.queryTokenizer\n            });\n            this.storage = this.cacheKey ? new PersistentStorage(this.cacheKey) : null;\n        }\n        Bloodhound.noConflict = function noConflict() {\n            root.Bloodhound = old;\n            return Bloodhound;\n        };\n        Bloodhound.tokenizers = tokenizers;\n        _.mixin(Bloodhound.prototype, {\n            _loadPrefetch: function loadPrefetch(o) {\n                var that = this, serialized, deferred;\n                if (serialized = this._readFromStorage(o.thumbprint)) {\n                    this.index.bootstrap(serialized);\n                    deferred = $.Deferred().resolve();\n                } else {\n                    deferred = $.ajax(o.url, o.ajax).done(handlePrefetchResponse);\n                }\n                return deferred;\n                function handlePrefetchResponse(resp) {\n                    that.clear();\n                    that.add(o.filter ? o.filter(resp) : resp);\n                    that._saveToStorage(that.index.serialize(), o.thumbprint, o.ttl);\n                }\n            },\n            _getFromRemote: function getFromRemote(query, cb) {\n                var that = this, url, uriEncodedQuery;\n                if (!this.transport) {\n                    return;\n                }\n                query = query || \"\";\n                uriEncodedQuery = encodeURIComponent(query);\n                url = this.remote.replace ? this.remote.replace(this.remote.url, query) : this.remote.url.replace(this.remote.wildcard, uriEncodedQuery);\n                return this.transport.get(url, this.remote.ajax, handleRemoteResponse);\n                function handleRemoteResponse(err, resp) {\n                    err ? cb([]) : cb(that.remote.filter ? that.remote.filter(resp) : resp);\n                }\n            },\n            _cancelLastRemoteRequest: function cancelLastRemoteRequest() {\n                this.transport && this.transport.cancel();\n            },\n            _saveToStorage: function saveToStorage(data, thumbprint, ttl) {\n                if (this.storage) {\n                    this.storage.set(keys.data, data, ttl);\n                    this.storage.set(keys.protocol, location.protocol, ttl);\n                    this.storage.set(keys.thumbprint, thumbprint, ttl);\n                }\n            },\n            _readFromStorage: function readFromStorage(thumbprint) {\n                var stored = {}, isExpired;\n                if (this.storage) {\n                    stored.data = this.storage.get(keys.data);\n                    stored.protocol = this.storage.get(keys.protocol);\n                    stored.thumbprint = this.storage.get(keys.thumbprint);\n                }\n                isExpired = stored.thumbprint !== thumbprint || stored.protocol !== location.protocol;\n                return stored.data && !isExpired ? stored.data : null;\n            },\n            _initialize: function initialize() {\n                var that = this, local = this.local, deferred;\n                deferred = this.prefetch ? this._loadPrefetch(this.prefetch) : $.Deferred().resolve();\n                local && deferred.done(addLocalToIndex);\n                this.transport = this.remote ? new Transport(this.remote) : null;\n                return this.initPromise = deferred.promise();\n                function addLocalToIndex() {\n                    that.add(_.isFunction(local) ? local() : local);\n                }\n            },\n            initialize: function initialize(force) {\n                return !this.initPromise || force ? this._initialize() : this.initPromise;\n            },\n            add: function add(data) {\n                this.index.add(data);\n            },\n            get: function get(query, cb) {\n                var that = this, matches = [], cacheHit = false;\n                matches = this.index.get(query);\n                matches = this.sorter(matches).slice(0, this.limit);\n                matches.length < this.limit ? cacheHit = this._getFromRemote(query, returnRemoteMatches) : this._cancelLastRemoteRequest();\n                if (!cacheHit) {\n                    (matches.length > 0 || !this.transport) && cb && cb(matches);\n                }\n                function returnRemoteMatches(remoteMatches) {\n                    var matchesWithBackfill = matches.slice(0);\n                    _.each(remoteMatches, function(remoteMatch) {\n                        var isDuplicate;\n                        isDuplicate = _.some(matchesWithBackfill, function(match) {\n                            return that.dupDetector(remoteMatch, match);\n                        });\n                        !isDuplicate && matchesWithBackfill.push(remoteMatch);\n                        return matchesWithBackfill.length < that.limit;\n                    });\n                    cb && cb(that.sorter(matchesWithBackfill));\n                }\n            },\n            clear: function clear() {\n                this.index.reset();\n            },\n            clearPrefetchCache: function clearPrefetchCache() {\n                this.storage && this.storage.clear();\n            },\n            clearRemoteCache: function clearRemoteCache() {\n                this.transport && Transport.resetCache();\n            },\n            ttAdapter: function ttAdapter() {\n                return _.bind(this.get, this);\n            }\n        });\n        return Bloodhound;\n        function getSorter(sortFn) {\n            return _.isFunction(sortFn) ? sort : noSort;\n            function sort(array) {\n                return array.sort(sortFn);\n            }\n            function noSort(array) {\n                return array;\n            }\n        }\n        function ignoreDuplicates() {\n            return false;\n        }\n    })(this);\n    var html = function() {\n        return {\n            wrapper: '<span class=\"twitter-typeahead\"></span>',\n            dropdown: '<span class=\"tt-dropdown-menu\"></span>',\n            dataset: '<div class=\"tt-dataset-%CLASS%\"></div>',\n            suggestions: '<span class=\"tt-suggestions\"></span>',\n            suggestion: '<div class=\"tt-suggestion\"></div>'\n        };\n    }();\n    var css = function() {\n        \"use strict\";\n        var css = {\n            wrapper: {\n                position: \"relative\",\n                display: \"inline-block\"\n            },\n            hint: {\n                position: \"absolute\",\n                top: \"0\",\n                left: \"0\",\n                borderColor: \"transparent\",\n                boxShadow: \"none\",\n                opacity: \"1\"\n            },\n            input: {\n                position: \"relative\",\n                verticalAlign: \"top\",\n                backgroundColor: \"transparent\"\n            },\n            inputWithNoHint: {\n                position: \"relative\",\n                verticalAlign: \"top\"\n            },\n            dropdown: {\n                position: \"absolute\",\n                top: \"100%\",\n                left: \"0\",\n                zIndex: \"100\",\n                display: \"none\"\n            },\n            suggestions: {\n                display: \"block\"\n            },\n            suggestion: {\n                whiteSpace: \"nowrap\",\n                cursor: \"pointer\"\n            },\n            suggestionChild: {\n                whiteSpace: \"normal\"\n            },\n            ltr: {\n                left: \"0\",\n                right: \"auto\"\n            },\n            rtl: {\n                left: \"auto\",\n                right: \" 0\"\n            }\n        };\n        if (_.isMsie()) {\n            _.mixin(css.input, {\n                backgroundImage: \"url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)\"\n            });\n        }\n        if (_.isMsie() && _.isMsie() <= 7) {\n            _.mixin(css.input, {\n                marginTop: \"-1px\"\n            });\n        }\n        return css;\n    }();\n    var EventBus = function() {\n        \"use strict\";\n        var namespace = \"typeahead:\";\n        function EventBus(o) {\n            if (!o || !o.el) {\n                $.error(\"EventBus initialized without el\");\n            }\n            this.$el = $(o.el);\n        }\n        _.mixin(EventBus.prototype, {\n            trigger: function(type) {\n                var args = [].slice.call(arguments, 1);\n                this.$el.trigger(namespace + type, args);\n            }\n        });\n        return EventBus;\n    }();\n    var EventEmitter = function() {\n        \"use strict\";\n        var splitter = /\\s+/, nextTick = getNextTick();\n        return {\n            onSync: onSync,\n            onAsync: onAsync,\n            off: off,\n            trigger: trigger\n        };\n        function on(method, types, cb, context) {\n            var this$1 = this;\n\n            var type;\n            if (!cb) {\n                return this;\n            }\n            types = types.split(splitter);\n            cb = context ? bindContext(cb, context) : cb;\n            this._callbacks = this._callbacks || {};\n            while (type = types.shift()) {\n                this$1._callbacks[type] = this$1._callbacks[type] || {\n                    sync: [],\n                    async: []\n                };\n                this$1._callbacks[type][method].push(cb);\n            }\n            return this;\n        }\n        function onAsync(types, cb, context) {\n            return on.call(this, \"async\", types, cb, context);\n        }\n        function onSync(types, cb, context) {\n            return on.call(this, \"sync\", types, cb, context);\n        }\n        function off(types) {\n            var this$1 = this;\n\n            var type;\n            if (!this._callbacks) {\n                return this;\n            }\n            types = types.split(splitter);\n            while (type = types.shift()) {\n                delete this$1._callbacks[type];\n            }\n            return this;\n        }\n        function trigger(types) {\n            var this$1 = this;\n\n            var type, callbacks, args, syncFlush, asyncFlush;\n            if (!this._callbacks) {\n                return this;\n            }\n            types = types.split(splitter);\n            args = [].slice.call(arguments, 1);\n            while ((type = types.shift()) && (callbacks = this._callbacks[type])) {\n                syncFlush = getFlush(callbacks.sync, this$1, [ type ].concat(args));\n                asyncFlush = getFlush(callbacks.async, this$1, [ type ].concat(args));\n                syncFlush() && nextTick(asyncFlush);\n            }\n            return this;\n        }\n        function getFlush(callbacks, context, args) {\n            return flush;\n            function flush() {\n                var cancelled;\n                for (var i = 0, len = callbacks.length; !cancelled && i < len; i += 1) {\n                    cancelled = callbacks[i].apply(context, args) === false;\n                }\n                return !cancelled;\n            }\n        }\n        function getNextTick() {\n            var nextTickFn;\n            if (window.setImmediate) {\n                nextTickFn = function nextTickSetImmediate(fn) {\n                    setImmediate(function() {\n                        fn();\n                    });\n                };\n            } else {\n                nextTickFn = function nextTickSetTimeout(fn) {\n                    setTimeout(function() {\n                        fn();\n                    }, 0);\n                };\n            }\n            return nextTickFn;\n        }\n        function bindContext(fn, context) {\n            return fn.bind ? fn.bind(context) : function() {\n                fn.apply(context, [].slice.call(arguments, 0));\n            };\n        }\n    }();\n    var highlight = function(doc) {\n        \"use strict\";\n        var defaults = {\n            node: null,\n            pattern: null,\n            tagName: \"strong\",\n            className: null,\n            wordsOnly: false,\n            caseSensitive: false\n        };\n        return function hightlight(o) {\n            var regex;\n            o = _.mixin({}, defaults, o);\n            if (!o.node || !o.pattern) {\n                return;\n            }\n            o.pattern = _.isArray(o.pattern) ? o.pattern : [ o.pattern ];\n            regex = getRegex(o.pattern, o.caseSensitive, o.wordsOnly);\n            traverse(o.node, hightlightTextNode);\n            function hightlightTextNode(textNode) {\n                var match, patternNode, wrapperNode;\n                if (match = regex.exec(textNode.data)) {\n                    wrapperNode = doc.createElement(o.tagName);\n                    o.className && (wrapperNode.className = o.className);\n                    patternNode = textNode.splitText(match.index);\n                    patternNode.splitText(match[0].length);\n                    wrapperNode.appendChild(patternNode.cloneNode(true));\n                    textNode.parentNode.replaceChild(wrapperNode, patternNode);\n                }\n                return !!match;\n            }\n            function traverse(el, hightlightTextNode) {\n                var childNode, TEXT_NODE_TYPE = 3;\n                for (var i = 0; i < el.childNodes.length; i++) {\n                    childNode = el.childNodes[i];\n                    if (childNode.nodeType === TEXT_NODE_TYPE) {\n                        i += hightlightTextNode(childNode) ? 1 : 0;\n                    } else {\n                        traverse(childNode, hightlightTextNode);\n                    }\n                }\n            }\n        };\n        function getRegex(patterns, caseSensitive, wordsOnly) {\n            var escapedPatterns = [], regexStr;\n            for (var i = 0, len = patterns.length; i < len; i++) {\n                escapedPatterns.push(_.escapeRegExChars(patterns[i]));\n            }\n            regexStr = wordsOnly ? \"\\\\b(\" + escapedPatterns.join(\"|\") + \")\\\\b\" : \"(\" + escapedPatterns.join(\"|\") + \")\";\n            return caseSensitive ? new RegExp(regexStr) : new RegExp(regexStr, \"i\");\n        }\n    }(window.document);\n    var Input = function() {\n        \"use strict\";\n        var specialKeyCodeMap;\n        specialKeyCodeMap = {\n            9: \"tab\",\n            27: \"esc\",\n            37: \"left\",\n            39: \"right\",\n            13: \"enter\",\n            38: \"up\",\n            40: \"down\"\n        };\n        function Input(o) {\n            var that = this, onBlur, onFocus, onKeydown, onInput;\n            o = o || {};\n            if (!o.input) {\n                $.error(\"input is missing\");\n            }\n            onBlur = _.bind(this._onBlur, this);\n            onFocus = _.bind(this._onFocus, this);\n            onKeydown = _.bind(this._onKeydown, this);\n            onInput = _.bind(this._onInput, this);\n            this.$hint = $(o.hint);\n            this.$input = $(o.input).on(\"blur.tt\", onBlur).on(\"focus.tt\", onFocus).on(\"keydown.tt\", onKeydown);\n            if (this.$hint.length === 0) {\n                this.setHint = this.getHint = this.clearHint = this.clearHintIfInvalid = _.noop;\n            }\n            if (!_.isMsie()) {\n                this.$input.on(\"input.tt\", onInput);\n            } else {\n                this.$input.on(\"keydown.tt keypress.tt cut.tt paste.tt\", function($e) {\n                    if (specialKeyCodeMap[$e.which || $e.keyCode]) {\n                        return;\n                    }\n                    _.defer(_.bind(that._onInput, that, $e));\n                });\n            }\n            this.query = this.$input.val();\n            this.$overflowHelper = buildOverflowHelper(this.$input);\n        }\n        Input.normalizeQuery = function(str) {\n            return (str || \"\").replace(/^\\s*/g, \"\").replace(/\\s{2,}/g, \" \");\n        };\n        _.mixin(Input.prototype, EventEmitter, {\n            _onBlur: function onBlur() {\n                this.resetInputValue();\n                this.trigger(\"blurred\");\n            },\n            _onFocus: function onFocus() {\n                this.trigger(\"focused\");\n            },\n            _onKeydown: function onKeydown($e) {\n                var keyName = specialKeyCodeMap[$e.which || $e.keyCode];\n                this._managePreventDefault(keyName, $e);\n                if (keyName && this._shouldTrigger(keyName, $e)) {\n                    this.trigger(keyName + \"Keyed\", $e);\n                }\n            },\n            _onInput: function onInput() {\n                this._checkInputValue();\n            },\n            _managePreventDefault: function managePreventDefault(keyName, $e) {\n                var preventDefault, hintValue, inputValue;\n                switch (keyName) {\n                    case \"tab\":\n                        hintValue = this.getHint();\n                        inputValue = this.getInputValue();\n                        preventDefault = hintValue && hintValue !== inputValue && !withModifier($e);\n                        break;\n\n                    case \"up\":\n                    case \"down\":\n                        preventDefault = !withModifier($e);\n                        break;\n\n                    default:\n                        preventDefault = false;\n                }\n                preventDefault && $e.preventDefault();\n            },\n            _shouldTrigger: function shouldTrigger(keyName, $e) {\n                var trigger;\n                switch (keyName) {\n                    case \"tab\":\n                        trigger = !withModifier($e);\n                        break;\n\n                    default:\n                        trigger = true;\n                }\n                return trigger;\n            },\n            _checkInputValue: function checkInputValue() {\n                var inputValue, areEquivalent, hasDifferentWhitespace;\n                inputValue = this.getInputValue();\n                areEquivalent = areQueriesEquivalent(inputValue, this.query);\n                hasDifferentWhitespace = areEquivalent ? this.query.length !== inputValue.length : false;\n                this.query = inputValue;\n                if (!areEquivalent) {\n                    this.trigger(\"queryChanged\", this.query);\n                } else if (hasDifferentWhitespace) {\n                    this.trigger(\"whitespaceChanged\", this.query);\n                }\n            },\n            focus: function focus() {\n                this.$input.focus();\n            },\n            blur: function blur() {\n                this.$input.blur();\n            },\n            getQuery: function getQuery() {\n                return this.query;\n            },\n            setQuery: function setQuery(query) {\n                this.query = query;\n            },\n            getInputValue: function getInputValue() {\n                return this.$input.val();\n            },\n            setInputValue: function setInputValue(value, silent) {\n                this.$input.val(value);\n                silent ? this.clearHint() : this._checkInputValue();\n            },\n            resetInputValue: function resetInputValue() {\n                this.setInputValue(this.query, true);\n            },\n            getHint: function getHint() {\n                return this.$hint.val();\n            },\n            setHint: function setHint(value) {\n                this.$hint.val(value);\n            },\n            clearHint: function clearHint() {\n                this.setHint(\"\");\n            },\n            clearHintIfInvalid: function clearHintIfInvalid() {\n                var val, hint, valIsPrefixOfHint, isValid;\n                val = this.getInputValue();\n                hint = this.getHint();\n                valIsPrefixOfHint = val !== hint && hint.indexOf(val) === 0;\n                isValid = val !== \"\" && valIsPrefixOfHint && !this.hasOverflow();\n                !isValid && this.clearHint();\n            },\n            getLanguageDirection: function getLanguageDirection() {\n                return (this.$input.css(\"direction\") || \"ltr\").toLowerCase();\n            },\n            hasOverflow: function hasOverflow() {\n                var constraint = this.$input.width() - 2;\n                this.$overflowHelper.text(this.getInputValue());\n                return this.$overflowHelper.width() >= constraint;\n            },\n            isCursorAtEnd: function() {\n                var valueLength, selectionStart, range;\n                valueLength = this.$input.val().length;\n                selectionStart = this.$input[0].selectionStart;\n                if (_.isNumber(selectionStart)) {\n                    return selectionStart === valueLength;\n                } else if (document.selection) {\n                    range = document.selection.createRange();\n                    range.moveStart(\"character\", -valueLength);\n                    return valueLength === range.text.length;\n                }\n                return true;\n            },\n            destroy: function destroy() {\n                this.$hint.off(\".tt\");\n                this.$input.off(\".tt\");\n                this.$hint = this.$input = this.$overflowHelper = null;\n            }\n        });\n        return Input;\n        function buildOverflowHelper($input) {\n            return $('<pre aria-hidden=\"true\"></pre>').css({\n                position: \"absolute\",\n                visibility: \"hidden\",\n                whiteSpace: \"pre\",\n                fontFamily: $input.css(\"font-family\"),\n                fontSize: $input.css(\"font-size\"),\n                fontStyle: $input.css(\"font-style\"),\n                fontVariant: $input.css(\"font-variant\"),\n                fontWeight: $input.css(\"font-weight\"),\n                wordSpacing: $input.css(\"word-spacing\"),\n                letterSpacing: $input.css(\"letter-spacing\"),\n                textIndent: $input.css(\"text-indent\"),\n                textRendering: $input.css(\"text-rendering\"),\n                textTransform: $input.css(\"text-transform\")\n            }).insertAfter($input);\n        }\n        function areQueriesEquivalent(a, b) {\n            return Input.normalizeQuery(a) === Input.normalizeQuery(b);\n        }\n        function withModifier($e) {\n            return $e.altKey || $e.ctrlKey || $e.metaKey || $e.shiftKey;\n        }\n    }();\n    var Dataset = function() {\n        \"use strict\";\n        var datasetKey = \"ttDataset\", valueKey = \"ttValue\", datumKey = \"ttDatum\";\n        function Dataset(o) {\n            o = o || {};\n            o.templates = o.templates || {};\n            if (!o.source) {\n                $.error(\"missing source\");\n            }\n            if (o.name && !isValidName(o.name)) {\n                $.error(\"invalid dataset name: \" + o.name);\n            }\n            this.query = null;\n            this.highlight = !!o.highlight;\n            this.name = o.name || _.getUniqueId();\n            this.source = o.source;\n            this.displayFn = getDisplayFn(o.display || o.displayKey);\n            this.templates = getTemplates(o.templates, this.displayFn);\n            this.$el = $(html.dataset.replace(\"%CLASS%\", this.name));\n        }\n        Dataset.extractDatasetName = function extractDatasetName(el) {\n            return $(el).data(datasetKey);\n        };\n        Dataset.extractValue = function extractDatum(el) {\n            return $(el).data(valueKey);\n        };\n        Dataset.extractDatum = function extractDatum(el) {\n            return $(el).data(datumKey);\n        };\n        _.mixin(Dataset.prototype, EventEmitter, {\n            _render: function render(query, suggestions) {\n                if (!this.$el) {\n                    return;\n                }\n                var that = this, hasSuggestions;\n                this.$el.empty();\n                hasSuggestions = suggestions && suggestions.length;\n                if (!hasSuggestions && this.templates.empty) {\n                    this.$el.html(getEmptyHtml()).prepend(that.templates.header ? getHeaderHtml() : null).append(that.templates.footer ? getFooterHtml() : null);\n                } else if (hasSuggestions) {\n                    this.$el.html(getSuggestionsHtml()).prepend(that.templates.header ? getHeaderHtml() : null).append(that.templates.footer ? getFooterHtml() : null);\n                }\n                this.trigger(\"rendered\");\n                function getEmptyHtml() {\n                    return that.templates.empty({\n                        query: query,\n                        isEmpty: true\n                    });\n                }\n                function getSuggestionsHtml() {\n                    var $suggestions, nodes;\n                    $suggestions = $(html.suggestions).css(css.suggestions);\n                    nodes = _.map(suggestions, getSuggestionNode);\n                    $suggestions.append.apply($suggestions, nodes);\n                    that.highlight && highlight({\n                        className: \"tt-highlight\",\n                        node: $suggestions[0],\n                        pattern: query\n                    });\n                    return $suggestions;\n                    function getSuggestionNode(suggestion) {\n                        var $el;\n                        $el = $(html.suggestion).append(that.templates.suggestion(suggestion)).data(datasetKey, that.name).data(valueKey, that.displayFn(suggestion)).data(datumKey, suggestion);\n                        $el.children().each(function() {\n                            $(this).css(css.suggestionChild);\n                        });\n                        return $el;\n                    }\n                }\n                function getHeaderHtml() {\n                    return that.templates.header({\n                        query: query,\n                        isEmpty: !hasSuggestions\n                    });\n                }\n                function getFooterHtml() {\n                    return that.templates.footer({\n                        query: query,\n                        isEmpty: !hasSuggestions\n                    });\n                }\n            },\n            getRoot: function getRoot() {\n                return this.$el;\n            },\n            update: function update(query) {\n                var that = this;\n                this.query = query;\n                this.canceled = false;\n                this.source(query, render);\n                function render(suggestions) {\n                    if (!that.canceled && query === that.query) {\n                        that._render(query, suggestions);\n                    }\n                }\n            },\n            cancel: function cancel() {\n                this.canceled = true;\n            },\n            clear: function clear() {\n                this.cancel();\n                this.$el.empty();\n                this.trigger(\"rendered\");\n            },\n            isEmpty: function isEmpty() {\n                return this.$el.is(\":empty\");\n            },\n            destroy: function destroy() {\n                this.$el = null;\n            }\n        });\n        return Dataset;\n        function getDisplayFn(display) {\n            display = display || \"value\";\n            return _.isFunction(display) ? display : displayFn;\n            function displayFn(obj) {\n                return obj[display];\n            }\n        }\n        function getTemplates(templates, displayFn) {\n            return {\n                empty: templates.empty && _.templatify(templates.empty),\n                header: templates.header && _.templatify(templates.header),\n                footer: templates.footer && _.templatify(templates.footer),\n                suggestion: templates.suggestion || suggestionTemplate\n            };\n            function suggestionTemplate(context) {\n                return \"<p>\" + displayFn(context) + \"</p>\";\n            }\n        }\n        function isValidName(str) {\n            return /^[_a-zA-Z0-9-]+$/.test(str);\n        }\n    }();\n    var Dropdown = function() {\n        \"use strict\";\n        function Dropdown(o) {\n            var that = this, onSuggestionClick, onSuggestionMouseEnter, onSuggestionMouseLeave;\n            o = o || {};\n            if (!o.menu) {\n                $.error(\"menu is required\");\n            }\n            this.isOpen = false;\n            this.isEmpty = true;\n            this.datasets = _.map(o.datasets, initializeDataset);\n            onSuggestionClick = _.bind(this._onSuggestionClick, this);\n            onSuggestionMouseEnter = _.bind(this._onSuggestionMouseEnter, this);\n            onSuggestionMouseLeave = _.bind(this._onSuggestionMouseLeave, this);\n            this.$menu = $(o.menu).on(\"click.tt\", \".tt-suggestion\", onSuggestionClick).on(\"mouseenter.tt\", \".tt-suggestion\", onSuggestionMouseEnter).on(\"mouseleave.tt\", \".tt-suggestion\", onSuggestionMouseLeave);\n            _.each(this.datasets, function(dataset) {\n                that.$menu.append(dataset.getRoot());\n                dataset.onSync(\"rendered\", that._onRendered, that);\n            });\n        }\n        _.mixin(Dropdown.prototype, EventEmitter, {\n            _onSuggestionClick: function onSuggestionClick($e) {\n                this.trigger(\"suggestionClicked\", $($e.currentTarget));\n            },\n            _onSuggestionMouseEnter: function onSuggestionMouseEnter($e) {\n                this._removeCursor();\n                this._setCursor($($e.currentTarget), true);\n            },\n            _onSuggestionMouseLeave: function onSuggestionMouseLeave() {\n                this._removeCursor();\n            },\n            _onRendered: function onRendered() {\n                this.isEmpty = _.every(this.datasets, isDatasetEmpty);\n                this.isEmpty ? this._hide() : this.isOpen && this._show();\n                this.trigger(\"datasetRendered\");\n                function isDatasetEmpty(dataset) {\n                    return dataset.isEmpty();\n                }\n            },\n            _hide: function() {\n                this.$menu.hide();\n            },\n            _show: function() {\n                this.$menu.css(\"display\", \"block\");\n            },\n            _getSuggestions: function getSuggestions() {\n                return this.$menu.find(\".tt-suggestion\");\n            },\n            _getCursor: function getCursor() {\n                return this.$menu.find(\".tt-cursor\").first();\n            },\n            _setCursor: function setCursor($el, silent) {\n                $el.first().addClass(\"tt-cursor\");\n                !silent && this.trigger(\"cursorMoved\");\n            },\n            _removeCursor: function removeCursor() {\n                this._getCursor().removeClass(\"tt-cursor\");\n            },\n            _moveCursor: function moveCursor(increment) {\n                var $suggestions, $oldCursor, newCursorIndex, $newCursor;\n                if (!this.isOpen) {\n                    return;\n                }\n                $oldCursor = this._getCursor();\n                $suggestions = this._getSuggestions();\n                this._removeCursor();\n                newCursorIndex = $suggestions.index($oldCursor) + increment;\n                newCursorIndex = (newCursorIndex + 1) % ($suggestions.length + 1) - 1;\n                if (newCursorIndex === -1) {\n                    this.trigger(\"cursorRemoved\");\n                    return;\n                } else if (newCursorIndex < -1) {\n                    newCursorIndex = $suggestions.length - 1;\n                }\n                this._setCursor($newCursor = $suggestions.eq(newCursorIndex));\n                this._ensureVisible($newCursor);\n            },\n            _ensureVisible: function ensureVisible($el) {\n                var elTop, elBottom, menuScrollTop, menuHeight;\n                elTop = $el.position().top;\n                elBottom = elTop + $el.outerHeight(true);\n                menuScrollTop = this.$menu.scrollTop();\n                menuHeight = this.$menu.height() + parseInt(this.$menu.css(\"paddingTop\"), 10) + parseInt(this.$menu.css(\"paddingBottom\"), 10);\n                if (elTop < 0) {\n                    this.$menu.scrollTop(menuScrollTop + elTop);\n                } else if (menuHeight < elBottom) {\n                    this.$menu.scrollTop(menuScrollTop + (elBottom - menuHeight));\n                }\n            },\n            close: function close() {\n                if (this.isOpen) {\n                    this.isOpen = false;\n                    this._removeCursor();\n                    this._hide();\n                    this.trigger(\"closed\");\n                }\n            },\n            open: function open() {\n                if (!this.isOpen) {\n                    this.isOpen = true;\n                    !this.isEmpty && this._show();\n                    this.trigger(\"opened\");\n                }\n            },\n            setLanguageDirection: function setLanguageDirection(dir) {\n                this.$menu.css(dir === \"ltr\" ? css.ltr : css.rtl);\n            },\n            moveCursorUp: function moveCursorUp() {\n                this._moveCursor(-1);\n            },\n            moveCursorDown: function moveCursorDown() {\n                this._moveCursor(+1);\n            },\n            getDatumForSuggestion: function getDatumForSuggestion($el) {\n                var datum = null;\n                if ($el.length) {\n                    datum = {\n                        raw: Dataset.extractDatum($el),\n                        value: Dataset.extractValue($el),\n                        datasetName: Dataset.extractDatasetName($el)\n                    };\n                }\n                return datum;\n            },\n            getDatumForCursor: function getDatumForCursor() {\n                return this.getDatumForSuggestion(this._getCursor().first());\n            },\n            getDatumForTopSuggestion: function getDatumForTopSuggestion() {\n                return this.getDatumForSuggestion(this._getSuggestions().first());\n            },\n            update: function update(query) {\n                _.each(this.datasets, updateDataset);\n                function updateDataset(dataset) {\n                    dataset.update(query);\n                }\n            },\n            empty: function empty() {\n                _.each(this.datasets, clearDataset);\n                this.isEmpty = true;\n                function clearDataset(dataset) {\n                    dataset.clear();\n                }\n            },\n            isVisible: function isVisible() {\n                return this.isOpen && !this.isEmpty;\n            },\n            destroy: function destroy() {\n                this.$menu.off(\".tt\");\n                this.$menu = null;\n                _.each(this.datasets, destroyDataset);\n                function destroyDataset(dataset) {\n                    dataset.destroy();\n                }\n            }\n        });\n        return Dropdown;\n        function initializeDataset(oDataset) {\n            return new Dataset(oDataset);\n        }\n    }();\n    var Typeahead = function() {\n        \"use strict\";\n        var attrsKey = \"ttAttrs\";\n        function Typeahead(o) {\n            var $menu, $input, $hint;\n            o = o || {};\n            if (!o.input) {\n                $.error(\"missing input\");\n            }\n            this.isActivated = false;\n            this.autoselect = !!o.autoselect;\n            this.minLength = _.isNumber(o.minLength) ? o.minLength : 1;\n            this.$node = buildDom(o.input, o.withHint);\n            $menu = this.$node.find(\".tt-dropdown-menu\");\n            $input = this.$node.find(\".tt-input\");\n            $hint = this.$node.find(\".tt-hint\");\n            $input.on(\"blur.tt\", function($e) {\n                var active, isActive, hasActive;\n                active = document.activeElement;\n                isActive = $menu.is(active);\n                hasActive = $menu.has(active).length > 0;\n                if (_.isMsie() && (isActive || hasActive)) {\n                    $e.preventDefault();\n                    $e.stopImmediatePropagation();\n                    _.defer(function() {\n                        $input.focus();\n                    });\n                }\n            });\n            $menu.on(\"mousedown.tt\", function($e) {\n                $e.preventDefault();\n            });\n            this.eventBus = o.eventBus || new EventBus({\n                el: $input\n            });\n            this.dropdown = new Dropdown({\n                menu: $menu,\n                datasets: o.datasets\n            }).onSync(\"suggestionClicked\", this._onSuggestionClicked, this).onSync(\"cursorMoved\", this._onCursorMoved, this).onSync(\"cursorRemoved\", this._onCursorRemoved, this).onSync(\"opened\", this._onOpened, this).onSync(\"closed\", this._onClosed, this).onAsync(\"datasetRendered\", this._onDatasetRendered, this);\n            this.input = new Input({\n                input: $input,\n                hint: $hint\n            }).onSync(\"focused\", this._onFocused, this).onSync(\"blurred\", this._onBlurred, this).onSync(\"enterKeyed\", this._onEnterKeyed, this).onSync(\"tabKeyed\", this._onTabKeyed, this).onSync(\"escKeyed\", this._onEscKeyed, this).onSync(\"upKeyed\", this._onUpKeyed, this).onSync(\"downKeyed\", this._onDownKeyed, this).onSync(\"leftKeyed\", this._onLeftKeyed, this).onSync(\"rightKeyed\", this._onRightKeyed, this).onSync(\"queryChanged\", this._onQueryChanged, this).onSync(\"whitespaceChanged\", this._onWhitespaceChanged, this);\n            this._setLanguageDirection();\n        }\n        _.mixin(Typeahead.prototype, {\n            _onSuggestionClicked: function onSuggestionClicked(type, $el) {\n                var datum;\n                if (datum = this.dropdown.getDatumForSuggestion($el)) {\n                    this._select(datum);\n                }\n            },\n            _onCursorMoved: function onCursorMoved() {\n                var datum = this.dropdown.getDatumForCursor();\n                this.input.setInputValue(datum.value, true);\n                this.eventBus.trigger(\"cursorchanged\", datum.raw, datum.datasetName);\n            },\n            _onCursorRemoved: function onCursorRemoved() {\n                this.input.resetInputValue();\n                this._updateHint();\n            },\n            _onDatasetRendered: function onDatasetRendered() {\n                this._updateHint();\n            },\n            _onOpened: function onOpened() {\n                this._updateHint();\n                this.eventBus.trigger(\"opened\");\n            },\n            _onClosed: function onClosed() {\n                this.input.clearHint();\n                this.eventBus.trigger(\"closed\");\n            },\n            _onFocused: function onFocused() {\n                this.isActivated = true;\n                this.dropdown.open();\n            },\n            _onBlurred: function onBlurred() {\n                this.isActivated = false;\n                this.dropdown.empty();\n                this.dropdown.close();\n            },\n            _onEnterKeyed: function onEnterKeyed(type, $e) {\n                var cursorDatum, topSuggestionDatum;\n                cursorDatum = this.dropdown.getDatumForCursor();\n                topSuggestionDatum = this.dropdown.getDatumForTopSuggestion();\n                if (cursorDatum) {\n                    this._select(cursorDatum);\n                    $e.preventDefault();\n                } else if (this.autoselect && topSuggestionDatum) {\n                    this._select(topSuggestionDatum);\n                    $e.preventDefault();\n                }\n            },\n            _onTabKeyed: function onTabKeyed(type, $e) {\n                var datum;\n                if (datum = this.dropdown.getDatumForCursor()) {\n                    this._select(datum);\n                    $e.preventDefault();\n                } else {\n                    this._autocomplete(true);\n                }\n            },\n            _onEscKeyed: function onEscKeyed() {\n                this.dropdown.close();\n                this.input.resetInputValue();\n            },\n            _onUpKeyed: function onUpKeyed() {\n                var query = this.input.getQuery();\n                this.dropdown.isEmpty && query.length >= this.minLength ? this.dropdown.update(query) : this.dropdown.moveCursorUp();\n                this.dropdown.open();\n            },\n            _onDownKeyed: function onDownKeyed() {\n                var query = this.input.getQuery();\n                this.dropdown.isEmpty && query.length >= this.minLength ? this.dropdown.update(query) : this.dropdown.moveCursorDown();\n                this.dropdown.open();\n            },\n            _onLeftKeyed: function onLeftKeyed() {\n                this.dir === \"rtl\" && this._autocomplete();\n            },\n            _onRightKeyed: function onRightKeyed() {\n                this.dir === \"ltr\" && this._autocomplete();\n            },\n            _onQueryChanged: function onQueryChanged(e, query) {\n                this.input.clearHintIfInvalid();\n                query.length >= this.minLength ? this.dropdown.update(query) : this.dropdown.empty();\n                this.dropdown.open();\n                this._setLanguageDirection();\n            },\n            _onWhitespaceChanged: function onWhitespaceChanged() {\n                this._updateHint();\n                this.dropdown.open();\n            },\n            _setLanguageDirection: function setLanguageDirection() {\n                var dir;\n                if (this.dir !== (dir = this.input.getLanguageDirection())) {\n                    this.dir = dir;\n                    this.$node.css(\"direction\", dir);\n                    this.dropdown.setLanguageDirection(dir);\n                }\n            },\n            _updateHint: function updateHint() {\n                var datum, val, query, escapedQuery, frontMatchRegEx, match;\n                datum = this.dropdown.getDatumForTopSuggestion();\n                if (datum && this.dropdown.isVisible() && !this.input.hasOverflow()) {\n                    val = this.input.getInputValue();\n                    query = Input.normalizeQuery(val);\n                    escapedQuery = _.escapeRegExChars(query);\n                    frontMatchRegEx = new RegExp(\"^(?:\" + escapedQuery + \")(.+$)\", \"i\");\n                    match = frontMatchRegEx.exec(datum.value);\n                    match ? this.input.setHint(val + match[1]) : this.input.clearHint();\n                } else {\n                    this.input.clearHint();\n                }\n            },\n            _autocomplete: function autocomplete(laxCursor) {\n                var hint, query, isCursorAtEnd, datum;\n                hint = this.input.getHint();\n                query = this.input.getQuery();\n                isCursorAtEnd = laxCursor || this.input.isCursorAtEnd();\n                if (hint && query !== hint && isCursorAtEnd) {\n                    datum = this.dropdown.getDatumForTopSuggestion();\n                    datum && this.input.setInputValue(datum.value);\n                    this.eventBus.trigger(\"autocompleted\", datum.raw, datum.datasetName);\n                }\n            },\n            _select: function select(datum) {\n                this.input.setQuery(datum.value);\n                this.input.setInputValue(datum.value, true);\n                this._setLanguageDirection();\n                this.eventBus.trigger(\"selected\", datum.raw, datum.datasetName);\n                this.dropdown.close();\n                _.defer(_.bind(this.dropdown.empty, this.dropdown));\n            },\n            open: function open() {\n                this.dropdown.open();\n            },\n            close: function close() {\n                this.dropdown.close();\n            },\n            setVal: function setVal(val) {\n                val = _.toStr(val);\n                if (this.isActivated) {\n                    this.input.setInputValue(val);\n                } else {\n                    this.input.setQuery(val);\n                    this.input.setInputValue(val, true);\n                }\n                this._setLanguageDirection();\n            },\n            getVal: function getVal() {\n                return this.input.getQuery();\n            },\n            destroy: function destroy() {\n                this.input.destroy();\n                this.dropdown.destroy();\n                destroyDomStructure(this.$node);\n                this.$node = null;\n            }\n        });\n        return Typeahead;\n        function buildDom(input, withHint) {\n            var $input, $wrapper, $dropdown, $hint;\n            $input = $(input);\n            $wrapper = $(html.wrapper).css(css.wrapper);\n            $dropdown = $(html.dropdown).css(css.dropdown);\n            $hint = $input.clone().css(css.hint).css(getBackgroundStyles($input));\n            $hint.val(\"\").removeData().addClass(\"tt-hint\").removeAttr(\"id name placeholder required\").prop(\"readonly\", true).attr({\n                autocomplete: \"off\",\n                spellcheck: \"false\",\n                tabindex: -1\n            });\n            $input.data(attrsKey, {\n                dir: $input.attr(\"dir\"),\n                autocomplete: $input.attr(\"autocomplete\"),\n                spellcheck: $input.attr(\"spellcheck\"),\n                style: $input.attr(\"style\")\n            });\n            $input.addClass(\"tt-input\").attr({\n                autocomplete: \"off\",\n                spellcheck: false\n            }).css(withHint ? css.input : css.inputWithNoHint);\n            try {\n                !$input.attr(\"dir\") && $input.attr(\"dir\", \"auto\");\n            } catch (e) {}\n            return $input.wrap($wrapper).parent().prepend(withHint ? $hint : null).append($dropdown);\n        }\n        function getBackgroundStyles($el) {\n            return {\n                backgroundAttachment: $el.css(\"background-attachment\"),\n                backgroundClip: $el.css(\"background-clip\"),\n                backgroundColor: $el.css(\"background-color\"),\n                backgroundImage: $el.css(\"background-image\"),\n                backgroundOrigin: $el.css(\"background-origin\"),\n                backgroundPosition: $el.css(\"background-position\"),\n                backgroundRepeat: $el.css(\"background-repeat\"),\n                backgroundSize: $el.css(\"background-size\")\n            };\n        }\n        function destroyDomStructure($node) {\n            var $input = $node.find(\".tt-input\");\n            _.each($input.data(attrsKey), function(val, key) {\n                _.isUndefined(val) ? $input.removeAttr(key) : $input.attr(key, val);\n            });\n            $input.detach().removeData(attrsKey).removeClass(\"tt-input\").insertAfter($node);\n            $node.remove();\n        }\n    }();\n    (function() {\n        \"use strict\";\n        var old, typeaheadKey, methods;\n        old = $.fn.typeahead;\n        typeaheadKey = \"ttTypeahead\";\n        methods = {\n            initialize: function initialize(o, datasets) {\n                datasets = _.isArray(datasets) ? datasets : [].slice.call(arguments, 1);\n                o = o || {};\n                return this.each(attach);\n                function attach() {\n                    var $input = $(this), eventBus, typeahead;\n                    _.each(datasets, function(d) {\n                        d.highlight = !!o.highlight;\n                    });\n                    typeahead = new Typeahead({\n                        input: $input,\n                        eventBus: eventBus = new EventBus({\n                            el: $input\n                        }),\n                        withHint: _.isUndefined(o.hint) ? true : !!o.hint,\n                        minLength: o.minLength,\n                        autoselect: o.autoselect,\n                        datasets: datasets\n                    });\n                    $input.data(typeaheadKey, typeahead);\n                }\n            },\n            open: function open() {\n                return this.each(openTypeahead);\n                function openTypeahead() {\n                    var $input = $(this), typeahead;\n                    if (typeahead = $input.data(typeaheadKey)) {\n                        typeahead.open();\n                    }\n                }\n            },\n            close: function close() {\n                return this.each(closeTypeahead);\n                function closeTypeahead() {\n                    var $input = $(this), typeahead;\n                    if (typeahead = $input.data(typeaheadKey)) {\n                        typeahead.close();\n                    }\n                }\n            },\n            val: function val(newVal) {\n                return !arguments.length ? getVal(this.first()) : this.each(setVal);\n                function setVal() {\n                    var $input = $(this), typeahead;\n                    if (typeahead = $input.data(typeaheadKey)) {\n                        typeahead.setVal(newVal);\n                    }\n                }\n                function getVal($input) {\n                    var typeahead, query;\n                    if (typeahead = $input.data(typeaheadKey)) {\n                        query = typeahead.getVal();\n                    }\n                    return query;\n                }\n            },\n            destroy: function destroy() {\n                return this.each(unattach);\n                function unattach() {\n                    var $input = $(this), typeahead;\n                    if (typeahead = $input.data(typeaheadKey)) {\n                        typeahead.destroy();\n                        $input.removeData(typeaheadKey);\n                    }\n                }\n            }\n        };\n        $.fn.typeahead = function(method) {\n            var tts;\n            if (methods[method] && method !== \"initialize\") {\n                tts = this.filter(function() {\n                    return !!$(this).data(typeaheadKey);\n                });\n                return methods[method].apply(tts, [].slice.call(arguments, 1));\n            } else {\n                return methods.initialize.apply(this, arguments);\n            }\n        };\n        $.fn.typeahead.noConflict = function noConflict() {\n            $.fn.typeahead = old;\n            return this;\n        };\n    })();\n})(window.jQuery);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).setImmediate))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcmVzb3VyY2VzL2Fzc2V0cy9qcy92ZW5kb3IvdHlwZWFoZWFkLmpzPzNhZDEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiB0eXBlYWhlYWQuanMgMC4xMC41XG4gKiBodHRwczovL2dpdGh1Yi5jb20vdHdpdHRlci90eXBlYWhlYWQuanNcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgVHdpdHRlciwgSW5jLiBhbmQgb3RoZXIgY29udHJpYnV0b3JzOyBMaWNlbnNlZCBNSVRcbiAqL1xuXG4oZnVuY3Rpb24oJCkge1xuICAgIHZhciBfID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNNc2llOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSA/IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goLyhtc2llIHxydjopKFxcZCsoLlxcZCspPykvaSlbMl0gOiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0JsYW5rU3RyaW5nOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXN0ciB8fCAvXlxccyokLy50ZXN0KHN0cik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXNjYXBlUmVnRXhDaGFyczogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFwtXFxbXFxdXFwvXFx7XFx9XFwoXFwpXFwqXFwrXFw/XFwuXFxcXFxcXlxcJFxcfF0vZywgXCJcXFxcJCZcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNTdHJpbmc6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzTnVtYmVyOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJudW1iZXJcIjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0FycmF5OiAkLmlzQXJyYXksXG4gICAgICAgICAgICBpc0Z1bmN0aW9uOiAkLmlzRnVuY3Rpb24sXG4gICAgICAgICAgICBpc09iamVjdDogJC5pc1BsYWluT2JqZWN0LFxuICAgICAgICAgICAgaXNVbmRlZmluZWQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvU3RyOiBmdW5jdGlvbiB0b1N0cihzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uaXNVbmRlZmluZWQocykgfHwgcyA9PT0gbnVsbCA/IFwiXCIgOiBzICsgXCJcIjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiaW5kOiAkLnByb3h5LFxuICAgICAgICAgICAgZWFjaDogZnVuY3Rpb24oY29sbGVjdGlvbiwgY2IpIHtcbiAgICAgICAgICAgICAgICAkLmVhY2goY29sbGVjdGlvbiwgcmV2ZXJzZUFyZ3MpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJldmVyc2VBcmdzKGluZGV4LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IodmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWFwOiAkLm1hcCxcbiAgICAgICAgICAgIGZpbHRlcjogJC5ncmVwLFxuICAgICAgICAgICAgZXZlcnk6IGZ1bmN0aW9uKG9iaiwgdGVzdCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICQuZWFjaChvYmosIGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHJlc3VsdCA9IHRlc3QuY2FsbChudWxsLCB2YWwsIGtleSwgb2JqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzb21lOiBmdW5jdGlvbihvYmosIHRlc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJC5lYWNoKG9iaiwgZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9IHRlc3QuY2FsbChudWxsLCB2YWwsIGtleSwgb2JqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1peGluOiAkLmV4dGVuZCxcbiAgICAgICAgICAgIGdldFVuaXF1ZUlkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY291bnRlcisrO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KCksXG4gICAgICAgICAgICB0ZW1wbGF0aWZ5OiBmdW5jdGlvbiB0ZW1wbGF0aWZ5KG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiAkLmlzRnVuY3Rpb24ob2JqKSA/IG9iaiA6IHRlbXBsYXRlO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRlbXBsYXRlKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKG9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZmVyOiBmdW5jdGlvbihmbikge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlYm91bmNlOiBmdW5jdGlvbihmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGltZW91dCwgcmVzdWx0O1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzLCBsYXRlciwgY2FsbE5vdztcbiAgICAgICAgICAgICAgICAgICAgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRocm90dGxlOiBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQsIGFyZ3MsIHRpbWVvdXQsIHJlc3VsdCwgcHJldmlvdXMsIGxhdGVyO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzID0gMDtcbiAgICAgICAgICAgICAgICBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKSwgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm9vcDogZnVuY3Rpb24oKSB7fVxuICAgICAgICB9O1xuICAgIH0oKTtcbiAgICB2YXIgVkVSU0lPTiA9IFwiMC4xMC41XCI7XG4gICAgdmFyIHRva2VuaXplcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub253b3JkOiBub253b3JkLFxuICAgICAgICAgICAgd2hpdGVzcGFjZTogd2hpdGVzcGFjZSxcbiAgICAgICAgICAgIG9iajoge1xuICAgICAgICAgICAgICAgIG5vbndvcmQ6IGdldE9ialRva2VuaXplcihub253b3JkKSxcbiAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlOiBnZXRPYmpUb2tlbml6ZXIod2hpdGVzcGFjZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gd2hpdGVzcGFjZShzdHIpIHtcbiAgICAgICAgICAgIHN0ciA9IF8udG9TdHIoc3RyKTtcbiAgICAgICAgICAgIHJldHVybiBzdHIgPyBzdHIuc3BsaXQoL1xccysvKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG5vbndvcmQoc3RyKSB7XG4gICAgICAgICAgICBzdHIgPSBfLnRvU3RyKHN0cik7XG4gICAgICAgICAgICByZXR1cm4gc3RyID8gc3RyLnNwbGl0KC9cXFcrLykgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRPYmpUb2tlbml6ZXIodG9rZW5pemVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gc2V0S2V5KCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiB0b2tlbml6ZShvKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGFyZ3MsIGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQodG9rZW5pemVyKF8udG9TdHIob1trXSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KCk7XG4gICAgdmFyIExydUNhY2hlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBmdW5jdGlvbiBMcnVDYWNoZShtYXhTaXplKSB7XG4gICAgICAgICAgICB0aGlzLm1heFNpemUgPSBfLmlzTnVtYmVyKG1heFNpemUpID8gbWF4U2l6ZSA6IDEwMDtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1heFNpemUgPD0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0ID0gdGhpcy5nZXQgPSAkLm5vb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXy5taXhpbihMcnVDYWNoZS5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhaWxJdGVtID0gdGhpcy5saXN0LnRhaWwsIG5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2l6ZSA+PSB0aGlzLm1heFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0LnJlbW92ZSh0YWlsSXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmhhc2hbdGFpbEl0ZW0ua2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPSB0aGlzLmhhc2hba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnZhbCA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0Lm1vdmVUb0Zyb250KG5vZGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBuZXcgTm9kZShrZXksIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdC5hZGQobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzaFtrZXldID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5oYXNoW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0Lm1vdmVUb0Zyb250KG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS52YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzaCA9IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdCA9IG5ldyBMaXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBMaXN0KCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBfLm1peGluKExpc3QucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uIGFkZChub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGVhZCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLm5leHQgPSB0aGlzLmhlYWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZC5wcmV2ID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gbm9kZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwgfHwgbm9kZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5wcmV2ID8gbm9kZS5wcmV2Lm5leHQgPSBub2RlLm5leHQgOiB0aGlzLmhlYWQgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICAgICAgbm9kZS5uZXh0ID8gbm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXYgOiB0aGlzLnRhaWwgPSBub2RlLnByZXY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW92ZVRvRnJvbnQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShub2RlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIE5vZGUoa2V5LCB2YWwpIHtcbiAgICAgICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICAgICAgICB0aGlzLnByZXYgPSB0aGlzLm5leHQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBMcnVDYWNoZTtcbiAgICB9KCk7XG4gICAgdmFyIFBlcnNpc3RlbnRTdG9yYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgbHMsIG1ldGhvZHM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBscyA9IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgICAgICAgICBscy5zZXRJdGVtKFwifn5+XCIsIFwiIVwiKTtcbiAgICAgICAgICAgIGxzLnJlbW92ZUl0ZW0oXCJ+fn5cIik7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIFBlcnNpc3RlbnRTdG9yYWdlKG5hbWVzcGFjZSkge1xuICAgICAgICAgICAgdGhpcy5wcmVmaXggPSBbIFwiX19cIiwgbmFtZXNwYWNlLCBcIl9fXCIgXS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgdGhpcy50dGxLZXkgPSBcIl9fdHRsX19cIjtcbiAgICAgICAgICAgIHRoaXMua2V5TWF0Y2hlciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBfLmVzY2FwZVJlZ0V4Q2hhcnModGhpcy5wcmVmaXgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobHMgJiYgd2luZG93LkpTT04pIHtcbiAgICAgICAgICAgIG1ldGhvZHMgPSB7XG4gICAgICAgICAgICAgICAgX3ByZWZpeDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByZWZpeCArIGtleTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF90dGxLZXk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJlZml4KGtleSkgKyB0aGlzLnR0bEtleTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRXhwaXJlZChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGUobHMuZ2V0SXRlbSh0aGlzLl9wcmVmaXgoa2V5KSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbCwgdHRsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfLmlzTnVtYmVyKHR0bCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxzLnNldEl0ZW0odGhpcy5fdHRsS2V5KGtleSksIGVuY29kZShub3coKSArIHR0bCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbHMucmVtb3ZlSXRlbSh0aGlzLl90dGxLZXkoa2V5KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxzLnNldEl0ZW0odGhpcy5fcHJlZml4KGtleSksIGVuY29kZSh2YWwpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxzLnJlbW92ZUl0ZW0odGhpcy5fdHRsS2V5KGtleSkpO1xuICAgICAgICAgICAgICAgICAgICBscy5yZW1vdmVJdGVtKHRoaXMuX3ByZWZpeChrZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpLCBrZXksIGtleXMgPSBbXSwgbGVuID0gbHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoa2V5ID0gbHMua2V5KGkpKS5tYXRjaCh0aGlzLmtleU1hdGNoZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleS5yZXBsYWNlKHRoaXMua2V5TWF0Y2hlciwgXCJcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGtleXMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoa2V5c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc0V4cGlyZWQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHRsID0gZGVjb2RlKGxzLmdldEl0ZW0odGhpcy5fdHRsS2V5KGtleSkpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uaXNOdW1iZXIodHRsKSAmJiBub3coKSA+IHR0bCA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kcyA9IHtcbiAgICAgICAgICAgICAgICBnZXQ6IF8ubm9vcCxcbiAgICAgICAgICAgICAgICBzZXQ6IF8ubm9vcCxcbiAgICAgICAgICAgICAgICByZW1vdmU6IF8ubm9vcCxcbiAgICAgICAgICAgICAgICBjbGVhcjogXy5ub29wLFxuICAgICAgICAgICAgICAgIGlzRXhwaXJlZDogXy5ub29wXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIF8ubWl4aW4oUGVyc2lzdGVudFN0b3JhZ2UucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbnRTdG9yYWdlO1xuICAgICAgICBmdW5jdGlvbiBub3coKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KF8uaXNVbmRlZmluZWQodmFsKSA/IG51bGwgOiB2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlY29kZSh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbCk7XG4gICAgICAgIH1cbiAgICB9KCk7XG4gICAgdmFyIFRyYW5zcG9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIHBlbmRpbmdSZXF1ZXN0c0NvdW50ID0gMCwgcGVuZGluZ1JlcXVlc3RzID0ge30sIG1heFBlbmRpbmdSZXF1ZXN0cyA9IDYsIHNoYXJlZENhY2hlID0gbmV3IExydUNhY2hlKDEwKTtcbiAgICAgICAgZnVuY3Rpb24gVHJhbnNwb3J0KG8pIHtcbiAgICAgICAgICAgIG8gPSBvIHx8IHt9O1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubGFzdFVybCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9zZW5kID0gby50cmFuc3BvcnQgPyBjYWxsYmFja1RvRGVmZXJyZWQoby50cmFuc3BvcnQpIDogJC5hamF4O1xuICAgICAgICAgICAgdGhpcy5fZ2V0ID0gby5yYXRlTGltaXRlciA/IG8ucmF0ZUxpbWl0ZXIodGhpcy5fZ2V0KSA6IHRoaXMuX2dldDtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlID0gby5jYWNoZSA9PT0gZmFsc2UgPyBuZXcgTHJ1Q2FjaGUoMCkgOiBzaGFyZWRDYWNoZTtcbiAgICAgICAgfVxuICAgICAgICBUcmFuc3BvcnQuc2V0TWF4UGVuZGluZ1JlcXVlc3RzID0gZnVuY3Rpb24gc2V0TWF4UGVuZGluZ1JlcXVlc3RzKG51bSkge1xuICAgICAgICAgICAgbWF4UGVuZGluZ1JlcXVlc3RzID0gbnVtO1xuICAgICAgICB9O1xuICAgICAgICBUcmFuc3BvcnQucmVzZXRDYWNoZSA9IGZ1bmN0aW9uIHJlc2V0Q2FjaGUoKSB7XG4gICAgICAgICAgICBzaGFyZWRDYWNoZS5yZXNldCgpO1xuICAgICAgICB9O1xuICAgICAgICBfLm1peGluKFRyYW5zcG9ydC5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIF9nZXQ6IGZ1bmN0aW9uKHVybCwgbywgY2IpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsIGpxWGhyO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbmNlbGxlZCB8fCB1cmwgIT09IHRoaXMubGFzdFVybCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqcVhociA9IHBlbmRpbmdSZXF1ZXN0c1t1cmxdKSB7XG4gICAgICAgICAgICAgICAgICAgIGpxWGhyLmRvbmUoZG9uZSkuZmFpbChmYWlsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBlbmRpbmdSZXF1ZXN0c0NvdW50IDwgbWF4UGVuZGluZ1JlcXVlc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdSZXF1ZXN0c0NvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdSZXF1ZXN0c1t1cmxdID0gdGhpcy5fc2VuZCh1cmwsIG8pLmRvbmUoZG9uZSkuZmFpbChmYWlsKS5hbHdheXMoYWx3YXlzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRGVja1JlcXVlc3RBcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb25lKHJlc3ApIHtcbiAgICAgICAgICAgICAgICAgICAgY2IgJiYgY2IobnVsbCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX2NhY2hlLnNldCh1cmwsIHJlc3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBmYWlsKCkge1xuICAgICAgICAgICAgICAgICAgICBjYiAmJiBjYih0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYWx3YXlzKCkge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUmVxdWVzdHNDb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGVuZGluZ1JlcXVlc3RzW3VybF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0Lm9uRGVja1JlcXVlc3RBcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9nZXQuYXBwbHkodGhhdCwgdGhhdC5vbkRlY2tSZXF1ZXN0QXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm9uRGVja1JlcXVlc3RBcmdzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKHVybCwgbywgY2IpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzcDtcbiAgICAgICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKG8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiID0gbztcbiAgICAgICAgICAgICAgICAgICAgbyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFVybCA9IHVybDtcbiAgICAgICAgICAgICAgICBpZiAocmVzcCA9IHRoaXMuX2NhY2hlLmdldCh1cmwpKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uZGVmZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYiAmJiBjYihudWxsLCByZXNwKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2V0KHVybCwgbywgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gISFyZXNwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFRyYW5zcG9ydDtcbiAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2tUb0RlZmVycmVkKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3VzdG9tU2VuZFdyYXBwZXIodXJsLCBvKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpO1xuICAgICAgICAgICAgICAgIGZuKHVybCwgbywgb25TdWNjZXNzLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQ7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gb25TdWNjZXNzKHJlc3ApIHtcbiAgICAgICAgICAgICAgICAgICAgXy5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzcCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBvbkVycm9yKGVycikge1xuICAgICAgICAgICAgICAgICAgICBfLmRlZmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KCk7XG4gICAgdmFyIFNlYXJjaEluZGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBmdW5jdGlvbiBTZWFyY2hJbmRleChvKSB7XG4gICAgICAgICAgICBvID0gbyB8fCB7fTtcbiAgICAgICAgICAgIGlmICghby5kYXR1bVRva2VuaXplciB8fCAhby5xdWVyeVRva2VuaXplcikge1xuICAgICAgICAgICAgICAgICQuZXJyb3IoXCJkYXR1bVRva2VuaXplciBhbmQgcXVlcnlUb2tlbml6ZXIgYXJlIGJvdGggcmVxdWlyZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRhdHVtVG9rZW5pemVyID0gby5kYXR1bVRva2VuaXplcjtcbiAgICAgICAgICAgIHRoaXMucXVlcnlUb2tlbml6ZXIgPSBvLnF1ZXJ5VG9rZW5pemVyO1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIF8ubWl4aW4oU2VhcmNoSW5kZXgucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBib290c3RyYXA6IGZ1bmN0aW9uIGJvb3RzdHJhcChvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXR1bXMgPSBvLmRhdHVtcztcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWUgPSBvLnRyaWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWRkOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBfLmlzQXJyYXkoZGF0YSkgPyBkYXRhIDogWyBkYXRhIF07XG4gICAgICAgICAgICAgICAgXy5lYWNoKGRhdGEsIGZ1bmN0aW9uKGRhdHVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCwgdG9rZW5zO1xuICAgICAgICAgICAgICAgICAgICBpZCA9IHRoYXQuZGF0dW1zLnB1c2goZGF0dW0pIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gbm9ybWFsaXplVG9rZW5zKHRoYXQuZGF0dW1Ub2tlbml6ZXIoZGF0dW0pKTtcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKHRva2VucywgZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlLCBjaGFycywgY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gdGhhdC50cmllO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnMgPSB0b2tlbi5zcGxpdChcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaCA9IGNoYXJzLnNoaWZ0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlbltjaF0gfHwgKG5vZGUuY2hpbGRyZW5bY2hdID0gbmV3Tm9kZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmlkcy5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQocXVlcnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsIHRva2VucywgbWF0Y2hlcztcbiAgICAgICAgICAgICAgICB0b2tlbnMgPSBub3JtYWxpemVUb2tlbnModGhpcy5xdWVyeVRva2VuaXplcihxdWVyeSkpO1xuICAgICAgICAgICAgICAgIF8uZWFjaCh0b2tlbnMsIGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlLCBjaGFycywgY2gsIGlkcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlID0gdGhhdC50cmllO1xuICAgICAgICAgICAgICAgICAgICBjaGFycyA9IHRva2VuLnNwbGl0KFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobm9kZSAmJiAoY2ggPSBjaGFycy5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bY2hdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlICYmIGNoYXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRzID0gbm9kZS5pZHMuc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2hlcyA/IGdldEludGVyc2VjdGlvbihtYXRjaGVzLCBpZHMpIDogaWRzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXMgPyBfLm1hcCh1bmlxdWUobWF0Y2hlcyksIGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmRhdHVtc1tpZF07XG4gICAgICAgICAgICAgICAgfSkgOiBbXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXR1bXMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWUgPSBuZXdOb2RlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0dW1zOiB0aGlzLmRhdHVtcyxcbiAgICAgICAgICAgICAgICAgICAgdHJpZTogdGhpcy50cmllXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBTZWFyY2hJbmRleDtcbiAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXplVG9rZW5zKHRva2Vucykge1xuICAgICAgICAgICAgdG9rZW5zID0gXy5maWx0ZXIodG9rZW5zLCBmdW5jdGlvbih0b2tlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIXRva2VuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0b2tlbnMgPSBfLm1hcCh0b2tlbnMsIGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbmV3Tm9kZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWRzOiBbXSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjoge31cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdW5pcXVlKGFycmF5KSB7XG4gICAgICAgICAgICB2YXIgc2VlbiA9IHt9LCB1bmlxdWVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNlZW5bYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZW5bYXJyYXlbaV1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlcy5wdXNoKGFycmF5W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5pcXVlcztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb24oYXJyYXlBLCBhcnJheUIpIHtcbiAgICAgICAgICAgIHZhciBhaSA9IDAsIGJpID0gMCwgaW50ZXJzZWN0aW9uID0gW107XG4gICAgICAgICAgICBhcnJheUEgPSBhcnJheUEuc29ydChjb21wYXJlKTtcbiAgICAgICAgICAgIGFycmF5QiA9IGFycmF5Qi5zb3J0KGNvbXBhcmUpO1xuICAgICAgICAgICAgdmFyIGxlbkFycmF5QSA9IGFycmF5QS5sZW5ndGgsIGxlbkFycmF5QiA9IGFycmF5Qi5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoYWkgPCBsZW5BcnJheUEgJiYgYmkgPCBsZW5BcnJheUIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXlBW2FpXSA8IGFycmF5QltiaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWkrKztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFycmF5QVthaV0gPiBhcnJheUJbYmldKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uLnB1c2goYXJyYXlBW2FpXSk7XG4gICAgICAgICAgICAgICAgICAgIGFpKys7XG4gICAgICAgICAgICAgICAgICAgIGJpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGludGVyc2VjdGlvbjtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0oKTtcbiAgICB2YXIgb1BhcnNlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvY2FsOiBnZXRMb2NhbCxcbiAgICAgICAgICAgIHByZWZldGNoOiBnZXRQcmVmZXRjaCxcbiAgICAgICAgICAgIHJlbW90ZTogZ2V0UmVtb3RlXG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIGdldExvY2FsKG8pIHtcbiAgICAgICAgICAgIHJldHVybiBvLmxvY2FsIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0UHJlZmV0Y2gobykge1xuICAgICAgICAgICAgdmFyIHByZWZldGNoLCBkZWZhdWx0cztcbiAgICAgICAgICAgIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgICAgIHVybDogbnVsbCxcbiAgICAgICAgICAgICAgICB0aHVtYnByaW50OiBcIlwiLFxuICAgICAgICAgICAgICAgIHR0bDogMjQgKiA2MCAqIDYwICogMWUzLFxuICAgICAgICAgICAgICAgIGZpbHRlcjogbnVsbCxcbiAgICAgICAgICAgICAgICBhamF4OiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwcmVmZXRjaCA9IG8ucHJlZmV0Y2ggfHwgbnVsbCkge1xuICAgICAgICAgICAgICAgIHByZWZldGNoID0gXy5pc1N0cmluZyhwcmVmZXRjaCkgPyB7XG4gICAgICAgICAgICAgICAgICAgIHVybDogcHJlZmV0Y2hcbiAgICAgICAgICAgICAgICB9IDogcHJlZmV0Y2g7XG4gICAgICAgICAgICAgICAgcHJlZmV0Y2ggPSBfLm1peGluKGRlZmF1bHRzLCBwcmVmZXRjaCk7XG4gICAgICAgICAgICAgICAgcHJlZmV0Y2gudGh1bWJwcmludCA9IFZFUlNJT04gKyBwcmVmZXRjaC50aHVtYnByaW50O1xuICAgICAgICAgICAgICAgIHByZWZldGNoLmFqYXgudHlwZSA9IHByZWZldGNoLmFqYXgudHlwZSB8fCBcIkdFVFwiO1xuICAgICAgICAgICAgICAgIHByZWZldGNoLmFqYXguZGF0YVR5cGUgPSBwcmVmZXRjaC5hamF4LmRhdGFUeXBlIHx8IFwianNvblwiO1xuICAgICAgICAgICAgICAgICFwcmVmZXRjaC51cmwgJiYgJC5lcnJvcihcInByZWZldGNoIHJlcXVpcmVzIHVybCB0byBiZSBzZXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJlZmV0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0UmVtb3RlKG8pIHtcbiAgICAgICAgICAgIHZhciByZW1vdGUsIGRlZmF1bHRzO1xuICAgICAgICAgICAgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiBudWxsLFxuICAgICAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdpbGRjYXJkOiBcIiVRVUVSWVwiLFxuICAgICAgICAgICAgICAgIHJlcGxhY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgcmF0ZUxpbWl0Qnk6IFwiZGVib3VuY2VcIixcbiAgICAgICAgICAgICAgICByYXRlTGltaXRXYWl0OiAzMDAsXG4gICAgICAgICAgICAgICAgc2VuZDogbnVsbCxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgYWpheDoge31cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocmVtb3RlID0gby5yZW1vdGUgfHwgbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlbW90ZSA9IF8uaXNTdHJpbmcocmVtb3RlKSA/IHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiByZW1vdGVcbiAgICAgICAgICAgICAgICB9IDogcmVtb3RlO1xuICAgICAgICAgICAgICAgIHJlbW90ZSA9IF8ubWl4aW4oZGVmYXVsdHMsIHJlbW90ZSk7XG4gICAgICAgICAgICAgICAgcmVtb3RlLnJhdGVMaW1pdGVyID0gL150aHJvdHRsZSQvaS50ZXN0KHJlbW90ZS5yYXRlTGltaXRCeSkgPyBieVRocm90dGxlKHJlbW90ZS5yYXRlTGltaXRXYWl0KSA6IGJ5RGVib3VuY2UocmVtb3RlLnJhdGVMaW1pdFdhaXQpO1xuICAgICAgICAgICAgICAgIHJlbW90ZS5hamF4LnR5cGUgPSByZW1vdGUuYWpheC50eXBlIHx8IFwiR0VUXCI7XG4gICAgICAgICAgICAgICAgcmVtb3RlLmFqYXguZGF0YVR5cGUgPSByZW1vdGUuYWpheC5kYXRhVHlwZSB8fCBcImpzb25cIjtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVtb3RlLnJhdGVMaW1pdEJ5O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZW1vdGUucmF0ZUxpbWl0V2FpdDtcbiAgICAgICAgICAgICAgICAhcmVtb3RlLnVybCAmJiAkLmVycm9yKFwicmVtb3RlIHJlcXVpcmVzIHVybCB0byBiZSBzZXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVtb3RlO1xuICAgICAgICAgICAgZnVuY3Rpb24gYnlEZWJvdW5jZSh3YWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLmRlYm91bmNlKGZuLCB3YWl0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gYnlUaHJvdHRsZSh3YWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLnRocm90dGxlKGZuLCB3YWl0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSgpO1xuICAgIChmdW5jdGlvbihyb290KSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgb2xkLCBrZXlzO1xuICAgICAgICBvbGQgPSByb290LkJsb29kaG91bmQ7XG4gICAgICAgIGtleXMgPSB7XG4gICAgICAgICAgICBkYXRhOiBcImRhdGFcIixcbiAgICAgICAgICAgIHByb3RvY29sOiBcInByb3RvY29sXCIsXG4gICAgICAgICAgICB0aHVtYnByaW50OiBcInRodW1icHJpbnRcIlxuICAgICAgICB9O1xuICAgICAgICByb290LkJsb29kaG91bmQgPSBCbG9vZGhvdW5kO1xuICAgICAgICBmdW5jdGlvbiBCbG9vZGhvdW5kKG8pIHtcbiAgICAgICAgICAgIGlmICghbyB8fCAhby5sb2NhbCAmJiAhby5wcmVmZXRjaCAmJiAhby5yZW1vdGUpIHtcbiAgICAgICAgICAgICAgICAkLmVycm9yKFwib25lIG9mIGxvY2FsLCBwcmVmZXRjaCwgb3IgcmVtb3RlIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5saW1pdCA9IG8ubGltaXQgfHwgNTtcbiAgICAgICAgICAgIHRoaXMuc29ydGVyID0gZ2V0U29ydGVyKG8uc29ydGVyKTtcbiAgICAgICAgICAgIHRoaXMuZHVwRGV0ZWN0b3IgPSBvLmR1cERldGVjdG9yIHx8IGlnbm9yZUR1cGxpY2F0ZXM7XG4gICAgICAgICAgICB0aGlzLmxvY2FsID0gb1BhcnNlci5sb2NhbChvKTtcbiAgICAgICAgICAgIHRoaXMucHJlZmV0Y2ggPSBvUGFyc2VyLnByZWZldGNoKG8pO1xuICAgICAgICAgICAgdGhpcy5yZW1vdGUgPSBvUGFyc2VyLnJlbW90ZShvKTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVLZXkgPSB0aGlzLnByZWZldGNoID8gdGhpcy5wcmVmZXRjaC5jYWNoZUtleSB8fCB0aGlzLnByZWZldGNoLnVybCA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gbmV3IFNlYXJjaEluZGV4KHtcbiAgICAgICAgICAgICAgICBkYXR1bVRva2VuaXplcjogby5kYXR1bVRva2VuaXplcixcbiAgICAgICAgICAgICAgICBxdWVyeVRva2VuaXplcjogby5xdWVyeVRva2VuaXplclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSB0aGlzLmNhY2hlS2V5ID8gbmV3IFBlcnNpc3RlbnRTdG9yYWdlKHRoaXMuY2FjaGVLZXkpIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBCbG9vZGhvdW5kLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgICAgICAgICAgcm9vdC5CbG9vZGhvdW5kID0gb2xkO1xuICAgICAgICAgICAgcmV0dXJuIEJsb29kaG91bmQ7XG4gICAgICAgIH07XG4gICAgICAgIEJsb29kaG91bmQudG9rZW5pemVycyA9IHRva2VuaXplcnM7XG4gICAgICAgIF8ubWl4aW4oQmxvb2Rob3VuZC5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIF9sb2FkUHJlZmV0Y2g6IGZ1bmN0aW9uIGxvYWRQcmVmZXRjaChvKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLCBzZXJpYWxpemVkLCBkZWZlcnJlZDtcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWFsaXplZCA9IHRoaXMuX3JlYWRGcm9tU3RvcmFnZShvLnRodW1icHJpbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXguYm9vdHN0cmFwKHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZCA9ICQuRGVmZXJyZWQoKS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQgPSAkLmFqYXgoby51cmwsIG8uYWpheCkuZG9uZShoYW5kbGVQcmVmZXRjaFJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZVByZWZldGNoUmVzcG9uc2UocmVzcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYWRkKG8uZmlsdGVyID8gby5maWx0ZXIocmVzcCkgOiByZXNwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fc2F2ZVRvU3RvcmFnZSh0aGF0LmluZGV4LnNlcmlhbGl6ZSgpLCBvLnRodW1icHJpbnQsIG8udHRsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2dldEZyb21SZW1vdGU6IGZ1bmN0aW9uIGdldEZyb21SZW1vdGUocXVlcnksIGNiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLCB1cmwsIHVyaUVuY29kZWRRdWVyeTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBxdWVyeSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIHVyaUVuY29kZWRRdWVyeSA9IGVuY29kZVVSSUNvbXBvbmVudChxdWVyeSk7XG4gICAgICAgICAgICAgICAgdXJsID0gdGhpcy5yZW1vdGUucmVwbGFjZSA/IHRoaXMucmVtb3RlLnJlcGxhY2UodGhpcy5yZW1vdGUudXJsLCBxdWVyeSkgOiB0aGlzLnJlbW90ZS51cmwucmVwbGFjZSh0aGlzLnJlbW90ZS53aWxkY2FyZCwgdXJpRW5jb2RlZFF1ZXJ5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQuZ2V0KHVybCwgdGhpcy5yZW1vdGUuYWpheCwgaGFuZGxlUmVtb3RlUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZVJlbW90ZVJlc3BvbnNlKGVyciwgcmVzcCkge1xuICAgICAgICAgICAgICAgICAgICBlcnIgPyBjYihbXSkgOiBjYih0aGF0LnJlbW90ZS5maWx0ZXIgPyB0aGF0LnJlbW90ZS5maWx0ZXIocmVzcCkgOiByZXNwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2NhbmNlbExhc3RSZW1vdGVSZXF1ZXN0OiBmdW5jdGlvbiBjYW5jZWxMYXN0UmVtb3RlUmVxdWVzdCgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydCAmJiB0aGlzLnRyYW5zcG9ydC5jYW5jZWwoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2F2ZVRvU3RvcmFnZTogZnVuY3Rpb24gc2F2ZVRvU3RvcmFnZShkYXRhLCB0aHVtYnByaW50LCB0dGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5zZXQoa2V5cy5kYXRhLCBkYXRhLCB0dGwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0KGtleXMucHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sLCB0dGwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0KGtleXMudGh1bWJwcmludCwgdGh1bWJwcmludCwgdHRsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3JlYWRGcm9tU3RvcmFnZTogZnVuY3Rpb24gcmVhZEZyb21TdG9yYWdlKHRodW1icHJpbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcmVkID0ge30sIGlzRXhwaXJlZDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlZC5kYXRhID0gdGhpcy5zdG9yYWdlLmdldChrZXlzLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBzdG9yZWQucHJvdG9jb2wgPSB0aGlzLnN0b3JhZ2UuZ2V0KGtleXMucHJvdG9jb2wpO1xuICAgICAgICAgICAgICAgICAgICBzdG9yZWQudGh1bWJwcmludCA9IHRoaXMuc3RvcmFnZS5nZXQoa2V5cy50aHVtYnByaW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXNFeHBpcmVkID0gc3RvcmVkLnRodW1icHJpbnQgIT09IHRodW1icHJpbnQgfHwgc3RvcmVkLnByb3RvY29sICE9PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmVkLmRhdGEgJiYgIWlzRXhwaXJlZCA/IHN0b3JlZC5kYXRhIDogbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsIGxvY2FsID0gdGhpcy5sb2NhbCwgZGVmZXJyZWQ7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQgPSB0aGlzLnByZWZldGNoID8gdGhpcy5fbG9hZFByZWZldGNoKHRoaXMucHJlZmV0Y2gpIDogJC5EZWZlcnJlZCgpLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICBsb2NhbCAmJiBkZWZlcnJlZC5kb25lKGFkZExvY2FsVG9JbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0aGlzLnJlbW90ZSA/IG5ldyBUcmFuc3BvcnQodGhpcy5yZW1vdGUpIDogbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0UHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2UoKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhZGRMb2NhbFRvSW5kZXgoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYWRkKF8uaXNGdW5jdGlvbihsb2NhbCkgPyBsb2NhbCgpIDogbG9jYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLmluaXRQcm9taXNlIHx8IGZvcmNlID8gdGhpcy5faW5pdGlhbGl6ZSgpIDogdGhpcy5pbml0UHJvbWlzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uIGFkZChkYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleC5hZGQoZGF0YSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQocXVlcnksIGNiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLCBtYXRjaGVzID0gW10sIGNhY2hlSGl0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbWF0Y2hlcyA9IHRoaXMuaW5kZXguZ2V0KHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBtYXRjaGVzID0gdGhpcy5zb3J0ZXIobWF0Y2hlcykuc2xpY2UoMCwgdGhpcy5saW1pdCk7XG4gICAgICAgICAgICAgICAgbWF0Y2hlcy5sZW5ndGggPCB0aGlzLmxpbWl0ID8gY2FjaGVIaXQgPSB0aGlzLl9nZXRGcm9tUmVtb3RlKHF1ZXJ5LCByZXR1cm5SZW1vdGVNYXRjaGVzKSA6IHRoaXMuX2NhbmNlbExhc3RSZW1vdGVSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZUhpdCkge1xuICAgICAgICAgICAgICAgICAgICAobWF0Y2hlcy5sZW5ndGggPiAwIHx8ICF0aGlzLnRyYW5zcG9ydCkgJiYgY2IgJiYgY2IobWF0Y2hlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJldHVyblJlbW90ZU1hdGNoZXMocmVtb3RlTWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlc1dpdGhCYWNrZmlsbCA9IG1hdGNoZXMuc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChyZW1vdGVNYXRjaGVzLCBmdW5jdGlvbihyZW1vdGVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzRHVwbGljYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNEdXBsaWNhdGUgPSBfLnNvbWUobWF0Y2hlc1dpdGhCYWNrZmlsbCwgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5kdXBEZXRlY3RvcihyZW1vdGVNYXRjaCwgbWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNEdXBsaWNhdGUgJiYgbWF0Y2hlc1dpdGhCYWNrZmlsbC5wdXNoKHJlbW90ZU1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzV2l0aEJhY2tmaWxsLmxlbmd0aCA8IHRoYXQubGltaXQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjYiAmJiBjYih0aGF0LnNvcnRlcihtYXRjaGVzV2l0aEJhY2tmaWxsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnJlc2V0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xlYXJQcmVmZXRjaENhY2hlOiBmdW5jdGlvbiBjbGVhclByZWZldGNoQ2FjaGUoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlICYmIHRoaXMuc3RvcmFnZS5jbGVhcigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsZWFyUmVtb3RlQ2FjaGU6IGZ1bmN0aW9uIGNsZWFyUmVtb3RlQ2FjaGUoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQgJiYgVHJhbnNwb3J0LnJlc2V0Q2FjaGUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0dEFkYXB0ZXI6IGZ1bmN0aW9uIHR0QWRhcHRlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5iaW5kKHRoaXMuZ2V0LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBCbG9vZGhvdW5kO1xuICAgICAgICBmdW5jdGlvbiBnZXRTb3J0ZXIoc29ydEZuKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKHNvcnRGbikgPyBzb3J0IDogbm9Tb3J0O1xuICAgICAgICAgICAgZnVuY3Rpb24gc29ydChhcnJheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheS5zb3J0KHNvcnRGbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBub1NvcnQoYXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaWdub3JlRHVwbGljYXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pKHRoaXMpO1xuICAgIHZhciBodG1sID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3cmFwcGVyOiAnPHNwYW4gY2xhc3M9XCJ0d2l0dGVyLXR5cGVhaGVhZFwiPjwvc3Bhbj4nLFxuICAgICAgICAgICAgZHJvcGRvd246ICc8c3BhbiBjbGFzcz1cInR0LWRyb3Bkb3duLW1lbnVcIj48L3NwYW4+JyxcbiAgICAgICAgICAgIGRhdGFzZXQ6ICc8ZGl2IGNsYXNzPVwidHQtZGF0YXNldC0lQ0xBU1MlXCI+PC9kaXY+JyxcbiAgICAgICAgICAgIHN1Z2dlc3Rpb25zOiAnPHNwYW4gY2xhc3M9XCJ0dC1zdWdnZXN0aW9uc1wiPjwvc3Bhbj4nLFxuICAgICAgICAgICAgc3VnZ2VzdGlvbjogJzxkaXYgY2xhc3M9XCJ0dC1zdWdnZXN0aW9uXCI+PC9kaXY+J1xuICAgICAgICB9O1xuICAgIH0oKTtcbiAgICB2YXIgY3NzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgY3NzID0ge1xuICAgICAgICAgICAgd3JhcHBlcjoge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgICAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhpbnQ6IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgIHRvcDogXCIwXCIsXG4gICAgICAgICAgICAgICAgbGVmdDogXCIwXCIsXG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgICAgICBib3hTaGFkb3c6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IFwiMVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5wdXQ6IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246IFwidG9wXCIsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnB1dFdpdGhOb0hpbnQ6IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246IFwidG9wXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkcm9wZG93bjoge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICAgICAgdG9wOiBcIjEwMCVcIixcbiAgICAgICAgICAgICAgICBsZWZ0OiBcIjBcIixcbiAgICAgICAgICAgICAgICB6SW5kZXg6IFwiMTAwXCIsXG4gICAgICAgICAgICAgICAgZGlzcGxheTogXCJub25lXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWdnZXN0aW9uczoge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1Z2dlc3Rpb246IHtcbiAgICAgICAgICAgICAgICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiLFxuICAgICAgICAgICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWdnZXN0aW9uQ2hpbGQ6IHtcbiAgICAgICAgICAgICAgICB3aGl0ZVNwYWNlOiBcIm5vcm1hbFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbHRyOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogXCIwXCIsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IFwiYXV0b1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnRsOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogXCJhdXRvXCIsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IFwiIDBcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoXy5pc01zaWUoKSkge1xuICAgICAgICAgICAgXy5taXhpbihjc3MuaW5wdXQsIHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwidXJsKGRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veUg1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlCUkFBNylcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF8uaXNNc2llKCkgJiYgXy5pc01zaWUoKSA8PSA3KSB7XG4gICAgICAgICAgICBfLm1peGluKGNzcy5pbnB1dCwge1xuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogXCItMXB4XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjc3M7XG4gICAgfSgpO1xuICAgIHZhciBFdmVudEJ1cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IFwidHlwZWFoZWFkOlwiO1xuICAgICAgICBmdW5jdGlvbiBFdmVudEJ1cyhvKSB7XG4gICAgICAgICAgICBpZiAoIW8gfHwgIW8uZWwpIHtcbiAgICAgICAgICAgICAgICAkLmVycm9yKFwiRXZlbnRCdXMgaW5pdGlhbGl6ZWQgd2l0aG91dCBlbFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJGVsID0gJChvLmVsKTtcbiAgICAgICAgfVxuICAgICAgICBfLm1peGluKEV2ZW50QnVzLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsLnRyaWdnZXIobmFtZXNwYWNlICsgdHlwZSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gRXZlbnRCdXM7XG4gICAgfSgpO1xuICAgIHZhciBFdmVudEVtaXR0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBzcGxpdHRlciA9IC9cXHMrLywgbmV4dFRpY2sgPSBnZXROZXh0VGljaygpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb25TeW5jOiBvblN5bmMsXG4gICAgICAgICAgICBvbkFzeW5jOiBvbkFzeW5jLFxuICAgICAgICAgICAgb2ZmOiBvZmYsXG4gICAgICAgICAgICB0cmlnZ2VyOiB0cmlnZ2VyXG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIG9uKG1ldGhvZCwgdHlwZXMsIGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgdHlwZTtcbiAgICAgICAgICAgIGlmICghY2IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGVzID0gdHlwZXMuc3BsaXQoc3BsaXR0ZXIpO1xuICAgICAgICAgICAgY2IgPSBjb250ZXh0ID8gYmluZENvbnRleHQoY2IsIGNvbnRleHQpIDogY2I7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICAgICAgICAgICB3aGlsZSAodHlwZSA9IHR5cGVzLnNoaWZ0KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja3NbdHlwZV0gPSB0aGlzLl9jYWxsYmFja3NbdHlwZV0gfHwge1xuICAgICAgICAgICAgICAgICAgICBzeW5jOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgYXN5bmM6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja3NbdHlwZV1bbWV0aG9kXS5wdXNoKGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uQXN5bmModHlwZXMsIGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gb24uY2FsbCh0aGlzLCBcImFzeW5jXCIsIHR5cGVzLCBjYiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25TeW5jKHR5cGVzLCBjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIG9uLmNhbGwodGhpcywgXCJzeW5jXCIsIHR5cGVzLCBjYiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb2ZmKHR5cGVzKSB7XG4gICAgICAgICAgICB2YXIgdHlwZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlcyA9IHR5cGVzLnNwbGl0KHNwbGl0dGVyKTtcbiAgICAgICAgICAgIHdoaWxlICh0eXBlID0gdHlwZXMuc2hpZnQoKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbdHlwZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0cmlnZ2VyKHR5cGVzKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSwgY2FsbGJhY2tzLCBhcmdzLCBzeW5jRmx1c2gsIGFzeW5jRmx1c2g7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZXMgPSB0eXBlcy5zcGxpdChzcGxpdHRlcik7XG4gICAgICAgICAgICBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgd2hpbGUgKCh0eXBlID0gdHlwZXMuc2hpZnQoKSkgJiYgKGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1t0eXBlXSkpIHtcbiAgICAgICAgICAgICAgICBzeW5jRmx1c2ggPSBnZXRGbHVzaChjYWxsYmFja3Muc3luYywgdGhpcywgWyB0eXBlIF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICAgICAgICBhc3luY0ZsdXNoID0gZ2V0Rmx1c2goY2FsbGJhY2tzLmFzeW5jLCB0aGlzLCBbIHR5cGUgXS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgICAgIHN5bmNGbHVzaCgpICYmIG5leHRUaWNrKGFzeW5jRmx1c2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0Rmx1c2goY2FsbGJhY2tzLCBjb250ZXh0LCBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmx1c2g7XG4gICAgICAgICAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FuY2VsbGVkO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyAhY2FuY2VsbGVkICYmIGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxsZWQgPSBjYWxsYmFja3NbaV0uYXBwbHkoY29udGV4dCwgYXJncykgPT09IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gIWNhbmNlbGxlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXROZXh0VGljaygpIHtcbiAgICAgICAgICAgIHZhciBuZXh0VGlja0ZuO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgICAgICAgICBuZXh0VGlja0ZuID0gZnVuY3Rpb24gbmV4dFRpY2tTZXRJbW1lZGlhdGUoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dFRpY2tGbiA9IGZ1bmN0aW9uIG5leHRUaWNrU2V0VGltZW91dChmbikge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXh0VGlja0ZuO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJpbmRDb250ZXh0KGZuLCBjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYmluZCA/IGZuLmJpbmQoY29udGV4dCkgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmbi5hcHBseShjb250ZXh0LCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0oKTtcbiAgICB2YXIgaGlnaGxpZ2h0ID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBub2RlOiBudWxsLFxuICAgICAgICAgICAgcGF0dGVybjogbnVsbCxcbiAgICAgICAgICAgIHRhZ05hbWU6IFwic3Ryb25nXCIsXG4gICAgICAgICAgICBjbGFzc05hbWU6IG51bGwsXG4gICAgICAgICAgICB3b3Jkc09ubHk6IGZhbHNlLFxuICAgICAgICAgICAgY2FzZVNlbnNpdGl2ZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGhpZ2h0bGlnaHQobykge1xuICAgICAgICAgICAgdmFyIHJlZ2V4O1xuICAgICAgICAgICAgbyA9IF8ubWl4aW4oe30sIGRlZmF1bHRzLCBvKTtcbiAgICAgICAgICAgIGlmICghby5ub2RlIHx8ICFvLnBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvLnBhdHRlcm4gPSBfLmlzQXJyYXkoby5wYXR0ZXJuKSA/IG8ucGF0dGVybiA6IFsgby5wYXR0ZXJuIF07XG4gICAgICAgICAgICByZWdleCA9IGdldFJlZ2V4KG8ucGF0dGVybiwgby5jYXNlU2Vuc2l0aXZlLCBvLndvcmRzT25seSk7XG4gICAgICAgICAgICB0cmF2ZXJzZShvLm5vZGUsIGhpZ2h0bGlnaHRUZXh0Tm9kZSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBoaWdodGxpZ2h0VGV4dE5vZGUodGV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2gsIHBhdHRlcm5Ob2RlLCB3cmFwcGVyTm9kZTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPSByZWdleC5leGVjKHRleHROb2RlLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXJOb2RlID0gZG9jLmNyZWF0ZUVsZW1lbnQoby50YWdOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgby5jbGFzc05hbWUgJiYgKHdyYXBwZXJOb2RlLmNsYXNzTmFtZSA9IG8uY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybk5vZGUgPSB0ZXh0Tm9kZS5zcGxpdFRleHQobWF0Y2guaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuTm9kZS5zcGxpdFRleHQobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlck5vZGUuYXBwZW5kQ2hpbGQocGF0dGVybk5vZGUuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dE5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQod3JhcHBlck5vZGUsIHBhdHRlcm5Ob2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhbWF0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiB0cmF2ZXJzZShlbCwgaGlnaHRsaWdodFRleHROb2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSwgVEVYVF9OT0RFX1RZUEUgPSAzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBlbC5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSBURVhUX05PREVfVFlQRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBoaWdodGxpZ2h0VGV4dE5vZGUoY2hpbGROb2RlKSA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2UoY2hpbGROb2RlLCBoaWdodGxpZ2h0VGV4dE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBnZXRSZWdleChwYXR0ZXJucywgY2FzZVNlbnNpdGl2ZSwgd29yZHNPbmx5KSB7XG4gICAgICAgICAgICB2YXIgZXNjYXBlZFBhdHRlcm5zID0gW10sIHJlZ2V4U3RyO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhdHRlcm5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZFBhdHRlcm5zLnB1c2goXy5lc2NhcGVSZWdFeENoYXJzKHBhdHRlcm5zW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWdleFN0ciA9IHdvcmRzT25seSA/IFwiXFxcXGIoXCIgKyBlc2NhcGVkUGF0dGVybnMuam9pbihcInxcIikgKyBcIilcXFxcYlwiIDogXCIoXCIgKyBlc2NhcGVkUGF0dGVybnMuam9pbihcInxcIikgKyBcIilcIjtcbiAgICAgICAgICAgIHJldHVybiBjYXNlU2Vuc2l0aXZlID8gbmV3IFJlZ0V4cChyZWdleFN0cikgOiBuZXcgUmVnRXhwKHJlZ2V4U3RyLCBcImlcIik7XG4gICAgICAgIH1cbiAgICB9KHdpbmRvdy5kb2N1bWVudCk7XG4gICAgdmFyIElucHV0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgc3BlY2lhbEtleUNvZGVNYXA7XG4gICAgICAgIHNwZWNpYWxLZXlDb2RlTWFwID0ge1xuICAgICAgICAgICAgOTogXCJ0YWJcIixcbiAgICAgICAgICAgIDI3OiBcImVzY1wiLFxuICAgICAgICAgICAgMzc6IFwibGVmdFwiLFxuICAgICAgICAgICAgMzk6IFwicmlnaHRcIixcbiAgICAgICAgICAgIDEzOiBcImVudGVyXCIsXG4gICAgICAgICAgICAzODogXCJ1cFwiLFxuICAgICAgICAgICAgNDA6IFwiZG93blwiXG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIElucHV0KG8pIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcywgb25CbHVyLCBvbkZvY3VzLCBvbktleWRvd24sIG9uSW5wdXQ7XG4gICAgICAgICAgICBvID0gbyB8fCB7fTtcbiAgICAgICAgICAgIGlmICghby5pbnB1dCkge1xuICAgICAgICAgICAgICAgICQuZXJyb3IoXCJpbnB1dCBpcyBtaXNzaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25CbHVyID0gXy5iaW5kKHRoaXMuX29uQmx1ciwgdGhpcyk7XG4gICAgICAgICAgICBvbkZvY3VzID0gXy5iaW5kKHRoaXMuX29uRm9jdXMsIHRoaXMpO1xuICAgICAgICAgICAgb25LZXlkb3duID0gXy5iaW5kKHRoaXMuX29uS2V5ZG93biwgdGhpcyk7XG4gICAgICAgICAgICBvbklucHV0ID0gXy5iaW5kKHRoaXMuX29uSW5wdXQsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy4kaGludCA9ICQoby5oaW50KTtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0ID0gJChvLmlucHV0KS5vbihcImJsdXIudHRcIiwgb25CbHVyKS5vbihcImZvY3VzLnR0XCIsIG9uRm9jdXMpLm9uKFwia2V5ZG93bi50dFwiLCBvbktleWRvd24pO1xuICAgICAgICAgICAgaWYgKHRoaXMuJGhpbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRIaW50ID0gdGhpcy5nZXRIaW50ID0gdGhpcy5jbGVhckhpbnQgPSB0aGlzLmNsZWFySGludElmSW52YWxpZCA9IF8ubm9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghXy5pc01zaWUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGlucHV0Lm9uKFwiaW5wdXQudHRcIiwgb25JbnB1dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuJGlucHV0Lm9uKFwia2V5ZG93bi50dCBrZXlwcmVzcy50dCBjdXQudHQgcGFzdGUudHRcIiwgZnVuY3Rpb24oJGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWNpYWxLZXlDb2RlTWFwWyRlLndoaWNoIHx8ICRlLmtleUNvZGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXy5kZWZlcihfLmJpbmQodGhhdC5fb25JbnB1dCwgdGhhdCwgJGUpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLiRpbnB1dC52YWwoKTtcbiAgICAgICAgICAgIHRoaXMuJG92ZXJmbG93SGVscGVyID0gYnVpbGRPdmVyZmxvd0hlbHBlcih0aGlzLiRpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgSW5wdXQubm9ybWFsaXplUXVlcnkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiAoc3RyIHx8IFwiXCIpLnJlcGxhY2UoL15cXHMqL2csIFwiXCIpLnJlcGxhY2UoL1xcc3syLH0vZywgXCIgXCIpO1xuICAgICAgICB9O1xuICAgICAgICBfLm1peGluKElucHV0LnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyLCB7XG4gICAgICAgICAgICBfb25CbHVyOiBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldElucHV0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJibHVycmVkXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkZvY3VzOiBmdW5jdGlvbiBvbkZvY3VzKCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihcImZvY3VzZWRcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uS2V5ZG93bjogZnVuY3Rpb24gb25LZXlkb3duKCRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleU5hbWUgPSBzcGVjaWFsS2V5Q29kZU1hcFskZS53aGljaCB8fCAkZS5rZXlDb2RlXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VQcmV2ZW50RGVmYXVsdChrZXlOYW1lLCAkZSk7XG4gICAgICAgICAgICAgICAgaWYgKGtleU5hbWUgJiYgdGhpcy5fc2hvdWxkVHJpZ2dlcihrZXlOYW1lLCAkZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKGtleU5hbWUgKyBcIktleWVkXCIsICRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uSW5wdXQ6IGZ1bmN0aW9uIG9uSW5wdXQoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tJbnB1dFZhbHVlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX21hbmFnZVByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiBtYW5hZ2VQcmV2ZW50RGVmYXVsdChrZXlOYW1lLCAkZSkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2ZW50RGVmYXVsdCwgaGludFZhbHVlLCBpbnB1dFZhbHVlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoa2V5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGFiXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBoaW50VmFsdWUgPSB0aGlzLmdldEhpbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSB0aGlzLmdldElucHV0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gaGludFZhbHVlICYmIGhpbnRWYWx1ZSAhPT0gaW5wdXRWYWx1ZSAmJiAhd2l0aE1vZGlmaWVyKCRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ1cFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZG93blwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQgPSAhd2l0aE1vZGlmaWVyKCRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCAmJiAkZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zaG91bGRUcmlnZ2VyOiBmdW5jdGlvbiBzaG91bGRUcmlnZ2VyKGtleU5hbWUsICRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyaWdnZXI7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChrZXlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0YWJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXIgPSAhd2l0aE1vZGlmaWVyKCRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyaWdnZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2NoZWNrSW5wdXRWYWx1ZTogZnVuY3Rpb24gY2hlY2tJbnB1dFZhbHVlKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dFZhbHVlLCBhcmVFcXVpdmFsZW50LCBoYXNEaWZmZXJlbnRXaGl0ZXNwYWNlO1xuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSB0aGlzLmdldElucHV0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICBhcmVFcXVpdmFsZW50ID0gYXJlUXVlcmllc0VxdWl2YWxlbnQoaW5wdXRWYWx1ZSwgdGhpcy5xdWVyeSk7XG4gICAgICAgICAgICAgICAgaGFzRGlmZmVyZW50V2hpdGVzcGFjZSA9IGFyZUVxdWl2YWxlbnQgPyB0aGlzLnF1ZXJ5Lmxlbmd0aCAhPT0gaW5wdXRWYWx1ZS5sZW5ndGggOiBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZUVxdWl2YWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwicXVlcnlDaGFuZ2VkXCIsIHRoaXMucXVlcnkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRGlmZmVyZW50V2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJ3aGl0ZXNwYWNlQ2hhbmdlZFwiLCB0aGlzLnF1ZXJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmx1cjogZnVuY3Rpb24gYmx1cigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5ibHVyKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UXVlcnk6IGZ1bmN0aW9uIGdldFF1ZXJ5KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldFF1ZXJ5OiBmdW5jdGlvbiBzZXRRdWVyeShxdWVyeSkge1xuICAgICAgICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRJbnB1dFZhbHVlOiBmdW5jdGlvbiBnZXRJbnB1dFZhbHVlKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRpbnB1dC52YWwoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRJbnB1dFZhbHVlOiBmdW5jdGlvbiBzZXRJbnB1dFZhbHVlKHZhbHVlLCBzaWxlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbnB1dC52YWwodmFsdWUpO1xuICAgICAgICAgICAgICAgIHNpbGVudCA/IHRoaXMuY2xlYXJIaW50KCkgOiB0aGlzLl9jaGVja0lucHV0VmFsdWUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldElucHV0VmFsdWU6IGZ1bmN0aW9uIHJlc2V0SW5wdXRWYWx1ZSgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldElucHV0VmFsdWUodGhpcy5xdWVyeSwgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SGludDogZnVuY3Rpb24gZ2V0SGludCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaGludC52YWwoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRIaW50OiBmdW5jdGlvbiBzZXRIaW50KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaGludC52YWwodmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsZWFySGludDogZnVuY3Rpb24gY2xlYXJIaW50KCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SGludChcIlwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGVhckhpbnRJZkludmFsaWQ6IGZ1bmN0aW9uIGNsZWFySGludElmSW52YWxpZCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsLCBoaW50LCB2YWxJc1ByZWZpeE9mSGludCwgaXNWYWxpZDtcbiAgICAgICAgICAgICAgICB2YWwgPSB0aGlzLmdldElucHV0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICBoaW50ID0gdGhpcy5nZXRIaW50KCk7XG4gICAgICAgICAgICAgICAgdmFsSXNQcmVmaXhPZkhpbnQgPSB2YWwgIT09IGhpbnQgJiYgaGludC5pbmRleE9mKHZhbCkgPT09IDA7XG4gICAgICAgICAgICAgICAgaXNWYWxpZCA9IHZhbCAhPT0gXCJcIiAmJiB2YWxJc1ByZWZpeE9mSGludCAmJiAhdGhpcy5oYXNPdmVyZmxvdygpO1xuICAgICAgICAgICAgICAgICFpc1ZhbGlkICYmIHRoaXMuY2xlYXJIaW50KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0TGFuZ3VhZ2VEaXJlY3Rpb246IGZ1bmN0aW9uIGdldExhbmd1YWdlRGlyZWN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy4kaW5wdXQuY3NzKFwiZGlyZWN0aW9uXCIpIHx8IFwibHRyXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzT3ZlcmZsb3c6IGZ1bmN0aW9uIGhhc092ZXJmbG93KCkge1xuICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gdGhpcy4kaW5wdXQud2lkdGgoKSAtIDI7XG4gICAgICAgICAgICAgICAgdGhpcy4kb3ZlcmZsb3dIZWxwZXIudGV4dCh0aGlzLmdldElucHV0VmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG92ZXJmbG93SGVscGVyLndpZHRoKCkgPj0gY29uc3RyYWludDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0N1cnNvckF0RW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVMZW5ndGgsIHNlbGVjdGlvblN0YXJ0LCByYW5nZTtcbiAgICAgICAgICAgICAgICB2YWx1ZUxlbmd0aCA9IHRoaXMuJGlucHV0LnZhbCgpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGFydCA9IHRoaXMuJGlucHV0WzBdLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChfLmlzTnVtYmVyKHNlbGVjdGlvblN0YXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uU3RhcnQgPT09IHZhbHVlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLm1vdmVTdGFydChcImNoYXJhY3RlclwiLCAtdmFsdWVMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVMZW5ndGggPT09IHJhbmdlLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGhpbnQub2ZmKFwiLnR0XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGlucHV0Lm9mZihcIi50dFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRoaW50ID0gdGhpcy4kaW5wdXQgPSB0aGlzLiRvdmVyZmxvd0hlbHBlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gSW5wdXQ7XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkT3ZlcmZsb3dIZWxwZXIoJGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gJCgnPHByZSBhcmlhLWhpZGRlbj1cInRydWVcIj48L3ByZT4nKS5jc3Moe1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogXCJoaWRkZW5cIixcbiAgICAgICAgICAgICAgICB3aGl0ZVNwYWNlOiBcInByZVwiLFxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6ICRpbnB1dC5jc3MoXCJmb250LWZhbWlseVwiKSxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJGlucHV0LmNzcyhcImZvbnQtc2l6ZVwiKSxcbiAgICAgICAgICAgICAgICBmb250U3R5bGU6ICRpbnB1dC5jc3MoXCJmb250LXN0eWxlXCIpLFxuICAgICAgICAgICAgICAgIGZvbnRWYXJpYW50OiAkaW5wdXQuY3NzKFwiZm9udC12YXJpYW50XCIpLFxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICRpbnB1dC5jc3MoXCJmb250LXdlaWdodFwiKSxcbiAgICAgICAgICAgICAgICB3b3JkU3BhY2luZzogJGlucHV0LmNzcyhcIndvcmQtc3BhY2luZ1wiKSxcbiAgICAgICAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiAkaW5wdXQuY3NzKFwibGV0dGVyLXNwYWNpbmdcIiksXG4gICAgICAgICAgICAgICAgdGV4dEluZGVudDogJGlucHV0LmNzcyhcInRleHQtaW5kZW50XCIpLFxuICAgICAgICAgICAgICAgIHRleHRSZW5kZXJpbmc6ICRpbnB1dC5jc3MoXCJ0ZXh0LXJlbmRlcmluZ1wiKSxcbiAgICAgICAgICAgICAgICB0ZXh0VHJhbnNmb3JtOiAkaW5wdXQuY3NzKFwidGV4dC10cmFuc2Zvcm1cIilcbiAgICAgICAgICAgIH0pLmluc2VydEFmdGVyKCRpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXJlUXVlcmllc0VxdWl2YWxlbnQoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIElucHV0Lm5vcm1hbGl6ZVF1ZXJ5KGEpID09PSBJbnB1dC5ub3JtYWxpemVRdWVyeShiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3aXRoTW9kaWZpZXIoJGUpIHtcbiAgICAgICAgICAgIHJldHVybiAkZS5hbHRLZXkgfHwgJGUuY3RybEtleSB8fCAkZS5tZXRhS2V5IHx8ICRlLnNoaWZ0S2V5O1xuICAgICAgICB9XG4gICAgfSgpO1xuICAgIHZhciBEYXRhc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgZGF0YXNldEtleSA9IFwidHREYXRhc2V0XCIsIHZhbHVlS2V5ID0gXCJ0dFZhbHVlXCIsIGRhdHVtS2V5ID0gXCJ0dERhdHVtXCI7XG4gICAgICAgIGZ1bmN0aW9uIERhdGFzZXQobykge1xuICAgICAgICAgICAgbyA9IG8gfHwge307XG4gICAgICAgICAgICBvLnRlbXBsYXRlcyA9IG8udGVtcGxhdGVzIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCFvLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgICQuZXJyb3IoXCJtaXNzaW5nIHNvdXJjZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvLm5hbWUgJiYgIWlzVmFsaWROYW1lKG8ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAkLmVycm9yKFwiaW52YWxpZCBkYXRhc2V0IG5hbWU6IFwiICsgby5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucXVlcnkgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHQgPSAhIW8uaGlnaGxpZ2h0O1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gby5uYW1lIHx8IF8uZ2V0VW5pcXVlSWQoKTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlID0gby5zb3VyY2U7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlGbiA9IGdldERpc3BsYXlGbihvLmRpc3BsYXkgfHwgby5kaXNwbGF5S2V5KTtcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGVzID0gZ2V0VGVtcGxhdGVzKG8udGVtcGxhdGVzLCB0aGlzLmRpc3BsYXlGbik7XG4gICAgICAgICAgICB0aGlzLiRlbCA9ICQoaHRtbC5kYXRhc2V0LnJlcGxhY2UoXCIlQ0xBU1MlXCIsIHRoaXMubmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIERhdGFzZXQuZXh0cmFjdERhdGFzZXROYW1lID0gZnVuY3Rpb24gZXh0cmFjdERhdGFzZXROYW1lKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gJChlbCkuZGF0YShkYXRhc2V0S2V5KTtcbiAgICAgICAgfTtcbiAgICAgICAgRGF0YXNldC5leHRyYWN0VmFsdWUgPSBmdW5jdGlvbiBleHRyYWN0RGF0dW0oZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAkKGVsKS5kYXRhKHZhbHVlS2V5KTtcbiAgICAgICAgfTtcbiAgICAgICAgRGF0YXNldC5leHRyYWN0RGF0dW0gPSBmdW5jdGlvbiBleHRyYWN0RGF0dW0oZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAkKGVsKS5kYXRhKGRhdHVtS2V5KTtcbiAgICAgICAgfTtcbiAgICAgICAgXy5taXhpbihEYXRhc2V0LnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyLCB7XG4gICAgICAgICAgICBfcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocXVlcnksIHN1Z2dlc3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLiRlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcywgaGFzU3VnZ2VzdGlvbnM7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWwuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICBoYXNTdWdnZXN0aW9ucyA9IHN1Z2dlc3Rpb25zICYmIHN1Z2dlc3Rpb25zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc1N1Z2dlc3Rpb25zICYmIHRoaXMudGVtcGxhdGVzLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsLmh0bWwoZ2V0RW1wdHlIdG1sKCkpLnByZXBlbmQodGhhdC50ZW1wbGF0ZXMuaGVhZGVyID8gZ2V0SGVhZGVySHRtbCgpIDogbnVsbCkuYXBwZW5kKHRoYXQudGVtcGxhdGVzLmZvb3RlciA/IGdldEZvb3Rlckh0bWwoKSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzU3VnZ2VzdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWwuaHRtbChnZXRTdWdnZXN0aW9uc0h0bWwoKSkucHJlcGVuZCh0aGF0LnRlbXBsYXRlcy5oZWFkZXIgPyBnZXRIZWFkZXJIdG1sKCkgOiBudWxsKS5hcHBlbmQodGhhdC50ZW1wbGF0ZXMuZm9vdGVyID8gZ2V0Rm9vdGVySHRtbCgpIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihcInJlbmRlcmVkXCIpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldEVtcHR5SHRtbCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQudGVtcGxhdGVzLmVtcHR5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRW1wdHk6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFN1Z2dlc3Rpb25zSHRtbCgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICRzdWdnZXN0aW9ucywgbm9kZXM7XG4gICAgICAgICAgICAgICAgICAgICRzdWdnZXN0aW9ucyA9ICQoaHRtbC5zdWdnZXN0aW9ucykuY3NzKGNzcy5zdWdnZXN0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzID0gXy5tYXAoc3VnZ2VzdGlvbnMsIGdldFN1Z2dlc3Rpb25Ob2RlKTtcbiAgICAgICAgICAgICAgICAgICAgJHN1Z2dlc3Rpb25zLmFwcGVuZC5hcHBseSgkc3VnZ2VzdGlvbnMsIG5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5oaWdobGlnaHQgJiYgaGlnaGxpZ2h0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJ0dC1oaWdobGlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6ICRzdWdnZXN0aW9uc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHN1Z2dlc3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRTdWdnZXN0aW9uTm9kZShzdWdnZXN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgJGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgJGVsID0gJChodG1sLnN1Z2dlc3Rpb24pLmFwcGVuZCh0aGF0LnRlbXBsYXRlcy5zdWdnZXN0aW9uKHN1Z2dlc3Rpb24pKS5kYXRhKGRhdGFzZXRLZXksIHRoYXQubmFtZSkuZGF0YSh2YWx1ZUtleSwgdGhhdC5kaXNwbGF5Rm4oc3VnZ2VzdGlvbikpLmRhdGEoZGF0dW1LZXksIHN1Z2dlc3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgJGVsLmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNzcyhjc3Muc3VnZ2VzdGlvbkNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRlbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRIZWFkZXJIdG1sKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC50ZW1wbGF0ZXMuaGVhZGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRW1wdHk6ICFoYXNTdWdnZXN0aW9uc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Rm9vdGVySHRtbCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQudGVtcGxhdGVzLmZvb3Rlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VtcHR5OiAhaGFzU3VnZ2VzdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFJvb3Q6IGZ1bmN0aW9uIGdldFJvb3QoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGVsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2UocXVlcnksIHJlbmRlcik7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVuZGVyKHN1Z2dlc3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhhdC5jYW5jZWxlZCAmJiBxdWVyeSA9PT0gdGhhdC5xdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fcmVuZGVyKHF1ZXJ5LCBzdWdnZXN0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWwuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJyZW5kZXJlZFwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRlbC5pcyhcIjplbXB0eVwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBEYXRhc2V0O1xuICAgICAgICBmdW5jdGlvbiBnZXREaXNwbGF5Rm4oZGlzcGxheSkge1xuICAgICAgICAgICAgZGlzcGxheSA9IGRpc3BsYXkgfHwgXCJ2YWx1ZVwiO1xuICAgICAgICAgICAgcmV0dXJuIF8uaXNGdW5jdGlvbihkaXNwbGF5KSA/IGRpc3BsYXkgOiBkaXNwbGF5Rm47XG4gICAgICAgICAgICBmdW5jdGlvbiBkaXNwbGF5Rm4ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ialtkaXNwbGF5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRUZW1wbGF0ZXModGVtcGxhdGVzLCBkaXNwbGF5Rm4pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZW1wdHk6IHRlbXBsYXRlcy5lbXB0eSAmJiBfLnRlbXBsYXRpZnkodGVtcGxhdGVzLmVtcHR5KSxcbiAgICAgICAgICAgICAgICBoZWFkZXI6IHRlbXBsYXRlcy5oZWFkZXIgJiYgXy50ZW1wbGF0aWZ5KHRlbXBsYXRlcy5oZWFkZXIpLFxuICAgICAgICAgICAgICAgIGZvb3RlcjogdGVtcGxhdGVzLmZvb3RlciAmJiBfLnRlbXBsYXRpZnkodGVtcGxhdGVzLmZvb3RlciksXG4gICAgICAgICAgICAgICAgc3VnZ2VzdGlvbjogdGVtcGxhdGVzLnN1Z2dlc3Rpb24gfHwgc3VnZ2VzdGlvblRlbXBsYXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZnVuY3Rpb24gc3VnZ2VzdGlvblRlbXBsYXRlKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCI8cD5cIiArIGRpc3BsYXlGbihjb250ZXh0KSArIFwiPC9wPlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzVmFsaWROYW1lKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIC9eW19hLXpBLVowLTktXSskLy50ZXN0KHN0cik7XG4gICAgICAgIH1cbiAgICB9KCk7XG4gICAgdmFyIERyb3Bkb3duID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBmdW5jdGlvbiBEcm9wZG93bihvKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsIG9uU3VnZ2VzdGlvbkNsaWNrLCBvblN1Z2dlc3Rpb25Nb3VzZUVudGVyLCBvblN1Z2dlc3Rpb25Nb3VzZUxlYXZlO1xuICAgICAgICAgICAgbyA9IG8gfHwge307XG4gICAgICAgICAgICBpZiAoIW8ubWVudSkge1xuICAgICAgICAgICAgICAgICQuZXJyb3IoXCJtZW51IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaXNFbXB0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRhdGFzZXRzID0gXy5tYXAoby5kYXRhc2V0cywgaW5pdGlhbGl6ZURhdGFzZXQpO1xuICAgICAgICAgICAgb25TdWdnZXN0aW9uQ2xpY2sgPSBfLmJpbmQodGhpcy5fb25TdWdnZXN0aW9uQ2xpY2ssIHRoaXMpO1xuICAgICAgICAgICAgb25TdWdnZXN0aW9uTW91c2VFbnRlciA9IF8uYmluZCh0aGlzLl9vblN1Z2dlc3Rpb25Nb3VzZUVudGVyLCB0aGlzKTtcbiAgICAgICAgICAgIG9uU3VnZ2VzdGlvbk1vdXNlTGVhdmUgPSBfLmJpbmQodGhpcy5fb25TdWdnZXN0aW9uTW91c2VMZWF2ZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLiRtZW51ID0gJChvLm1lbnUpLm9uKFwiY2xpY2sudHRcIiwgXCIudHQtc3VnZ2VzdGlvblwiLCBvblN1Z2dlc3Rpb25DbGljaykub24oXCJtb3VzZWVudGVyLnR0XCIsIFwiLnR0LXN1Z2dlc3Rpb25cIiwgb25TdWdnZXN0aW9uTW91c2VFbnRlcikub24oXCJtb3VzZWxlYXZlLnR0XCIsIFwiLnR0LXN1Z2dlc3Rpb25cIiwgb25TdWdnZXN0aW9uTW91c2VMZWF2ZSk7XG4gICAgICAgICAgICBfLmVhY2godGhpcy5kYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCkge1xuICAgICAgICAgICAgICAgIHRoYXQuJG1lbnUuYXBwZW5kKGRhdGFzZXQuZ2V0Um9vdCgpKTtcbiAgICAgICAgICAgICAgICBkYXRhc2V0Lm9uU3luYyhcInJlbmRlcmVkXCIsIHRoYXQuX29uUmVuZGVyZWQsIHRoYXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXy5taXhpbihEcm9wZG93bi5wcm90b3R5cGUsIEV2ZW50RW1pdHRlciwge1xuICAgICAgICAgICAgX29uU3VnZ2VzdGlvbkNsaWNrOiBmdW5jdGlvbiBvblN1Z2dlc3Rpb25DbGljaygkZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihcInN1Z2dlc3Rpb25DbGlja2VkXCIsICQoJGUuY3VycmVudFRhcmdldCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vblN1Z2dlc3Rpb25Nb3VzZUVudGVyOiBmdW5jdGlvbiBvblN1Z2dlc3Rpb25Nb3VzZUVudGVyKCRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQ3Vyc29yKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0Q3Vyc29yKCQoJGUuY3VycmVudFRhcmdldCksIHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vblN1Z2dlc3Rpb25Nb3VzZUxlYXZlOiBmdW5jdGlvbiBvblN1Z2dlc3Rpb25Nb3VzZUxlYXZlKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUN1cnNvcigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vblJlbmRlcmVkOiBmdW5jdGlvbiBvblJlbmRlcmVkKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNFbXB0eSA9IF8uZXZlcnkodGhpcy5kYXRhc2V0cywgaXNEYXRhc2V0RW1wdHkpO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNFbXB0eSA/IHRoaXMuX2hpZGUoKSA6IHRoaXMuaXNPcGVuICYmIHRoaXMuX3Nob3coKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJkYXRhc2V0UmVuZGVyZWRcIik7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaXNEYXRhc2V0RW1wdHkoZGF0YXNldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YXNldC5pc0VtcHR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9oaWRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRtZW51LmhpZGUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kbWVudS5jc3MoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2dldFN1Z2dlc3Rpb25zOiBmdW5jdGlvbiBnZXRTdWdnZXN0aW9ucygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kbWVudS5maW5kKFwiLnR0LXN1Z2dlc3Rpb25cIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2dldEN1cnNvcjogZnVuY3Rpb24gZ2V0Q3Vyc29yKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRtZW51LmZpbmQoXCIudHQtY3Vyc29yXCIpLmZpcnN0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3NldEN1cnNvcjogZnVuY3Rpb24gc2V0Q3Vyc29yKCRlbCwgc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgJGVsLmZpcnN0KCkuYWRkQ2xhc3MoXCJ0dC1jdXJzb3JcIik7XG4gICAgICAgICAgICAgICAgIXNpbGVudCAmJiB0aGlzLnRyaWdnZXIoXCJjdXJzb3JNb3ZlZFwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVtb3ZlQ3Vyc29yOiBmdW5jdGlvbiByZW1vdmVDdXJzb3IoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0Q3Vyc29yKCkucmVtb3ZlQ2xhc3MoXCJ0dC1jdXJzb3JcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX21vdmVDdXJzb3I6IGZ1bmN0aW9uIG1vdmVDdXJzb3IoaW5jcmVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyICRzdWdnZXN0aW9ucywgJG9sZEN1cnNvciwgbmV3Q3Vyc29ySW5kZXgsICRuZXdDdXJzb3I7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRvbGRDdXJzb3IgPSB0aGlzLl9nZXRDdXJzb3IoKTtcbiAgICAgICAgICAgICAgICAkc3VnZ2VzdGlvbnMgPSB0aGlzLl9nZXRTdWdnZXN0aW9ucygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUN1cnNvcigpO1xuICAgICAgICAgICAgICAgIG5ld0N1cnNvckluZGV4ID0gJHN1Z2dlc3Rpb25zLmluZGV4KCRvbGRDdXJzb3IpICsgaW5jcmVtZW50O1xuICAgICAgICAgICAgICAgIG5ld0N1cnNvckluZGV4ID0gKG5ld0N1cnNvckluZGV4ICsgMSkgJSAoJHN1Z2dlc3Rpb25zLmxlbmd0aCArIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBpZiAobmV3Q3Vyc29ySW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihcImN1cnNvclJlbW92ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5ld0N1cnNvckluZGV4IDwgLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q3Vyc29ySW5kZXggPSAkc3VnZ2VzdGlvbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0Q3Vyc29yKCRuZXdDdXJzb3IgPSAkc3VnZ2VzdGlvbnMuZXEobmV3Q3Vyc29ySW5kZXgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbnN1cmVWaXNpYmxlKCRuZXdDdXJzb3IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9lbnN1cmVWaXNpYmxlOiBmdW5jdGlvbiBlbnN1cmVWaXNpYmxlKCRlbCkge1xuICAgICAgICAgICAgICAgIHZhciBlbFRvcCwgZWxCb3R0b20sIG1lbnVTY3JvbGxUb3AsIG1lbnVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgZWxUb3AgPSAkZWwucG9zaXRpb24oKS50b3A7XG4gICAgICAgICAgICAgICAgZWxCb3R0b20gPSBlbFRvcCArICRlbC5vdXRlckhlaWdodCh0cnVlKTtcbiAgICAgICAgICAgICAgICBtZW51U2Nyb2xsVG9wID0gdGhpcy4kbWVudS5zY3JvbGxUb3AoKTtcbiAgICAgICAgICAgICAgICBtZW51SGVpZ2h0ID0gdGhpcy4kbWVudS5oZWlnaHQoKSArIHBhcnNlSW50KHRoaXMuJG1lbnUuY3NzKFwicGFkZGluZ1RvcFwiKSwgMTApICsgcGFyc2VJbnQodGhpcy4kbWVudS5jc3MoXCJwYWRkaW5nQm90dG9tXCIpLCAxMCk7XG4gICAgICAgICAgICAgICAgaWYgKGVsVG9wIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRtZW51LnNjcm9sbFRvcChtZW51U2Nyb2xsVG9wICsgZWxUb3ApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWVudUhlaWdodCA8IGVsQm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJG1lbnUuc2Nyb2xsVG9wKG1lbnVTY3JvbGxUb3AgKyAoZWxCb3R0b20gLSBtZW51SGVpZ2h0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQ3Vyc29yKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwiY2xvc2VkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcGVuOiBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc09wZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAhdGhpcy5pc0VtcHR5ICYmIHRoaXMuX3Nob3coKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwib3BlbmVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRMYW5ndWFnZURpcmVjdGlvbjogZnVuY3Rpb24gc2V0TGFuZ3VhZ2VEaXJlY3Rpb24oZGlyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kbWVudS5jc3MoZGlyID09PSBcImx0clwiID8gY3NzLmx0ciA6IGNzcy5ydGwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vdmVDdXJzb3JVcDogZnVuY3Rpb24gbW92ZUN1cnNvclVwKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVDdXJzb3IoLTEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vdmVDdXJzb3JEb3duOiBmdW5jdGlvbiBtb3ZlQ3Vyc29yRG93bigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3ZlQ3Vyc29yKCsxKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXREYXR1bUZvclN1Z2dlc3Rpb246IGZ1bmN0aW9uIGdldERhdHVtRm9yU3VnZ2VzdGlvbigkZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0dW0gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICgkZWwubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdHVtID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmF3OiBEYXRhc2V0LmV4dHJhY3REYXR1bSgkZWwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IERhdGFzZXQuZXh0cmFjdFZhbHVlKCRlbCksXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhc2V0TmFtZTogRGF0YXNldC5leHRyYWN0RGF0YXNldE5hbWUoJGVsKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0dW07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RGF0dW1Gb3JDdXJzb3I6IGZ1bmN0aW9uIGdldERhdHVtRm9yQ3Vyc29yKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERhdHVtRm9yU3VnZ2VzdGlvbih0aGlzLl9nZXRDdXJzb3IoKS5maXJzdCgpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXREYXR1bUZvclRvcFN1Z2dlc3Rpb246IGZ1bmN0aW9uIGdldERhdHVtRm9yVG9wU3VnZ2VzdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREYXR1bUZvclN1Z2dlc3Rpb24odGhpcy5fZ2V0U3VnZ2VzdGlvbnMoKS5maXJzdCgpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShxdWVyeSkge1xuICAgICAgICAgICAgICAgIF8uZWFjaCh0aGlzLmRhdGFzZXRzLCB1cGRhdGVEYXRhc2V0KTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVEYXRhc2V0KGRhdGFzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YXNldC51cGRhdGUocXVlcnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbXB0eTogZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgICAgICAgICAgICAgXy5lYWNoKHRoaXMuZGF0YXNldHMsIGNsZWFyRGF0YXNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0VtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjbGVhckRhdGFzZXQoZGF0YXNldCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhc2V0LmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzVmlzaWJsZTogZnVuY3Rpb24gaXNWaXNpYmxlKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzT3BlbiAmJiAhdGhpcy5pc0VtcHR5O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kbWVudS5vZmYoXCIudHRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy4kbWVudSA9IG51bGw7XG4gICAgICAgICAgICAgICAgXy5lYWNoKHRoaXMuZGF0YXNldHMsIGRlc3Ryb3lEYXRhc2V0KTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZXN0cm95RGF0YXNldChkYXRhc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFzZXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBEcm9wZG93bjtcbiAgICAgICAgZnVuY3Rpb24gaW5pdGlhbGl6ZURhdGFzZXQob0RhdGFzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0YXNldChvRGF0YXNldCk7XG4gICAgICAgIH1cbiAgICB9KCk7XG4gICAgdmFyIFR5cGVhaGVhZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIGF0dHJzS2V5ID0gXCJ0dEF0dHJzXCI7XG4gICAgICAgIGZ1bmN0aW9uIFR5cGVhaGVhZChvKSB7XG4gICAgICAgICAgICB2YXIgJG1lbnUsICRpbnB1dCwgJGhpbnQ7XG4gICAgICAgICAgICBvID0gbyB8fCB7fTtcbiAgICAgICAgICAgIGlmICghby5pbnB1dCkge1xuICAgICAgICAgICAgICAgICQuZXJyb3IoXCJtaXNzaW5nIGlucHV0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc0FjdGl2YXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hdXRvc2VsZWN0ID0gISFvLmF1dG9zZWxlY3Q7XG4gICAgICAgICAgICB0aGlzLm1pbkxlbmd0aCA9IF8uaXNOdW1iZXIoby5taW5MZW5ndGgpID8gby5taW5MZW5ndGggOiAxO1xuICAgICAgICAgICAgdGhpcy4kbm9kZSA9IGJ1aWxkRG9tKG8uaW5wdXQsIG8ud2l0aEhpbnQpO1xuICAgICAgICAgICAgJG1lbnUgPSB0aGlzLiRub2RlLmZpbmQoXCIudHQtZHJvcGRvd24tbWVudVwiKTtcbiAgICAgICAgICAgICRpbnB1dCA9IHRoaXMuJG5vZGUuZmluZChcIi50dC1pbnB1dFwiKTtcbiAgICAgICAgICAgICRoaW50ID0gdGhpcy4kbm9kZS5maW5kKFwiLnR0LWhpbnRcIik7XG4gICAgICAgICAgICAkaW5wdXQub24oXCJibHVyLnR0XCIsIGZ1bmN0aW9uKCRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2ZSwgaXNBY3RpdmUsIGhhc0FjdGl2ZTtcbiAgICAgICAgICAgICAgICBhY3RpdmUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgIGlzQWN0aXZlID0gJG1lbnUuaXMoYWN0aXZlKTtcbiAgICAgICAgICAgICAgICBoYXNBY3RpdmUgPSAkbWVudS5oYXMoYWN0aXZlKS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIGlmIChfLmlzTXNpZSgpICYmIChpc0FjdGl2ZSB8fCBoYXNBY3RpdmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICRlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBfLmRlZmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJG1lbnUub24oXCJtb3VzZWRvd24udHRcIiwgZnVuY3Rpb24oJGUpIHtcbiAgICAgICAgICAgICAgICAkZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50QnVzID0gby5ldmVudEJ1cyB8fCBuZXcgRXZlbnRCdXMoe1xuICAgICAgICAgICAgICAgIGVsOiAkaW5wdXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5kcm9wZG93biA9IG5ldyBEcm9wZG93bih7XG4gICAgICAgICAgICAgICAgbWVudTogJG1lbnUsXG4gICAgICAgICAgICAgICAgZGF0YXNldHM6IG8uZGF0YXNldHNcbiAgICAgICAgICAgIH0pLm9uU3luYyhcInN1Z2dlc3Rpb25DbGlja2VkXCIsIHRoaXMuX29uU3VnZ2VzdGlvbkNsaWNrZWQsIHRoaXMpLm9uU3luYyhcImN1cnNvck1vdmVkXCIsIHRoaXMuX29uQ3Vyc29yTW92ZWQsIHRoaXMpLm9uU3luYyhcImN1cnNvclJlbW92ZWRcIiwgdGhpcy5fb25DdXJzb3JSZW1vdmVkLCB0aGlzKS5vblN5bmMoXCJvcGVuZWRcIiwgdGhpcy5fb25PcGVuZWQsIHRoaXMpLm9uU3luYyhcImNsb3NlZFwiLCB0aGlzLl9vbkNsb3NlZCwgdGhpcykub25Bc3luYyhcImRhdGFzZXRSZW5kZXJlZFwiLCB0aGlzLl9vbkRhdGFzZXRSZW5kZXJlZCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gbmV3IElucHV0KHtcbiAgICAgICAgICAgICAgICBpbnB1dDogJGlucHV0LFxuICAgICAgICAgICAgICAgIGhpbnQ6ICRoaW50XG4gICAgICAgICAgICB9KS5vblN5bmMoXCJmb2N1c2VkXCIsIHRoaXMuX29uRm9jdXNlZCwgdGhpcykub25TeW5jKFwiYmx1cnJlZFwiLCB0aGlzLl9vbkJsdXJyZWQsIHRoaXMpLm9uU3luYyhcImVudGVyS2V5ZWRcIiwgdGhpcy5fb25FbnRlcktleWVkLCB0aGlzKS5vblN5bmMoXCJ0YWJLZXllZFwiLCB0aGlzLl9vblRhYktleWVkLCB0aGlzKS5vblN5bmMoXCJlc2NLZXllZFwiLCB0aGlzLl9vbkVzY0tleWVkLCB0aGlzKS5vblN5bmMoXCJ1cEtleWVkXCIsIHRoaXMuX29uVXBLZXllZCwgdGhpcykub25TeW5jKFwiZG93bktleWVkXCIsIHRoaXMuX29uRG93bktleWVkLCB0aGlzKS5vblN5bmMoXCJsZWZ0S2V5ZWRcIiwgdGhpcy5fb25MZWZ0S2V5ZWQsIHRoaXMpLm9uU3luYyhcInJpZ2h0S2V5ZWRcIiwgdGhpcy5fb25SaWdodEtleWVkLCB0aGlzKS5vblN5bmMoXCJxdWVyeUNoYW5nZWRcIiwgdGhpcy5fb25RdWVyeUNoYW5nZWQsIHRoaXMpLm9uU3luYyhcIndoaXRlc3BhY2VDaGFuZ2VkXCIsIHRoaXMuX29uV2hpdGVzcGFjZUNoYW5nZWQsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fc2V0TGFuZ3VhZ2VEaXJlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBfLm1peGluKFR5cGVhaGVhZC5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIF9vblN1Z2dlc3Rpb25DbGlja2VkOiBmdW5jdGlvbiBvblN1Z2dlc3Rpb25DbGlja2VkKHR5cGUsICRlbCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXR1bTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0dW0gPSB0aGlzLmRyb3Bkb3duLmdldERhdHVtRm9yU3VnZ2VzdGlvbigkZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdChkYXR1bSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkN1cnNvck1vdmVkOiBmdW5jdGlvbiBvbkN1cnNvck1vdmVkKCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXR1bSA9IHRoaXMuZHJvcGRvd24uZ2V0RGF0dW1Gb3JDdXJzb3IoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0LnNldElucHV0VmFsdWUoZGF0dW0udmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMudHJpZ2dlcihcImN1cnNvcmNoYW5nZWRcIiwgZGF0dW0ucmF3LCBkYXR1bS5kYXRhc2V0TmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uQ3Vyc29yUmVtb3ZlZDogZnVuY3Rpb24gb25DdXJzb3JSZW1vdmVkKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQucmVzZXRJbnB1dFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlSGludCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkRhdGFzZXRSZW5kZXJlZDogZnVuY3Rpb24gb25EYXRhc2V0UmVuZGVyZWQoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlSGludCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbk9wZW5lZDogZnVuY3Rpb24gb25PcGVuZWQoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlSGludCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMudHJpZ2dlcihcIm9wZW5lZFwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25DbG9zZWQ6IGZ1bmN0aW9uIG9uQ2xvc2VkKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQuY2xlYXJIaW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy50cmlnZ2VyKFwiY2xvc2VkXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkZvY3VzZWQ6IGZ1bmN0aW9uIG9uRm9jdXNlZCgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzQWN0aXZhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duLm9wZW4oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25CbHVycmVkOiBmdW5jdGlvbiBvbkJsdXJyZWQoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0FjdGl2YXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJvcGRvd24uZW1wdHkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duLmNsb3NlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uRW50ZXJLZXllZDogZnVuY3Rpb24gb25FbnRlcktleWVkKHR5cGUsICRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnNvckRhdHVtLCB0b3BTdWdnZXN0aW9uRGF0dW07XG4gICAgICAgICAgICAgICAgY3Vyc29yRGF0dW0gPSB0aGlzLmRyb3Bkb3duLmdldERhdHVtRm9yQ3Vyc29yKCk7XG4gICAgICAgICAgICAgICAgdG9wU3VnZ2VzdGlvbkRhdHVtID0gdGhpcy5kcm9wZG93bi5nZXREYXR1bUZvclRvcFN1Z2dlc3Rpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yRGF0dW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0KGN1cnNvckRhdHVtKTtcbiAgICAgICAgICAgICAgICAgICAgJGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYXV0b3NlbGVjdCAmJiB0b3BTdWdnZXN0aW9uRGF0dW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0KHRvcFN1Z2dlc3Rpb25EYXR1bSk7XG4gICAgICAgICAgICAgICAgICAgICRlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vblRhYktleWVkOiBmdW5jdGlvbiBvblRhYktleWVkKHR5cGUsICRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdHVtO1xuICAgICAgICAgICAgICAgIGlmIChkYXR1bSA9IHRoaXMuZHJvcGRvd24uZ2V0RGF0dW1Gb3JDdXJzb3IoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3QoZGF0dW0pO1xuICAgICAgICAgICAgICAgICAgICAkZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dG9jb21wbGV0ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uRXNjS2V5ZWQ6IGZ1bmN0aW9uIG9uRXNjS2V5ZWQoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQucmVzZXRJbnB1dFZhbHVlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uVXBLZXllZDogZnVuY3Rpb24gb25VcEtleWVkKCkge1xuICAgICAgICAgICAgICAgIHZhciBxdWVyeSA9IHRoaXMuaW5wdXQuZ2V0UXVlcnkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duLmlzRW1wdHkgJiYgcXVlcnkubGVuZ3RoID49IHRoaXMubWluTGVuZ3RoID8gdGhpcy5kcm9wZG93bi51cGRhdGUocXVlcnkpIDogdGhpcy5kcm9wZG93bi5tb3ZlQ3Vyc29yVXAoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duLm9wZW4oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25Eb3duS2V5ZWQ6IGZ1bmN0aW9uIG9uRG93bktleWVkKCkge1xuICAgICAgICAgICAgICAgIHZhciBxdWVyeSA9IHRoaXMuaW5wdXQuZ2V0UXVlcnkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duLmlzRW1wdHkgJiYgcXVlcnkubGVuZ3RoID49IHRoaXMubWluTGVuZ3RoID8gdGhpcy5kcm9wZG93bi51cGRhdGUocXVlcnkpIDogdGhpcy5kcm9wZG93bi5tb3ZlQ3Vyc29yRG93bigpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJvcGRvd24ub3BlbigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkxlZnRLZXllZDogZnVuY3Rpb24gb25MZWZ0S2V5ZWQoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXIgPT09IFwicnRsXCIgJiYgdGhpcy5fYXV0b2NvbXBsZXRlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uUmlnaHRLZXllZDogZnVuY3Rpb24gb25SaWdodEtleWVkKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlyID09PSBcImx0clwiICYmIHRoaXMuX2F1dG9jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vblF1ZXJ5Q2hhbmdlZDogZnVuY3Rpb24gb25RdWVyeUNoYW5nZWQoZSwgcXVlcnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0LmNsZWFySGludElmSW52YWxpZCgpO1xuICAgICAgICAgICAgICAgIHF1ZXJ5Lmxlbmd0aCA+PSB0aGlzLm1pbkxlbmd0aCA/IHRoaXMuZHJvcGRvd24udXBkYXRlKHF1ZXJ5KSA6IHRoaXMuZHJvcGRvd24uZW1wdHkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duLm9wZW4oKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRMYW5ndWFnZURpcmVjdGlvbigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbldoaXRlc3BhY2VDaGFuZ2VkOiBmdW5jdGlvbiBvbldoaXRlc3BhY2VDaGFuZ2VkKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUhpbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duLm9wZW4oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2V0TGFuZ3VhZ2VEaXJlY3Rpb246IGZ1bmN0aW9uIHNldExhbmd1YWdlRGlyZWN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXI7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlyICE9PSAoZGlyID0gdGhpcy5pbnB1dC5nZXRMYW5ndWFnZURpcmVjdGlvbigpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpciA9IGRpcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbm9kZS5jc3MoXCJkaXJlY3Rpb25cIiwgZGlyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5zZXRMYW5ndWFnZURpcmVjdGlvbihkaXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdXBkYXRlSGludDogZnVuY3Rpb24gdXBkYXRlSGludCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0dW0sIHZhbCwgcXVlcnksIGVzY2FwZWRRdWVyeSwgZnJvbnRNYXRjaFJlZ0V4LCBtYXRjaDtcbiAgICAgICAgICAgICAgICBkYXR1bSA9IHRoaXMuZHJvcGRvd24uZ2V0RGF0dW1Gb3JUb3BTdWdnZXN0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdHVtICYmIHRoaXMuZHJvcGRvd24uaXNWaXNpYmxlKCkgJiYgIXRoaXMuaW5wdXQuaGFzT3ZlcmZsb3coKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB0aGlzLmlucHV0LmdldElucHV0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSBJbnB1dC5ub3JtYWxpemVRdWVyeSh2YWwpO1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUXVlcnkgPSBfLmVzY2FwZVJlZ0V4Q2hhcnMocXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICBmcm9udE1hdGNoUmVnRXggPSBuZXcgUmVnRXhwKFwiXig/OlwiICsgZXNjYXBlZFF1ZXJ5ICsgXCIpKC4rJClcIiwgXCJpXCIpO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGZyb250TWF0Y2hSZWdFeC5leGVjKGRhdHVtLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPyB0aGlzLmlucHV0LnNldEhpbnQodmFsICsgbWF0Y2hbMV0pIDogdGhpcy5pbnB1dC5jbGVhckhpbnQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0LmNsZWFySGludCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYXV0b2NvbXBsZXRlOiBmdW5jdGlvbiBhdXRvY29tcGxldGUobGF4Q3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhpbnQsIHF1ZXJ5LCBpc0N1cnNvckF0RW5kLCBkYXR1bTtcbiAgICAgICAgICAgICAgICBoaW50ID0gdGhpcy5pbnB1dC5nZXRIaW50KCk7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSB0aGlzLmlucHV0LmdldFF1ZXJ5KCk7XG4gICAgICAgICAgICAgICAgaXNDdXJzb3JBdEVuZCA9IGxheEN1cnNvciB8fCB0aGlzLmlucHV0LmlzQ3Vyc29yQXRFbmQoKTtcbiAgICAgICAgICAgICAgICBpZiAoaGludCAmJiBxdWVyeSAhPT0gaGludCAmJiBpc0N1cnNvckF0RW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdHVtID0gdGhpcy5kcm9wZG93bi5nZXREYXR1bUZvclRvcFN1Z2dlc3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0dW0gJiYgdGhpcy5pbnB1dC5zZXRJbnB1dFZhbHVlKGRhdHVtLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudEJ1cy50cmlnZ2VyKFwiYXV0b2NvbXBsZXRlZFwiLCBkYXR1bS5yYXcsIGRhdHVtLmRhdGFzZXROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3NlbGVjdDogZnVuY3Rpb24gc2VsZWN0KGRhdHVtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5zZXRRdWVyeShkYXR1bS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5zZXRJbnB1dFZhbHVlKGRhdHVtLnZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRMYW5ndWFnZURpcmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRCdXMudHJpZ2dlcihcInNlbGVjdGVkXCIsIGRhdHVtLnJhdywgZGF0dW0uZGF0YXNldE5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJvcGRvd24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBfLmRlZmVyKF8uYmluZCh0aGlzLmRyb3Bkb3duLmVtcHR5LCB0aGlzLmRyb3Bkb3duKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3BlbjogZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duLm9wZW4oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5jbG9zZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldFZhbDogZnVuY3Rpb24gc2V0VmFsKHZhbCkge1xuICAgICAgICAgICAgICAgIHZhbCA9IF8udG9TdHIodmFsKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0FjdGl2YXRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0LnNldElucHV0VmFsdWUodmFsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0LnNldFF1ZXJ5KHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQuc2V0SW5wdXRWYWx1ZSh2YWwsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRMYW5ndWFnZURpcmVjdGlvbigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFZhbDogZnVuY3Rpb24gZ2V0VmFsKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlucHV0LmdldFF1ZXJ5KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICBkZXN0cm95RG9tU3RydWN0dXJlKHRoaXMuJG5vZGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuJG5vZGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFR5cGVhaGVhZDtcbiAgICAgICAgZnVuY3Rpb24gYnVpbGREb20oaW5wdXQsIHdpdGhIaW50KSB7XG4gICAgICAgICAgICB2YXIgJGlucHV0LCAkd3JhcHBlciwgJGRyb3Bkb3duLCAkaGludDtcbiAgICAgICAgICAgICRpbnB1dCA9ICQoaW5wdXQpO1xuICAgICAgICAgICAgJHdyYXBwZXIgPSAkKGh0bWwud3JhcHBlcikuY3NzKGNzcy53cmFwcGVyKTtcbiAgICAgICAgICAgICRkcm9wZG93biA9ICQoaHRtbC5kcm9wZG93bikuY3NzKGNzcy5kcm9wZG93bik7XG4gICAgICAgICAgICAkaGludCA9ICRpbnB1dC5jbG9uZSgpLmNzcyhjc3MuaGludCkuY3NzKGdldEJhY2tncm91bmRTdHlsZXMoJGlucHV0KSk7XG4gICAgICAgICAgICAkaGludC52YWwoXCJcIikucmVtb3ZlRGF0YSgpLmFkZENsYXNzKFwidHQtaGludFwiKS5yZW1vdmVBdHRyKFwiaWQgbmFtZSBwbGFjZWhvbGRlciByZXF1aXJlZFwiKS5wcm9wKFwicmVhZG9ubHlcIiwgdHJ1ZSkuYXR0cih7XG4gICAgICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiBcIm9mZlwiLFxuICAgICAgICAgICAgICAgIHNwZWxsY2hlY2s6IFwiZmFsc2VcIixcbiAgICAgICAgICAgICAgICB0YWJpbmRleDogLTFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJGlucHV0LmRhdGEoYXR0cnNLZXksIHtcbiAgICAgICAgICAgICAgICBkaXI6ICRpbnB1dC5hdHRyKFwiZGlyXCIpLFxuICAgICAgICAgICAgICAgIGF1dG9jb21wbGV0ZTogJGlucHV0LmF0dHIoXCJhdXRvY29tcGxldGVcIiksXG4gICAgICAgICAgICAgICAgc3BlbGxjaGVjazogJGlucHV0LmF0dHIoXCJzcGVsbGNoZWNrXCIpLFxuICAgICAgICAgICAgICAgIHN0eWxlOiAkaW5wdXQuYXR0cihcInN0eWxlXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRpbnB1dC5hZGRDbGFzcyhcInR0LWlucHV0XCIpLmF0dHIoe1xuICAgICAgICAgICAgICAgIGF1dG9jb21wbGV0ZTogXCJvZmZcIixcbiAgICAgICAgICAgICAgICBzcGVsbGNoZWNrOiBmYWxzZVxuICAgICAgICAgICAgfSkuY3NzKHdpdGhIaW50ID8gY3NzLmlucHV0IDogY3NzLmlucHV0V2l0aE5vSGludCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICEkaW5wdXQuYXR0cihcImRpclwiKSAmJiAkaW5wdXQuYXR0cihcImRpclwiLCBcImF1dG9cIik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgcmV0dXJuICRpbnB1dC53cmFwKCR3cmFwcGVyKS5wYXJlbnQoKS5wcmVwZW5kKHdpdGhIaW50ID8gJGhpbnQgOiBudWxsKS5hcHBlbmQoJGRyb3Bkb3duKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRCYWNrZ3JvdW5kU3R5bGVzKCRlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQXR0YWNobWVudDogJGVsLmNzcyhcImJhY2tncm91bmQtYXR0YWNobWVudFwiKSxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ2xpcDogJGVsLmNzcyhcImJhY2tncm91bmQtY2xpcFwiKSxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICRlbC5jc3MoXCJiYWNrZ3JvdW5kLWNvbG9yXCIpLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogJGVsLmNzcyhcImJhY2tncm91bmQtaW1hZ2VcIiksXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZE9yaWdpbjogJGVsLmNzcyhcImJhY2tncm91bmQtb3JpZ2luXCIpLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogJGVsLmNzcyhcImJhY2tncm91bmQtcG9zaXRpb25cIiksXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZFJlcGVhdDogJGVsLmNzcyhcImJhY2tncm91bmQtcmVwZWF0XCIpLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRTaXplOiAkZWwuY3NzKFwiYmFja2dyb3VuZC1zaXplXCIpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlc3Ryb3lEb21TdHJ1Y3R1cmUoJG5vZGUpIHtcbiAgICAgICAgICAgIHZhciAkaW5wdXQgPSAkbm9kZS5maW5kKFwiLnR0LWlucHV0XCIpO1xuICAgICAgICAgICAgXy5lYWNoKCRpbnB1dC5kYXRhKGF0dHJzS2V5KSwgZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBfLmlzVW5kZWZpbmVkKHZhbCkgPyAkaW5wdXQucmVtb3ZlQXR0cihrZXkpIDogJGlucHV0LmF0dHIoa2V5LCB2YWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkaW5wdXQuZGV0YWNoKCkucmVtb3ZlRGF0YShhdHRyc0tleSkucmVtb3ZlQ2xhc3MoXCJ0dC1pbnB1dFwiKS5pbnNlcnRBZnRlcigkbm9kZSk7XG4gICAgICAgICAgICAkbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH0oKTtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgb2xkLCB0eXBlYWhlYWRLZXksIG1ldGhvZHM7XG4gICAgICAgIG9sZCA9ICQuZm4udHlwZWFoZWFkO1xuICAgICAgICB0eXBlYWhlYWRLZXkgPSBcInR0VHlwZWFoZWFkXCI7XG4gICAgICAgIG1ldGhvZHMgPSB7XG4gICAgICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKG8sIGRhdGFzZXRzKSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldHMgPSBfLmlzQXJyYXkoZGF0YXNldHMpID8gZGF0YXNldHMgOiBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgbyA9IG8gfHwge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChhdHRhY2gpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGF0dGFjaCgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICRpbnB1dCA9ICQodGhpcyksIGV2ZW50QnVzLCB0eXBlYWhlYWQ7XG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChkYXRhc2V0cywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5oaWdobGlnaHQgPSAhIW8uaGlnaGxpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdHlwZWFoZWFkID0gbmV3IFR5cGVhaGVhZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogJGlucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRCdXM6IGV2ZW50QnVzID0gbmV3IEV2ZW50QnVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbDogJGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhIaW50OiBfLmlzVW5kZWZpbmVkKG8uaGludCkgPyB0cnVlIDogISFvLmhpbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5MZW5ndGg6IG8ubWluTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b3NlbGVjdDogby5hdXRvc2VsZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YXNldHM6IGRhdGFzZXRzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAkaW5wdXQuZGF0YSh0eXBlYWhlYWRLZXksIHR5cGVhaGVhZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wZW46IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChvcGVuVHlwZWFoZWFkKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBvcGVuVHlwZWFoZWFkKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgJGlucHV0ID0gJCh0aGlzKSwgdHlwZWFoZWFkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZWFoZWFkID0gJGlucHV0LmRhdGEodHlwZWFoZWFkS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZWFoZWFkLm9wZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChjbG9zZVR5cGVhaGVhZCk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2xvc2VUeXBlYWhlYWQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAkaW5wdXQgPSAkKHRoaXMpLCB0eXBlYWhlYWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlYWhlYWQgPSAkaW5wdXQuZGF0YSh0eXBlYWhlYWRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlYWhlYWQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWw6IGZ1bmN0aW9uIHZhbChuZXdWYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWFyZ3VtZW50cy5sZW5ndGggPyBnZXRWYWwodGhpcy5maXJzdCgpKSA6IHRoaXMuZWFjaChzZXRWYWwpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldFZhbCgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICRpbnB1dCA9ICQodGhpcyksIHR5cGVhaGVhZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVhaGVhZCA9ICRpbnB1dC5kYXRhKHR5cGVhaGVhZEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVhaGVhZC5zZXRWYWwobmV3VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRWYWwoJGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlYWhlYWQsIHF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZWFoZWFkID0gJGlucHV0LmRhdGEodHlwZWFoZWFkS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSB0eXBlYWhlYWQuZ2V0VmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2godW5hdHRhY2gpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVuYXR0YWNoKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgJGlucHV0ID0gJCh0aGlzKSwgdHlwZWFoZWFkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZWFoZWFkID0gJGlucHV0LmRhdGEodHlwZWFoZWFkS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZWFoZWFkLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRpbnB1dC5yZW1vdmVEYXRhKHR5cGVhaGVhZEtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgICQuZm4udHlwZWFoZWFkID0gZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICB2YXIgdHRzO1xuICAgICAgICAgICAgaWYgKG1ldGhvZHNbbWV0aG9kXSAmJiBtZXRob2QgIT09IFwiaW5pdGlhbGl6ZVwiKSB7XG4gICAgICAgICAgICAgICAgdHRzID0gdGhpcy5maWx0ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhISQodGhpcykuZGF0YSh0eXBlYWhlYWRLZXkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2RzW21ldGhvZF0uYXBwbHkodHRzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgICQuZm4udHlwZWFoZWFkLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgICAgICAgICAgJC5mbi50eXBlYWhlYWQgPSBvbGQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICB9KSgpO1xufSkod2luZG93LmpRdWVyeSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHJlc291cmNlcy9hc3NldHMvanMvdmVuZG9yL3R5cGVhaGVhZC5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 12 */
/***/ function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcz84MmU0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 13 */
/***/ function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() { return this; })();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 14 */
/***/ function(module, exports) {

eval("module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: false,\r\n\t\t\tget: function() { return module.l; }\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: false,\r\n\t\t\tget: function() { return module.i; }\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2MzYzIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtb2R1bGUubDsgfVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1vZHVsZS5pOyB9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

eval("// jQuery core\nwindow.jQuery = window.$ = __webpack_require__(7);\n\n// These all require jQuery\n__webpack_require__(9);\n__webpack_require__(5);\n__webpack_require__(11);\n__webpack_require__(10);\n__webpack_require__(3);\n__webpack_require__(4);\n\n// Standalone vendor libraries\nvar Hogan = __webpack_require__(6);\nvar Mousetrap = __webpack_require__(8);\nvar algoliasearch = __webpack_require__(2);\n\njQuery(function($) {\n\n  // Smooth scroll to anchor\n  $('body.home a[href*=\"#\"]:not([href=\"#\"])').click(function() {\n    if (location.pathname.replace(/^\\//,'') === this.pathname.replace(/^\\//,'') && location.hostname == this.hostname) {\n      var target = $(this.hash);\n      target = target.length ? target : $('[name=' + this.hash.slice(1) +']');\n      if (target.length) {\n        $('html,body').animate({\n          scrollTop: target.offset().top\n        }, 1000);\n        return false;\n      }\n    }\n  });\n\n  var scotchPanel = $('#slide-menu').scotchPanel({\n    containerSelector: 'body',\n    direction: 'left',\n    duration: 300,\n    transition: 'ease',\n    distanceX: '70%',\n    forceMinHeight: true,\n    minHeight: '2500px',\n    enableEscapeKey: true\n  }).show(); // show to avoid flash of content\n\n  $('.toggle-slide').click(function() {\n    scotchPanel.css('overflow', 'scroll');\n    scotchPanel.toggle();\n    return false;\n  });\n\n  $('.overlay').click(function() {\n    // CLOSE ONLY\n    scotchPanel.close();\n  });\n\n  // Hide the slide menu when changing the browser width\n\n  function checkSize() {\n    if (window.matchMedia(\"(min-width: 960px)\").matches) {\n      scotchPanel.close();\n    }\n  }\n\n  checkSize();\n  window.onresize = checkSize;\n\n  // gheading links\n  $('.docs-wrapper').find('a[name]').each(function () {\n    var anchor = $('<a href=\"#' + this.name + '\"/>');\n    $(this).parent().next('h2').wrapInner(anchor);\n  });\n\n  // It's nice to just write in Markdown, so this will adjust\n  // our blockquote style to fill in the icon flag and label\n  $('.docs blockquote p:first-child').each(function() {\n    var str = $(this).html();\n    var match = str.match(/\\{(.*?)\\}/);\n\n    if (match) {\n      var icon = match[1] || false;\n      var word = match[1] || false;\n    }\n\n    if (icon) {\n      switch (icon) {\n        case \"note\":\n          icon = '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:a=\"http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/\" version=\"1.1\" x=\"0px\" y=\"0px\" width=\"90px\" height=\"90px\" viewBox=\"0 0 90 90\" enable-background=\"new 0 0 90 90\" xml:space=\"preserve\"><path fill=\"#FFFFFF\" d=\"M45 0C20.1 0 0 20.1 0 45s20.1 45 45 45 45-20.1 45-45S69.9 0 45 0zM45 74.5c-3.6 0-6.5-2.9-6.5-6.5s2.9-6.5 6.5-6.5 6.5 2.9 6.5 6.5S48.6 74.5 45 74.5zM52.1 23.9l-2.5 29.6c0 2.5-2.1 4.6-4.6 4.6 -2.5 0-4.6-2.1-4.6-4.6l-2.5-29.6c-0.1-0.4-0.1-0.7-0.1-1.1 0-4 3.2-7.2 7.2-7.2 4 0 7.2 3.2 7.2 7.2C52.2 23.1 52.2 23.5 52.1 23.9z\"/></svg>';\n          break;\n        case \"tip\":\n          icon = '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:a=\"http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/\" version=\"1.1\" x=\"0px\" y=\"0px\" width=\"56.6px\" height=\"87.5px\" viewBox=\"0 0 56.6 87.5\" enable-background=\"new 0 0 56.6 87.5\" xml:space=\"preserve\"><path fill=\"#FFFFFF\" d=\"M28.7 64.5c-1.4 0-2.5-1.1-2.5-2.5v-5.7 -5V41c0-1.4 1.1-2.5 2.5-2.5s2.5 1.1 2.5 2.5v10.1 5 5.8C31.2 63.4 30.1 64.5 28.7 64.5zM26.4 0.1C11.9 1 0.3 13.1 0 27.7c-0.1 7.9 3 15.2 8.2 20.4 0.5 0.5 0.8 1 1 1.7l3.1 13.1c0.3 1.1 1.3 1.9 2.4 1.9 0.3 0 0.7-0.1 1.1-0.2 1.1-0.5 1.6-1.8 1.4-3l-2-8.4 -0.4-1.8c-0.7-2.9-2-5.7-4-8 -1-1.2-2-2.5-2.7-3.9C5.8 35.3 4.7 30.3 5.4 25 6.7 14.5 15.2 6.3 25.6 5.1c13.9-1.5 25.8 9.4 25.8 23 0 4.1-1.1 7.9-2.9 11.2 -0.8 1.4-1.7 2.7-2.7 3.9 -2 2.3-3.3 5-4 8L41.4 53l-2 8.4c-0.3 1.2 0.3 2.5 1.4 3 0.3 0.2 0.7 0.2 1.1 0.2 1.1 0 2.2-0.8 2.4-1.9l3.1-13.1c0.2-0.6 0.5-1.2 1-1.7 5-5.1 8.2-12.1 8.2-19.8C56.4 12 42.8-1 26.4 0.1zM43.7 69.6c0 0.5-0.1 0.9-0.3 1.3 -0.4 0.8-0.7 1.6-0.9 2.5 -0.7 3-2 8.6-2 8.6 -1.3 3.2-4.4 5.5-7.9 5.5h-4.1H28h-0.5 -3.6c-3.5 0-6.7-2.4-7.9-5.7l-0.1-0.4 -1.8-7.8c-0.4-1.1-0.8-2.1-1.2-3.1 -0.1-0.3-0.2-0.5-0.2-0.9 0.1-1.3 1.3-2.1 2.6-2.1H41C42.4 67.5 43.6 68.2 43.7 69.6zM37.7 72.5H26.9c-4.2 0-7.2 3.9-6.3 7.9 0.6 1.3 1.8 2.1 3.2 2.1h4.1 0.5 0.5 3.6c1.4 0 2.7-0.8 3.2-2.1L37.7 72.5z\"/></svg>'\n          break;\n        case \"laracast\":\n        case \"video\":\n          icon = '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:a=\"http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/\" version=\"1.1\" x=\"0px\" y=\"0px\" width=\"68.9px\" height=\"59.9px\" viewBox=\"0 0 68.9 59.9\" enable-background=\"new 0 0 68.9 59.9\" xml:space=\"preserve\"><path fill=\"#FFFFFF\" d=\"M63.7 0H5.3C2.4 0 0 2.4 0 5.3v49.3c0 2.9 2.4 5.3 5.3 5.3h58.3c2.9 0 5.3-2.4 5.3-5.3V5.3C69 2.4 66.6 0 63.7 0zM5.3 4h58.3c0.7 0 1.3 0.6 1.3 1.3V48H4V5.3C4 4.6 4.6 4 5.3 4zM13 52v4h-2v-4H13zM17 52h2v4h-2V52zM23 52h2v4h-2V52zM29 52h2v4h-2V52zM35 52h2v4h-2V52zM41 52h2v4h-2V52zM4 54.7V52h3v4H5.3C4.6 56 4 55.4 4 54.7zM63.7 56H47v-4h18v2.7C65 55.4 64.4 56 63.7 56zM26 38.7c0.3 0.2 0.7 0.3 1 0.3 0.4 0 0.7-0.1 1-0.3l17-10c0.6-0.4 1-1 1-1.7s-0.4-1.4-1-1.7l-17-10c-0.6-0.4-1.4-0.4-2 0s-1 1-1 1.7v20C25 37.7 25.4 38.4 26 38.7zM29 20.5L40.1 27 29 33.5V20.5z\"/></svg>';\n          break;\n      }\n      $(this).html(str.replace(/\\{(.*?)\\}/, '<div class=\"flag\"><span class=\"svg\">'+ icon +'</span></div>'));\n      $(this).parent().addClass('has-icon ' + word);\n    }\n  });\n\n  Mousetrap.bind('/', function(e) {\n    e.preventDefault();\n    $('#search-input').focus();\n  });\n\n  Mousetrap.bind([\"ctrl+b\", \"command+b\"], function(e) {\n    e.preventDefault();\n    $(\".sidebar\").find( \"h2\" ).addClass('is-active');\n  });\n\n  initAlgoliaSearch();\n\n  // Fixes FOUC for the search box\n  $('.search.invisible').removeClass('invisible');\n\n  function initAlgoliaSearch() {\n    if (window.algolia_app_id === '') {\n      return;\n    }\n\n    var client = algoliasearch(window.algolia_app_id, window.algolia_search_key);\n    var index = client.initIndex('docs');\n\n    var templates = {\n      suggestion: Hogan.compile($('#search_suggestion_template').html()),\n      empty: Hogan.compile($('#search_empty_template').html()),\n      footer: Hogan.compile($('#search_footer_template').html())\n    };\n    var $searchInput = $('#search-input');\n    var $article = $('article');\n\n      // typeahead datasets\n      // https://github.com/twitter/typeahead.js/blob/master/doc/jquery_typeahead.md#datasets\n    var datasets = [];\n\n    datasets.push({\n      source: function searchAlgolia(query, cb) {\n      index.search(query, {\n        hitsPerPage: 5, tagFilters: [window.version]\n      }, function searchCallback(err, content) {\n          if (err) {\n            throw err;\n          }\n          cb(content.hits)\n        });\n      },\n      templates: {\n        suggestion: templates.suggestion.render.bind(templates.suggestion),\n        empty: templates.empty.render.bind(templates.empty),\n        footer: templates.footer.render.bind(templates.footer)\n      }\n    });\n\n    var typeahead = $searchInput.typeahead({hint: false}, datasets);\n    var old_input = '';\n\n    typeahead.on('typeahead:selected', function changePage(e, item) {\n      window.location.href = '/docs/' + item._tags[0] + '/' + item.link;\n    });\n\n    typeahead.on('keyup', function(e) {\n      old_input = $(this).typeahead('val');\n\n      if ($(this).val() === '' && old_input.length == $(this).typeahead('val')) {\n        $article.css('opacity', '1');\n        $searchInput.closest('#search-wrapper').removeClass('not-empty');\n      } else {\n        $article.css('opacity', '0.1');\n        $searchInput.closest('#search-wrapper').addClass('not-empty');\n      }\n      if (e.keyCode === 27) {\n        $article.css('opacity', '1');\n      }\n    });\n\n    typeahead.on('typeahead:closed', function () {\n      $article.css('opacity', '1');\n    });\n\n    typeahead.on('typeahead:closed',\n        function (e) {\n            // keep menu open if input element is still focused\n            if ($(e.target).is(':focus')) {\n                return false;\n            }\n        }\n    );\n\n    $('#cross').click(function() {\n      typeahead.typeahead('val', '').keyup();\n      $article.css('opacity', '1');\n    });\n  }\n\n  // collapse and expand for the sidebar\n  var toggles = document.querySelectorAll('.sidebar h2'),\n      togglesList = document.querySelectorAll('.sidebar h2 + ul');\n\n  for (var i = 0; i < toggles.length; i++) {\n    toggles[i].addEventListener('click', expandItem);\n    toggles[i].addEventListener('keydown', expandItemKeyboard);\n    toggles[i].setAttribute('tabindex', '0');\n  }\n\n  // Via https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API#Testing_for_availability\n  function storageAvailable(type) {\n    try {\n      var storage = window[type],\n          x = '__storage_test__';\n      storage.setItem(x, x);\n      storage.removeItem(x);\n      return true;\n    } catch(e) {\n      return e instanceof DOMException && (\n          // everything except Firefox\n          e.code === 22 ||\n          // Firefox\n          e.code === 1014 ||\n          // test name field too, because code might not be present\n          // everything except Firefox\n          e.name === 'QuotaExceededError' ||\n          // Firefox\n          e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\n          // acknowledge QuotaExceededError only if there's something already stored\n          storage.length !== 0;\n    }\n  }\n\n  // Track the state of the doc collapse\n  var docCollapsed = true;\n  function expandDocs(e) {\n    for (var i = 0; i < toggles.length; i++) {\n      if(docCollapsed) {\n        toggles[i].classList.add('is-active')\n      } else {\n        toggles[i].classList.remove('is-active')\n      }\n    }\n\n    // Modify states\n    docCollapsed = !docCollapsed;\n    document.getElementById('doc-expand').text = (docCollapsed ? 'â¶' : 'â¼');\n\n    // Modify LS if we can\n    if (storageAvailable('localStorage')) {\n      localStorage.setItem('laravel_docCollapsed', docCollapsed);\n    }\n    // Cancel event\n    if(e) {\n      e.preventDefault();\n    }\n  }\n\n  // Load the users previous preference if available\n  if(storageAvailable('localStorage')) {\n    // Can't use if(var) since this is a boolean, LS returns null for unset keys\n    if(localStorage.getItem('laravel_docCollapsed') === null) {\n      localStorage.setItem('laravel_docCollapsed', true)\n    } else {\n      // Load previous state, and if it was false, then expand the doc\n      // LS will store booleans as strings, we will \"cast\" them back here\n      localStorage.getItem('laravel_docCollapsed') == 'false' ? expandDocs() : null\n    }\n  }\n\n  // Register event listener\n  document.getElementById('doc-expand') ? document.getElementById('doc-expand').addEventListener('click', expandDocs) : null;\n\n  if ($('.sidebar ul').length) {\n    var current = $('.sidebar ul').find('li a[href=\"' + window.location.pathname + '\"]');\n\n    if (current.length) {\n      current.parent().css('font-weight', 'bold');\n\n      // Only toggle the state if the user has collapsed the documentation\n      if(docCollapsed) {\n        current.closest('ul').prev().toggleClass('is-active');\n      }\n    }\n  }\n\n  function expandItem(e) {\n    var elem = e.target;\n\n    if(elem.classList.contains('is-active')) {\n      elem.classList.remove('is-active');\n    } else {\n      clearItems();\n      elem.classList.add('is-active');\n    }\n  }\n\n  function expandItemKeyboard(e) {\n    clearItems();\n    var elem = e.target;\n\n    if (e.keyCode === 13) {\n      elem.classList.toggle('is-active');\n    }\n\n    if (e.keyCode === 39) {\n      elem.classList.add('is-active');\n    }\n\n    if (e.keyCode === 37) {\n      elem.classList.remove('is-active');\n    }\n  }\n\n  function clearItems() {\n    for (var i = 0; i < toggles.length; i++) {\n      toggles[i].classList.remove('is-active');\n    }\n  }\n\n\n    // sidebar nav active state\n    $('.sidebar li').removeClass('active');\n\n    if (location.pathname != '/docs/5.1' && location.pathname != '/docs/5.1/') {\n        $('.sidebar a[href=\"' + location.pathname + '\"]').parent().addClass('active');\n    }\n\n     if ($('.anchorific').length == 0) {\n        $('article .main-content').anchorific({\n            navigation: '.anchorific', // position of navigation\n            speed: 200, // speed of sliding back to top\n            anchorClass: 'anchorific', // class of anchor links\n            anchorText: '#', // prepended or appended to anchor headings\n            top: '.top', // back to top button or link class\n            spy: true, // scroll spy\n            position: 'append', // position of anchor text\n            spyOffset: 0 // specify heading offset for spy scrolling\n        });\n    }\n\n});\n\n\n\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcmVzb3VyY2VzL2Fzc2V0cy9qcy9sYXJhdmVsLmpzP2M0MDYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8galF1ZXJ5IGNvcmVcbndpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IHJlcXVpcmUoJy4vdmVuZG9yL2pxdWVyeS5qcycpO1xuXG4vLyBUaGVzZSBhbGwgcmVxdWlyZSBqUXVlcnlcbnJlcXVpcmUoJy4vdmVuZG9yL3ByaXNtLmpzJyk7XG5yZXF1aXJlKCcuL3ZlbmRvci9ib290c3RyYXAuanMnKTtcbnJlcXVpcmUoJy4vdmVuZG9yL3R5cGVhaGVhZC5qcycpO1xucmVxdWlyZSgnLi92ZW5kb3Ivc2NvdGNoUGFuZWxzLmpzJyk7XG5yZXF1aXJlKCcuL3ZlbmRvci9hbmFseXRpY3MuanMnKTtcbnJlcXVpcmUoJy4vdmVuZG9yL2FuY2hvcmlmaWMuanMnKTtcblxuLy8gU3RhbmRhbG9uZSB2ZW5kb3IgbGlicmFyaWVzXG5jb25zdCBIb2dhbiA9IHJlcXVpcmUoJy4vdmVuZG9yL2hvZ2FuLmpzJyk7XG5jb25zdCBNb3VzZXRyYXAgPSByZXF1aXJlKCcuL3ZlbmRvci9tb3VzZXRyYXAuanMnKTtcbmNvbnN0IGFsZ29saWFzZWFyY2ggPSByZXF1aXJlKCcuL3ZlbmRvci9hbGdvbGlhc2VhcmNoLmpzJyk7XG5cbmpRdWVyeShmdW5jdGlvbigkKSB7XG5cbiAgLy8gU21vb3RoIHNjcm9sbCB0byBhbmNob3JcbiAgJCgnYm9keS5ob21lIGFbaHJlZio9XCIjXCJdOm5vdChbaHJlZj1cIiNcIl0pJykuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL15cXC8vLCcnKSA9PT0gdGhpcy5wYXRobmFtZS5yZXBsYWNlKC9eXFwvLywnJykgJiYgbG9jYXRpb24uaG9zdG5hbWUgPT0gdGhpcy5ob3N0bmFtZSkge1xuICAgICAgdmFyIHRhcmdldCA9ICQodGhpcy5oYXNoKTtcbiAgICAgIHRhcmdldCA9IHRhcmdldC5sZW5ndGggPyB0YXJnZXQgOiAkKCdbbmFtZT0nICsgdGhpcy5oYXNoLnNsaWNlKDEpICsnXScpO1xuICAgICAgaWYgKHRhcmdldC5sZW5ndGgpIHtcbiAgICAgICAgJCgnaHRtbCxib2R5JykuYW5pbWF0ZSh7XG4gICAgICAgICAgc2Nyb2xsVG9wOiB0YXJnZXQub2Zmc2V0KCkudG9wXG4gICAgICAgIH0sIDEwMDApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICB2YXIgc2NvdGNoUGFuZWwgPSAkKCcjc2xpZGUtbWVudScpLnNjb3RjaFBhbmVsKHtcbiAgICBjb250YWluZXJTZWxlY3RvcjogJ2JvZHknLFxuICAgIGRpcmVjdGlvbjogJ2xlZnQnLFxuICAgIGR1cmF0aW9uOiAzMDAsXG4gICAgdHJhbnNpdGlvbjogJ2Vhc2UnLFxuICAgIGRpc3RhbmNlWDogJzcwJScsXG4gICAgZm9yY2VNaW5IZWlnaHQ6IHRydWUsXG4gICAgbWluSGVpZ2h0OiAnMjUwMHB4JyxcbiAgICBlbmFibGVFc2NhcGVLZXk6IHRydWVcbiAgfSkuc2hvdygpOyAvLyBzaG93IHRvIGF2b2lkIGZsYXNoIG9mIGNvbnRlbnRcblxuICAkKCcudG9nZ2xlLXNsaWRlJykuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgc2NvdGNoUGFuZWwuY3NzKCdvdmVyZmxvdycsICdzY3JvbGwnKTtcbiAgICBzY290Y2hQYW5lbC50b2dnbGUoKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xuXG4gICQoJy5vdmVybGF5JykuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgLy8gQ0xPU0UgT05MWVxuICAgIHNjb3RjaFBhbmVsLmNsb3NlKCk7XG4gIH0pO1xuXG4gIC8vIEhpZGUgdGhlIHNsaWRlIG1lbnUgd2hlbiBjaGFuZ2luZyB0aGUgYnJvd3NlciB3aWR0aFxuXG4gIGZ1bmN0aW9uIGNoZWNrU2l6ZSgpIHtcbiAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEoXCIobWluLXdpZHRoOiA5NjBweClcIikubWF0Y2hlcykge1xuICAgICAgc2NvdGNoUGFuZWwuY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICBjaGVja1NpemUoKTtcbiAgd2luZG93Lm9ucmVzaXplID0gY2hlY2tTaXplO1xuXG4gIC8vIGdoZWFkaW5nIGxpbmtzXG4gICQoJy5kb2NzLXdyYXBwZXInKS5maW5kKCdhW25hbWVdJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFuY2hvciA9ICQoJzxhIGhyZWY9XCIjJyArIHRoaXMubmFtZSArICdcIi8+Jyk7XG4gICAgJCh0aGlzKS5wYXJlbnQoKS5uZXh0KCdoMicpLndyYXBJbm5lcihhbmNob3IpO1xuICB9KTtcblxuICAvLyBJdCdzIG5pY2UgdG8ganVzdCB3cml0ZSBpbiBNYXJrZG93biwgc28gdGhpcyB3aWxsIGFkanVzdFxuICAvLyBvdXIgYmxvY2txdW90ZSBzdHlsZSB0byBmaWxsIGluIHRoZSBpY29uIGZsYWcgYW5kIGxhYmVsXG4gICQoJy5kb2NzIGJsb2NrcXVvdGUgcDpmaXJzdC1jaGlsZCcpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0ciA9ICQodGhpcykuaHRtbCgpO1xuICAgIHZhciBtYXRjaCA9IHN0ci5tYXRjaCgvXFx7KC4qPylcXH0vKTtcblxuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIGljb24gPSBtYXRjaFsxXSB8fCBmYWxzZTtcbiAgICAgIHZhciB3b3JkID0gbWF0Y2hbMV0gfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGljb24pIHtcbiAgICAgIHN3aXRjaCAoaWNvbikge1xuICAgICAgICBjYXNlIFwibm90ZVwiOlxuICAgICAgICAgIGljb24gPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeG1sbnM6YT1cImh0dHA6Ly9ucy5hZG9iZS5jb20vQWRvYmVTVkdWaWV3ZXJFeHRlbnNpb25zLzMuMC9cIiB2ZXJzaW9uPVwiMS4xXCIgeD1cIjBweFwiIHk9XCIwcHhcIiB3aWR0aD1cIjkwcHhcIiBoZWlnaHQ9XCI5MHB4XCIgdmlld0JveD1cIjAgMCA5MCA5MFwiIGVuYWJsZS1iYWNrZ3JvdW5kPVwibmV3IDAgMCA5MCA5MFwiIHhtbDpzcGFjZT1cInByZXNlcnZlXCI+PHBhdGggZmlsbD1cIiNGRkZGRkZcIiBkPVwiTTQ1IDBDMjAuMSAwIDAgMjAuMSAwIDQ1czIwLjEgNDUgNDUgNDUgNDUtMjAuMSA0NS00NVM2OS45IDAgNDUgMHpNNDUgNzQuNWMtMy42IDAtNi41LTIuOS02LjUtNi41czIuOS02LjUgNi41LTYuNSA2LjUgMi45IDYuNSA2LjVTNDguNiA3NC41IDQ1IDc0LjV6TTUyLjEgMjMuOWwtMi41IDI5LjZjMCAyLjUtMi4xIDQuNi00LjYgNC42IC0yLjUgMC00LjYtMi4xLTQuNi00LjZsLTIuNS0yOS42Yy0wLjEtMC40LTAuMS0wLjctMC4xLTEuMSAwLTQgMy4yLTcuMiA3LjItNy4yIDQgMCA3LjIgMy4yIDcuMiA3LjJDNTIuMiAyMy4xIDUyLjIgMjMuNSA1Mi4xIDIzLjl6XCIvPjwvc3ZnPic7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0aXBcIjpcbiAgICAgICAgICBpY29uID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHhtbG5zOmE9XCJodHRwOi8vbnMuYWRvYmUuY29tL0Fkb2JlU1ZHVmlld2VyRXh0ZW5zaW9ucy8zLjAvXCIgdmVyc2lvbj1cIjEuMVwiIHg9XCIwcHhcIiB5PVwiMHB4XCIgd2lkdGg9XCI1Ni42cHhcIiBoZWlnaHQ9XCI4Ny41cHhcIiB2aWV3Qm94PVwiMCAwIDU2LjYgODcuNVwiIGVuYWJsZS1iYWNrZ3JvdW5kPVwibmV3IDAgMCA1Ni42IDg3LjVcIiB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPjxwYXRoIGZpbGw9XCIjRkZGRkZGXCIgZD1cIk0yOC43IDY0LjVjLTEuNCAwLTIuNS0xLjEtMi41LTIuNXYtNS43IC01VjQxYzAtMS40IDEuMS0yLjUgMi41LTIuNXMyLjUgMS4xIDIuNSAyLjV2MTAuMSA1IDUuOEMzMS4yIDYzLjQgMzAuMSA2NC41IDI4LjcgNjQuNXpNMjYuNCAwLjFDMTEuOSAxIDAuMyAxMy4xIDAgMjcuN2MtMC4xIDcuOSAzIDE1LjIgOC4yIDIwLjQgMC41IDAuNSAwLjggMSAxIDEuN2wzLjEgMTMuMWMwLjMgMS4xIDEuMyAxLjkgMi40IDEuOSAwLjMgMCAwLjctMC4xIDEuMS0wLjIgMS4xLTAuNSAxLjYtMS44IDEuNC0zbC0yLTguNCAtMC40LTEuOGMtMC43LTIuOS0yLTUuNy00LTggLTEtMS4yLTItMi41LTIuNy0zLjlDNS44IDM1LjMgNC43IDMwLjMgNS40IDI1IDYuNyAxNC41IDE1LjIgNi4zIDI1LjYgNS4xYzEzLjktMS41IDI1LjggOS40IDI1LjggMjMgMCA0LjEtMS4xIDcuOS0yLjkgMTEuMiAtMC44IDEuNC0xLjcgMi43LTIuNyAzLjkgLTIgMi4zLTMuMyA1LTQgOEw0MS40IDUzbC0yIDguNGMtMC4zIDEuMiAwLjMgMi41IDEuNCAzIDAuMyAwLjIgMC43IDAuMiAxLjEgMC4yIDEuMSAwIDIuMi0wLjggMi40LTEuOWwzLjEtMTMuMWMwLjItMC42IDAuNS0xLjIgMS0xLjcgNS01LjEgOC4yLTEyLjEgOC4yLTE5LjhDNTYuNCAxMiA0Mi44LTEgMjYuNCAwLjF6TTQzLjcgNjkuNmMwIDAuNS0wLjEgMC45LTAuMyAxLjMgLTAuNCAwLjgtMC43IDEuNi0wLjkgMi41IC0wLjcgMy0yIDguNi0yIDguNiAtMS4zIDMuMi00LjQgNS41LTcuOSA1LjVoLTQuMUgyOGgtMC41IC0zLjZjLTMuNSAwLTYuNy0yLjQtNy45LTUuN2wtMC4xLTAuNCAtMS44LTcuOGMtMC40LTEuMS0wLjgtMi4xLTEuMi0zLjEgLTAuMS0wLjMtMC4yLTAuNS0wLjItMC45IDAuMS0xLjMgMS4zLTIuMSAyLjYtMi4xSDQxQzQyLjQgNjcuNSA0My42IDY4LjIgNDMuNyA2OS42ek0zNy43IDcyLjVIMjYuOWMtNC4yIDAtNy4yIDMuOS02LjMgNy45IDAuNiAxLjMgMS44IDIuMSAzLjIgMi4xaDQuMSAwLjUgMC41IDMuNmMxLjQgMCAyLjctMC44IDMuMi0yLjFMMzcuNyA3Mi41elwiLz48L3N2Zz4nXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsYXJhY2FzdFwiOlxuICAgICAgICBjYXNlIFwidmlkZW9cIjpcbiAgICAgICAgICBpY29uID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHhtbG5zOmE9XCJodHRwOi8vbnMuYWRvYmUuY29tL0Fkb2JlU1ZHVmlld2VyRXh0ZW5zaW9ucy8zLjAvXCIgdmVyc2lvbj1cIjEuMVwiIHg9XCIwcHhcIiB5PVwiMHB4XCIgd2lkdGg9XCI2OC45cHhcIiBoZWlnaHQ9XCI1OS45cHhcIiB2aWV3Qm94PVwiMCAwIDY4LjkgNTkuOVwiIGVuYWJsZS1iYWNrZ3JvdW5kPVwibmV3IDAgMCA2OC45IDU5LjlcIiB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPjxwYXRoIGZpbGw9XCIjRkZGRkZGXCIgZD1cIk02My43IDBINS4zQzIuNCAwIDAgMi40IDAgNS4zdjQ5LjNjMCAyLjkgMi40IDUuMyA1LjMgNS4zaDU4LjNjMi45IDAgNS4zLTIuNCA1LjMtNS4zVjUuM0M2OSAyLjQgNjYuNiAwIDYzLjcgMHpNNS4zIDRoNTguM2MwLjcgMCAxLjMgMC42IDEuMyAxLjNWNDhINFY1LjNDNCA0LjYgNC42IDQgNS4zIDR6TTEzIDUydjRoLTJ2LTRIMTN6TTE3IDUyaDJ2NGgtMlY1MnpNMjMgNTJoMnY0aC0yVjUyek0yOSA1MmgydjRoLTJWNTJ6TTM1IDUyaDJ2NGgtMlY1MnpNNDEgNTJoMnY0aC0yVjUyek00IDU0LjdWNTJoM3Y0SDUuM0M0LjYgNTYgNCA1NS40IDQgNTQuN3pNNjMuNyA1Nkg0N3YtNGgxOHYyLjdDNjUgNTUuNCA2NC40IDU2IDYzLjcgNTZ6TTI2IDM4LjdjMC4zIDAuMiAwLjcgMC4zIDEgMC4zIDAuNCAwIDAuNy0wLjEgMS0wLjNsMTctMTBjMC42LTAuNCAxLTEgMS0xLjdzLTAuNC0xLjQtMS0xLjdsLTE3LTEwYy0wLjYtMC40LTEuNC0wLjQtMiAwcy0xIDEtMSAxLjd2MjBDMjUgMzcuNyAyNS40IDM4LjQgMjYgMzguN3pNMjkgMjAuNUw0MC4xIDI3IDI5IDMzLjVWMjAuNXpcIi8+PC9zdmc+JztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgICQodGhpcykuaHRtbChzdHIucmVwbGFjZSgvXFx7KC4qPylcXH0vLCAnPGRpdiBjbGFzcz1cImZsYWdcIj48c3BhbiBjbGFzcz1cInN2Z1wiPicrIGljb24gKyc8L3NwYW4+PC9kaXY+JykpO1xuICAgICAgJCh0aGlzKS5wYXJlbnQoKS5hZGRDbGFzcygnaGFzLWljb24gJyArIHdvcmQpO1xuICAgIH1cbiAgfSk7XG5cbiAgTW91c2V0cmFwLmJpbmQoJy8nLCBmdW5jdGlvbihlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICQoJyNzZWFyY2gtaW5wdXQnKS5mb2N1cygpO1xuICB9KTtcblxuICBNb3VzZXRyYXAuYmluZChbXCJjdHJsK2JcIiwgXCJjb21tYW5kK2JcIl0sIGZ1bmN0aW9uKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgJChcIi5zaWRlYmFyXCIpLmZpbmQoIFwiaDJcIiApLmFkZENsYXNzKCdpcy1hY3RpdmUnKTtcbiAgfSk7XG5cbiAgaW5pdEFsZ29saWFTZWFyY2goKTtcblxuICAvLyBGaXhlcyBGT1VDIGZvciB0aGUgc2VhcmNoIGJveFxuICAkKCcuc2VhcmNoLmludmlzaWJsZScpLnJlbW92ZUNsYXNzKCdpbnZpc2libGUnKTtcblxuICBmdW5jdGlvbiBpbml0QWxnb2xpYVNlYXJjaCgpIHtcbiAgICBpZiAod2luZG93LmFsZ29saWFfYXBwX2lkID09PSAnJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjbGllbnQgPSBhbGdvbGlhc2VhcmNoKHdpbmRvdy5hbGdvbGlhX2FwcF9pZCwgd2luZG93LmFsZ29saWFfc2VhcmNoX2tleSk7XG4gICAgdmFyIGluZGV4ID0gY2xpZW50LmluaXRJbmRleCgnZG9jcycpO1xuXG4gICAgdmFyIHRlbXBsYXRlcyA9IHtcbiAgICAgIHN1Z2dlc3Rpb246IEhvZ2FuLmNvbXBpbGUoJCgnI3NlYXJjaF9zdWdnZXN0aW9uX3RlbXBsYXRlJykuaHRtbCgpKSxcbiAgICAgIGVtcHR5OiBIb2dhbi5jb21waWxlKCQoJyNzZWFyY2hfZW1wdHlfdGVtcGxhdGUnKS5odG1sKCkpLFxuICAgICAgZm9vdGVyOiBIb2dhbi5jb21waWxlKCQoJyNzZWFyY2hfZm9vdGVyX3RlbXBsYXRlJykuaHRtbCgpKVxuICAgIH07XG4gICAgdmFyICRzZWFyY2hJbnB1dCA9ICQoJyNzZWFyY2gtaW5wdXQnKTtcbiAgICB2YXIgJGFydGljbGUgPSAkKCdhcnRpY2xlJyk7XG5cbiAgICAgIC8vIHR5cGVhaGVhZCBkYXRhc2V0c1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3R3aXR0ZXIvdHlwZWFoZWFkLmpzL2Jsb2IvbWFzdGVyL2RvYy9qcXVlcnlfdHlwZWFoZWFkLm1kI2RhdGFzZXRzXG4gICAgdmFyIGRhdGFzZXRzID0gW107XG5cbiAgICBkYXRhc2V0cy5wdXNoKHtcbiAgICAgIHNvdXJjZTogZnVuY3Rpb24gc2VhcmNoQWxnb2xpYShxdWVyeSwgY2IpIHtcbiAgICAgIGluZGV4LnNlYXJjaChxdWVyeSwge1xuICAgICAgICBoaXRzUGVyUGFnZTogNSwgdGFnRmlsdGVyczogW3dpbmRvdy52ZXJzaW9uXVxuICAgICAgfSwgZnVuY3Rpb24gc2VhcmNoQ2FsbGJhY2soZXJyLCBjb250ZW50KSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYihjb250ZW50LmhpdHMpXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHRlbXBsYXRlczoge1xuICAgICAgICBzdWdnZXN0aW9uOiB0ZW1wbGF0ZXMuc3VnZ2VzdGlvbi5yZW5kZXIuYmluZCh0ZW1wbGF0ZXMuc3VnZ2VzdGlvbiksXG4gICAgICAgIGVtcHR5OiB0ZW1wbGF0ZXMuZW1wdHkucmVuZGVyLmJpbmQodGVtcGxhdGVzLmVtcHR5KSxcbiAgICAgICAgZm9vdGVyOiB0ZW1wbGF0ZXMuZm9vdGVyLnJlbmRlci5iaW5kKHRlbXBsYXRlcy5mb290ZXIpXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgdHlwZWFoZWFkID0gJHNlYXJjaElucHV0LnR5cGVhaGVhZCh7aGludDogZmFsc2V9LCBkYXRhc2V0cyk7XG4gICAgdmFyIG9sZF9pbnB1dCA9ICcnO1xuXG4gICAgdHlwZWFoZWFkLm9uKCd0eXBlYWhlYWQ6c2VsZWN0ZWQnLCBmdW5jdGlvbiBjaGFuZ2VQYWdlKGUsIGl0ZW0pIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gJy9kb2NzLycgKyBpdGVtLl90YWdzWzBdICsgJy8nICsgaXRlbS5saW5rO1xuICAgIH0pO1xuXG4gICAgdHlwZWFoZWFkLm9uKCdrZXl1cCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIG9sZF9pbnB1dCA9ICQodGhpcykudHlwZWFoZWFkKCd2YWwnKTtcblxuICAgICAgaWYgKCQodGhpcykudmFsKCkgPT09ICcnICYmIG9sZF9pbnB1dC5sZW5ndGggPT0gJCh0aGlzKS50eXBlYWhlYWQoJ3ZhbCcpKSB7XG4gICAgICAgICRhcnRpY2xlLmNzcygnb3BhY2l0eScsICcxJyk7XG4gICAgICAgICRzZWFyY2hJbnB1dC5jbG9zZXN0KCcjc2VhcmNoLXdyYXBwZXInKS5yZW1vdmVDbGFzcygnbm90LWVtcHR5Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkYXJ0aWNsZS5jc3MoJ29wYWNpdHknLCAnMC4xJyk7XG4gICAgICAgICRzZWFyY2hJbnB1dC5jbG9zZXN0KCcjc2VhcmNoLXdyYXBwZXInKS5hZGRDbGFzcygnbm90LWVtcHR5Jyk7XG4gICAgICB9XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAyNykge1xuICAgICAgICAkYXJ0aWNsZS5jc3MoJ29wYWNpdHknLCAnMScpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdHlwZWFoZWFkLm9uKCd0eXBlYWhlYWQ6Y2xvc2VkJywgZnVuY3Rpb24gKCkge1xuICAgICAgJGFydGljbGUuY3NzKCdvcGFjaXR5JywgJzEnKTtcbiAgICB9KTtcblxuICAgIHR5cGVhaGVhZC5vbigndHlwZWFoZWFkOmNsb3NlZCcsXG4gICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyBrZWVwIG1lbnUgb3BlbiBpZiBpbnB1dCBlbGVtZW50IGlzIHN0aWxsIGZvY3VzZWRcbiAgICAgICAgICAgIGlmICgkKGUudGFyZ2V0KS5pcygnOmZvY3VzJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgJCgnI2Nyb3NzJykuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICB0eXBlYWhlYWQudHlwZWFoZWFkKCd2YWwnLCAnJykua2V5dXAoKTtcbiAgICAgICRhcnRpY2xlLmNzcygnb3BhY2l0eScsICcxJyk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBjb2xsYXBzZSBhbmQgZXhwYW5kIGZvciB0aGUgc2lkZWJhclxuICB2YXIgdG9nZ2xlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zaWRlYmFyIGgyJyksXG4gICAgICB0b2dnbGVzTGlzdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zaWRlYmFyIGgyICsgdWwnKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRvZ2dsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0b2dnbGVzW2ldLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXhwYW5kSXRlbSk7XG4gICAgdG9nZ2xlc1tpXS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZXhwYW5kSXRlbUtleWJvYXJkKTtcbiAgICB0b2dnbGVzW2ldLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnMCcpO1xuICB9XG5cbiAgLy8gVmlhIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJfU3RvcmFnZV9BUEkvVXNpbmdfdGhlX1dlYl9TdG9yYWdlX0FQSSNUZXN0aW5nX2Zvcl9hdmFpbGFiaWxpdHlcbiAgZnVuY3Rpb24gc3RvcmFnZUF2YWlsYWJsZSh0eXBlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBzdG9yYWdlID0gd2luZG93W3R5cGVdLFxuICAgICAgICAgIHggPSAnX19zdG9yYWdlX3Rlc3RfXyc7XG4gICAgICBzdG9yYWdlLnNldEl0ZW0oeCwgeCk7XG4gICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oeCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uICYmIChcbiAgICAgICAgICAvLyBldmVyeXRoaW5nIGV4Y2VwdCBGaXJlZm94XG4gICAgICAgICAgZS5jb2RlID09PSAyMiB8fFxuICAgICAgICAgIC8vIEZpcmVmb3hcbiAgICAgICAgICBlLmNvZGUgPT09IDEwMTQgfHxcbiAgICAgICAgICAvLyB0ZXN0IG5hbWUgZmllbGQgdG9vLCBiZWNhdXNlIGNvZGUgbWlnaHQgbm90IGJlIHByZXNlbnRcbiAgICAgICAgICAvLyBldmVyeXRoaW5nIGV4Y2VwdCBGaXJlZm94XG4gICAgICAgICAgZS5uYW1lID09PSAnUXVvdGFFeGNlZWRlZEVycm9yJyB8fFxuICAgICAgICAgIC8vIEZpcmVmb3hcbiAgICAgICAgICBlLm5hbWUgPT09ICdOU19FUlJPUl9ET01fUVVPVEFfUkVBQ0hFRCcpICYmXG4gICAgICAgICAgLy8gYWNrbm93bGVkZ2UgUXVvdGFFeGNlZWRlZEVycm9yIG9ubHkgaWYgdGhlcmUncyBzb21ldGhpbmcgYWxyZWFkeSBzdG9yZWRcbiAgICAgICAgICBzdG9yYWdlLmxlbmd0aCAhPT0gMDtcbiAgICB9XG4gIH1cblxuICAvLyBUcmFjayB0aGUgc3RhdGUgb2YgdGhlIGRvYyBjb2xsYXBzZVxuICB2YXIgZG9jQ29sbGFwc2VkID0gdHJ1ZTtcbiAgZnVuY3Rpb24gZXhwYW5kRG9jcyhlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2dnbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZihkb2NDb2xsYXBzZWQpIHtcbiAgICAgICAgdG9nZ2xlc1tpXS5jbGFzc0xpc3QuYWRkKCdpcy1hY3RpdmUnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9nZ2xlc1tpXS5jbGFzc0xpc3QucmVtb3ZlKCdpcy1hY3RpdmUnKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1vZGlmeSBzdGF0ZXNcbiAgICBkb2NDb2xsYXBzZWQgPSAhZG9jQ29sbGFwc2VkO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkb2MtZXhwYW5kJykudGV4dCA9IChkb2NDb2xsYXBzZWQgPyAn4pa2JyA6ICfilrwnKTtcblxuICAgIC8vIE1vZGlmeSBMUyBpZiB3ZSBjYW5cbiAgICBpZiAoc3RvcmFnZUF2YWlsYWJsZSgnbG9jYWxTdG9yYWdlJykpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdsYXJhdmVsX2RvY0NvbGxhcHNlZCcsIGRvY0NvbGxhcHNlZCk7XG4gICAgfVxuICAgIC8vIENhbmNlbCBldmVudFxuICAgIGlmKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICAvLyBMb2FkIHRoZSB1c2VycyBwcmV2aW91cyBwcmVmZXJlbmNlIGlmIGF2YWlsYWJsZVxuICBpZihzdG9yYWdlQXZhaWxhYmxlKCdsb2NhbFN0b3JhZ2UnKSkge1xuICAgIC8vIENhbid0IHVzZSBpZih2YXIpIHNpbmNlIHRoaXMgaXMgYSBib29sZWFuLCBMUyByZXR1cm5zIG51bGwgZm9yIHVuc2V0IGtleXNcbiAgICBpZihsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbGFyYXZlbF9kb2NDb2xsYXBzZWQnKSA9PT0gbnVsbCkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2xhcmF2ZWxfZG9jQ29sbGFwc2VkJywgdHJ1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTG9hZCBwcmV2aW91cyBzdGF0ZSwgYW5kIGlmIGl0IHdhcyBmYWxzZSwgdGhlbiBleHBhbmQgdGhlIGRvY1xuICAgICAgLy8gTFMgd2lsbCBzdG9yZSBib29sZWFucyBhcyBzdHJpbmdzLCB3ZSB3aWxsIFwiY2FzdFwiIHRoZW0gYmFjayBoZXJlXG4gICAgICBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbGFyYXZlbF9kb2NDb2xsYXBzZWQnKSA9PSAnZmFsc2UnID8gZXhwYW5kRG9jcygpIDogbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8vIFJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVyXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkb2MtZXhwYW5kJykgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZG9jLWV4cGFuZCcpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXhwYW5kRG9jcykgOiBudWxsO1xuXG4gIGlmICgkKCcuc2lkZWJhciB1bCcpLmxlbmd0aCkge1xuICAgIHZhciBjdXJyZW50ID0gJCgnLnNpZGViYXIgdWwnKS5maW5kKCdsaSBhW2hyZWY9XCInICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgJ1wiXScpO1xuXG4gICAgaWYgKGN1cnJlbnQubGVuZ3RoKSB7XG4gICAgICBjdXJyZW50LnBhcmVudCgpLmNzcygnZm9udC13ZWlnaHQnLCAnYm9sZCcpO1xuXG4gICAgICAvLyBPbmx5IHRvZ2dsZSB0aGUgc3RhdGUgaWYgdGhlIHVzZXIgaGFzIGNvbGxhcHNlZCB0aGUgZG9jdW1lbnRhdGlvblxuICAgICAgaWYoZG9jQ29sbGFwc2VkKSB7XG4gICAgICAgIGN1cnJlbnQuY2xvc2VzdCgndWwnKS5wcmV2KCkudG9nZ2xlQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cGFuZEl0ZW0oZSkge1xuICAgIHZhciBlbGVtID0gZS50YXJnZXQ7XG5cbiAgICBpZihlbGVtLmNsYXNzTGlzdC5jb250YWlucygnaXMtYWN0aXZlJykpIHtcbiAgICAgIGVsZW0uY2xhc3NMaXN0LnJlbW92ZSgnaXMtYWN0aXZlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFySXRlbXMoKTtcbiAgICAgIGVsZW0uY2xhc3NMaXN0LmFkZCgnaXMtYWN0aXZlJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZXhwYW5kSXRlbUtleWJvYXJkKGUpIHtcbiAgICBjbGVhckl0ZW1zKCk7XG4gICAgdmFyIGVsZW0gPSBlLnRhcmdldDtcblxuICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICBlbGVtLmNsYXNzTGlzdC50b2dnbGUoJ2lzLWFjdGl2ZScpO1xuICAgIH1cblxuICAgIGlmIChlLmtleUNvZGUgPT09IDM5KSB7XG4gICAgICBlbGVtLmNsYXNzTGlzdC5hZGQoJ2lzLWFjdGl2ZScpO1xuICAgIH1cblxuICAgIGlmIChlLmtleUNvZGUgPT09IDM3KSB7XG4gICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWFjdGl2ZScpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFySXRlbXMoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2dnbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b2dnbGVzW2ldLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWFjdGl2ZScpO1xuICAgIH1cbiAgfVxuXG5cbiAgICAvLyBzaWRlYmFyIG5hdiBhY3RpdmUgc3RhdGVcbiAgICAkKCcuc2lkZWJhciBsaScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcblxuICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZSAhPSAnL2RvY3MvNS4xJyAmJiBsb2NhdGlvbi5wYXRobmFtZSAhPSAnL2RvY3MvNS4xLycpIHtcbiAgICAgICAgJCgnLnNpZGViYXIgYVtocmVmPVwiJyArIGxvY2F0aW9uLnBhdGhuYW1lICsgJ1wiXScpLnBhcmVudCgpLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICB9XG5cbiAgICAgaWYgKCQoJy5hbmNob3JpZmljJykubGVuZ3RoID09IDApIHtcbiAgICAgICAgJCgnYXJ0aWNsZSAubWFpbi1jb250ZW50JykuYW5jaG9yaWZpYyh7XG4gICAgICAgICAgICBuYXZpZ2F0aW9uOiAnLmFuY2hvcmlmaWMnLCAvLyBwb3NpdGlvbiBvZiBuYXZpZ2F0aW9uXG4gICAgICAgICAgICBzcGVlZDogMjAwLCAvLyBzcGVlZCBvZiBzbGlkaW5nIGJhY2sgdG8gdG9wXG4gICAgICAgICAgICBhbmNob3JDbGFzczogJ2FuY2hvcmlmaWMnLCAvLyBjbGFzcyBvZiBhbmNob3IgbGlua3NcbiAgICAgICAgICAgIGFuY2hvclRleHQ6ICcjJywgLy8gcHJlcGVuZGVkIG9yIGFwcGVuZGVkIHRvIGFuY2hvciBoZWFkaW5nc1xuICAgICAgICAgICAgdG9wOiAnLnRvcCcsIC8vIGJhY2sgdG8gdG9wIGJ1dHRvbiBvciBsaW5rIGNsYXNzXG4gICAgICAgICAgICBzcHk6IHRydWUsIC8vIHNjcm9sbCBzcHlcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYXBwZW5kJywgLy8gcG9zaXRpb24gb2YgYW5jaG9yIHRleHRcbiAgICAgICAgICAgIHNweU9mZnNldDogMCAvLyBzcGVjaWZ5IGhlYWRpbmcgb2Zmc2V0IGZvciBzcHkgc2Nyb2xsaW5nXG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cblxuXG5cblxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcmVzb3VyY2VzL2Fzc2V0cy9qcy9sYXJhdmVsLmpzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ]);